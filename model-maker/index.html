<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Model Maker</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.js"></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <script src='threegeojson.js'></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.css" type="text/css" />


    <script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-array@1"></script>
<script src="https://unpkg.com/d3-collection@1"></script>
<script src="https://unpkg.com/d3-dispatch@1"></script>
<script src="https://unpkg.com/d3-request@1"></script>
<script src="https://unpkg.com/d3-timer@1"></script>

<style type="text/css">
  
  html, body {
  margin: 0;
  height: 100%;
}

  #map { 
    position: absolute; 
    top: 0; 
    bottom: 0; 
    width: 50%; 
    left: 0; 
    z-index: 10; 
  }

  #c {
    width: 50%;
    height: 100%;
    display: block;
    position: absolute;
    right: 0;
  }


</style>

</head>


<body style='margin: 0; overflow: hidden;'>
  <div id="map"></div>
  <canvas id="c"></canvas>


  <script type="module">





var generatedRoute = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [
            -0.9389743208885192,
            51.00546844730805
          ],
          [
            -0.9383225440979004,
            51.00515620883096
          ],
          [
            -0.9382903575897216,
            51.00534523994379
          ],
          [
            -0.9375742077827454,
            51.00532161109682
          ]
        ]
      }
    },
  ]
}

var actualRoute = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [
            -0.9389930963516235,
            51.005476886156636
          ],
          [
            -0.938955545425415,
            51.00543975521135
          ],
          [
            -0.9388884902000427,
            51.00541781418427
          ],
          [
            -0.9388643503189087,
            51.00542456527062
          ],
          [
            -0.9388107061386108,
            51.00537899541858
          ],
          [
            -0.9387060999870299,
            51.00534186439498
          ],
          [
            -0.9386390447616576,
            51.00531654777089
          ],
          [
            -0.9385827183723449,
            51.00526422670402
          ],
          [
            -0.938604176044464,
            51.005205154460846
          ],
          [
            -0.9384486079216002,
            51.00512414097645
          ],
          [
            -0.9384432435035706,
            51.0052220322523
          ],
          [
            -0.9384030103683471,
            51.005218656694495
          ],
          [
            -0.9383144974708557,
            51.00524734892796
          ],
          [
            -0.9382849931716918,
            51.00529629446169
          ],
          [
            -0.9382984042167664,
            51.00533511329658
          ],
          [
            -0.9382957220077514,
            51.00536380545799
          ],
          [
            -0.9382018446922301,
            51.005368868778724
          ],
          [
            -0.9380596876144408,
            51.00535199104073
          ],
          [
            -0.9379148483276366,
            51.00533511329658
          ],
          [
            -0.937732458114624,
            51.00533848884588
          ],
          [
            -0.9375420212745667,
            51.00531654777089
          ]
        ]
      }
    }
  ]
}






mapboxgl.accessToken = 'pk.eyJ1Ijoic2ptYXJzaGFsbHVrIiwiYSI6ImNpeDBleG1hdjAwNGEyenBoODAxODRxeGkifQ.tad1YtixbGXoQGGF_Z84Ng';
var map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v11',
  center: [-0.93875203281641,51.005568447565174],
  zoom: 18
});


var draw = new MapboxDraw({
  displayControlsDefault: false,
  controls: {
    line_string: true,
    trash: true
  }
});
map.addControl(draw);





map.on('draw.create', updateArea);
map.on('draw.delete', updateArea);
map.on('draw.update', updateArea);
    


    // Three.js - Load .OBJ ?
// from https://threejsfundamentals.org/threejs/threejs-load-obj-no-materials.html


import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/GLTFLoader.js';

function main() {


  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 1;
  const far = 100;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 10, 20);

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

  window.scene = new THREE.Scene();
  scene.background = new THREE.Color('white');

  {
    const planeSize = 40;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    // scene.add(mesh);
  }

  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 1;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 10, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }




  /*
  {
    var manager = new THREE.LoadingManager();
    var textureLoader = new THREE.TextureLoader(manager);

            var texture = textureLoader.load('https://cdn.shopify.com/s/files/1/0558/2081/products/Batman_Returns_FC_1024x1024.jpg?v=1541685585');
    var toon = new THREE.MeshDepthMaterial({
                transparent: true,
                opacity: 0.5
       });
    const objLoader = new OBJLoader2();
    objLoader.load('https://sjmarshalluk.github.io/model-maker/arrows.obj', (root) => {
      root.traverse(function(child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = toon;
                            // child.material.shininess=0;
                            // child.material.specular=0xffffff;
                            //child.material.normalMap = texture;
                        }
                    });
      root.position.set(0,2,0);
      scene.add(root);
      
    });
  }
  */






  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();








function updateArea(e) {
  var route = draw.getAll();
  var center = turf.centerOfMass(route);

  

  renderPlaces(route,center);

}

var center = turf.centerOfMass(actualRoute);
renderPlaces(generatedRoute,actualRoute,center)


function renderPlaces(route,actualRoute,center) {

  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];


  

  var arPathPoints = {
    "type":"FeatureCollection",
    "features":[]
  };

  var routeLength = turf.length(route.features[0], {units: 'kilometers'});
  var options = {units: 'kilometers'};
  var lengthMetres = routeLength * 1000;

  var i;
  for (i = 0; i < lengthMetres; i++) {
    var distanceAlong = i * 0.001;
    var along = turf.along(route.features[0], distanceAlong, options);
    arPathPoints.features.push(along)

    if (i === lengthMetres || i > lengthMetres) {
      //console.log(arPathPoints)
    }
  }

  for(i=0; i < arPathPoints.features.length; i++) {

    let latitude = arPathPoints.features[i].geometry.coordinates[1];
    let longitude = arPathPoints.features[i].geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;

    addPathPoint(offsetX,offsetY);
  };







  var arActualPoints = {
    "type":"FeatureCollection",
    "features":[]
  };

  var actualRouteLength = turf.length(actualRoute.features[0], {units: 'kilometers'});
  var options = {units: 'kilometers'};
  var actualLengthMetres = actualRouteLength * 1000;

  var i;
  for (i = 0; i < actualLengthMetres; i++) {
    var distanceAlong = i * 0.001;
    var along = turf.along(actualRoute.features[0], distanceAlong, options);
    arActualPoints.features.push(along);



    if (i === lengthMetres || i > lengthMetres) {
      //console.log(arPathPoints)
    }
  }

  console.log(arActualPoints);
  console.log(arPathPoints);

  for(i=0; i < arActualPoints.features.length; i++) {

    console.log(arActualPoints.features[i]);

    let latitude = arActualPoints.features[i].geometry.coordinates[1];
    let longitude = arActualPoints.features[i].geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;

    addActualPathPoint(offsetX,offsetY);
  };




  



  route.features[0].geometry.coordinates.forEach(function(turn,index) {
    let latitude = turn[1];
    let longitude = turn[0];


    var latlng = "latitude: " + String(turn[1]) + ";longitude: " + String(turn[0]);



    if (index < route.features[0].geometry.coordinates.length - 1) {
      var thisCoords = route.features[0].geometry.coordinates[index];
      var thisPoint = turf.point(thisCoords);

      var next = route.features[0].geometry.coordinates[index + 1];
      console.log(next)
      var nextPoint = turf.point(next);

      var bearing = turf.bearing(thisPoint, nextPoint);
      

      

      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (thisCoords[0] - centerLng) * 10000;
      var offsetY = (thisCoords[1] - centerLat) * 10000;

      addTurn(offsetX,offsetY,bearing);
    }



  })




  function addTurn(offsetX,offsetY,bearing) {
    
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/model-maker/arrows.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.1,0.1,0.1);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }

  function addPathPoint(offsetX,offsetY) {
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/ar-tester/path.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.1,0.1,0.1);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }

  function addActualPathPoint(offsetX,offsetY) {
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/ar-tester/path.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.1,0.1,0.1);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }


}

  </script>

</body>

</html>