<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Model Maker</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://unpkg.com/osmtogeojson@2.2.12/osmtogeojson.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.js"></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <script src='threegeojson.js'></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.css" type="text/css" />


    <script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://unpkg.com/d3-array@1"></script>
<script src="https://unpkg.com/d3-collection@1"></script>
<script src="https://unpkg.com/d3-dispatch@1"></script>
<script src="https://unpkg.com/d3-request@1"></script>
<script src="https://unpkg.com/d3-timer@1"></script>

<style type="text/css">
  
  html, body {
  margin: 0;
  height: 100%;
}

  #map { 
    position: absolute; 
    top: 0; 
    bottom: 0; 
    width: 50%; 
    left: 0; 
    z-index: 10; 
  }

  #c {
    width: 50%;
    height: 100%;
    display: block;
    position: absolute;
    right: 0;
  }


</style>

</head>


<body style='margin: 0; overflow: hidden;'>
  <div id="map"></div>
  <canvas id="c"></canvas>


  <script type="module">





var generatedRoute = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [
            -0.9389743208885192,
            51.00546844730805
          ],
          [
            -0.9383225440979004,
            51.00515620883096
          ],
          [
            -0.9382903575897216,
            51.00534523994379
          ],
          [
            -0.9375742077827454,
            51.00532161109682
          ]
        ]
      }
    },
  ]
}

var actualRoute = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [
            -0.9389930963516235,
            51.005476886156636
          ],
          [
            -0.938955545425415,
            51.00543975521135
          ],
          [
            -0.9388884902000427,
            51.00541781418427
          ],
          [
            -0.9388643503189087,
            51.00542456527062
          ],
          [
            -0.9388107061386108,
            51.00537899541858
          ],
          [
            -0.9387060999870299,
            51.00534186439498
          ],
          [
            -0.9386390447616576,
            51.00531654777089
          ],
          [
            -0.9385827183723449,
            51.00526422670402
          ],
          [
            -0.938604176044464,
            51.005205154460846
          ],
          [
            -0.9384486079216002,
            51.00512414097645
          ],
          [
            -0.9384432435035706,
            51.0052220322523
          ],
          [
            -0.9384030103683471,
            51.005218656694495
          ],
          [
            -0.9383144974708557,
            51.00524734892796
          ],
          [
            -0.9382849931716918,
            51.00529629446169
          ],
          [
            -0.9382984042167664,
            51.00533511329658
          ],
          [
            -0.9382957220077514,
            51.00536380545799
          ],
          [
            -0.9382018446922301,
            51.005368868778724
          ],
          [
            -0.9380596876144408,
            51.00535199104073
          ],
          [
            -0.9379148483276366,
            51.00533511329658
          ],
          [
            -0.937732458114624,
            51.00533848884588
          ],
          [
            -0.9375420212745667,
            51.00531654777089
          ]
        ]
      }
    }
  ]
}






mapboxgl.accessToken = 'pk.eyJ1Ijoic2ptYXJzaGFsbHVrIiwiYSI6ImNpeDBleG1hdjAwNGEyenBoODAxODRxeGkifQ.tad1YtixbGXoQGGF_Z84Ng';
var map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v11',
  center: [-0.93875203281641,51.005568447565174],
  zoom: 18
});



map.on('load', function() {


  if (map.getLayer('generatedRoute')) {
    map.removeLayer('generatedRoute');
  }
  if (map.getSource('generatedRoute')) {
    map.removeSource('generatedRoute');
  }
  if (map.getLayer('actualRoute')) {
    map.removeLayer('actualRoute');
  }
  if (map.getSource('actualRoute')) {
    map.removeSource('actualRoute');
  }
  map.addSource('generatedRoute', {
      "type": "geojson",
      "data": generatedRoute
  });
  map.addLayer({
      "id": "generatedRoute",
      "type": "line",
      "source": "generatedRoute",
      "paint": {
        "line-color": "blue",
        "line-opacity": 1,
        "line-width": 4
      },
      "layout": {
        'line-cap': 'round',
        'line-join': 'round'
      }
  });
  map.addSource('actualRoute', {
      "type": "geojson",
      "data": actualRoute
  });
  map.addLayer({
      "id": "actualRoute",
      "type": "line",
      "source": "actualRoute",
      "paint": {
        "line-color": "red",
        "line-opacity": 1,
        "line-width": 4
      },
      "layout": {
        'line-cap': 'round',
        'line-join': 'round'
      }
  });
})


var draw = new MapboxDraw({
  displayControlsDefault: false,
  controls: {
    line_string: true,
    trash: true
  }
});
map.addControl(draw);





map.on('draw.create', updateArea);
map.on('draw.delete', updateArea);
map.on('draw.update', updateArea);
    


    // Three.js - Load .OBJ ?
// from https://threejsfundamentals.org/threejs/threejs-load-obj-no-materials.html


import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/GLTFLoader.js';



  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 1;
  const far = 100;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 10, 20);

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 1, 0);
  controls.update();

  window.scene = new THREE.Scene();
  scene.background = new THREE.Color('white');

  {
    const planeSize = 40;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    // scene.add(mesh);
  }

  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 1;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 10, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }




  /*
  {
    var manager = new THREE.LoadingManager();
    var textureLoader = new THREE.TextureLoader(manager);

            var texture = textureLoader.load('https://cdn.shopify.com/s/files/1/0558/2081/products/Batman_Returns_FC_1024x1024.jpg?v=1541685585');
    var toon = new THREE.MeshDepthMaterial({
                transparent: true,
                opacity: 0.5
       });
    const objLoader = new OBJLoader2();
    objLoader.load('https://sjmarshalluk.github.io/model-maker/arrows.obj', (root) => {
      root.traverse(function(child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = toon;
                            // child.material.shininess=0;
                            // child.material.specular=0xffffff;
                            //child.material.normalMap = texture;
                        }
                    });
      root.position.set(0,2,0);
      scene.add(root);
      
    });
  }
  */






  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);









function updateArea(e) {
  var route = draw.getAll();
  var center = turf.centerOfMass(route);

  

  renderPlaces(route,center);

}

window.center = turf.centerOfMass(actualRoute);
renderPlaces(generatedRoute,actualRoute,center)




window.osmLines = {
  "type":"FeatureCollection",
  "features":[]
};
window.osmBuildings = {
  "type":"FeatureCollection",
  "features":[]
};



getOsmBbox();
function getOsmBbox() {
  var bounds = map.getBounds();
  window.searchBbox = bounds._sw.lat + ',' + bounds._sw.lng + ',' + bounds._ne.lat + ',' + bounds._ne.lng;
  showFeature()
}

function queryOsm() {
  if (map.getLayer('features-point')) {
    map.removeLayer('features-point');
  }
  if (map.getLayer('features-polygon')) {
    map.removeLayer('features-polygon');
  }
  if (map.getLayer('features-line')) {
    map.removeLayer('features-line');
  }
  if (map.getSource('feats')) {
    map.removeSource('feats');
  }
  showFeature()
}

function buildOverpassApiUrlFeat() {

  var nodeQuery = '';
  var wayQuery = '';
  var relationQuery = '';

  wayQuery += 'way[building](' + searchBbox + ');'

  wayQuery += 'way[highway](' + searchBbox + ');'

  //wayQuery += 'node[entrance](' + searchBbox + ');'



      


  //var nodeQuery = 'node[' + overpassQuery + '](' + searchBbox + ');';
  //var nodeQuery = 'node[tourism=attraction](' + searchBbox + ');node[natural=peak](' + searchBbox + ');';
  //var wayQuery = 'way[' + overpassQuery + '](' + searchBbox + ');';
  //var relationQuery = 'relation[' + overpassQuery + '](' + searchBbox + ');';
  var query = '?data=[out:json][timeout:15];(' + nodeQuery + wayQuery + relationQuery + ');out body geom;';
  var baseUrl = 'https://z.overpass-api.de/api/interpreter';
  var resultUrl = baseUrl + query;
  return resultUrl;
}


function showFeature(type,feature,shape){

  //var queryFeatures = type + '=' + feature;
  //var queryFeatures = 'tourism=attraction;natural=peak';
  var overpassApiUrlFeat = buildOverpassApiUrlFeat();
  $.get(overpassApiUrlFeat, function (osmDataAsJson) {
    var resultAsGeojson = osmtogeojson(osmDataAsJson);
    console.log(resultAsGeojson);


    var outlines = {
      "type":"FeatureCollection",
      "features":[]
    };

    var outlinesPoly = {
      "type":"FeatureCollection",
      "features":[]
    }

    



    resultAsGeojson.features.forEach(function(result) {
      if (result.properties.tags.entrance === 'yes') {
        var bufferedDoor = turf.buffer(result, 0.0003, {units: 'kilometers'});
        doors.features.push(bufferedDoor);
      }
      
      if (result.properties.tags.building === 'yes' || result.properties.tags.building === 'parking' || result.properties.tags.building === 'commercial' || result.properties.tags.building === 'office' || result.properties.tags.building === 'apartments') {
        
        osmBuildings.features.push(result);
        console.log(osmBuildings)
      }
      



      if(result.geometry.type == 'LineString') {
        if (result.properties.tags.highway == 'motorway') {
          result.properties.roadcolour = '#CF2081';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'primary') {
          result.properties.roadcolour = '#F99906';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'secondary') {
          result.properties.roadcolour = '#F3F313';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'tertiary') {
          result.properties.roadcolour = '#FFF9B3';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'residential') {
          result.properties.roadcolour = '#ffffff';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'pedestrian') {
          result.properties.roadcolour = '#ffffff';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'unclassified') {
          result.properties.roadcolour = '#ffffff';
          osmLines.features.push(result);
        }


      }
    });

    console.log(osmLines)
    renderOsm()

  });   
}



function renderOsm() {
  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];



  osmLines.features.forEach(function(road,index) {

    var material = new THREE.LineBasicMaterial({
      color: 0xCCCCCC,
      linewidth: 5
    });

    var points = [];

    osmLines.features[index].geometry.coordinates.forEach(function(turn,index) {
      let latitude = turn[1];
      let longitude = turn[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      points.push( new THREE.Vector3( offsetY,0,offsetX ) );



    })



    var geometry = new THREE.BufferGeometry().setFromPoints( points );

    var line = new THREE.Line( geometry, material );
    scene.add( line );
    
  });




  

  osmBuildings.features.forEach(function(building,index) {

    var building = new THREE.Shape();

    var buildingPoints = [];

    osmBuildings.features[index].geometry.coordinates[0].forEach(function(turn,index) {
      let latitude = turn[1];
      let longitude = turn[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      buildingPoints.push( new THREE.Vector3( offsetY,offsetX ) );



    })


    var shape = new THREE.Shape( buildingPoints );


    var extrudeSettings = { amount: 1, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
    console.log(buildingPoints)
    var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

    var material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );
    var mesh = new THREE.Mesh( geometry, material2 );

    mesh.position.set( 0, 1, 0 );
    mesh.rotation.set(1.56,0,0);

    scene.add( mesh );
    
    
  });
  

}



function renderPlaces(route,actualRoute,center) {

  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];


  

  var arPathPoints = {
    "type":"FeatureCollection",
    "features":[]
  };

  var routeLength = turf.length(route.features[0], {units: 'kilometers'});
  var options = {units: 'kilometers'};
  var lengthMetres = routeLength * 1000;

  var i;
  for (i = 0; i < lengthMetres; i++) {
    var distanceAlong = i * 0.001;
    var along = turf.along(route.features[0], distanceAlong, options);
    arPathPoints.features.push(along)

    if (i === lengthMetres || i > lengthMetres) {
      //console.log(arPathPoints)
    }
  }

  for(i=0; i < arPathPoints.features.length; i++) {

    let latitude = arPathPoints.features[i].geometry.coordinates[1];
    let longitude = arPathPoints.features[i].geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;

    addPathPoint(offsetX,offsetY);

    if (i === 0) {
      //camera.position.set(offsetX, 1, offsetY);
    }

  };








  var arActualPoints = {
    "type":"FeatureCollection",
    "features":[]
  };

  var actualRouteLength = turf.length(actualRoute.features[0], {units: 'kilometers'});
  var options = {units: 'kilometers'};
  var actualLengthMetres = actualRouteLength * 1000;

  var i;
  for (i = 0; i < actualLengthMetres; i++) {
    var distanceAlong = i * 0.001;
    var along = turf.along(actualRoute.features[0], distanceAlong, options);
    arActualPoints.features.push(along);



    if (i === lengthMetres || i > lengthMetres) {
      //console.log(arPathPoints)
    }
  }

  console.log(arActualPoints);
  console.log(arPathPoints);

  for(i=0; i < arActualPoints.features.length; i++) {

    console.log(arActualPoints.features[i]);

    let latitude = arActualPoints.features[i].geometry.coordinates[1];
    let longitude = arActualPoints.features[i].geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;

    addActualPathPoint(offsetX,offsetY);
  };




  



  route.features[0].geometry.coordinates.forEach(function(turn,index) {
    let latitude = turn[1];
    let longitude = turn[0];


    var latlng = "latitude: " + String(turn[1]) + ";longitude: " + String(turn[0]);



    if (index === 0) {
      var thisCoords = route.features[0].geometry.coordinates[index];
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (thisCoords[0] - centerLng) * 10000;
      var offsetY = (thisCoords[1] - centerLat) * 10000;

      addMarker(offsetX,offsetY);
    }

    if (index === route.features[0].geometry.coordinates.length - 1) {
      var thisCoords = route.features[0].geometry.coordinates[index];
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (thisCoords[0] - centerLng) * 10000;
      var offsetY = (thisCoords[1] - centerLat) * 10000;

      addMarker(offsetX,offsetY);
    }

    if (index > 0 && index < route.features[0].geometry.coordinates.length - 1) {
      var thisCoords = route.features[0].geometry.coordinates[index];
      var thisPoint = turf.point(thisCoords);

      var next = route.features[0].geometry.coordinates[index + 1];
      console.log(next)
      var nextPoint = turf.point(next);

      var bearing = turf.bearing(thisPoint, nextPoint);
      

      

      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (thisCoords[0] - centerLng) * 10000;
      var offsetY = (thisCoords[1] - centerLat) * 10000;

      addTurn(offsetX,offsetY,bearing);
    }



  })




  function addTurn(offsetX,offsetY,bearing) {
    
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/model-maker/arrows.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0.3,offsetX);
      root.scale.set(0.04,0.04,0.04);
      root.rotation.set(0,bearing,0);
      scene.add(root);

    });
  }

  function addPathPoint(offsetX,offsetY) {
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/ar-tester/path.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.1,0.1,0.1);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }

  function addActualPathPoint(offsetX,offsetY) {
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/model-maker/actual-path.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.1,0.1,0.1);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }

  function addMarker(offsetX,offsetY) {
    const gltfLoader = new GLTFLoader();
    const url = 'https://sjmarshalluk.github.io/ar-tester/path.gltf';
    gltfLoader.load(url, (gltf) => {
      const root = gltf.scene;

      root.position.set(offsetY,0,offsetX);
      root.scale.set(0.3,0.1,0.3);
      root.rotation.set(0,0,0);
      scene.add(root);

    });
  }


}

  </script>

</body>

</html>