<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Model Maker</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://unpkg.com/osmtogeojson@2.2.12/osmtogeojson.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.js"></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <script src='threegeojson.js'></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.css" type="text/css" />


     <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.4.2/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.4.2/mapbox-gl-geocoder.css" type="text/css"/>



      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>



<style type="text/css">
  
  html, body {
  margin: 0;
  height: 100%;
}

  #map { 
    position: absolute; 
    top: 0; 
    bottom: 0; 
    width: 50%; 
    left: 0; 
    z-index: 10; 
  }

  #c {
    width: 50%; 
    height: 100%;
    display: block;
    position: absolute;
    right: 0;
  }


  #control-panel {
    position: absolute;
    top: 0;
    left: 0;
    background-color: #333;
    padding: 20px;
    z-index: 9000;
    width: 100%;
    height: 100%;
    display: none;
  }
  #line-panel {
    position: absolute;
    top: 0;
    left: 0;
    background-color: #333;
    padding: 20px;
    z-index: 9000;
    width: 100%;
    height: 100%;
    display: none;
  }

  #osm-panel {
    top: 0;
    right: 0;
    background-color: #333;
    z-index: 1000;
    width: 100%;
    color: #fff;
    padding-top: 20px;
  }



  #search {
  width: 100%;
  height: 40px;
  border-radius: 10px;
  background-color: #fff;
  z-index: 2000;
  top: 0;
  left: 0;
}

  #navbar {

  }

  #sidebar {
    width: 200px;
    position: absolute;
    left: 0;
    height: 100%;
    padding: 10px;
    background-color: #333;
    color: #fff;
  }
  #editor {
    height: 100%;
    position: absolute;
    top: 0;
    width: calc(100% - 200px);
    right: 0;
  }


.mapboxgl-popup {
max-width: 400px;
font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
}

.AttributionContainer { display: none; }
        .BearingIndicatorContainer  { display: none; }
        .ZoomContainer  { display: none; }

.mapboxgl-ctrl-logo,
.mapboxgl-ctrl-attrib {
  display: none!important
}

.mapboxgl-ctrl-geocoder {
  width: 100%!important;
  min-width: 0;
}

</style>

</head>


<body style='margin: 0; overflow: hidden;'>

  <div class="modal" tabindex="-1" id="myModal">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-body">
        <button id="dot">Dot</button><button id="arrow">Arrow</button>
      </div>
    </div>
  </div>
</div>


  

     <div id="sidebar">

      <div id="line-panel">

          <div class="slidecontainer">
            <input type="range" min="0" max="100" value="0" class="slider" id="route-size-slider">
          </div>

          <div class="slidecontainer">
            <input type="range" min="3" max="15" value="0" class="slider" id="route-dash-slider">
          </div>

          <button id="delete-btn">Delete</button>

          <button id="done">Done</button>

        </div>




        <div id="control-panel">

          <div class="slidecontainer">
            <input type="range" min="0" max="100" value="0" class="slider" id="scale-slider">
          </div>

          <div class="slidecontainer">
            <input type="range" min="0" max="100" value="0" class="slider" id="angle-slider">
          </div>

          <button id="delete-btn">Delete</button>

          <button id="done">Done</button>

        </div>

        <div id="search">
          <div id="geocoder" class="geocoder"></div>
        </div>
        

        

        <div id="osm-panel">

          <h6>Buildings</h6>
          <div class="slidecontainer">
            <input type="range" min="0" max="100" value="10" class="slider" id="building-slider">
          </div>


          <h6>Roads</h6>
          <div class="slidecontainer">
            <input type="range" min="0" max="10" value="3" class="slider" id="road-slider">
          </div>

          

        </div>

      <div style="position: absolute;bottom: 0; width: 100%; left: 0; padding: 10px">
      <button id="save-settings" class="btn btn-block">Save settings</button>
      <button id="export_scene" class="btn btn-block">Export Scene</button>
    </div>
    </div>


    

  <div id="editor">

    <div id="map"></div>

    <button id="set-btn" class="btn btn-outline-success" style="position: absolute; top: 48%; right: 20%; z-index: 1000">Create model</button>
    <canvas id="c"></canvas>

  </div>


  <script type="module">



var savedSettings = localStorage.getItem("mysettings");
if (savedSettings) {
  var modelSettings = {
    "buildingHeight": 1,
    "buildingColor": 0x00afaf,
    "roadWidth": 0.003,
    "pathWidth": 0.001
  }
} else {
  var modelSettings = JSON.parse(savedSettings);
}

console.log(modelSettings)


mapboxgl.accessToken = 'pk.eyJ1Ijoic2ptYXJzaGFsbHVrIiwiYSI6ImNpeDBleG1hdjAwNGEyenBoODAxODRxeGkifQ.tad1YtixbGXoQGGF_Z84Ng';
var map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v11',
  center: [-0.93875203281641,51.005568447565174],
  zoom: 18
});

var geocoder = new MapboxGeocoder({
  accessToken: mapboxgl.accessToken,
  mapboxgl: mapboxgl
});
document.getElementById('geocoder').appendChild(geocoder.onAdd(map));


geocoder.on('results', function(results) {
   console.log(results);
})

/*
geocoder.on('result', function(ev) {
  console.log(ev.result.center);
  map.jumpTo({ center: ev.result.center, zoom: 17 });
  clearLayers();
  $('.mapboxgl-marker').css('display','none');
  var activeFeatures = osmFeatures.filter(d => d.status === 'active');
  if (activeFeatures.length == 0) {
  } else {
    getOsmBbox();
  }
  
})
*/

geocoder.on('result', function(ev) {
  console.log(ev.result.center);
  map.jumpTo({ center: ev.result.center, zoom: 18 });
  
  
});



var draw = new MapboxDraw({
  displayControlsDefault: false,
  controls: {
    line_string: true,
    trash: true
  }
});
map.addControl(draw);


var lines = {
  "type":"FeatureCollection",
  "features":[]
};

var points = {
  "type":"FeatureCollection",
  "features":[]
};


map.on('load', function() {


map.addSource('lines', {
  'type': 'geojson',
  'data': lines
});
map.addLayer({
  'id': 'lines',
  'type': 'line',
  'source': 'lines',
  'layout': {
    'line-join': 'round',
    'line-cap': 'round'
  },
  'paint': {
    'line-color': '#888',
    'line-width': 8
  }
});

map.addSource('points', {
  "type": "geojson",
  "data": points
});
map.addLayer({
  "id": "points",
  "type": "circle",
  "source": 'points',
  'paint': {
    'circle-radius': 5,
    'circle-color': '#ffffff',
    /*
    'circle-stroke-width': 2,
    'circle-stroke-color': [
      'match',
      ['get', 'status'],
      'verified',
      '#05CB63',
      'removed',
      '#E05643',
      'skipped',
      '#aaaaaa',
      'inactive',
      '#aaaaaa',
      '#EA45CE'
    ],
    */
  }
});


});

/*
var scaleSlider = document.getElementById("scale-slider");
  scaleSlider.oninput = function() {
    var scaleAmount = this.value / 100;
    root.scale.set(scaleAmount,scaleAmount,scaleAmount)
  }
*/

map.on('click', 'lines', function(e) {

  var thisLine = e.features[0];
  var featureCount = e.features[0].properties.count;

  


  document.getElementById('line-panel').style.display = 'block';

  var routeSizeSlider = document.getElementById("route-size-slider");
  routeSizeSlider.oninput = function() {

    for (var i = 0; i < featureCount; i++) {
      var object = scene.getObjectByName( "route-" + i  );
      scene.remove( object );
    }

    //var scaleAmount = this.value / 2000;
    //paintRoads(scaleAmount)
    //modelSettings.roadWidth = scaleAmount;
    //root.scale.set(scaleAmount,scaleAmount,scaleAmount)
  }

  var routeDashSlider = document.getElementById("route-dash-slider");
  routeDashSlider.oninput = function() {

    for (var i = 0; i < featureCount; i++) {
      var object = scene.getObjectByName( "route-" + i  );
      scene.remove( object );
    }



    var scaleAmount = this.value / 5000;

    console.log(thisLine)
    console.log(scaleAmount)

    renderPlaces(thisLine,scaleAmount,model)
  }


  var modelSelect = document.getElementById("model-select");
  modelSelect.addEventListener("change", function() {
    var value = modelSelect.options[e.selectedIndex].value;

    for (var i = 0; i < featureCount; i++) {
      var object = scene.getObjectByName( "route-" + i  );
      scene.remove( object );
    }

    renderPlaces(thisLine,scaleAmount,value)

  });

  
  


});




map.on('draw.create', updateArea);
map.on('draw.delete', updateArea);
map.on('draw.update', updateArea);


function updateArea(e) {
  var route = draw.getAll();


  var thisRoute = route.features[0];

  renderPlaces(thisRoute,0.005,model);
  console.log(route);

  //var layers = map.getStyle().layers;


  

  map.getSource('lines').setData(lines);


  
}







var setBtn = document.getElementById('set-btn');
setBtn.style.display = 'block';
setBtn.addEventListener('click', function() {
  setBtn.style.display = 'none';
  setScene();
})


 


    // Three.js - Load .OBJ ?
// from https://threejsfundamentals.org/threejs/threejs-load-obj-no-materials.html


import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/GLTFLoader.js';
import {GLTFExporter} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/exporters/GLTFExporter.js';



  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 1;
  const far = 100;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(5, 5, 5);
  

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 1, 0);
  controls.update();

  var objects = [];
  window.scene = new THREE.Scene();
  scene.background = new THREE.Color('white');

  {
    const planeSize = 40;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    // scene.add(mesh);
  }

  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 1;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 10, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }




  /*
  {
    var manager = new THREE.LoadingManager();
    var textureLoader = new THREE.TextureLoader(manager);

            var texture = textureLoader.load('https://cdn.shopify.com/s/files/1/0558/2081/products/Batman_Returns_FC_1024x1024.jpg?v=1541685585');
    var toon = new THREE.MeshDepthMaterial({
                transparent: true,
                opacity: 0.5
       });
    const objLoader = new OBJLoader2();
    objLoader.load('https://sjmarshalluk.github.io/model-maker/arrows.obj', (root) => {
      root.traverse(function(child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = toon;
                            // child.material.shininess=0;
                            // child.material.specular=0xffffff;
                            //child.material.normalMap = texture;
                        }
                    });
      root.position.set(0,2,0);
      scene.add(root);
      
    });
  }
  */



  /*
  document.addEventListener( 'mousedown', onDocumentMouseDown );

  function onDocumentMouseDown( event ) {    

    console.log(objects)
    console.log(event)
    event.preventDefault();
    var mouse3D = new THREE.Vector3( ( event.clientX / canvas.width ) * 2 - 1,   
                            -( event.clientY / canvas.height ) * 2 + 1,  
                            0 );     
    var raycaster =  new THREE.Raycaster();                                        
   raycaster.setFromCamera( mouse3D, camera );
    var intersects = raycaster.intersectObjects( objects );
    console.log(intersects)
    if ( intersects.length > 0 ) {
        intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
    }
  }
  */




  

  const pickPosition = {x: 0, y: 0};
  
  clearPickPosition();

  function getCanvasRelativePosition(event) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) * canvas.width  / rect.width,
      y: (event.clientY - rect.top ) * canvas.height / rect.height,
    };
  }




  var activeObject = null;
  var objectColor = null;
  function setPickPosition(event) {
    class PickHelper {
      constructor() {
        this.raycaster = new THREE.Raycaster();
        //this.pickedObject = null;
        this.pickedObjectSavedColor = 0;
      }
      pick(normalizedPosition, scene, camera) {
        // restore the color if there is a picked object
        console.log(this.pickedObject)
        if (activeObject) {
          console.log('active')
          activeObject.material.color.setHex(objectColor);
          activeObject = undefined;
        }

        // cast a ray through the frustum
        this.raycaster.setFromCamera(normalizedPosition, camera);
        // get the list of objects the ray intersected
        const intersectedObjects = this.raycaster.intersectObjects(scene.children, true);
        console.log(intersectedObjects)
        if (intersectedObjects.length) {
          // pick the first object. It's the closest one
          this.pickedObject = intersectedObjects[0].object;
          // save its color
          this.pickedObjectSavedColor = this.pickedObject.material.color.getHex();

          activeObject = this.pickedObject;
          objectColor = this.pickedObject.material.color.getHex();

          //this.pickedObject.scale.set(1,1,1);

          this.pickedObject.material.color.setHex(0xFFFF00);




          console.log(activeObject)
          showControls(this.pickedObject);


          // set its emissive color to flashing red/yellow
          //this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
        }
      }
    }
    const pickHelper = new PickHelper();

    pickHelper.pick(pickPosition, scene, camera);

    const pos = getCanvasRelativePosition(event);


    pickPosition.x = (pos.x / canvas.width ) *  2 - 1; 
    pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y

  }

  function clearPickPosition() {
    // unlike the mouse which always has a position
    // if the user stops touching the screen we want
    // to stop picking. For now we just pick a value
    // unlikely to pick something
    pickPosition.x = -100000;
    pickPosition.y = -100000;
  }

  canvas.addEventListener('mousedown', setPickPosition);
  canvas.addEventListener('mousup', clearPickPosition);
  //window.addEventListener('mouseleave', clearPickPosition);






  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  render()

  //requestAnimationFrame(render);



window.pointType;

function setScene() {




 var bounds = map.getBounds();
  console.log(bounds)
var sceneExtent = turf.polygon([[
    [bounds._ne.lng,bounds._ne.lat],
    [bounds._sw.lng,bounds._ne.lat],
    [bounds._sw.lng,bounds._sw.lat],
    [bounds._ne.lng,bounds._sw.lat],
    [bounds._ne.lng,bounds._ne.lat]
    ]], { name: 'poly1' });
console.log(sceneExtent)


window.center = turf.centerOfMass(sceneExtent);

getOsmBbox();

//map.on('click', addPoint);




}



window.osmLines = {
  "type":"FeatureCollection",
  "features":[]
};
window.osmBuildings = {
  "type":"FeatureCollection",
  "features":[]
};
window.osmNodes = {
  "type":"FeatureCollection",
  "features":[]
};




function getOsmBbox() {
  var bounds = map.getBounds();
  window.searchBbox = bounds._sw.lat + ',' + bounds._sw.lng + ',' + bounds._ne.lat + ',' + bounds._ne.lng;
  showFeature()
}

function queryOsm() {
  if (map.getLayer('features-point')) {
    map.removeLayer('features-point');
  }
  if (map.getLayer('features-polygon')) {
    map.removeLayer('features-polygon');
  }
  if (map.getLayer('features-line')) {
    map.removeLayer('features-line');
  }
  if (map.getSource('feats')) {
    map.removeSource('feats');
  }
  showFeature()
}

function buildOverpassApiUrlFeat() {

  var nodeQuery = '';
  var wayQuery = '';
  var relationQuery = '';

  wayQuery += 'way[building](' + searchBbox + ');'

  wayQuery += 'way[highway](' + searchBbox + ');'

  nodeQuery += 'node[highway=bus_stop](' + searchBbox + ');'

  //wayQuery += 'node[entrance](' + searchBbox + ');'



      


  //var nodeQuery = 'node[' + overpassQuery + '](' + searchBbox + ');';
  //var nodeQuery = 'node[tourism=attraction](' + searchBbox + ');node[natural=peak](' + searchBbox + ');';
  //var wayQuery = 'way[' + overpassQuery + '](' + searchBbox + ');';
  //var relationQuery = 'relation[' + overpassQuery + '](' + searchBbox + ');';
  var query = '?data=[out:json][timeout:15];(' + nodeQuery + wayQuery + relationQuery + ');out body geom;';
  var baseUrl = 'https://z.overpass-api.de/api/interpreter';
  var resultUrl = baseUrl + query;
  return resultUrl;
}


function showFeature(type,feature,shape){

  //var queryFeatures = type + '=' + feature;
  //var queryFeatures = 'tourism=attraction;natural=peak';
  var overpassApiUrlFeat = buildOverpassApiUrlFeat();
  $.get(overpassApiUrlFeat, function (osmDataAsJson) {
    var resultAsGeojson = osmtogeojson(osmDataAsJson);
    console.log(resultAsGeojson);


    var outlines = {
      "type":"FeatureCollection",
      "features":[]
    };

    var outlinesPoly = {
      "type":"FeatureCollection",
      "features":[]
    }

    



    resultAsGeojson.features.forEach(function(result) {
      if (result.properties.tags.entrance === 'yes') {
        var bufferedDoor = turf.buffer(result, 0.0003, {units: 'kilometers'});
        doors.features.push(bufferedDoor);
      }
      
      if (result.properties.tags.building === 'yes' || result.properties.tags.building === 'parking' || result.properties.tags.building === 'commercial' || result.properties.tags.building === 'office' || result.properties.tags.building === 'apartments') {
        
        osmBuildings.features.push(result);
        console.log(osmBuildings)
      }
      

      if(result.geometry.type == 'Point') {
        if (result.properties.tags.highway == 'bus_stop') {
          osmNodes.features.push(result);
        }
      }



      if(result.geometry.type == 'LineString') {
        if (result.properties.tags.highway == 'motorway') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'primary') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'secondary') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'tertiary') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'residential') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'pedestrian') {
          result.properties.linetype = 'path';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'footway') {
          result.properties.linetype = 'path';
          osmLines.features.push(result);
        }
        if (result.properties.tags.highway == 'unclassified') {
          result.properties.linetype = 'road';
          osmLines.features.push(result);
        }


      }
    });

    console.log(osmLines)
    renderOsm()

  });   
}



function paintRoads(width) {

  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];

  var roads = [];

  osmLines.features.forEach(function(road,index) {
    if(road.properties.linetype === 'road') {
      var buffered = turf.buffer(road, width, {units: 'kilometers'});
      roads.push(buffered);
    }
  })

  window.roadCount = roads.length;

  roads.forEach(function(rd,index) {


    var roadPoints = [];

    roads[index].geometry.coordinates[0].forEach(function(corner,index) {
      let latitude = corner[1];
      let longitude = corner[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      roadPoints.push( new THREE.Vector3( offsetY,offsetX ) );



    })




    var shape = new THREE.Shape( roadPoints );

    var extrudeSettings = { amount: 0.01, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

    var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

    var material = new THREE.MeshBasicMaterial( {
      color: 0xCCCCCC
    } );

    //var material2 = new THREE.MeshLambertMaterial( { color: 0xCCCCCC, emissive: 0x2a2a2a, emissiveIntensity: 1, wireframe: false } );
    var mesh = new THREE.Mesh( geometry, material );

    mesh.position.set( 0, 0, 0 );
    mesh.rotation.set(1.56,0,0);
    mesh.name = 'road-' + index;

    scene.add( mesh );
    
    
    
  });


  /*

  osmLines.features.forEach(function(road,index) {

    var material = new THREE.LineBasicMaterial({
      color: 0xCCCCCC,
      linewidth: 5
    });

    var points = [];

    osmLines.features[index].geometry.coordinates.forEach(function(turn,index) {
      let latitude = turn[1];
      let longitude = turn[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      points.push( new THREE.Vector3( offsetY,0,offsetX ) );



    })



    var geometry = new THREE.BufferGeometry().setFromPoints( points );

    var line = new THREE.Line( geometry, material );
    scene.add( line );
    
  });

  */


  

}


function paintPaths(width) {

  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];

  var paths = [];

  osmLines.features.forEach(function(path,index) {
    if(path.properties.linetype === 'path') {
      var buffered = turf.buffer(path, width, {units: 'kilometers'});
      paths.push(buffered);
    }
  })

  window.roadCount = paths.length;

  paths.forEach(function(rd,index) {


    var pathPoints = [];

    paths[index].geometry.coordinates[0].forEach(function(corner,index) {
      let latitude = corner[1];
      let longitude = corner[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      pathPoints.push( new THREE.Vector3( offsetY,offsetX ) );



    })




    var shape = new THREE.Shape( pathPoints );

    var extrudeSettings = { amount: 0.01, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

    var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

    var material = new THREE.MeshBasicMaterial( {
      color: 0xCCCCCC
    } );

    //var material2 = new THREE.MeshLambertMaterial( { color: 0xCCCCCC, emissive: 0x2a2a2a, emissiveIntensity: 1, wireframe: false } );
    var mesh = new THREE.Mesh( geometry, material );

    mesh.position.set( 0, 0.01, 0 );
    mesh.rotation.set(1.56,0,0);
    mesh.name = 'path-' + index;

    scene.add( mesh );
    
    
  });


}



function paintBuildings(height) {
  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];

  window.buildingCount = osmBuildings.features.length;
  

  osmBuildings.features.forEach(function(building,index) {


    var buildingPoints = [];

    osmBuildings.features[index].geometry.coordinates[0].forEach(function(turn,index) {
      let latitude = turn[1];
      let longitude = turn[0];


      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (longitude - centerLng) * 10000;
      var offsetY = (latitude - centerLat) * 10000;

      //addTurn(offsetX,offsetY,bearing);


      buildingPoints.push( new THREE.Vector3( offsetY,offsetX ) );



    })


    var shape = new THREE.Shape( buildingPoints );


    var extrudeSettings = { amount: height, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
    console.log(buildingPoints)
    var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

    var material = new THREE.MeshBasicMaterial( {
      color: modelSettings.buildingColor
    } );

    //var material2 = new THREE.MeshLambertMaterial( { color: 0xaaaaaa, wireframe: false } );
    var mesh = new THREE.Mesh( geometry, material );

    mesh.position.set( 0, height, 0 );
    mesh.rotation.set(1.56,0,0);

    mesh.material.transparent = true;
    mesh.material.opacity = 0.5; 
    mesh.name = 'building-' + index;

    scene.add( mesh );
    
    
  });
  
}



function paintNodes(e,type) {
  console.log(osmNodes)
  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];

  osmNodes.features.forEach(function(node,index) {    console.log(e)


    let latitude = node.geometry.coordinates[1];
    let longitude = node.geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;


    addNewPoint(offsetX,offsetY);

    

  })


}









function renderOsm() {
  



  paintRoads(modelSettings.roadWidth);

  paintPaths(modelSettings.pathWidth);

  paintBuildings(modelSettings.buildingHeight);

  paintNodes();


}
  






function addPoint(e) {


  // ADD TO MAP


  document.getElementById('myModal').style.display = 'block';


  /*
  var popup = new mapboxgl.Popup({
    closeButton: false,
    closeOnClick: false
  });

  popup.setLngLat([e.lngLat.lng,e.lngLat.lat]).setHTML('<button id="dot">Dot</button><button id="arrow">Arrow</button>').addTo(map);
  */

  document.getElementById('dot').addEventListener('click', function() {
    var type = 'dot';
    setPoint(e,type);
    document.getElementById('myModal').style.display = 'none';
  })
  document.getElementById('arrow').addEventListener('click', function() {
    var type = 'arrow';
    setPoint(e,type);
    document.getElementById('myModal').style.display = 'none';
  })

}




function setPoint(e,type) {
  console.log(e)


  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];



  let latitude = e.lngLat.lat;
  let longitude = e.lngLat.lng;

  // threejs json
  var pointX = turf.point([longitude,centerLat]);
  var pointY = turf.point([centerLng,latitude]);
  var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
  var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

  var offsetX = (longitude - centerLng) * 10000;
  var offsetY = (latitude - centerLat) * 10000;


  if (type === 'dot') {
    addNewPoint(offsetX,offsetY);
  }
  if (type === 'arrow') {
    addNewArrow(offsetX,offsetY);
  }

  


}



function renderPlaces(route,dashSize,model) {




  var centerLng = center.geometry.coordinates[0];
  var centerLat = center.geometry.coordinates[1];


  var arPathPoints = {
    "type":"FeatureCollection",
    "features":[]
  };

  var routeLength = turf.length(route, {units: 'kilometers'});
  var options = {units: 'kilometers'};
  var lengthMetres = routeLength * 1000;

  var i;
  for (i = 0; i < lengthMetres; i++) {
    var distanceAlong = i * dashSize;
    console.log(dashSize)
    var along = turf.along(route, distanceAlong, options);
    arPathPoints.features.push(along)

    if (i === lengthMetres || i > lengthMetres) {
      //console.log(arPathPoints)
    }
  }

  for(i=0; i < arPathPoints.features.length; i++) {

    let latitude = arPathPoints.features[i].geometry.coordinates[1];
    let longitude = arPathPoints.features[i].geometry.coordinates[0];

    // threejs json
    var pointX = turf.point([longitude,centerLat]);
    var pointY = turf.point([centerLng,latitude]);
    var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
    var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

    var offsetX = (longitude - centerLng) * 10000;
    var offsetY = (latitude - centerLat) * 10000;

    addNewPoint(offsetX,offsetY,'route',i,model);



  };


  route.geometry.coordinates.forEach(function(turn,index) {
    let latitude = turn[1];
    let longitude = turn[0];


    if (index < route.geometry.coordinates.length - 1) {
      var thisCoords = route.geometry.coordinates[index];

      // threejs json
      var pointX = turf.point([longitude,centerLat]);
      var pointY = turf.point([centerLng,latitude]);
      var distanceX = turf.distance(pointX, center, {units: 'kilometers'});
      var distanceY = turf.distance(pointY, center, {units: 'kilometers'});

      var offsetX = (thisCoords[0] - centerLng) * 10000;
      var offsetY = (thisCoords[1] - centerLat) * 10000;

      addNewArrow(offsetX,offsetY);
    }


    

  })

  route.properties.count = arPathPoints.features.length;
  lines.features.push(route);


}



function addPathPoint(offsetX,offsetY) {
  const gltfLoader = new GLTFLoader();
  const url = 'https://sjmarshalluk.github.io/ar-tester/path.gltf';
  gltfLoader.load(url, (gltf) => {
    const root = gltf.scene;

    root.position.set(offsetY,0,offsetX);
    root.scale.set(0.1,0.1,0.1);
    root.rotation.set(0,0,0);
    scene.add(root);


  });
}


function addNewPoint(offsetX,offsetY,id,index,model) {
  const gltfLoader = new GLTFLoader();

  if (model === 'arrow') {
    const url = 'https://sjmarshalluk.github.io/model-maker/assets/path/arrows.gltf';
  } else {
    const url = 'https://sjmarshalluk.github.io/model-maker/assets/path/point.gltf';
  }
  
  gltfLoader.load(url, (gltf) => {
    const root = gltf.scene;

    root.position.set(offsetY,0.1,offsetX);
    root.scale.set(0.1,0.1,0.1);
    root.rotation.set(0,0,0);
    root.name = id + '-' + index;

    scene.add(root);

    //objects.push(root);
    //showControls(root);

  });
}

function addNewArrow(offsetX,offsetY) {
  console.log('arrow')
  const gltfLoader = new GLTFLoader();
  const url = 'https://sjmarshalluk.github.io/model-maker/arrows.gltf';
  gltfLoader.load(url, (gltf) => {
    const root = gltf.scene;

    root.position.set(offsetY,0,offsetX);
    root.scale.set(0.1,0.1,0.1);
    root.rotation.set(0,0,0);
    

    scene.add(root);

    //showControls(root);

  });
}

function showControls(root) {
  console.log('hello')

  var controls = document.getElementById('control-panel');
  controls.style.display = 'block';

  var scaleSlider = document.getElementById("scale-slider");
  scaleSlider.oninput = function() {
    var scaleAmount = this.value / 100;
    root.scale.set(scaleAmount,scaleAmount,scaleAmount)
  }

  var angleSlider = document.getElementById("angle-slider");
  angleSlider.oninput = function() {
    var angleAmount = this.value / 10;
    root.rotation.set(0,angleAmount,0)
  }


  var deleteBtn = document.getElementById("delete-btn");
  deleteBtn.addEventListener('click', function() {
    //root.geometry.dispose();
    //root.material.dispose();
    scene.remove( root );
    controls.style.display = 'none';
  });


  document.getElementById('done').addEventListener('click', function() {
    controls.style.display = 'none';
  })


}





  var buildingSlider = document.getElementById("building-slider");
  buildingSlider.oninput = function() {
    for (var i = 0; i < buildingCount; i++) {
      var object = scene.getObjectByName( "building-" + i  );
      scene.remove( object );
    }
    var scaleAmount = this.value / 20;
    paintBuildings(scaleAmount);
    modelSettings.buildingHeight = scaleAmount;
    //root.scale.set(scaleAmount,scaleAmount,scaleAmount)
  }



  var roadSlider = document.getElementById("road-slider");
  roadSlider.oninput = function() {
    for (var i = 0; i < roadCount; i++) {
      var object = scene.getObjectByName( "road-" + i  );
      scene.remove( object );
    }
    var scaleAmount = this.value / 2000;
    paintRoads(scaleAmount)
    modelSettings.roadWidth = scaleAmount;
    //root.scale.set(scaleAmount,scaleAmount,scaleAmount)
  }




document.getElementById( 'export_scene' ).addEventListener( 'click', function () {

        exportGLTF( scene );

      } );


var link = document.createElement( 'a' );
      link.style.display = 'none';
      document.body.appendChild( link ); // Firefox workaround, see #6594


function exportGLTF( input ) {

        var gltfExporter = new GLTFExporter();


        gltfExporter.parse( input, function ( result ) {

          if ( result instanceof ArrayBuffer ) {

            saveArrayBuffer( result, 'scene.glb' );

          } else {

            var output = JSON.stringify( result, null, 2 );
            console.log( output );
            saveString( output, 'scene.gltf' );

          }

        } );

      }


      function saveString( text, filename ) {

        save( new Blob( [ text ], { type: 'text/plain' } ), filename );

      }

      function saveArrayBuffer( buffer, filename ) {

        save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

      }


      function save( blob, filename ) {

        link.href = URL.createObjectURL( blob );
        link.download = filename;
        link.click();

        // URL.revokeObjectURL( url ); breaks Firefox...

      }



document.getElementById('save-settings').addEventListener('click', saveSettings);
function saveSettings() {

  console.log(modelSettings);



  if (typeof(Storage) !== "undefined") {
    localStorage.setItem("mysettings", JSON.stringify(modelSettings));
  } else {
  }
}



  </script>

</body>

</html>