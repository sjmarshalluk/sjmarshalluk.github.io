/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: GeoJsonHeatmapExample */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJsonHeatmapExample", function() { return GeoJsonHeatmapExample; });
/* harmony import */ var _here_harp_geoutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
/* harmony import */ var _here_harp_geoutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_here_harp_geoutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _here_harp_map_controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @here/harp-map-controls */ "./node_modules/@here/harp-map-controls/index.js");
/* harmony import */ var _here_harp_map_controls__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_here_harp_map_controls__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _here_harp_mapview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
/* harmony import */ var _here_harp_mapview__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_here_harp_mapview__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @here/harp-omv-datasource */ "./node_modules/@here/harp-omv-datasource/index.js");
/* harmony import */ var _here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */





/**
 * This example demonstrates how to generate a heatmap-like [[StyleSet]] for a GeoJson. To do so,
 * each [[Style]] needs to define its own color shade, and they all need to be staggered on a
 * specific range of values. Here, the values are brought directly in the data of the GeoJson,
 * through the properties held in each feature. This GeoJson is a map of Italy, each feature
 * represents a region, and the properties bear the population density of that region. We can
 * narrow the `when` [[Expr]] condition of a [[Style]] to a value in a property, by simply writing
 * `propertyName` in the condition. The algorithm then reads:
 * ```typescript
 * [[include:geojson_heatmap1.ts]]
 * ```
 *
 * The algorithm loops through a range of values to create the [[Style]]s based on a range of
 * values, hence the variables in use. Externally it is wrapped in a more readable function where we
 * can simply describe the heatmap desired:
 * ```typescript
 * [[include:geojson_heatmap2.ts]]
 * ```
 *
 * Finally this [[StyleSet]] is assigned to the [[DataSource]]:
 * ```typescript
 * [[include:geojson_heatmap3.ts]]
 * ```
 */
var GeoJsonHeatmapExample;
(function (GeoJsonHeatmapExample) {

        document.body.innerHTML += `
        <style>
            #mouse-picked-result{
                position:absolute;
                bottom:5px;
                border-radius: 5px;
                margin-left:10px;
                padding: 9px 12px;
                background: #37afaa;
                display: inline-block;
                visibility: hidden;
                text-align: left;
                right:50px;
            }
            #mapCanvas {
              top: 0;
            }
            #info{
                color: #fff;
                width: 80%;
                left: 50%;
                position: relative;
                margin: 10px 0 0 -40%;
                font-size: 15px;
            }
            @media screen and (max-width: 700px) {
                #info{
                    font-size:11px;
                }
            }
        </style>
        <p id=info>Click/touch a feature on the map to read its data (Land masses are not features).
        </p>
        <pre id="mouse-picked-result"></pre>
    `;

    /**
     * Creates a new MapView for the HTMLCanvasElement of the given id.
     */
    function initializeBaseMap(id, theme) {
        const canvas = document.getElementById(id);
        const mapView = new _here_harp_mapview__WEBPACK_IMPORTED_MODULE_2__["MapView"]({
            canvas,
            theme,
            maxZoomLevel: 25
        });

        var pfield = new _here_harp_geoutils__WEBPACK_IMPORTED_MODULE_0__["GeoCoordinates"](51.005568447565174,-0.93875203281641);
        mapView.lookAt({
            target: pfield,
            zoomLevel: 20,
            tilt: 83,
            heading: 0
        });
        const controls = new _here_harp_map_controls__WEBPACK_IMPORTED_MODULE_1__["MapControls"](mapView);
        // Add an UI.
        const ui = new _here_harp_map_controls__WEBPACK_IMPORTED_MODULE_1__["MapControlsUI"](controls);
        canvas.parentElement.appendChild(ui.domElement);
        window.addEventListener("resize", () => {
            mapView.resize(window.innerWidth, window.innerHeight);
        });
        const baseMapDataSource = new _here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3__["OmvDataSource"]({
            baseUrl: "https://vector.hereapi.com/v2/vectortiles/base/mc",
            authenticationCode: "NArg_UpAiSGsoA_se-_KME_uKZbzknxpAtGsgcPAErY"
        });
        mapView.addDataSource(baseMapDataSource);


        /*
        canvas.addEventListener("mousedown", event => {
            lastCanvasPosition = getCanvasPosition(event, canvas);
        });
        canvas.addEventListener("mouseup", event => {
            const canvasPos = getCanvasPosition(event, canvas);
            
            if (isPick(canvasPos)) {
                handlePick(mapView, canvasPos.x, canvasPos.y);
            }
        });
        */
        return mapView;
    }


    const customTheme = {
        extends: "resources/berlin_tilezen_night_reduced.json",
        styles: {
            //geojson: densityStyleSet
        }
    };

    const baseMap = initializeBaseMap("map", customTheme);

    


    const geoJsonDataProvider = new _here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3__["GeoJsonDataProvider"]("italy", new URL("resources/flat.json", window.location.href));
    const geoJsonDataSource = new _here_harp_omv_datasource__WEBPACK_IMPORTED_MODULE_3__["OmvDataSource"]({
        dataProvider: geoJsonDataProvider,
        styleSetName: "geojson",
        maxDataLevel: 25,
        maxDisplayLevel: 25
    });


    baseMap.addDataSource(geoJsonDataSource).then(() => {
       const styles = [
       {
          when: "$geometryType == 'polygon'",
          technique: "extruded-polygon",
          renderOrder: 10000,
          attr: {
             color: "#7ED321",
             height: 5,
            boundaryWalls: false,
            wireframe: true

          }
       },{
          when: "$geometryType == 'line'",
          technique: "solid-line",
          renderOrder: 10001,
          attr: {
             color: "#fff",
             lineWidth: 5,
            metricUnit: "Pixel"

          }
       }
       ]
       geoJsonDataSource.setStyleSet(styles);
       //map.canvas.addEventListener("click", (e: MouseEvent) => { const intersectionResults = map.intersectMapObjects(e.pageX, e.pageY); const usableResults = intersectionResults.filter(result => result.userData !== undefined); console.log(intersectionResults, usableResults) };
       baseMap.update();
    });

    var canvas = document.getElementById("map");




function handleOrientation(event) {
  updateFieldIfNotNull('Orientation_a', event.alpha);
  updateFieldIfNotNull('Orientation_b', event.beta);
  updateFieldIfNotNull('Orientation_g', event.gamma);
    mapView.lookAt({ tilt: event.beta });

    //var rotation = event.gamma - (event.gamma * 2);
    mapView.lookAt({ heading: event.alpha });


}



let is_running = false;
let demo_button = document.getElementById("start_demo");
demo_button.onclick = function(e) {
  e.preventDefault();

  if (
    DeviceMotionEvent &&
    typeof DeviceMotionEvent.requestPermission === "function"
  ) {
    DeviceMotionEvent.requestPermission();
  }
  
  if (is_running){
    //window.removeEventListener("devicemotion", handleMotion);
    window.removeEventListener("deviceorientation", handleOrientation);
    demo_button.innerHTML = "Start demo";
    demo_button.classList.add('btn-success');
    demo_button.classList.remove('btn-danger');
    is_running = false;
  }else{
    //window.addEventListener("devicemotion", handleMotion);
    window.addEventListener("deviceorientation", handleOrientation);
    document.getElementById("start_demo").innerHTML = "Stop demo";
    demo_button.classList.remove('btn-success');
    demo_button.classList.add('btn-danger');
    is_running = true;
  }
};








/*

    let lastCanvasPosition;
    function getCanvasPosition(event, canvas) {
        const { left, top } = canvas.getBoundingClientRect();
        return { x: event.clientX - Math.floor(left), y: event.clientY - Math.floor(top) };
    }
    // Trigger picking event only if there's (almost) no dragging.
    function isPick(eventPosition) {
        const MAX_MOVE = 5;
        return (lastCanvasPosition &&
            Math.abs(lastCanvasPosition.x - eventPosition.x) <= MAX_MOVE &&
            Math.abs(lastCanvasPosition.y - eventPosition.y) <= MAX_MOVE);
    }
    // snippet:datasource_object_picking_2.ts
    const element = document.getElementById("mouse-picked-result");
    let current;
    function handlePick(mapViewUsed, x, y) {

        
        // get an array of intersection results from MapView
        let usableIntersections = mapViewUsed
            .intersectMapObjects(x, y)
            .filter(item => item.userData !== undefined);
        

        console.log(mapViewUsed); 

        let usableIntersections = mapViewUsed;


        if (usableIntersections.length > 1) {
            usableIntersections = usableIntersections.filter(item => item !== current);
        }
        if (usableIntersections.length === 0) {
            // Hide helper box
            element.style.visibility = "hidden";
            return;
        }
        
        // Get userData from the first result;
        current = usableIntersections;
        //if (current.userData.name !== undefined) {

            mapViewUsed.setDynamicProperty("selection", [current.m_drawing]);
        //}
        // Show helper box
        element.style.visibility = "visible";
        // Display userData inside of helper box
        element.innerText = JSON.stringify(current.m_drawing, undefined, 2);
    }
    // end:datasource_object_picking_2.ts



*/
    
    
})(GeoJsonHeatmapExample || (GeoJsonHeatmapExample = {}));


/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index-decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index-decoder.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./lib/StyleSetEvaluator */ "./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/IMeshBuffers */ "./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Outliner */ "./node_modules/@here/harp-datasource-protocol/lib/Outliner.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThreeBufferUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ "./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js"), exports);
//# sourceMappingURL=index-decoder.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Components used for the decoding and styling of data that is used by the Datasources.
 *
 * @remarks
 * The DataSource Protocol package contains components used for the decoding and styling
 * of data that is used by the Datasources.
 * This code is shared between the ui-thread and the web-workers which are
 * used to parallelise the decoding of the data.
 * This module contains interfaces for choosing techniques form the techniques
 * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/ColorUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Techniques */ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TechniqueParams */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Theme */ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/PostEffects */ "./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/PropertyValue */ "./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ITileDecoder */ "./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ITiler */ "./node_modules/@here/harp-datasource-protocol/lib/ITiler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DecodedTile */ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileInfo */ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ "./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThemeVisitor */ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/StringEncodedNumeral */ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorUtils = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js");
const SHIFT_TRANSPARENCY = 24;
const SHIFT_RED = 16;
const SHIFT_GREEN = 8;
const SHIFT_BLUE = 0;
// tslint:disable: no-bitwise
//    Allow bitwise operations for colors decoding
// tslint:disable-next-line: no-bitwise
const HEX_FULL_CHANNEL = 0xff;
const HEX_RGB_MASK = 0xffffff;
const HEX_TRGB_MASK = 0xffffffff;
const tmpColor = new THREE.Color();
/**
 * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.
 *
 * The functions provided allows for conversion from and to our custom number based color format,
 * which contains transparency, red, green and blue color channels in a way that each channel
 * occupies 8 bits of resulting number (color format 0xTTRRGGBB).
 * In order to preserve compatibility with THREE.Color class and its hexadecimal color
 * representation, we do not store __alpha__ channel in encoded color's number, but replace it
 * with __transparency__ channel, which is simply opposite to alpha:
 * ```transparency = 0xFF - alpha```
 * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,
 * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],
 * [[THREE.Color.setHex]]).
 * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.
 */
var ColorUtils;
(function (ColorUtils) {
    /**
     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).
     *
     * We do not use direct alpha channel mapping to hex in order to preserve compatibility
     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency
     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].
     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and
     * color defining transparency (alpha < 255) is always recognizable by the oldest
     * bit set:
     * ```typescript
     * (color >> SHIFT_TRANSPARENCY) !== 0.
     * ```
     * @note All input components are floating points in <0, 1> range (inclusively).
     * @note Although method encodes transparency channel in single number value, it is still
     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to
     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.
     */
    function getHexFromRgba(r, g, b, a) {
        harp_utils_1.assert(a >= 0 && a <= 1);
        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);
        return ((t << SHIFT_TRANSPARENCY) ^
            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgba = getHexFromRgba;
    /**
     * Encodes RGB all color channels in single number with format 0xRRGGBB.
     *
     * All input channels should be in <0, 1> range (inclusively).
     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.
     *
     * @note This method is fully compatible with THREE.js color encoding, so
     * you may pass this value directly to THREE.Color c-tor.
     */
    function getHexFromRgb(r, g, b) {
        harp_utils_1.assert(r >= 0 && r <= 1);
        harp_utils_1.assert(g >= 0 && g <= 1);
        harp_utils_1.assert(b >= 0 && b <= 1);
        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgb = getHexFromRgb;
    /**
     * Encode and convert HSL value to number coded color format (0xRRGGBB).
     *
     * @see getHexFromRgb.
     * @param h - Hue component value between 0 and 1.
     * @param s - Saturation value between 0 and 1.
     * @param l - Lightness channel between 0 and 1.
     */
    function getHexFromHsl(h, s, l) {
        harp_utils_1.assert(h >= 0 && h <= 1);
        harp_utils_1.assert(s >= 0 && s <= 1);
        harp_utils_1.assert(l >= 0 && l <= 1);
        return tmpColor.setHSL(h, s, l).getHex();
    }
    ColorUtils.getHexFromHsl = getHexFromHsl;
    /**
     * Retrieve RGBA channels separately from number encoded custom color format.
     *
     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color
     * format.
     *
     * @see getHexFromRgba.
     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating
     * point from 0 to 1 inclusively.
     */
    function getRgbaFromHex(hex, target = new RGBA_1.RGBA()) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.a =
            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /
                HEX_FULL_CHANNEL;
        return target;
    }
    ColorUtils.getRgbaFromHex = getRgbaFromHex;
    /**
     * Determines if number encoded color contains alpha (opacity) defined and different then 255.
     *
     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns True if color has transparency defined.
     */
    function hasAlphaInHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex >> SHIFT_TRANSPARENCY !== 0;
    }
    ColorUtils.hasAlphaInHex = hasAlphaInHex;
    /**
     * Retrieves alpha color channel from hex encoded color value.
     *
     * @see getHexFromRgba.
     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns The floating point alpha component in <0, 1> range.
     */
    function getAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);
    }
    ColorUtils.getAlphaFromHex = getAlphaFromHex;
    /**
     * Remove transparency info from the number coded color, makes it compatible with external libs.
     *
     * @see getAlphaFromHex.
     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns number coded color value representable as 0xRRGGBB in hex.
     */
    function removeAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex & HEX_RGB_MASK;
    }
    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;
})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));
//# sourceMappingURL=ColorUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeatureText = exports.getFeatureName = exports.getFeatureId = exports.getProjectionName = exports.getProjection = exports.GeometryType = exports.getArrayConstructor = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr - specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName - string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection - `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;
/**
 * @returns Feature id from the provided attribute map.
 */
function getFeatureId(attributeMap) {
    if (attributeMap === undefined) {
        return 0;
    }
    if (typeof attributeMap === "number") {
        return attributeMap;
    }
    if (attributeMap.hasOwnProperty("$id")) {
        return attributeMap.$id;
    }
    return 0;
}
exports.getFeatureId = getFeatureId;
/**
 * Determine the name of (OMV) feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param env - Environment containing the tags from the (OMV) feature.
 * @param useAbbreviation - `true` to use the abbreviation if available.
 * @param useIsoCode - `true` to use the tag "iso_code".
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureName(env, basePropName, useAbbreviation, useIsoCode, languages) {
    let name;
    if (basePropName === undefined) {
        basePropName = "name";
    }
    if (useAbbreviation) {
        const abbreviation = env.lookup(`${basePropName}:short`);
        if (typeof abbreviation === "string" && abbreviation.length > 0) {
            return abbreviation;
        }
    }
    if (useIsoCode) {
        const isoCode = env.lookup(`iso_code`);
        if (typeof isoCode === "string" && isoCode.length > 0) {
            return isoCode;
        }
    }
    if (languages !== undefined) {
        for (const lang of languages) {
            name = env.lookup(`${basePropName}:${lang}`) || env.lookup(`${basePropName}_${lang}`);
            if (typeof name === "string" && name.length > 0) {
                return name;
            }
        }
    }
    name = env.lookup(basePropName);
    if (typeof name === "string") {
        return name;
    }
    return undefined;
}
exports.getFeatureName = getFeatureName;
/**
 * Determine the text string of the map feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param feature - Feature, including properties from the (OMV) feature.
 * @param technique - technique defining how text should be created from feature
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureText(context, technique, languages) {
    let useAbbreviation;
    let useIsoCode;
    const env = context instanceof Expr_1.Env ? context : context.env;
    let propName = "name";
    if (Techniques_1.isTextTechnique(technique) ||
        Techniques_1.isPoiTechnique(technique) ||
        Techniques_1.isLineMarkerTechnique(technique)) {
        if (technique.text !== undefined) {
            return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);
        }
        // tslint:disable-next-line: deprecation
        if (technique.label !== undefined) {
            // tslint:disable-next-line: deprecation
            propName = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.label);
            if (typeof propName !== "string") {
                return undefined;
            }
        }
        // tslint:disable-next-line: deprecation
        useAbbreviation = technique.useAbbreviation;
        // tslint:disable-next-line: deprecation
        useIsoCode = technique.useIsoCode;
    }
    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);
}
exports.getFeatureText = getFeatureText;
//# sourceMappingURL=DecodedTile.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Env.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Env.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapEnv = exports.Env = void 0;
/**
 * A class used to lookup properties by name.
 *
 * @remarks
 * Concrete implementation of `Env` like {@link MapEnv} are used
 * to resolve the property names used in {@link Expr | style expressions}.
 *
 * @example
 * ```typescript
 * const env = new MapEnv({
 *     kind: "landuse",
 * });
 *
 * const expr = Expr.fromJson(["get", "kind"]);
 *
 * const value = expr.evaluate(env);
 *
 * console.log(`kind is '${value}`);
 * ```
 */
class Env {
    /**
     * Returns `true` if the given object is an instance of {@link Env}.
     *
     * @param object - The object to test.
     */
    static isEnv(object) {
        return object instanceof Env;
    }
    /**
     * Returns property in {@link Env} by name.
     *
     * @param name - Name of property.
     */
    lookup(name) {
        return undefined;
    }
    /**
     * Return an object containing all properties of this environment. (Here: empty object).
     */
    unmap() {
        return {};
    }
}
exports.Env = Env;
/**
 * `MapEnv` is a concrete implementation of {@link Env} that
 * creates a lookup environment from a set of properties.
 *
 * @example
 * ```typescript
 * const baseEnv = new MapEnv({
 *     $zoom: 14,
 * });
 *
 * // extends baseEnv with a the new binding (kind, "landuse").
 * const env = new MapEnv({ kind: "landuse" }, baseEnv);
 *
 * const zoom = env.lookup("$zoom"); // zoom is 14
 * const kind = env.lookup("kind"); // kind is is "landuse"
 *
 * const expr = Expr.fromJson(["get", "kind"]);
 * const value = expr.evaluate(env); // value is "landuse"
 * ```
 */
class MapEnv extends Env {
    constructor(entries, parent) {
        super();
        this.entries = entries;
        this.parent = parent;
    }
    /**
     * Returns property in {@link Env} by name.
     *
     * @param name - Name of property.
     * @override
     */
    lookup(name) {
        if (this.entries.hasOwnProperty(name)) {
            const value = this.entries[name];
            if (value !== undefined) {
                return value;
            }
        }
        return this.parent ? this.parent.lookup(name) : undefined;
    }
    /**
     * Return an object containing all properties of this environment, takes care of the parent
     * object.
     * @override
     */
    unmap() {
        const obj = this.parent ? this.parent.unmap() : {};
        for (const key in this.entries) {
            if (this.entries.hasOwnProperty(key)) {
                obj[key] = this.entries[key];
            }
        }
        return obj;
    }
}
exports.MapEnv = MapEnv;
//# sourceMappingURL=Env.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Expr.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterpolateExpr = exports.StepExpr = exports.CaseExpr = exports.MatchExpr = exports.CallExpr = exports.HasAttributeExpr = exports.ObjectLiteralExpr = exports.StringLiteralExpr = exports.NumberLiteralExpr = exports.BooleanLiteralExpr = exports.NullLiteralExpr = exports.LiteralExpr = exports.VarExpr = exports.Expr = exports.ExprScope = exports.isJsonExpr = exports.ExprDependencies = void 0;
const ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ "./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js");
const ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ "./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js");
const ExprParser_1 = __webpack_require__(/*! ./ExprParser */ "./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js");
const Theme_1 = __webpack_require__(/*! ./Theme */ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js");
__exportStar(__webpack_require__(/*! ./Env */ "./node_modules/@here/harp-datasource-protocol/lib/Env.js"), exports);
const exprEvaluator = new ExprEvaluator_1.ExprEvaluator();
const exprInstantiator = new ExprInstantiator_1.ExprInstantiator();
/**
 * The dependencies of an {@link Expr}.
 */
class ExprDependencies {
    constructor() {
        /**
         * The properties needed to evaluate the {@link Expr}.
         */
        this.properties = new Set();
    }
}
exports.ExprDependencies = ExprDependencies;
let ComputeExprDependencies = /** @class */ (() => {
    class ComputeExprDependencies {
        /**
         * Gets the dependencies of an {@link Expr}.
         *
         * @param expr - The {@link Expr} to process.
         * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
         * @param dependencies - The output [[Set]] of dependency names.
         */
        static of(expr) {
            const dependencies = new ExprDependencies();
            expr.accept(this.instance, dependencies);
            return dependencies;
        }
        visitNullLiteralExpr(expr, context) {
            // nothing to do
        }
        visitBooleanLiteralExpr(expr, context) {
            // nothing to do
        }
        visitNumberLiteralExpr(expr, context) {
            // nothing to do
        }
        visitStringLiteralExpr(expr, context) {
            // nothing to do
        }
        visitObjectLiteralExpr(expr, context) {
            // nothing to do
        }
        visitVarExpr(expr, context) {
            context.properties.add(expr.name);
        }
        visitHasAttributeExpr(expr, context) {
            context.properties.add(expr.name);
        }
        visitCallExpr(expr, context) {
            expr.args.forEach(childExpr => childExpr.accept(this, context));
            switch (expr.op) {
                case "dynamic-properties":
                    context.volatile = true;
                    break;
                case "feature-state":
                    context.featureState = true;
                    context.properties.add("$state");
                    context.properties.add("$id");
                    break;
                case "id":
                    context.properties.add("$id");
                    break;
                case "zoom":
                case "world-ppi-scale":
                case "world-discrete-ppi-scale":
                    context.properties.add("$zoom");
                    break;
                case "geometry-type":
                    context.properties.add("$geometryType");
                    break;
                default:
                    break;
            }
        }
        visitMatchExpr(expr, context) {
            expr.value.accept(this, context);
            expr.branches.forEach(([_, branch]) => branch.accept(this, context));
            expr.fallback.accept(this, context);
        }
        visitCaseExpr(expr, context) {
            expr.branches.forEach(([condition, branch]) => {
                condition.accept(this, context);
                branch.accept(this, context);
            });
            expr.fallback.accept(this, context);
        }
        visitStepExpr(expr, context) {
            expr.input.accept(this, context);
            expr.defaultValue.accept(this, context);
            expr.stops.forEach(([_, value]) => value.accept(this, context));
        }
        visitInterpolateExpr(expr, context) {
            expr.input.accept(this, context);
            expr.stops.forEach(([_, value]) => value.accept(this, context));
        }
    }
    ComputeExprDependencies.instance = new ComputeExprDependencies();
    return ComputeExprDependencies;
})();
function isJsonExpr(v) {
    return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
exports.isJsonExpr = isJsonExpr;
/**
 * The evaluation scope of an {@link Expr}.
 */
var ExprScope;
(function (ExprScope) {
    /**
     * The scope of an {@link Expr} used as value of an attribute.
     */
    ExprScope[ExprScope["Value"] = 0] = "Value";
    /**
     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.
     */
    ExprScope[ExprScope["Condition"] = 1] = "Condition";
    /**
     * The scope of an {@link Expr} used as dynamic property attribute value.
     */
    ExprScope[ExprScope["Dynamic"] = 2] = "Dynamic";
})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));
// tslint:disable:max-line-length
/**
 * Abstract class representing the
 * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}
 * used in {@link Theme}.
 */
// tslint:enable:max-line-length
class Expr {
    /**
     * Tests of given value is an {@link Expr}.
     *
     * @param value - The object to test.
     */
    static isExpr(value) {
        return value instanceof Expr;
    }
    /**
     * Creates an expression from the given `code`.
     *
     * @param code - The code to parse.
     * @returns The parsed {@link Expr}.
     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.
     */
    static parse(code) {
        const parser = new ExprParser_1.ExprParser(code);
        const expr = parser.parse();
        return expr;
    }
    // tslint:disable:max-line-length
    /**
     * Creates a style expression from JSON.
     *
     * @remarks
     * The optional set of {@link Theme.definitions | definitions} is used
     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.
     *
     * @param json - JSON object representing the expression to parse.
     * @param definitions - Optional set of definitions used to expand references.
     * @param definitionExprCache - Optional cache of `Expr` instances
     *
     * @example
     * ```typescript
     * const expr = Expr.fromJSON(["all",
     *     ["==", ["geometry-type"], "LineString"],
     *     ["has", "text"]
     * ]);
     * ```
     */
    // tslint:enable:max-line-length
    static fromJSON(json, definitions, definitionExprCache) {
        const referenceResolverState = definitions !== undefined
            ? {
                definitions,
                lockedNames: new Set(),
                cache: definitionExprCache || new Map()
            }
            : undefined;
        return parseNode(json, referenceResolverState);
    }
    /**
     * Evaluate an expression returning a {@link Value} object.
     *
     * @param env - The {@link Env} used to lookup symbols.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param cache - A cache of previously computed results.
     */
    evaluate(env, scope = ExprScope.Value, cache) {
        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));
    }
    /**
     * Instantiates this {@link Expr}.
     *
     * @remarks
     * references to the `get` and `has` operator using the given instantiation context.
     *
     * @param context - The [[InstantationContext]] used to resolve names.
     */
    instantiate(context) {
        return this.accept(exprInstantiator, context);
    }
    /**
     * Gets the dependencies of this {@link Expr}.
     */
    dependencies() {
        if (!this.m_dependencies) {
            this.m_dependencies = ComputeExprDependencies.of(this);
        }
        return this.m_dependencies;
    }
    /**
     * Create a unique object that is structurally equivalent to this {@link Expr}.
     *
     * @param pool - The [[ExprPool]] used to create a unique
     * equivalent object of this {@link Expr}.
     */
    intern(pool) {
        return pool.add(this);
    }
    toJSON() {
        return new ExprSerializer().serialize(this);
    }
    /**
     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.
     */
    isDynamic() {
        if (this.m_isDynamic === undefined) {
            this.m_isDynamic = this.exprIsDynamic();
        }
        return this.m_isDynamic;
    }
}
exports.Expr = Expr;
/**
 * A node representing a `get` expression.
 */
class VarExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitVarExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.VarExpr = VarExpr;
/**
 * A node representing a `literal` expression.
 */
class LiteralExpr extends Expr {
    /**
     * Create a [[LiteralExpr]] from the given value.
     *
     * @param value - A constant value.
     */
    static fromValue(value) {
        switch (typeof value) {
            case "boolean":
                return new BooleanLiteralExpr(value);
            case "number":
                return new NumberLiteralExpr(value);
            case "string":
                return new StringLiteralExpr(value);
            case "object":
                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);
            default:
                throw new Error(`failed to create a literal from '${value}'`);
        } // switch
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.LiteralExpr = LiteralExpr;
/**
 * Null literal expression.
 */
let NullLiteralExpr = /** @class */ (() => {
    class NullLiteralExpr extends LiteralExpr {
        constructor() {
            super();
            /** @override */
            this.value = null;
        }
        /** @override */
        accept(visitor, context) {
            return visitor.visitNullLiteralExpr(this, context);
        }
        /** @override */
        exprIsDynamic() {
            return false;
        }
    }
    NullLiteralExpr.instance = new NullLiteralExpr();
    return NullLiteralExpr;
})();
exports.NullLiteralExpr = NullLiteralExpr;
/**
 * Boolean literal expression.
 */
class BooleanLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitBooleanLiteralExpr(this, context);
    }
}
exports.BooleanLiteralExpr = BooleanLiteralExpr;
/**
 * Number literal expression.
 */
class NumberLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNumberLiteralExpr(this, context);
    }
}
exports.NumberLiteralExpr = NumberLiteralExpr;
/**
 * String literal expression.
 */
class StringLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.
     */
    get promotedValue() {
        var _a, _b, _c;
        if (this.m_promotedValue === undefined) {
            this.m_promotedValue = (_b = (_a = RGBA_1.RGBA.parse(this.value)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(this.value)) !== null && _b !== void 0 ? _b : null;
        }
        return (_c = this.m_promotedValue) !== null && _c !== void 0 ? _c : undefined;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStringLiteralExpr(this, context);
    }
}
exports.StringLiteralExpr = StringLiteralExpr;
/**
 * Object literal expression.
 */
class ObjectLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    get isArrayLiteral() {
        return Array.isArray(this.value);
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitObjectLiteralExpr(this, context);
    }
}
exports.ObjectLiteralExpr = ObjectLiteralExpr;
/**
 * A node reperesenting a `has` expression.
 */
class HasAttributeExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitHasAttributeExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.HasAttributeExpr = HasAttributeExpr;
/**
 * A node representing a `call` expression.
 */
class CallExpr extends Expr {
    constructor(op, args) {
        super();
        this.op = op;
        this.args = args;
    }
    /**
     * Returns the child nodes of this {@link Expr}.
     *
     * @deprecated Use {@link CallExpr.args} instead.
     */
    get children() {
        return this.args;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCallExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        const descriptor = this.descriptor || ExprEvaluator_1.ExprEvaluator.getOperator(this.op);
        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
            return true;
        }
        return this.args.some(e => e.isDynamic());
    }
}
exports.CallExpr = CallExpr;
/**
 * A node representing a `match` expression.
 */
class MatchExpr extends Expr {
    constructor(value, branches, fallback) {
        super();
        this.value = value;
        this.branches = branches;
        this.fallback = fallback;
    }
    /**
     * Tests if the given JSON node is a valid label for the `"match"` operator.
     *
     * @param node - A JSON value.
     */
    static isValidMatchLabel(node) {
        switch (typeof node) {
            case "number":
            case "string":
                return true;
            case "object":
                if (!Array.isArray(node) || node.length === 0) {
                    return false;
                }
                const elementTy = typeof node[0];
                if (elementTy === "number" || elementTy === "string") {
                    return node.every(t => typeof t === elementTy);
                }
                return false;
            default:
                return false;
        } // switch
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitMatchExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.value.isDynamic() ||
            this.branches.some(([_, branch]) => branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.MatchExpr = MatchExpr;
/**
 * A node representing a `case` expression.
 */
class CaseExpr extends Expr {
    constructor(branches, fallback) {
        super();
        this.branches = branches;
        this.fallback = fallback;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCaseExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.CaseExpr = CaseExpr;
/**
 * A node representing a `step` expression.
 */
class StepExpr extends Expr {
    constructor(input, defaultValue, stops) {
        super();
        this.input = input;
        this.defaultValue = defaultValue;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStepExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.input.isDynamic() ||
            this.defaultValue.isDynamic() ||
            this.stops.some(([_, value]) => value.isDynamic()));
    }
}
exports.StepExpr = StepExpr;
/**
 * A node representing an `interpolate` expression.
 */
class InterpolateExpr extends Expr {
    constructor(mode, input, stops) {
        super();
        this.mode = mode;
        this.input = input;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitInterpolateExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());
    }
}
exports.InterpolateExpr = InterpolateExpr;
/**
 * Serializes the Expr to JSON.
 *
 * @internal
 */
class ExprSerializer {
    serialize(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        if (expr.value instanceof THREE.Vector2) {
            return ["make-vector", expr.value.x, expr.value.y];
        }
        else if (expr.value instanceof THREE.Vector3) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z];
        }
        else if (expr.value instanceof THREE.Vector4) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z, expr.value.w];
        }
        return ["literal", expr.value];
    }
    visitVarExpr(expr, context) {
        return ["get", expr.name];
    }
    visitHasAttributeExpr(expr, context) {
        return ["has", expr.name];
    }
    visitCallExpr(expr, context) {
        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];
    }
    visitMatchExpr(expr, context) {
        const branches = [];
        for (const [label, body] of expr.branches) {
            branches.push(label, this.serialize(body));
        }
        return ["match", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        for (const [condition, body] of expr.branches) {
            branches.push(this.serialize(condition), this.serialize(body));
        }
        return ["case", ...branches, this.serialize(expr.fallback)];
    }
    visitStepExpr(expr, context) {
        const result = ["step"];
        result.push(this.serialize(expr.input));
        result.push(this.serialize(expr.defaultValue));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
    visitInterpolateExpr(expr, context) {
        const result = ["interpolate", expr.mode];
        result.push(this.serialize(expr.input));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
}
function parseNode(node, referenceResolverState) {
    if (Array.isArray(node)) {
        return parseCall(node, referenceResolverState);
    }
    else if (node === null) {
        return NullLiteralExpr.instance;
    }
    else if (typeof node === "boolean") {
        return new BooleanLiteralExpr(node);
    }
    else if (typeof node === "number") {
        return new NumberLiteralExpr(node);
    }
    else if (typeof node === "string") {
        return new StringLiteralExpr(node);
    }
    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);
}
function parseCall(node, referenceResolverState) {
    const op = node[0];
    if (typeof op !== "string") {
        throw new Error("expected a builtin function name");
    }
    switch (op) {
        case "!has":
        case "!in":
            return new CallExpr("!", [parseCall([op.slice(1), ...node.slice(1)])]);
        case "ref":
            return resolveReference(node, referenceResolverState);
        case "get":
            return parseGetExpr(node, referenceResolverState);
        case "has":
            return parseHasExpr(node, referenceResolverState);
        case "literal":
            return parseLiteralExpr(node);
        case "match":
            return parseMatchExpr(node, referenceResolverState);
        case "case":
            return parseCaseExpr(node, referenceResolverState);
        case "interpolate":
            return parseInterpolateExpr(node, referenceResolverState);
        case "step":
            return parseStepExpr(node, referenceResolverState);
        default:
            return makeCallExpr(op, node, referenceResolverState);
    } // switch
}
function parseGetExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("get", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new VarExpr(name);
}
function parseHasExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("has", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new HasAttributeExpr(name);
}
function parseLiteralExpr(node) {
    const obj = node[1];
    if (obj === null || typeof obj !== "object") {
        throw new Error("expected an object or array literal");
    }
    return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
    if (node.length < 4) {
        throw new Error("not enough arguments");
    }
    if (!(node.length % 2)) {
        throw new Error("fallback is missing in 'match' expression");
    }
    const value = parseNode(node[1], referenceResolverState);
    const conditions = [];
    for (let i = 2; i < node.length - 1; i += 2) {
        const label = node[i];
        if (!MatchExpr.isValidMatchLabel(label)) {
            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);
        }
        const expr = parseNode(node[i + 1], referenceResolverState);
        conditions.push([label, expr]);
    }
    const fallback = parseNode(node[node.length - 1], referenceResolverState);
    return new MatchExpr(value, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
    if (node.length < 3) {
        throw new Error("not enough arguments");
    }
    if (node.length % 2) {
        throw new Error("fallback is missing in 'case' expression");
    }
    const branches = [];
    for (let i = 1; i < node.length - 1; i += 2) {
        const condition = parseNode(node[i], referenceResolverState);
        const expr = parseNode(node[i + 1], referenceResolverState);
        branches.push([condition, expr]);
    }
    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);
    return new CaseExpr(branches, caseFallback);
}
function isInterpolationMode(object) {
    if (!Array.isArray(object)) {
        return false;
    }
    switch (object[0]) {
        case "discrete":
        case "linear":
        case "cubic":
        case "exponential":
            return true;
        default:
            return false;
    }
}
function parseInterpolateExpr(node, referenceResolverState) {
    const mode = node[1];
    if (!isInterpolationMode(mode)) {
        throw new Error("expected an interpolation type");
    }
    if (mode[0] === "exponential" && typeof mode[1] !== "number") {
        throw new Error("expected the base of the exponential interpolation");
    }
    const input = node[2] ? parseNode(node[2], referenceResolverState) : undefined;
    if (!Expr.isExpr(input)) {
        throw new Error(`expected the input of the interpolation`);
    }
    if (node.length === 3 || !(node.length % 2)) {
        throw new Error("invalid number of samples");
    }
    const stops = [];
    for (let i = 3; i < node.length - 1; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new InterpolateExpr(mode, input, stops);
}
function parseStepExpr(node, referenceResolverState) {
    if (node.length < 2) {
        throw new Error("expected the input of the 'step' operator");
    }
    if (node.length < 3 || !(node.length % 2)) {
        throw new Error("not enough arguments");
    }
    const input = parseNode(node[1], referenceResolverState);
    const defaultValue = parseNode(node[2], referenceResolverState);
    const stops = [];
    for (let i = 3; i < node.length; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new StepExpr(input, defaultValue, stops);
}
function makeCallExpr(op, node, referenceResolverState) {
    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));
}
function resolveReference(node, referenceResolverState) {
    if (typeof node[1] !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    if (referenceResolverState === undefined) {
        throw new Error(`ref used with no definitions`);
    }
    const name = node[1];
    if (referenceResolverState.lockedNames.has(name)) {
        throw new Error(`circular referene to '${name}'`);
    }
    if (!(name in referenceResolverState.definitions)) {
        throw new Error(`definition '${name}' not found`);
    }
    const cachedEntry = referenceResolverState.cache.get(name);
    if (cachedEntry !== undefined) {
        return cachedEntry;
    }
    let definitionEntry = referenceResolverState.definitions[name];
    let result;
    if (Theme_1.isLiteralDefinition(definitionEntry)) {
        return Expr.fromJSON(definitionEntry);
    }
    else if (Theme_1.isBoxedDefinition(definitionEntry)) {
        if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {
            // found a reference to an interpolation using
            // the deprecated object-like syntax.
            return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));
        }
        else if (isJsonExpr(definitionEntry.value)) {
            definitionEntry = definitionEntry.value;
        }
        else {
            return Expr.fromJSON(definitionEntry.value);
        }
    }
    if (isJsonExpr(definitionEntry)) {
        referenceResolverState.lockedNames.add(name);
        try {
            result = parseNode(definitionEntry, referenceResolverState);
        }
        finally {
            referenceResolverState.lockedNames.delete(name);
        }
    }
    else {
        throw new Error(`unsupported definition ${name}`);
    }
    referenceResolverState.cache.set(name, result);
    return result;
}
//# sourceMappingURL=Expr.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprEvaluator = exports.ExprEvaluatorContext = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js");
const CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js");
const ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js");
const ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js");
const FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js");
const FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js");
const MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js");
const MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js");
const MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js");
const ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js");
const StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js");
const TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js");
const VectorOperators_1 = __webpack_require__(/*! ./operators/VectorOperators */ "./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js");
const operatorDescriptors = new Map();
/**
 * Promote string literals and values to color and pixel constants.
 *
 * @hidden
 * @internal
 */
function promoteValue(context, expr) {
    var _a, _b, _c;
    if (expr instanceof Expr_1.StringLiteralExpr) {
        return (_a = expr.promotedValue) !== null && _a !== void 0 ? _a : expr.value;
    }
    const value = context.evaluate(expr);
    if (typeof value === "string") {
        return (_c = (_b = RGBA_1.RGBA.parse(value)) !== null && _b !== void 0 ? _b : Pixels_1.Pixels.parse(value)) !== null && _c !== void 0 ? _c : value;
    }
    return value;
}
function cubicInterpolate(context, interp, t) {
    if (t < interp.stops[0][0]) {
        return promoteValue(context, interp.stops[0][1]);
    }
    else if (t >= interp.stops[interp.stops.length - 1][0]) {
        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);
    }
    // indices
    const i1 = interp.stops.findIndex(stop => stop[0] > t);
    const i0 = Math.max(0, i1 - 1);
    const iP = i0 === 0 ? i1 : i0 - 1;
    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;
    // keys
    const tP = interp.stops[iP][0];
    const t0 = interp.stops[i0][0];
    const t1 = interp.stops[i1][0];
    const tN = interp.stops[iN][0];
    const dt = (t1 - t0) * 0.5;
    const wP = dt / (t0 - tP);
    const wN = dt / (tN - t1);
    const p = (t - t0) / (t1 - t0);
    const pp = p * p;
    const ppp = pp * p;
    // coefficients
    const cP = -wP * ppp + 2 * wP * pp - wP * p;
    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const cN = wN * ppp - wN * pp;
    // values
    const vP = promoteValue(context, interp.stops[iP][1]);
    const v0 = promoteValue(context, interp.stops[i0][1]);
    const v1 = promoteValue(context, interp.stops[i1][1]);
    const vN = promoteValue(context, interp.stops[iN][1]);
    if (typeof vP === "number" &&
        typeof v0 === "number" &&
        typeof v1 === "number" &&
        typeof vN === "number") {
        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;
    }
    else if (vP instanceof RGBA_1.RGBA &&
        v0 instanceof RGBA_1.RGBA &&
        v1 instanceof RGBA_1.RGBA &&
        vN instanceof RGBA_1.RGBA) {
        return new RGBA_1.RGBA(THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));
    }
    else if (vP instanceof Pixels_1.Pixels &&
        v0 instanceof Pixels_1.Pixels &&
        v1 instanceof Pixels_1.Pixels &&
        vN instanceof Pixels_1.Pixels) {
        return new Pixels_1.Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);
    }
    else if (vP instanceof THREE.Color &&
        v0 instanceof THREE.Color &&
        v1 instanceof THREE.Color &&
        vN instanceof THREE.Color) {
        return new THREE.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);
    }
    else if (vP instanceof THREE.Vector2 &&
        v0 instanceof THREE.Vector2 &&
        v1 instanceof THREE.Vector2 &&
        vN instanceof THREE.Vector2) {
        return new THREE.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);
    }
    else if (vP instanceof THREE.Vector3 &&
        v0 instanceof THREE.Vector3 &&
        v1 instanceof THREE.Vector3 &&
        vN instanceof THREE.Vector3) {
        return new THREE.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);
    }
    else if (vP instanceof THREE.Vector4 &&
        v0 instanceof THREE.Vector4 &&
        v1 instanceof THREE.Vector4 &&
        vN instanceof THREE.Vector4) {
        return new THREE.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);
    }
    else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {
        const N = vP.length;
        const r = [];
        for (let i = 0; i < N; ++i) {
            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];
        }
        return r;
    }
    throw new Error(`failed to interpolate values`);
}
/*
 * @hidden
 */
class ExprEvaluatorContext {
    constructor(evaluator, env, scope, cache) {
        this.evaluator = evaluator;
        this.env = env;
        this.scope = scope;
        this.cache = cache;
    }
    /**
     * Evaluate the given expression.
     *
     * @param expr - The {@link Expr} to evaluate.
     */
    evaluate(expr) {
        var _a, _b;
        if (expr === undefined) {
            throw new Error("Failed to evaluate expression");
        }
        const cachedResult = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(expr);
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        const result = expr.accept(this.evaluator, this);
        (_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(expr, result);
        return result;
    }
    /**
     * Wraps the given value in an {@link Expr} if needed.
     *
     * @param value -
     */
    wrapValue(value) {
        return Expr_1.Expr.isExpr(value) ? value : Expr_1.LiteralExpr.fromValue(value);
    }
}
exports.ExprEvaluatorContext = ExprEvaluatorContext;
/**
 * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.
 *
 * @hidden
 */
class ExprEvaluator {
    static defineOperator(op, builtin) {
        operatorDescriptors.set(op, builtin);
    }
    static defineOperators(builtins) {
        Object.getOwnPropertyNames(builtins).forEach(p => {
            this.defineOperator(p, builtins[p]);
        });
    }
    /**
     * Returns the [[OperatorDescriptor]] for the given operator name.
     * @hidden
     */
    static getOperator(op) {
        return operatorDescriptors.get(op);
    }
    visitVarExpr(expr, context) {
        const value = context.env.lookup(expr.name);
        return value !== undefined ? value : null;
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        return expr.value;
    }
    visitHasAttributeExpr(expr, context) {
        return context.env.lookup(expr.name) !== undefined;
    }
    visitMatchExpr(match, context) {
        const r = context.evaluate(match.value);
        for (const [label, body] of match.branches) {
            if (Array.isArray(label) && label.includes(r)) {
                return context.evaluate(body);
            }
            else if (label === r) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCaseExpr(match, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const firstDynamicCondition = match.branches.findIndex(([condition, _]) => condition.isDynamic());
            if (firstDynamicCondition !== -1) {
                let branches;
                // tslint:disable-next-line: prefer-for-of
                for (let i = 0; i < match.branches.length; ++i) {
                    const [condition, body] = match.branches[i];
                    const evaluatedCondition = context.evaluate(condition);
                    const evaluatedBody = context.evaluate(body);
                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {
                        return evaluatedBody;
                    }
                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {
                        // skip this branch, it constantly evaluates to false.
                        continue;
                    }
                    if (branches === undefined) {
                        branches = [];
                    }
                    branches === null || branches === void 0 ? void 0 : branches.push([
                        context.wrapValue(evaluatedCondition),
                        context.wrapValue(evaluatedBody)
                    ]);
                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {
                        // skip unreachble expressions
                        return new Expr_1.CaseExpr(branches, Expr_1.LiteralExpr.fromValue(null));
                    }
                }
                const fallback = context.evaluate(match.fallback);
                return branches === undefined
                    ? fallback
                    : new Expr_1.CaseExpr(branches, context.wrapValue(fallback));
            }
        }
        for (const [condition, body] of match.branches) {
            if (context.evaluate(condition)) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCallExpr(expr, context) {
        var _a;
        const descriptor = (_a = expr.descriptor) !== null && _a !== void 0 ? _a : operatorDescriptors.get(expr.op);
        if (descriptor) {
            expr.descriptor = descriptor;
            let result;
            if (context.scope === Expr_1.ExprScope.Value && expr.isDynamic()) {
                if (expr.descriptor.partialEvaluate) {
                    return expr.descriptor.partialEvaluate(context, expr);
                }
                const args = expr.args.map(arg => {
                    return context.wrapValue(context.evaluate(arg));
                });
                if (args.every((arg, i) => arg === expr.args[i])) {
                    return expr;
                }
                result = new Expr_1.CallExpr(expr.op, args);
            }
            else {
                result = descriptor.call(context, expr);
            }
            return result;
        }
        throw new Error(`undefined operator '${expr.op}'`);
    }
    visitStepExpr(expr, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const input = context.evaluate(expr.input);
            const defaultValue = context.evaluate(expr.defaultValue);
            return new Expr_1.StepExpr(context.wrapValue(input), context.wrapValue(defaultValue), 
            // tslint:disable-next-line: no-shadowed-variable
            expr.stops.map(([key, value]) => {
                const v = context.evaluate(value);
                return [key, context.wrapValue(v)];
            }));
        }
        else {
            const input = context.evaluate(expr.input);
            if (typeof input !== "number") {
                throw new Error(`input '${input}' must be a number`);
            }
            if (input < expr.stops[0][0]) {
                return context.evaluate(expr.defaultValue);
            }
            let index = expr.stops.findIndex(s => s[0] > input);
            if (index === -1) {
                index = expr.stops.length;
            }
            return context.evaluate(expr.stops[index - 1][1]);
        }
    }
    visitInterpolateExpr(expr, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const input = context.evaluate(expr.input);
            return new Expr_1.InterpolateExpr(expr.mode, context.wrapValue(input), expr.stops.map(([key, value]) => {
                const v = context.evaluate(value);
                return [key, context.wrapValue(v)];
            }));
        }
        else {
            const param = context.evaluate(expr.input);
            if (typeof param !== "number") {
                throw new Error(`input must be a number`);
            }
            if (expr.mode[0] === "cubic") {
                return cubicInterpolate(context, expr, param);
            }
            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);
            if (keyIndex === -1) {
                // all the keys are smaller than the parameter
                return context.evaluate(expr.stops[expr.stops.length - 1][1]);
            }
            else if (keyIndex === 0) {
                return context.evaluate(expr.stops[0][1]);
            }
            const [key, value] = expr.stops[keyIndex];
            const [prevKey, prevValue] = expr.stops[keyIndex - 1];
            const v0 = promoteValue(context, prevValue);
            let t = 0;
            switch (expr.mode[0]) {
                case "discrete":
                    return v0;
                case "linear":
                    t = (param - prevKey) / (key - prevKey);
                    break;
                case "exponential": {
                    const base = expr.mode[1];
                    t = (Math.pow(base, param - prevKey) - 1) / (Math.pow(base, key - prevKey) - 1);
                    break;
                }
                default:
                    throw new Error(`interpolation mode ${JSON.stringify(expr.mode)} is not supported`);
            }
            const v1 = promoteValue(context, value);
            if (typeof v0 === "number" && typeof v1 === "number") {
                return THREE.MathUtils.lerp(v0, v1, t);
            }
            else if (v0 instanceof RGBA_1.RGBA && v1 instanceof RGBA_1.RGBA) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof Pixels_1.Pixels && v1 instanceof Pixels_1.Pixels) {
                return new Pixels_1.Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));
            }
            else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {
                return v0.clone().lerp(v1, t);
            }
            else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {
                return v0.map((x, i) => THREE.MathUtils.lerp(x, v1[i], t));
            }
            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);
        }
    }
}
exports.ExprEvaluator = ExprEvaluator;
ExprEvaluator.defineOperators(CastOperators_1.CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators_1.MathOperators);
ExprEvaluator.defineOperators(StringOperators_1.StringOperators);
ExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);
ExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);
ExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);
ExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);
ExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);
ExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);
ExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);
ExprEvaluator.defineOperators(MapOperators_1.MapOperators);
ExprEvaluator.defineOperators(VectorOperators_1.VectorOperators);
//# sourceMappingURL=ExprEvaluator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprInstantiator = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const Env_1 = __webpack_require__(/*! ./Env */ "./node_modules/@here/harp-datasource-protocol/lib/Env.js");
const emptyEnv = new Env_1.Env();
/**
 * @hidden
 */
class ExprInstantiator {
    visitNullLiteralExpr(expr, _context) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, _context) {
        return expr;
    }
    visitNumberLiteralExpr(expr, _context) {
        return expr;
    }
    visitStringLiteralExpr(expr, _context) {
        return expr;
    }
    visitObjectLiteralExpr(expr, _context) {
        return expr;
    }
    visitVarExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name);
        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);
    }
    visitHasAttributeExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name) !== undefined;
        return Expr_1.LiteralExpr.fromValue(value);
    }
    visitCallExpr(expr, context) {
        const args = expr.args.map(arg => arg.accept(this, context));
        if (args.some((a, i) => a !== expr.args[i])) {
            return new Expr_1.CallExpr(expr.op, args);
        }
        return expr;
    }
    visitMatchExpr(match, context) {
        const value = match.value.accept(this, context);
        if (value instanceof Expr_1.LiteralExpr) {
            const r = value.value;
            for (const [label, body] of match.branches) {
                if (Array.isArray(label) && label.includes(r)) {
                    return body.accept(this, context);
                }
                else if (label === r) {
                    return body.accept(this, context);
                }
            }
            return match.fallback.accept(this, context);
        }
        let changed = match.value !== value;
        const branches = match.branches.map(([label, branch]) => {
            const newBranch = branch.accept(this, context);
            if (newBranch !== branch) {
                changed = true;
            }
            return [label, newBranch];
        });
        const fallback = match.fallback.accept(this, context);
        if (fallback !== match.fallback) {
            changed = true;
        }
        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        let changed = false;
        for (const [condition, branch] of expr.branches) {
            const newCondition = condition.accept(this, context);
            const deps = newCondition.dependencies();
            if (!condition.isDynamic() && deps.properties.size === 0) {
                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {
                    return branch.accept(this, context);
                }
            }
            else {
                if (newCondition !== condition) {
                    changed = true;
                }
                branches.push([newCondition, branch]);
            }
        }
        if (branches.length === 0) {
            // all the conditions of this CaseExpr evaluated
            // to false, so the resulting of instantiating this CaseExpr
            // is the same as instantiating its fallback expression.
            return expr.fallback.accept(this, context);
        }
        if (branches.length !== expr.branches.length) {
            // the number of branches changed, this means that
            // some of the branches had constant expressions that
            // evaluate to false. In this case the resulting
            // `CaseExpr` has less branches.
            changed = true;
        }
        // Instantiate the body of all the branches of this CaseExpr
        // that have dynamic conditions.
        branches.forEach(branch => {
            const instantiatedBranch = branch[1].accept(this, context);
            if (instantiatedBranch !== branch[1]) {
                changed = true;
            }
            branch[1] = instantiatedBranch;
        });
        const fallback = expr.fallback.accept(this, context);
        if (fallback !== expr.fallback) {
            changed = true;
        }
        if (!changed) {
            // nothing changed, return the old expression.
            return expr;
        }
        return new Expr_1.CaseExpr(branches, fallback);
    }
    visitStepExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.StepExpr(input, defaultValue, stops);
    }
    visitInterpolateExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.InterpolateExpr(expr.mode, input, stops);
    }
}
exports.ExprInstantiator = ExprInstantiator;
//# sourceMappingURL=ExprInstantiator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprParser = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
/**
 * Character value
 */
var Character;
(function (Character) {
    Character[Character["Tab"] = 9] = "Tab";
    Character[Character["Lf"] = 10] = "Lf";
    Character[Character["Cr"] = 13] = "Cr";
    Character[Character["Space"] = 32] = "Space";
    Character[Character["LParen"] = 40] = "LParen";
    Character[Character["RParen"] = 41] = "RParen";
    Character[Character["Comma"] = 44] = "Comma";
    Character[Character["Dot"] = 46] = "Dot";
    Character[Character["LBracket"] = 91] = "LBracket";
    Character[Character["Backslash"] = 92] = "Backslash";
    Character[Character["RBracket"] = 93] = "RBracket";
    Character[Character["_0"] = 48] = "_0";
    Character[Character["_9"] = 57] = "_9";
    Character[Character["_"] = 95] = "_";
    Character[Character["A"] = 64] = "A";
    Character[Character["Z"] = 90] = "Z";
    Character[Character["a"] = 97] = "a";
    Character[Character["z"] = 122] = "z";
    Character[Character["DoubleQuote"] = 34] = "DoubleQuote";
    Character[Character["SingleQuote"] = 39] = "SingleQuote";
    Character[Character["Exclaim"] = 33] = "Exclaim";
    Character[Character["Equal"] = 61] = "Equal";
    Character[Character["Caret"] = 94] = "Caret";
    Character[Character["Tilde"] = 126] = "Tilde";
    Character[Character["Dollar"] = 36] = "Dollar";
    Character[Character["Less"] = 60] = "Less";
    Character[Character["Greater"] = 62] = "Greater";
    Character[Character["Bar"] = 124] = "Bar";
    Character[Character["Amp"] = 38] = "Amp";
})(Character || (Character = {}));
/**
 * Check if a codepoint is a whitespace character.
 */
function isSpace(codepoint) {
    switch (codepoint) {
        case Character.Tab:
        case Character.Lf:
        case Character.Cr:
        case Character.Space:
            return true;
        default:
            return false;
    } // switch
}
/**
 * Check if codepoint is a digit character.
 */
function isNumber(codepoint) {
    return codepoint >= Character._0 && codepoint <= Character._9;
}
/**
 * Check if codepoint is a letter character.
 */
function isLetter(codepoint) {
    return ((codepoint >= Character.a && codepoint <= Character.z) ||
        (codepoint >= Character.A && codepoint <= Character.Z));
}
/**
 * Check if codepoint is either a digit or a letter character.
 */
function isLetterOrNumber(codepoint) {
    return isLetter(codepoint) || isNumber(codepoint);
}
/**
 * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.
 */
function isIdentChar(codepoint) {
    return (isLetterOrNumber(codepoint) ||
        codepoint === Character._ ||
        codepoint === Character.Dollar ||
        codepoint === Character.Dot ||
        codepoint === Character.LBracket ||
        codepoint === Character.RBracket);
}
/**
 * Tokens used in theme grammar.
 */
var Token;
(function (Token) {
    Token[Token["Eof"] = 0] = "Eof";
    Token[Token["Error"] = 1] = "Error";
    Token[Token["Identifier"] = 2] = "Identifier";
    Token[Token["Number"] = 3] = "Number";
    Token[Token["String"] = 4] = "String";
    Token[Token["Comma"] = 5] = "Comma";
    Token[Token["LParen"] = 6] = "LParen";
    Token[Token["RParen"] = 7] = "RParen";
    Token[Token["LBracket"] = 8] = "LBracket";
    Token[Token["RBracket"] = 9] = "RBracket";
    Token[Token["Exclaim"] = 10] = "Exclaim";
    Token[Token["TildeEqual"] = 11] = "TildeEqual";
    Token[Token["CaretEqual"] = 12] = "CaretEqual";
    Token[Token["DollarEqual"] = 13] = "DollarEqual";
    Token[Token["EqualEqual"] = 14] = "EqualEqual";
    Token[Token["ExclaimEqual"] = 15] = "ExclaimEqual";
    Token[Token["Less"] = 16] = "Less";
    Token[Token["Greater"] = 17] = "Greater";
    Token[Token["LessEqual"] = 18] = "LessEqual";
    Token[Token["GreaterEqual"] = 19] = "GreaterEqual";
    Token[Token["BarBar"] = 20] = "BarBar";
    Token[Token["AmpAmp"] = 21] = "AmpAmp";
})(Token || (Token = {}));
/**
 * Maps a token to its string name.
 */
function tokenSpell(token) {
    switch (token) {
        case Token.Eof:
            return "eof";
        case Token.Error:
            return "error";
        case Token.Identifier:
            return "identifier";
        case Token.Number:
            return "number";
        case Token.String:
            return "string";
        case Token.Comma:
            return ",";
        case Token.LParen:
            return "(";
        case Token.RParen:
            return ")";
        case Token.LBracket:
            return "[";
        case Token.RBracket:
            return "]";
        case Token.Exclaim:
            return "!";
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        case Token.BarBar:
            return "||";
        case Token.AmpAmp:
            return "&&";
        default:
            throw new Error(`invalid token ${token}`);
    }
}
/**
 * Lexer class implementation.
 */
class Lexer {
    constructor(code) {
        this.code = code;
        this.m_token = Token.Error;
        this.m_index = 0;
        this.m_char = Character.Lf;
    }
    /**
     * Single lexer token.
     */
    token() {
        return this.m_token;
    }
    /**
     * Parsed text.
     */
    text() {
        return this.m_text || "";
    }
    /**
     * Go to the next token.
     */
    next() {
        this.m_token = this.yylex();
        if (this.m_token === Token.Error) {
            throw new Error(`unexpected character ${this.m_char}`);
        }
        return this.m_token;
    }
    yyinp() {
        this.m_char = this.code.codePointAt(this.m_index++) || 0;
    }
    yylex() {
        this.m_text = undefined;
        while (isSpace(this.m_char)) {
            this.yyinp();
        }
        if (this.m_char === 0) {
            return Token.Eof;
        }
        const ch = this.m_char;
        this.yyinp();
        switch (ch) {
            case Character.LParen:
                return Token.LParen;
            case Character.RParen:
                return Token.RParen;
            case Character.LBracket:
                return Token.LBracket;
            case Character.RBracket:
                return Token.RBracket;
            case Character.Comma:
                return Token.Comma;
            case Character.SingleQuote:
            case Character.DoubleQuote: {
                const start = this.m_index - 1;
                while (this.m_char && this.m_char !== ch) {
                    // ### TODO handle escape sequences
                    this.yyinp();
                }
                if (this.m_char !== ch) {
                    throw new Error("Unfinished string literal");
                }
                this.yyinp();
                this.m_text = this.code.substring(start, this.m_index - 2);
                return Token.String;
            }
            case Character.Exclaim:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.ExclaimEqual;
                }
                return Token.Exclaim;
            case Character.Caret:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.CaretEqual;
                }
                return Token.Error;
            case Character.Tilde:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.TildeEqual;
                }
                return Token.Error;
            case Character.Equal:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.EqualEqual;
                }
                return Token.Error;
            case Character.Less:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.LessEqual;
                }
                return Token.Less;
            case Character.Greater:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.GreaterEqual;
                }
                return Token.Greater;
            case Character.Bar:
                if (this.m_char === Character.Bar) {
                    this.yyinp();
                    return Token.BarBar;
                }
                return Token.Error;
            case Character.Amp:
                if (this.m_char === Character.Amp) {
                    this.yyinp();
                    return Token.AmpAmp;
                }
                return Token.Error;
            default: {
                const start = this.m_index - 2;
                if (isLetter(ch) ||
                    ch === Character._ ||
                    (ch === Character.Dollar && isIdentChar(this.m_char))) {
                    while (isIdentChar(this.m_char)) {
                        this.yyinp();
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Identifier;
                }
                else if (isNumber(ch)) {
                    while (isNumber(this.m_char)) {
                        this.yyinp();
                    }
                    if (this.m_char === Character.Dot) {
                        this.yyinp();
                        while (isNumber(this.m_char)) {
                            this.yyinp();
                        }
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Number;
                }
                else if (ch === Character.Dollar) {
                    if (this.m_char === Character.Equal) {
                        this.yyinp();
                        return Token.DollarEqual;
                    }
                    return Token.Error;
                }
            }
        }
        return Token.Error;
    }
}
function getEqualityOp(token) {
    switch (token) {
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        default:
            return undefined;
    } // switch
}
function getRelationalOp(token) {
    switch (token) {
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        default:
            return undefined;
    } // switch
}
class ExprParser {
    constructor(code) {
        this.lex = new Lexer(code);
        this.lex.next();
    }
    parse() {
        return this.parseLogicalOr();
    }
    yyexpect(token) {
        if (this.lex.token() !== token) {
            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +
                `found '${tokenSpell(this.lex.token())}'`);
        }
        this.lex.next();
    }
    parsePrimary() {
        switch (this.lex.token()) {
            case Token.Identifier: {
                const text = this.lex.text();
                switch (text) {
                    case "has":
                        this.lex.next(); // skip has keyword
                        this.yyexpect(Token.LParen);
                        const hasAttribute = this.lex.text();
                        this.yyexpect(Token.Identifier);
                        this.yyexpect(Token.RParen);
                        return new Expr_1.HasAttributeExpr(hasAttribute);
                    case "length":
                        this.lex.next(); // skip length keyword
                        this.yyexpect(Token.LParen);
                        const value = this.parseLogicalOr();
                        this.yyexpect(Token.RParen);
                        return new Expr_1.CallExpr("length", [value]);
                    default:
                        const expr = new Expr_1.VarExpr(text);
                        this.lex.next();
                        return expr;
                }
            }
            case Token.LParen: {
                this.lex.next();
                const expr = this.parseLogicalOr();
                this.yyexpect(Token.RParen);
                return expr;
            }
            default:
                return this.parseLiteral();
        } // switch
    }
    parseLiteral() {
        switch (this.lex.token()) {
            case Token.Number: {
                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));
                this.lex.next();
                return expr;
            }
            case Token.String: {
                const expr = new Expr_1.StringLiteralExpr(this.lex.text());
                this.lex.next();
                return expr;
            }
            default:
                throw new Error("Syntax error");
        } // switch
    }
    parseUnary() {
        if (this.lex.token() === Token.Exclaim) {
            this.lex.next();
            return new Expr_1.CallExpr("!", [this.parseUnary()]);
        }
        return this.parsePrimary();
    }
    parseRelational() {
        let expr = this.parseUnary();
        while (true) {
            if (this.lex.token() === Token.Identifier && this.lex.text() === "in") {
                this.lex.next();
                this.yyexpect(Token.LBracket);
                const elements = [this.parseLiteral()];
                while (this.lex.token() === Token.Comma) {
                    this.lex.next();
                    elements.push(this.parseLiteral());
                }
                this.yyexpect(Token.RBracket);
                expr = new Expr_1.CallExpr("in", [
                    expr,
                    Expr_1.LiteralExpr.fromValue(elements.map(({ value }) => value))
                ]);
            }
            else {
                const op = getRelationalOp(this.lex.token());
                if (op === undefined) {
                    break;
                }
                this.lex.next();
                const right = this.parseUnary();
                expr = new Expr_1.CallExpr(op, [expr, right]);
            }
        }
        return expr;
    }
    parseEquality() {
        let expr = this.parseRelational();
        while (true) {
            let op = getEqualityOp(this.lex.token());
            if (op === undefined) {
                break;
            }
            if (op === "~=") {
                op = "in";
            }
            this.lex.next();
            const right = this.parseRelational();
            expr = new Expr_1.CallExpr(op, [expr, right]);
        }
        return expr;
    }
    parseLogicalAnd() {
        const expr = this.parseEquality();
        if (this.lex.token() !== Token.AmpAmp) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseEquality());
        } while (this.lex.token() === Token.AmpAmp);
        return new Expr_1.CallExpr("all", expressions);
    }
    parseLogicalOr() {
        const expr = this.parseLogicalAnd();
        if (this.lex.token() !== Token.BarBar) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseLogicalAnd());
        } while (this.lex.token() === Token.BarBar);
        return new Expr_1.CallExpr("any", expressions);
    }
}
exports.ExprParser = ExprParser;
//# sourceMappingURL=ExprParser.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprPool = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
/**
 * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.
 *
 * @hidden
 */
class ExprPool {
    constructor() {
        this.m_booleanLiterals = new Map();
        this.m_numberLiterals = new Map();
        this.m_stringLiterals = new Map();
        this.m_objectLiterals = new Map();
        this.m_arrayLiterals = [];
        this.m_varExprs = new Map();
        this.m_hasAttributeExprs = new Map();
        this.m_matchExprs = [];
        this.m_caseExprs = [];
        this.m_interpolateExprs = [];
        this.m_stepExprs = [];
        this.m_callExprs = new Map();
    }
    /**
     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}
     * object that is structurally equivalent to `expr`.
     *
     * @param expr - The {@link Expr} to add to this [[ExprPool]].
     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.
     */
    add(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return Expr_1.NullLiteralExpr.instance;
    }
    visitBooleanLiteralExpr(expr, context) {
        const e = this.m_booleanLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_booleanLiterals.set(expr.value, expr);
        return expr;
    }
    visitNumberLiteralExpr(expr, context) {
        const e = this.m_numberLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_numberLiterals.set(expr.value, expr);
        return expr;
    }
    visitStringLiteralExpr(expr, context) {
        const e = this.m_stringLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_stringLiterals.set(expr.value, expr);
        return expr;
    }
    visitObjectLiteralExpr(expr, context) {
        const e = this.m_objectLiterals.get(expr.value);
        if (e) {
            return e;
        }
        if (Array.isArray(expr.value)) {
            const array = expr.value;
            const r = this.m_arrayLiterals.find(literal => {
                const elements = literal.value;
                if (elements.length !== array.length) {
                    return false;
                }
                return array.every((x, i) => x === elements[i]);
            });
            if (r !== undefined) {
                return r;
            }
            this.m_arrayLiterals.push(expr);
        }
        this.m_objectLiterals.set(expr.value, expr);
        return expr;
    }
    visitVarExpr(expr, context) {
        const e = this.m_varExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_varExprs.set(expr.name, expr);
        return expr;
    }
    visitHasAttributeExpr(expr, context) {
        const e = this.m_hasAttributeExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_hasAttributeExprs.set(expr.name, expr);
        return expr;
    }
    visitMatchExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const branches = expr.branches.map(([label, body]) => [
            label,
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_matchExprs) {
            if (candidate.value !== value) {
                continue;
            }
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.MatchExpr(value, branches, fallback);
        this.m_matchExprs.push(r);
        return r;
    }
    visitCaseExpr(expr, context) {
        const branches = expr.branches.map(([condition, body]) => [
            condition.accept(this, context),
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_caseExprs) {
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.CaseExpr(branches, fallback);
        this.m_caseExprs.push(r);
        return r;
    }
    visitCallExpr(expr, context) {
        // rewrite the actual arguments
        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));
        // ensure we have a valid set of interned expressions for the calls
        if (!this.m_callExprs.has(expr.op)) {
            this.m_callExprs.set(expr.op, []);
        }
        // get the calls for the given operator.
        const calls = this.m_callExprs.get(expr.op);
        for (const call of calls) {
            // check the number of arguments
            if (call.args.length !== expressions.length) {
                continue;
            }
            // find the index of the first mismatch.
            let index = 0;
            for (; index < call.args.length; ++index) {
                if (call.args[index] !== expressions[index]) {
                    break;
                }
            }
            if (index === call.args.length) {
                // no mismatch found, return the 'interned' call.
                return call;
            }
        }
        const e = new Expr_1.CallExpr(expr.op, expressions);
        e.descriptor = expr.descriptor;
        calls.push(e);
        return e;
    }
    visitStepExpr(expr, context) {
        if (this.m_stepExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const step of this.m_stepExprs) {
            if (step.input === input &&
                step.defaultValue === defaultValue &&
                stops.length === step.stops.length &&
                stops.every(([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1])) {
                return step;
            }
        }
        const e = new Expr_1.StepExpr(input, defaultValue, stops);
        this.m_stepExprs.push(e);
        return e;
    }
    visitInterpolateExpr(expr, context) {
        if (this.m_interpolateExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const interp of this.m_interpolateExprs) {
            if (interp.input === input &&
                interp.mode[0] === expr.mode[0] &&
                interp.mode[1] === expr.mode[1] &&
                stops.length === interp.stops.length &&
                stops.every(([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1])) {
                return interp;
            }
        }
        const e = new Expr_1.InterpolateExpr(expr.mode, input, stops);
        this.m_interpolateExprs.push(e);
        return e;
    }
}
exports.ExprPool = ExprPool;
//# sourceMappingURL=ExprPool.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/GeoJsonDataType.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GeoJsonDataType.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/IMeshBuffers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=IMeshBuffers.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITileDecoder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ITileDecoder.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ITiler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ITiler.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ITiler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.interpolatedPropertyDefinitionToJsonExpr = exports.isInterpolatedPropertyDefinition = exports.InterpolationMode = void 0;
/**
 * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.
 * @internal
 */
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Discrete"] = 0] = "Discrete";
    InterpolationMode[InterpolationMode["Linear"] = 1] = "Linear";
    InterpolationMode[InterpolationMode["Cubic"] = 2] = "Cubic";
    InterpolationMode[InterpolationMode["Exponential"] = 3] = "Exponential";
})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));
/**
 * Checks if a property is interpolated.
 * @param p - property to be checked
 * @internal
 */
function isInterpolatedPropertyDefinition(p) {
    if (p &&
        p.interpolationMode === undefined &&
        Array.isArray(p.values) &&
        p.values.length > 0 &&
        p.values[0] !== undefined &&
        Array.isArray(p.zoomLevels) &&
        p.zoomLevels.length > 0 &&
        p.zoomLevels[0] !== undefined &&
        p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
exports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;
/**
 * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].
 *
 * @param property - A valid [[InterpolatedPropertyDefinition]]
 */
function interpolatedPropertyDefinitionToJsonExpr(property) {
    if (property.interpolation === undefined || property.interpolation === "Discrete") {
        const step = ["step", ["zoom"], property.values[0]];
        for (let i = 1; i < property.zoomLevels.length; ++i) {
            step.push(property.zoomLevels[i], property.values[i]);
        }
        return step;
    }
    const interpolation = ["interpolate"];
    switch (property.interpolation) {
        case "Linear":
            interpolation.push(["linear"]);
            break;
        case "Cubic":
            interpolation.push(["cubic"]);
            break;
        case "Exponential":
            interpolation.push([
                "exponential",
                property.exponent !== undefined ? property.exponent : 2
            ]);
            break;
        default:
            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);
    } //switch
    interpolation.push(["zoom"]);
    for (let i = 0; i < property.zoomLevels.length; ++i) {
        interpolation.push(property.zoomLevels[i], property.values[i]);
    }
    return interpolation;
}
exports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;
//# sourceMappingURL=InterpolatedPropertyDefs.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Outliner.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Outliner.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPolygonEdges = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const currEdgeStart = new THREE.Vector2();
const currEdgeGoal = new THREE.Vector2();
const prevEdgeStart = new THREE.Vector2();
const prevEdgeGoal = new THREE.Vector2();
/**
 * Fills an index buffer with the indices for the edges of a polygon contour.
 *
 * @param indexBuffer - Edge index buffer to be filled.
 * @param vertexOffset - Starting offset of the vertices composing the contour.
 * @param vertexStride - Number of elements per contour vertex.
 * @param polygonContour - Vertices that compose the contour.
 * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.
 */
function addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {
    for (let i = 0; i < polygonContourEdges.length; ++i) {
        if (polygonContourEdges[i]) {
            if (isExtruded === true) {
                const vFootprint0 = vertexOffset + i * 2;
                const vRoof0 = vFootprint0 + 1;
                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;
                const vRoof1 = vFootprint1 + 1;
                if (addFootprintEdges === true) {
                    indexBuffer.push(vFootprint0, vFootprint1);
                }
                indexBuffer.push(vRoof0, vRoof1);
                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;
                if (polygonContourEdges[prevEdgeIdx]) {
                    if (wallEdgeSlope !== undefined) {
                        const v0x = polygonContour[i * vertexStride];
                        const v0y = polygonContour[i * vertexStride + 1];
                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];
                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];
                        currEdgeStart.set(v0x, v0y);
                        currEdgeGoal.set(v1x, v1y);
                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);
                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);
                        if (prevEdgeGoal
                            .sub(prevEdgeStart)
                            .normalize()
                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {
                            indexBuffer.push(vFootprint0, vRoof0);
                        }
                    }
                    else {
                        indexBuffer.push(vFootprint0, vRoof0);
                    }
                }
            }
            else {
                const vFoot0 = vertexOffset + i;
                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);
                indexBuffer.push(vFoot0, vRoof0);
            }
        }
    }
}
exports.addPolygonEdges = addPolygonEdges;
//# sourceMappingURL=Outliner.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Pixels.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pixels = void 0;
const RX = /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/;
/**
 * A class representing Pixels.
 *
 * @hidden
 * @internal
 */
class Pixels {
    /**
     * Constructs a [[Pixels]] literal
     *
     * @param value - The number of pixels.
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * Parses a pixel string literal.
     *
     * @param text - The string color literal
     */
    static parse(text) {
        const match = RX.exec(text);
        if (match === null) {
            return undefined;
        }
        return new Pixels(Number(match[1]));
    }
    toJSON() {
        return `${this.value}px`;
    }
}
exports.Pixels = Pixels;
//# sourceMappingURL=Pixels.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PostEffects.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=PostEffects.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPropertyValue = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "./node_modules/@here/harp-datasource-protocol/lib/Pixels.js");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js");
const logger = harp_utils_1.LoggerManager.instance.create("PropertyValue");
/**
 * Get the value of the specified property in given `env`.
 *
 * @param property - Property of a technique.
 * @param env - The {@link Env} used to evaluate the property
 * @param cache - An optional expression cache.
 */
function getPropertyValue(property, env, cache) {
    var _a, _b, _c;
    if (Expr_1.Expr.isExpr(property)) {
        try {
            let r = property.evaluate(env, Expr_1.ExprScope.Dynamic, cache);
            if (typeof r === "string") {
                r = (_b = (_a = RGBA_1.RGBA.parse(r)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(r)) !== null && _b !== void 0 ? _b : r;
            }
            if (r instanceof RGBA_1.RGBA) {
                return r.getHex();
            }
            else if (r instanceof Pixels_1.Pixels) {
                return r.value * ((_c = Number(env.lookup("$pixelToMeters"))) !== null && _c !== void 0 ? _c : 1);
            }
            return r;
        }
        catch (error) {
            logger.error("failed to evaluate expression", JSON.stringify(property), "error", String(error));
            return null;
        }
    }
    if (property === null || typeof property === "undefined") {
        return null;
    }
    else if (typeof property !== "string") {
        // Property in numeric or array, etc. format
        return property;
    }
    else {
        // Non-interpolated string encoded numeral parsing
        const pixelToMeters = env.lookup("$pixelToMeters") || 1;
        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);
        return value !== undefined ? value : property;
    }
}
exports.getPropertyValue = getPropertyValue;
//# sourceMappingURL=PropertyValue.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/RGBA.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/RGBA.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RGBA = void 0;
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js");
/**
 * A class representing RGBA colors.
 *
 * @hidden
 * @internal
 */
class RGBA {
    /**
     * Constructs a [[RGBA]] color using the given components in the [0..1] range.
     */
    constructor(r = 1, g = 1, b = 1, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Parses a string describing a color.
     *
     * @param text - The string color literal
     */
    static parse(text) {
        const color = StringEncodedNumeral_1.parseStringEncodedColor(text);
        if (color === undefined) {
            return undefined;
        }
        return ColorUtils_1.ColorUtils.getRgbaFromHex(color);
    }
    /**
     * Clones this [[RGBA]] color.
     */
    clone() {
        return new RGBA(this.r, this.g, this.b, this.a);
    }
    /**
     * Returns this color encoded as one single number.
     */
    getHex() {
        return ColorUtils_1.ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);
    }
    /**
     * Linearly interpolate the components of this color.
     */
    lerp(target, t) {
        this.r = three_1.MathUtils.lerp(this.r, target.r, t);
        this.g = three_1.MathUtils.lerp(this.g, target.g, t);
        this.b = three_1.MathUtils.lerp(this.b, target.b, t);
        this.a = three_1.MathUtils.lerp(this.a, target.a, t);
        return this;
    }
    /**
     * Returns this color encoded as JSON literal.
     */
    toJSON() {
        // tslint:disable-next-line: no-bitwise
        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${this.a})`;
    }
}
exports.RGBA = RGBA;
//# sourceMappingURL=RGBA.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStringEncodedColor = exports.parseStringEncodedNumeral = exports.StringEncodedNumeralFormatMaxSize = exports.StringEncodedNumeralFormats = exports.StringEncodedColorFormats = exports.StringEncodedMetricFormats = exports.StringEncodedNumeralType = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js");
//@ts-ignore
const csscolorparser_1 = __webpack_require__(/*! csscolorparser */ "./node_modules/csscolorparser/csscolorparser.js");
/**
 * Enumeration of supported string encoded numerals.
 * @internal
 */
var StringEncodedNumeralType;
(function (StringEncodedNumeralType) {
    StringEncodedNumeralType[StringEncodedNumeralType["Meters"] = 0] = "Meters";
    StringEncodedNumeralType[StringEncodedNumeralType["Pixels"] = 1] = "Pixels";
    StringEncodedNumeralType[StringEncodedNumeralType["Hex"] = 2] = "Hex";
})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));
const StringEncodedMeters = {
    type: StringEncodedNumeralType.Meters,
    size: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedMeters.regExp.exec(encodedValue);
        return match ? (target[0] = Number(match[1])) !== undefined : false;
    }
};
const StringEncodedPixels = {
    type: StringEncodedNumeralType.Pixels,
    size: 1,
    mask: 1.0,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedPixels.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        target[0] = Number(match[1]);
        return true;
    }
};
const StringEncodedHex = {
    type: StringEncodedNumeralType.Hex,
    size: 4,
    regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedHex.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        const hex = match[1];
        const size = hex.length;
        // Only few sizes are possible for given reg-exp.
        harp_utils_1.assert(size === 4 || size === 8, `Matched incorrect hex color format`);
        // Note that we simply ignore alpha channel value.
        // TODO: To be resolved with HARP-7517
        if (size === 4) {
            // #RGB or #RGBA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
        }
        else if (size === 8) {
            // #RRGGBB or #RRGGBBAA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
        }
        return true;
    }
};
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.
 * @internal
 */
exports.StringEncodedMetricFormats = [
    StringEncodedMeters,
    StringEncodedPixels
];
const StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.
 * @internal
 */
exports.StringEncodedColorFormats = [StringEncodedHex];
const StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with
 * [[StringEncodedNumeralType]] enum).
 * @internal
 */
exports.StringEncodedNumeralFormats = [
    ...exports.StringEncodedMetricFormats,
    ...exports.StringEncodedColorFormats
];
/**
 * @internal
 */
exports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
const tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);
/**
 * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].
 *
 * @param numeral - The string representing numeric value.
 * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).
 * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression
 * provided in [[numeral]].
 */
function parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {
    return parseStringLiteral(numeral, exports.StringEncodedNumeralFormats, pixelToMeters);
}
exports.parseStringEncodedNumeral = parseStringEncodedNumeral;
/**
 * Parse string encoded color value using all known [[StringEncodedColorFormats]].
 *
 * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).
 * @returns The color parsed or __undefined__ if non of the known representations matches
 * the expression provided in [[color]].
 */
function parseStringEncodedColor(color) {
    return parseStringLiteral(color, exports.StringEncodedColorFormats);
}
exports.parseStringEncodedColor = parseStringEncodedColor;
function parseStringLiteral(text, formats, pixelToMeters = 1.0) {
    const matchedFormat = formats.find(format => {
        return format.decoder(text, tmpBuffer) ? true : false;
    });
    if (matchedFormat === undefined) {
        const components = csscolorparser_1.parseCSSColor(text);
        return Array.isArray(components) && !components.some(c => isNaN(c))
            ? ColorUtils_1.ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3])
            : undefined;
    }
    switch (matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type) {
        case StringEncodedNumeralType.Pixels:
            return tmpBuffer[0] * pixelToMeters;
        case StringEncodedNumeralType.Hex:
            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
        default:
            return tmpBuffer[0];
    }
}
//# sourceMappingURL=StringEncodedNumeral.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDecodedTechnique = exports.StyleSetEvaluator = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const ExprPool_1 = __webpack_require__(/*! ./ExprPool */ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js");
const TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js");
const Theme_1 = __webpack_require__(/*! ./Theme */ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js");
const logger = harp_utils_1.LoggerManager.instance.create("StyleSetEvaluator");
const emptyTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor({});
/**
 * [[StyleConditionClassifier]] searches for usages of `$layer` in `when` conditions
 * associated with styling rules.
 *
 * @hidden
 */
class StyleConditionClassifier {
    classify(style) {
        if (style._whenExpr) {
            const savedStyle = this.switchStyle(style);
            style._whenExpr = style._whenExpr.accept(this, undefined);
            this._style = savedStyle;
        }
    }
    visitNullLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitNumberLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitStringLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitObjectLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitVarExpr(expr, enclosingExpr) {
        return expr;
    }
    visitHasAttributeExpr(expr, enclosingExpr) {
        return expr;
    }
    visitMatchExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCaseExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCallExpr(call, enclosingExpr) {
        if (call.op === "all") {
            // processing of an `["all", e1, e2, ... eN]` expression. In this case
            // search for expressions matching comparison of `$layer` and string literals
            // in the sub expressions.
            const children = call.args
                .map(childExpr => childExpr.accept(this, call))
                .filter(childExpr => childExpr !== undefined);
            return new Expr_1.CallExpr(call.op, children);
        }
        else if (enclosingExpr) {
            // `call` is a direct child expression of an `"all"` operator.
            const matched = this.matchVarStringComparison(call);
            if (matched) {
                if (this._style.layer === undefined && matched.name === "$layer") {
                    // found a subexpression `["==", ["get", "$layer"], "some layer name"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $layer in
                    // [[StyleInternalParams]].
                    this._style.layer = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
                else if (this._style._geometryType === undefined &&
                    matched.name === "$geometryType") {
                    // found a subexpression `["==", ["get", "$geometryType"], "geometry"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $geometryType in
                    // [[StyleInternalParams]].
                    this._style._geometryType = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
            }
        }
        return call;
    }
    visitStepExpr(expr, enclosingExpr) {
        throw new Error("todo");
    }
    visitInterpolateExpr(expr, enclosingExpr) {
        throw new Error("todo");
    }
    /**
     * Tests if the given `call` matches the structure ["==", ["get", name], value].
     * If a match is found returns an object containing the `name` and the `value`;
     *
     * @param call - The expression to match.
     */
    matchVarStringComparison(call) {
        if (call.op === "==") {
            const left = call.args[0];
            const right = call.args[1];
            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {
                return { name: left.name, value: right.value };
            }
            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {
                return { name: right.name, value: left.value };
            }
        }
        return undefined;
    }
    /**
     * Sets the given `style` as current.
     *
     * @returns The previous `style`.
     */
    switchStyle(style) {
        const saved = this._style;
        this._style = style;
        return saved;
    }
}
class OptimizedSubSetKey {
    constructor(layer, geometryType) {
        this.key = "";
        this.set(layer, geometryType);
    }
    set(layer, geometryType, env) {
        let keyUpdateNeeded = false;
        if (layer === undefined) {
            const envLayer = env !== undefined ? env.lookup("$layer") : undefined;
            layer = typeof envLayer === "string" ? envLayer : undefined;
        }
        if (this.layer !== layer) {
            this.layer = layer;
            keyUpdateNeeded = true;
        }
        if (geometryType === undefined) {
            const envGeometryType = env !== undefined ? env.lookup("$geometryType") : undefined;
            geometryType = typeof envGeometryType === "string" ? envGeometryType : undefined;
        }
        if (this.geometryType !== geometryType) {
            this.geometryType = geometryType;
            keyUpdateNeeded = true;
        }
        if (keyUpdateNeeded) {
            this.updateKey();
        }
        return this;
    }
    updateKey() {
        if (this.layer !== undefined) {
            // tslint:disable-next-line:prefer-conditional-expression
            if (this.geometryType !== undefined) {
                this.key = `${this.layer}:${this.geometryType}`;
            }
            else {
                this.key = `${this.layer}:`;
            }
        }
        else {
            if (this.geometryType !== undefined) {
                this.key = `:${this.geometryType}`;
            }
            else {
                this.key = "all";
            }
        }
        this.cachedStyleSet = undefined;
    }
}
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
class StyleSetEvaluator {
    constructor(styleSet, definitions) {
        this.m_techniques = [];
        this.m_exprPool = new ExprPool_1.ExprPool();
        this.m_cachedResults = new Map();
        this.m_styleConditionClassifier = new StyleConditionClassifier();
        this.m_subStyleSetCache = new Map();
        this.m_definitionExprCache = new Map();
        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();
        this.m_emptyEnv = new Expr_1.Env();
        this.m_featureDependencies = [];
        this.m_definitions = definitions;
        this.styleSet = resolveReferences(styleSet, definitions);
        computeDefaultRenderOrder(this.styleSet);
        this.compileStyleSet();
    }
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     * representation.
     * @param layer - The optional layer name used to filter techniques.
     * @param geometryType - The optional geometryType used to filter techniques.
     */
    getMatchingTechniques(env, layer, geometryType) {
        if (this.m_previousResult &&
            this.m_previousEnv &&
            this.m_featureDependencies.every(p => { var _a; return ((_a = this.m_previousEnv) === null || _a === void 0 ? void 0 : _a.lookup(p)) === env.lookup(p); })) {
            return this.m_previousResult;
        }
        const result = [];
        this.m_cachedResults.clear();
        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
        optimizedSubSetKey.set(layer, geometryType, env);
        // get the requested $layer and $geometryType, if any.
        this.m_layer = optimizedSubSetKey.layer;
        this.m_geometryType = optimizedSubSetKey.geometryType;
        this.m_zoomLevel = env.lookup("$zoom");
        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
        for (const currStyle of searchedStyleSet) {
            if (this.processStyle(env, currStyle, result)) {
                break;
            }
        }
        this.m_previousResult = result;
        this.m_previousEnv = env;
        return result;
    }
    /**
     * Check if `styleSet` contains any rule related to `layer`.
     *
     * @param layer - name of layer
     */
    wantsLayer(layer) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);
    }
    /**
     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.
     *
     * @param layer - name of layer
     * @param geometryType - type of layer - `point`, `line` or `polygon`
     */
    wantsFeature(layer, geometryType) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))
            .length > 0);
    }
    /**
     * Get the expression evaluation cache, for further feature processing.
     *
     * This object is valid until next `getMatchingTechniques` call.
     */
    get expressionEvaluatorCache() {
        return this.m_cachedResults;
    }
    /**
     * Reset array of techniques.
     *
     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.
     */
    resetTechniques() {
        for (const techinque of this.m_techniques) {
            techinque._index = undefined;
        }
        this.m_techniques.length = 0;
        this.m_previousResult = undefined;
        this.m_previousEnv = undefined;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques() {
        return this.m_techniques;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get decodedTechniques() {
        return this.m_techniques.map(makeDecodedTechnique);
    }
    getOptimizedStyleSet(subSetKey) {
        if (subSetKey.cachedStyleSet !== undefined) {
            return subSetKey.cachedStyleSet;
        }
        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
        if (optimizedStyleSet !== undefined) {
            subSetKey.cachedStyleSet = optimizedStyleSet;
            return optimizedStyleSet;
        }
        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
        subSetKey.cachedStyleSet = optimizedStyleSet;
        return optimizedStyleSet;
    }
    createPreFilteredStyleSet(subSetKey) {
        const { layer, geometryType } = subSetKey;
        return this.styleSet.filter(style => {
            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {
                return false;
            }
            if (geometryType !== undefined &&
                style._geometryType !== undefined &&
                style._geometryType !== geometryType) {
                return false;
            }
            return true;
        });
    }
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    compileStyleSet() {
        this.m_featureDependencies = ["$layer", "$geometryType", "$zoom"];
        this.styleSet.forEach(style => this.compileStyle(style));
        // Create optimized styleSets for each `layer` & `geometryType` tuple.
        this.styleSet.forEach(style => {
            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
        });
    }
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style - The current style.
     */
    compileStyle(style) {
        this.checkStyleDynamicAttributes(style);
        if (style.when !== undefined) {
            try {
                style._whenExpr = Array.isArray(style.when)
                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)
                    : // tslint:disable-next-line: deprecation
                        Expr_1.Expr.parse(style.when);
                // search for usages of '$layer' and any other
                // special symbol that can be used to speed up the evaluation
                // of the `when` conditions associated to this `style`.
                this.m_styleConditionClassifier.classify(style);
                if (style._whenExpr !== undefined) {
                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                }
                const deps = style._whenExpr.dependencies();
                deps === null || deps === void 0 ? void 0 : deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                if (Expr_1.isJsonExpr(style.minZoomLevel)) {
                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);
                }
                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {
                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);
                }
            }
            catch (err) {
                logger.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
            }
        }
    }
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param style - Current style (could also be top of stack).
     * @param result - The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    processStyle(env, style, result) {
        if (!this.checkZoomLevel(env, style)) {
            return false;
        }
        if (this.m_layer !== undefined &&
            style.layer !== undefined &&
            style.layer !== this.m_layer) {
            return false;
        }
        if (this.m_geometryType !== undefined &&
            style._geometryType !== undefined &&
            style._geometryType !== this.m_geometryType) {
            return false;
        }
        if (style._whenExpr) {
            try {
                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {
                    // Stop processing this styling rule. The `when` condition
                    // associated with the current `style` evaluates to false so
                    // no techinque defined by this style should be applied.
                    return false;
                }
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);
                return false;
            }
        }
        if (style.technique === undefined) {
            return false;
        }
        // we found a technique!
        if (style.technique !== "none") {
            result.push(this.getTechniqueForStyleMatch(env, style));
        }
        // stop processing if "final" is set
        return style.final === true;
    }
    checkZoomLevel(env, style) {
        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {
            return true;
        }
        const zoomLevel = this.m_zoomLevel;
        if (zoomLevel === undefined) {
            return true;
        }
        if (style.minZoomLevel !== undefined) {
            let minZoomLevel = style.minZoomLevel;
            if (style._minZoomLevelExpr) {
                // the constraint is defined as expression, evaluate it and
                // use its value
                try {
                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                return false;
            }
        }
        if (style.maxZoomLevel !== undefined) {
            let maxZoomLevel = style.maxZoomLevel;
            if (style._maxZoomLevelExpr) {
                try {
                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof maxZoomLevel === "number" && zoomLevel > maxZoomLevel) {
                return false;
            }
        }
        return true;
    }
    getTechniqueForStyleMatch(env, style) {
        let technique;
        if (style._dynamicTechniques !== undefined) {
            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);
            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);
            technique = style._dynamicTechniques.get(key);
            if (technique === undefined) {
                technique = this.createTechnique(style, key, dynamicAttributes);
                style._dynamicTechniques.set(key, technique);
            }
        }
        else {
            technique = style._staticTechnique;
            if (technique === undefined) {
                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);
            }
        }
        if (technique._index === undefined) {
            technique._index = this.m_techniques.length;
            this.m_techniques.push(technique);
        }
        return technique;
    }
    getDynamicTechniqueKey(style, dynamicAttributes) {
        const dynamicAttrKey = dynamicAttributes
            .map(([_attrName, attrValue]) => {
            if (attrValue === undefined) {
                return "U";
            }
            else {
                return JSON.stringify(attrValue);
            }
        })
            .join(":");
        return `${style._styleSetIndex}:${dynamicAttrKey}`;
    }
    checkStyleDynamicAttributes(style) {
        var _a;
        if (style._dynamicTechniqueAttributes !== undefined || style.technique === "none") {
            return;
        }
        style._dynamicTechniqueAttributes = [];
        style._dynamicFeatureAttributes = [];
        style._dynamicForwardedAttributes = [];
        style._staticAttributes = [];
        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;
        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;
        const targetStaticAttributes = style._staticAttributes;
        const techniqueDescriptor = Techniques_1.techniqueDescriptors[style.technique] || emptyTechniqueDescriptor;
        const processAttribute = (attrName, attrValue) => {
            if (attrValue === undefined) {
                return;
            }
            if (Expr_1.isJsonExpr(attrValue)) {
                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);
            }
            else if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(attrValue)) {
                // found a property using an object-like interpolation definition.
                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const deps = attrValue.dependencies();
                if (deps.featureState) {
                    if (attrName !== "enabled") {
                        logger.log("feature-state is not supported in this context");
                    }
                    else {
                        style._usesFeatureState = true;
                    }
                }
                if (deps.properties.size === 0 && !attrValue.isDynamic()) {
                    // no data-dependencies detected.
                    attrValue = attrValue.evaluate(this.m_emptyEnv);
                }
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                let attrScope = techniqueDescriptor.attrScopes[attrName];
                if (attrScope === undefined) {
                    // Use [[AttrScope.TechniqueGeometry]] as default scope for the attribute.
                    attrScope = TechniqueDescriptor_1.AttrScope.TechniqueGeometry;
                }
                const deps = attrValue.dependencies();
                deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                switch (attrScope) {
                    case TechniqueDescriptor_1.AttrScope.FeatureGeometry:
                        dynamicFeatureAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptor_1.AttrScope.TechniqueGeometry:
                        dynamicTechniqueAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptor_1.AttrScope.TechniqueRendering:
                        if (deps.properties.size === 0) {
                            dynamicForwardedAttributes.push([attrName, attrValue]);
                        }
                        else {
                            dynamicTechniqueAttributes.push([attrName, attrValue]);
                        }
                        break;
                }
            }
            else if (attrValue !== undefined && attrValue !== null) {
                targetStaticAttributes.push([attrName, attrValue]);
            }
        };
        const replacement = new Map([
            ["category", "_category"],
            ["secondaryCategory", "_secondaryCategory"]
        ]);
        for (const p in style) {
            if (!style.hasOwnProperty(p)) {
                continue;
            }
            if (p.startsWith("_")) {
                continue;
            }
            if (["when", "technique", "layer", "attr", "description"].includes(p)) {
                continue;
            }
            const pp = (_a = replacement.get(p)) !== null && _a !== void 0 ? _a : p;
            processAttribute(pp, style[p]);
        }
        if (style.attr !== undefined) {
            for (const attrName in style.attr) {
                if (!style.attr.hasOwnProperty(attrName)) {
                    continue;
                }
                processAttribute(attrName, style.attr[attrName]);
            }
        }
        if (dynamicTechniqueAttributes.length > 0) {
            style._dynamicTechniques = new Map();
        }
    }
    evaluateTechniqueProperties(style, env) {
        if (style._dynamicTechniqueAttributes === undefined) {
            return [];
        }
        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {
            try {
                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);
                return [attrName, evaluatedValue];
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);
                return [attrName, null];
            }
        });
    }
    createTechnique(style, key, dynamicAttrs) {
        const technique = {};
        technique.name = style.technique;
        if (style._staticAttributes !== undefined) {
            for (const [attrName, attrValue] of style._staticAttributes) {
                if (attrValue !== null) {
                    technique[attrName] = attrValue;
                }
            }
        }
        for (const [attrName, attrValue] of dynamicAttrs) {
            if (attrValue !== null) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicFeatureAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicForwardedAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {
                technique[attrName] = attrValue;
            }
        }
        technique._index = this.m_techniques.length;
        technique._styleSetIndex = style._styleSetIndex;
        if (style.styleSet !== undefined) {
            technique._styleSet = style.styleSet;
        }
        if (style._usesFeatureState !== undefined) {
            technique._usesFeatureState = style._usesFeatureState;
        }
        this.m_techniques.push(technique);
        return technique;
    }
}
exports.StyleSetEvaluator = StyleSetEvaluator;
function computeDefaultRenderOrder(styleSet) {
    let techniqueRenderOrder = 0;
    let styleSetIndex = 0;
    for (const style of styleSet) {
        style._styleSetIndex = styleSetIndex++;
        if (style.technique !== undefined && style.renderOrder === undefined) {
            style.renderOrder = techniqueRenderOrder++;
        }
    }
}
function resolveReferences(styleSet, definitions) {
    return styleSet.map(style => resolveStyleReferences(style, definitions));
}
function resolveStyleReferences(style, definitions) {
    if (Expr_1.isJsonExpr(style)) {
        if (!Theme_1.isJsonExprReference(style)) {
            throw new Error("invalid expression in this context, only 'ref's are supported");
        }
        // expand and instantiate references to style definitions.
        const definitionName = style[1];
        const def = definitions && definitions[definitionName];
        if (!def) {
            throw new Error(`invalid reference '${definitionName}' - not found`);
        }
        if (!Theme_1.isActualSelectorDefinition(def)) {
            throw new Error(`invalid reference '${definitionName}' - expected style definition`);
        }
        // instantiate the style
        return resolveStyleReferences(def, definitions);
    }
    return Object.assign({}, style);
}
/**
 * Create transferable representation of dynamic technique.
 *
 * Converts  non-transferable {@link Expr}instances back to JSON form.
 */
function makeDecodedTechnique(technique) {
    const result = {};
    for (const attrName in technique) {
        if (!technique.hasOwnProperty(attrName)) {
            continue;
        }
        let attrValue = technique[attrName];
        if (typeof attrValue === "object" &&
            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {
            attrValue = Expr_1.LiteralExpr.fromValue(attrValue);
        }
        if (Expr_1.Expr.isExpr(attrValue)) {
            attrValue = attrValue.toJSON();
        }
        result[attrName] = attrValue;
    }
    return result;
}
exports.makeDecodedTechnique = makeDecodedTechnique;
//# sourceMappingURL=StyleSetEvaluator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateTechniqueAttr = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const PropertyValue_1 = __webpack_require__(/*! ./PropertyValue */ "./node_modules/@here/harp-datasource-protocol/lib/PropertyValue.js");
function evaluateTechniqueAttr(context, attrValue, defaultValue) {
    if (attrValue === undefined) {
        return defaultValue;
    }
    const result = Expr_1.Env.isEnv(context)
        ? PropertyValue_1.getPropertyValue(attrValue, context)
        : PropertyValue_1.getPropertyValue(attrValue, context.env, context.cachedExprResults);
    return result !== null && result !== void 0 ? result : defaultValue;
}
exports.evaluateTechniqueAttr = evaluateTechniqueAttr;
//# sourceMappingURL=TechniqueAttr.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTechniqueDescriptor = exports.AttrScope = void 0;
var AttrScope;
(function (AttrScope) {
    /**
     * Attributes that affect generation of feature geometry and thus must be resolved at decoding
     * time.
     *
     * They may have huge variancy as they are implemented as vertex attributes or embedded in
     * generated meshes.
     *
     * These attributes are available only in decoding scope.
     */
    AttrScope[AttrScope["FeatureGeometry"] = 0] = "FeatureGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * These attributes affect generated geometry and  thus must be resolved at decoding time.
     *
     * They shouldn't have big variancy and evaluate to at least dozens of values as each
     * combination of these attributes consitute new technique and material.
     *
     * These attributes are available in decoding and rendering scope.
     */
    AttrScope[AttrScope["TechniqueGeometry"] = 1] = "TechniqueGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * Attributes that can be changed in resulting object/material from frame to frame. They are
     * usually implemented as uniforms.
     *
     * These attributes may be available only at rendering scope.
     */
    AttrScope[AttrScope["TechniqueRendering"] = 2] = "TechniqueRendering";
})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));
function mergeTechniqueDescriptor(...descriptors) {
    const result = {
        attrScopes: {}
    };
    for (const descriptor of descriptors) {
        if (descriptor.attrTransparencyColor !== undefined) {
            result.attrTransparencyColor = descriptor.attrTransparencyColor;
        }
        if (descriptor.attrScopes !== undefined) {
            result.attrScopes = Object.assign(Object.assign({}, result.attrScopes), descriptor.attrScopes);
        }
    }
    return result;
}
exports.mergeTechniqueDescriptor = mergeTechniqueDescriptor;
//# sourceMappingURL=TechniqueDescriptor.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTextureBuffer = exports.PlacementToken = exports.PoiStackMode = exports.TextureCoordinateType = exports.GeometryKindSet = exports.GeometryKind = exports.StandardGeometryKind = void 0;
/**
 * Standard kinds of geometry.
 */
var StandardGeometryKind;
(function (StandardGeometryKind) {
    /**
     * Used in the enabledKinds/disabledKinds filter to match any kind.
     */
    StandardGeometryKind["All"] = "_all_";
    /**
     * Background geometry.
     */
    StandardGeometryKind["Background"] = "background";
    /**
     * Terrain geometry.
     */
    StandardGeometryKind["Terrain"] = "terrain";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Area"] = "area";
    /**
     * Default value for all line techniques.
     */
    StandardGeometryKind["Line"] = "line";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Water"] = "water";
    /**
     * Political borders.
     */
    StandardGeometryKind["Border"] = "border";
    /**
     * Basis for all roads.
     */
    StandardGeometryKind["Road"] = "road";
    /**
     * Default value for the ExtrudedPolygonTechnique.
     */
    StandardGeometryKind["Building"] = "building";
    /**
     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.
     */
    StandardGeometryKind["Label"] = "label";
    /**
     * Anything that may show up last.
     */
    StandardGeometryKind["Detail"] = "detail";
})(StandardGeometryKind = exports.StandardGeometryKind || (exports.StandardGeometryKind = {}));
exports.GeometryKind = StandardGeometryKind;
/**
 * A set of [[GeometryKind]]s.
 */
class GeometryKindSet extends Set {
    /**
     * Return `true` if the Set is a superset of the set 'subset'.
     */
    isSuperset(subset) {
        for (const elem of subset) {
            if (!this.has(elem)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return `true` if the Set intersects Set 'set'.
     */
    hasIntersection(set) {
        for (const elem of set) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'
     * if set is not a Set.
     */
    hasOrIntersects(set) {
        if (set instanceof Set) {
            return this.hasIntersection(set);
        }
        return this.has(set);
    }
    /**
     * Return `true` if this set and the array of elements share at least a single element.
     */
    hasOrIntersectsArray(subset) {
        for (const elem of subset) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
}
exports.GeometryKindSet = GeometryKindSet;
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
    /**
     * Texture coordinates in feature space.
     *
     * To compute texture coordinates in feature space,
     * the feature must have a property named `bbox` with value
     * the tuple `[west, south, east, north]`.
     */
    TextureCoordinateType["FeatureSpace"] = "feature-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Defines options (tokens) supported for text placements defined via [[placements]] attribute.
 *
 * @remarks
 * Possible values are defined as vertical placement letter and horizontal letter, where
 * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:
 * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),
 * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).
 * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:
 * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),
 * `SW` (south-west), `W` (west).
 */
var PlacementToken;
(function (PlacementToken) {
    PlacementToken["TopLeft"] = "TL";
    PlacementToken["Top"] = "T";
    PlacementToken["TopRight"] = "TR";
    PlacementToken["Right"] = "R";
    PlacementToken["BottomRight"] = "BR";
    PlacementToken["Bottom"] = "B";
    PlacementToken["BottomLeft"] = "BL";
    PlacementToken["Left"] = "L";
    PlacementToken["Center"] = "C";
    PlacementToken["NorthWest"] = "NW";
    PlacementToken["North"] = "N";
    PlacementToken["NorthEast"] = "NE";
    PlacementToken["East"] = "E";
    PlacementToken["SouthEast"] = "SE";
    PlacementToken["South"] = "S";
    PlacementToken["SouthWest"] = "SW";
    PlacementToken["West"] = "W";
})(PlacementToken = exports.PlacementToken || (exports.PlacementToken = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;
//# sourceMappingURL=TechniqueParams.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Techniques.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeTechniqueTextureName = exports.addBuffersToTransferList = exports.textureCoordinateType = exports.needsVertexNormals = exports.isLabelRejectionLineTechnique = exports.isShaderTechnique = exports.isTextTechnique = exports.isTerrainTechnique = exports.isStandardTechnique = exports.isExtrudedPolygonTechnique = exports.isFillTechnique = exports.isStandardExtrudedLineTechnique = exports.isBasicExtrudedLineTechnique = exports.isExtrudedLineTechnique = exports.isSegmentsTechnique = exports.isSpecialDashesLineTechnique = exports.isSolidLineTechnique = exports.isLineTechnique = exports.isLineMarkerTechnique = exports.isPoiTechnique = exports.isSquaresTechnique = exports.isCirclesTechnique = exports.lineTechniqueDescriptor = exports.solidLineTechniqueDescriptor = exports.circlesTechniquePropTypes = exports.squaresTechniquePropTypes = exports.pointTechniquePropTypes = exports.baseTechniqueParamsDescriptor = exports.techniqueDescriptors = exports.TRANSPARENCY_PROPERTY_KEYS = exports.TEXTURE_PROPERTY_KEYS = void 0;
const TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js");
const TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js");
/**
 * Names of the supported texture properties.
 * @internal
 */
exports.TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
/**
 * Names of the properties controlling transparency.
 * @internal
 */
exports.TRANSPARENCY_PROPERTY_KEYS = ["opacity", "transparent"];
/** @internal  */
exports.techniqueDescriptors = {};
/** @internal  */
exports.baseTechniqueParamsDescriptor = {
    // TODO: Choose which techniques should support color with transparency.
    // For now we chosen all, but it maybe not suitable for text or line marker techniques.
    attrTransparencyColor: "color",
    attrScopes: {
        renderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        enabled: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        kind: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        transient: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        fadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
};
/** @internal  */
exports.pointTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        texture: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        enablePicking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueGeometry
    }
});
/** @internal  */
exports.squaresTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);
exports.techniqueDescriptors.squares = exports.squaresTechniquePropTypes;
/** @internal  */
exports.circlesTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);
exports.techniqueDescriptors.circles = exports.circlesTechniquePropTypes;
const lineMarkerTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        priority: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        renderTextDuringMovements: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alwaysOnTop: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        showOnMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        stackMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        minDistance: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconXOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconYOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        screenHeight: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        screenWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        poiTable: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        poiName: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        poiNameField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexture: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        imageTextureField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexturePrefix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        imageTexturePostfix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        iconColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        iconBrightness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        placements: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["line-marker"] = lineMarkerTechniquePropTypes;
exports.techniqueDescriptors["labeled-icon"] = lineMarkerTechniquePropTypes;
const polygonalTechniqueDescriptor = {
    attrScopes: {
        polygonOffset: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        polygonOffsetFactor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        polygonOffsetUnits: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
};
/** @internal  */
exports.solidLineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrScopes: {
        clipping: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        secondaryRenderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        secondaryWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        secondaryColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        dashSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        gapSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["solid-line"] = exports.solidLineTechniqueDescriptor;
// TODO: Remove deprecated "dashed-line" support in future releases.
exports.techniqueDescriptors["dashed-line"] = exports.solidLineTechniqueDescriptor;
/** @internal  */
exports.lineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        // TODO, check, which are really dynamic !
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.FeatureGeometry
    }
});
exports.techniqueDescriptors.line = exports.lineTechniqueDescriptor;
const fillTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrScopes: {
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.fill = fillTechniqueDescriptor;
const standardTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        vertexColors: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        wireframe: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        roughness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        metalness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        alphaTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        depthTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        emissive: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        emissiveIntensity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        refractionRatio: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        map: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        mapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        normalMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        normalMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        displacementMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        displacementMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        roughnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        roughnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        emissiveMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        emissiveMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        bumpMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        bumpMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        metalnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        metalnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alphaMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        alphaMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry
    }
});
exports.techniqueDescriptors.standard = standardTechniqueDescriptor;
const extrudedPolygonTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
    attrScopes: {
        height: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        floorHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        defaultColor: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        defaultHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        constantHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        boundaryWalls: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        footprint: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        maxSlope: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        enableDepthPrePass: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        animateExtrusionDuration: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        animateExtrusion: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        lineColorMix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors["extruded-polygon"] = extrudedPolygonTechniqueDescriptor;
const textTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,
        minZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        mayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        reserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        priority: TechniqueDescriptor_1.AttrScope.TechniqueRendering,
        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.text = textTechniqueDescriptor;
const shaderTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {
    attrScopes: {
        primitive: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,
        params: TechniqueDescriptor_1.AttrScope.TechniqueRendering
    }
});
exports.techniqueDescriptors.shader = shaderTechniqueDescriptor;
/**
 * Type guard to check if an object is an instance of [[CirclesTechnique]].
 */
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
exports.isCirclesTechnique = isCirclesTechnique;
/**
 * Type guard to check if an object is an instance of [[SquaresTechnique]].
 */
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
exports.isSquaresTechnique = isSquaresTechnique;
/**
 * Type guard to check if an object is an instance of [[PoiTechnique]].
 */
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
exports.isPoiTechnique = isPoiTechnique;
/**
 * Type guard to check if an object is an instance of [[LineMarkerTechnique]].
 */
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
exports.isLineMarkerTechnique = isLineMarkerTechnique;
/**
 * Type guard to check if an object is an instance of [[LineTechnique]].
 */
function isLineTechnique(technique) {
    return technique.name === "line";
}
exports.isLineTechnique = isLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]].
 */
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line" || technique.name === "dashed-line";
}
exports.isSolidLineTechnique = isSolidLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SolidLineTechnique]] and is a kind that
 * has special dashes.
 * @note Lines with special dashes need line caps to render properly.
 */
function isSpecialDashesLineTechnique(technique) {
    return ((technique.name === "solid-line" || technique.name === "dashed-line") &&
        technique.dashes !== undefined &&
        technique.dashes !== "Square");
}
exports.isSpecialDashesLineTechnique = isSpecialDashesLineTechnique;
/**
 * Type guard to check if an object is an instance of [[SegmentsTechnique]].
 */
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
exports.isSegmentsTechnique = isSegmentsTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]
 * or [[StandardExtrudedLineTechnique]].
 */
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
exports.isExtrudedLineTechnique = isExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].
 */
function isBasicExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "basic";
}
exports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].
 */
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
exports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of [[FillTechnique]].
 */
function isFillTechnique(technique) {
    return technique.name === "fill";
}
exports.isFillTechnique = isFillTechnique;
/**
 * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].
 */
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
exports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;
/**
 * Type guard to check if an object is an instance of [[StandardTechnique]].
 */
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
exports.isStandardTechnique = isStandardTechnique;
/**
 * Type guard to check if an object is an instance of [[TerrainTechnique]].
 */
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
exports.isTerrainTechnique = isTerrainTechnique;
/**
 * Type guard to check if an object is an instance of [[TextTechnique]].
 */
function isTextTechnique(technique) {
    return technique.name === "text";
}
exports.isTextTechnique = isTextTechnique;
/**
 * Type guard to check if an object is an instance of [[ShaderTechnique]].
 */
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
exports.isShaderTechnique = isShaderTechnique;
function isLabelRejectionLineTechnique(technique) {
    return technique.name === "label-rejection-line";
}
exports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;
/**
 * Check if vertex normals should be generated for this technique (if no normals are in the data).
 * @param technique - Technique to check.
 */
function needsVertexNormals(technique) {
    return (isFillTechnique(technique) ||
        isStandardTechnique(technique) ||
        isTerrainTechnique(technique) ||
        isStandardExtrudedLineTechnique(technique));
}
exports.needsVertexNormals = needsVertexNormals;
/**
 * Get the texture coordinate type if the technique supports it.
 */
function textureCoordinateType(technique) {
    if (isStandardTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isExtrudedPolygonTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isTerrainTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else if (isShaderTechnique(technique)) {
        return technique.textureCoordinateType;
    }
    else {
        return undefined;
    }
}
exports.textureCoordinateType = textureCoordinateType;
/**
 * Add all the buffers of the technique to the transfer list.
 */
function addBuffersToTransferList(technique, transferList) {
    if (isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique)) {
        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {
            const textureProperty = technique[texturePropertyKey];
            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.buffer instanceof ArrayBuffer) {
                    transferList.push(textureProperty.buffer);
                }
            }
        }
    }
}
exports.addBuffersToTransferList = addBuffersToTransferList;
/**
 * Compose full texture name for given image name with technique specified.
 * Some techniques allows to add prefix/postfix to icons names specified, this
 * function uses technique information to create fully qualified texture name.
 * @param imageName - base name of the marker icon.
 * @param technique - the technique describing POI or line marker.
 * @returns fully qualified texture name for loading from atlas (without extension).
 */
function composeTechniqueTextureName(imageName, technique) {
    let textureName = imageName;
    if (typeof technique.imageTexturePrefix === "string") {
        textureName = technique.imageTexturePrefix + textureName;
    }
    if (typeof technique.imageTexturePostfix === "string") {
        textureName = textureName + technique.imageTexturePostfix;
    }
    return textureName;
}
exports.composeTechniqueTextureName = composeTechniqueTextureName;
//# sourceMappingURL=Techniques.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Theme.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isActualSelectorDefinition = exports.isJsonExprReference = exports.isLiteralDefinition = exports.isBoxedDefinition = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js");
/**
 * Checks if the given definition implements the [[BoxedDefinition]] interface.
 */
function isBoxedDefinition(def) {
    const bdef = def;
    return (typeof bdef === "object" &&
        bdef !== null &&
        (typeof bdef.type === "string" || typeof bdef.type === "undefined") &&
        (typeof bdef.value === "string" ||
            typeof bdef.value === "number" ||
            typeof bdef.value === "boolean" ||
            InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(bdef.value) ||
            Expr_1.isJsonExpr(bdef.value)));
}
exports.isBoxedDefinition = isBoxedDefinition;
function isLiteralDefinition(def) {
    return typeof def === "string" || typeof def === "number" || typeof def === "boolean";
}
exports.isLiteralDefinition = isLiteralDefinition;
/**
 * Checks if the given value is a reference to a definition.
 *
 * @param value - The value of a technique property.
 */
function isJsonExprReference(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        value[0] === "ref" &&
        typeof value[1] === "string");
}
exports.isJsonExprReference = isJsonExprReference;
function isActualSelectorDefinition(def) {
    const styleDef = def;
    return (typeof styleDef === "object" &&
        styleDef !== null &&
        !Array.isArray(styleDef) &&
        typeof styleDef.technique === "string");
}
exports.isActualSelectorDefinition = isActualSelectorDefinition;
//# sourceMappingURL=Theme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeVisitor = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
/**
 * The ThemeVisitor visits every style in the theme in a depth-first fashion.
 */
class ThemeVisitor {
    constructor(theme) {
        this.theme = theme;
    }
    /**
     * Applies a function to every style in the theme.
     *
     * @param visitFunc - Function to be called with `style` as an argument. Function should return
     *                  `true` to cancel visitation.
     * @returns `true` if function has finished prematurely.
     */
    visitStyles(visitFunc) {
        const visit = (style) => {
            if (Expr_1.isJsonExpr(style)) {
                return false;
            }
            if (visitFunc(style)) {
                return true;
            }
            return false;
        };
        if (this.theme.styles !== undefined) {
            for (const styleSetName in this.theme.styles) {
                if (this.theme.styles[styleSetName] !== undefined) {
                    for (const style of this.theme.styles[styleSetName]) {
                        if (visit(style)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.ThemeVisitor = ThemeVisitor;
//# sourceMappingURL=ThemeVisitor.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreeBufferUtils = void 0;
const DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js");
/**
 * Collection of helper methods to convert
 * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}
 * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.
 * See also [[CustomDatasourceExample]].
 */
var ThreeBufferUtils;
(function (ThreeBufferUtils) {
    function getBufferElementType(buffer) {
        if (buffer instanceof Int8Array) {
            return "int8";
        }
        else if (buffer instanceof Uint8Array) {
            return "uint8";
        }
        else if (buffer instanceof Int16Array) {
            return "int16";
        }
        else if (buffer instanceof Uint16Array) {
            return "uint16";
        }
        else if (buffer instanceof Int32Array) {
            return "int32";
        }
        else if (buffer instanceof Uint32Array) {
            return "uint32";
        }
        else if (buffer instanceof Float32Array) {
            return "float";
        }
        throw new Error(`Unsupported buffer type ${name}`);
    }
    ThreeBufferUtils.getBufferElementType = getBufferElementType;
    function fromThreeBufferAttribute(bufferAttribute) {
        const buffer = bufferAttribute.array;
        return {
            name: bufferAttribute.name,
            buffer: buffer.buffer,
            type: getBufferElementType(buffer),
            itemCount: bufferAttribute.itemSize,
            normalized: bufferAttribute.normalized
        };
    }
    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;
    function fromThreeInterleavedBufferAttribute(bufferAttribute) {
        throw new Error("Not implemented yet");
    }
    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;
    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {
        const vertexAttributes = [];
        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);
        for (const name of attributeNames) {
            const attribute = bufferGeometry.attributes[name];
            // FIXME: Also support InterleavedBufferAttribute
            const vertexAttribute = fromThreeBufferAttribute(attribute);
            vertexAttribute.name = name;
            vertexAttributes.push(vertexAttribute);
        }
        const index = bufferGeometry.index !== null
            ? fromThreeBufferAttribute(bufferGeometry.index)
            : undefined;
        let count = 0;
        if (index !== undefined) {
            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;
        }
        else {
            // If there is no index buffer, try to deduce the count from the position attribute.
            const posAttr = bufferGeometry.attributes.position;
            if (posAttr === undefined) {
                throw new Error("Missing position attibute to deduce item count");
            }
            count = posAttr.count;
        }
        return {
            type: DecodedTile_1.GeometryType.Unspecified,
            vertexAttributes,
            index,
            groups: [{ start: 0, count, technique: techniqueIndex }]
        };
    }
    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;
})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));
//# sourceMappingURL=ThreeBufferUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=TileInfo.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerDecoderProtocol = exports.RequestController = void 0;
/**
 * Allows to cancel and prioritize requests inside the requestQueue.
 *
 * @remarks
 * Useful to optimize the order of decoding tiles during animations and camera movements.
 *
 * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.
 */
class RequestController {
    /**
     * Creates an instance of `RequestController`.
     *
     * @param {number} priority
     * @param {AbortController} abortController Optional [[AbortController]] used internally, since
     *      [[AbortController]]s should not be subclassed.
     */
    constructor(priority = 0, abortController = new AbortController()) {
        this.priority = priority;
        this.abortController = abortController;
    }
    get signal() {
        return this.abortController.signal;
    }
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and
     * signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        this.abortController.abort();
    }
}
exports.RequestController = RequestController;
/**
 * Communication protocol with [[ITileDecoder]].
 */
var WorkerDecoderProtocol;
(function (WorkerDecoderProtocol) {
    /**
     * Define possible names of messages exchanged with decoder services within `WebWorker`.
     */
    let DecoderMessageName;
    (function (DecoderMessageName) {
        DecoderMessageName["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));
    /**
     * Type guard to check if an object is an instance of `ConfigurationMessage`.
     */
    function isConfigurationMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === DecoderMessageName.Configuration);
    }
    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;
    /**
     * Define possible names of requests called on decoder services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["DecodeTileRequest"] = "decode-tile-request";
        Requests["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a decoded tile object sent to a worker.
     */
    function isDecodeTileRequest(message) {
        return (message &&
            typeof message.type === "string" &&
            message.type === Requests.DecodeTileRequest);
    }
    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;
    /**
     * Type guard to check if an object is an info tile object sent to a worker.
     */
    function isTileInfoRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.TileInfoRequest);
    }
    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));
//# sourceMappingURL=WorkerDecoderProtocol.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerServiceProtocol = void 0;
/**
 * Common communication protocol for [[WorkerService]].
 */
var WorkerServiceProtocol;
(function (WorkerServiceProtocol) {
    /**
     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service
     * instances in workers.
     */
    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    /**
     * Define possible names of messages exchanged with services within `WebWorker`.
     */
    let ServiceMessageName;
    (function (ServiceMessageName) {
        ServiceMessageName["Initialized"] = "initialized";
        ServiceMessageName["Request"] = "request";
        ServiceMessageName["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));
    /**
     * Type guard to check if an object is a signal message from worker.
     */
    function isInitializedMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Initialized);
    }
    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;
    /**
     * Define possible names of requests called on services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["CreateService"] = "create-service";
        Requests["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));
    /**
     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.
     */
    function isUnknownServiceError(error) {
        return /unknown targetServiceType requested: /.test(error.message);
    }
    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isRequestMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Request);
    }
    WorkerServiceProtocol.isRequestMessage = isRequestMessage;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isResponseMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Response);
    }
    WorkerServiceProtocol.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));
//# sourceMappingURL=WorkerServiceProtocol.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerTilerProtocol = void 0;
/**
 * Communication protocol with [[ITiler]].
 */
var WorkerTilerProtocol;
(function (WorkerTilerProtocol) {
    /**
     * Define possible names of requests called on tiler services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["RegisterIndex"] = "register-index";
        Requests["UpdateIndex"] = "update-index";
        Requests["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));
    /**
     * Type guard to check if an object is an index registration request sent to a worker.
     */
    function isRegisterIndexRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.RegisterIndex);
    }
    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;
    /**
     * Type guard to check if an object is an update request for the index registration.
     */
    function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.UpdateIndex;
    }
    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;
    /**
     * Type guard to check if an object is a tile request sent to a worker.
     */
    function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.TileRequest;
    }
    WorkerTilerProtocol.isTileRequest = isTileRequest;
})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));
//# sourceMappingURL=WorkerTilerProtocol.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const VALID_ELEMENT_TYPES = ["boolean", "number", "string"];
function checkElementTypes(arg, array) {
    if (!(arg instanceof Expr_1.StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {
        throw new Error(`expected "boolean", "number" or "string" instead of '${JSON.stringify(arg)}'`);
    }
    const ty = arg.value;
    array.forEach((element, index) => {
        if (typeof element !== ty) {
            throw new Error(`expected array element at index ${index} to have type '${ty}'`);
        }
    });
}
function checkArrayLength(arg, array) {
    if (!(arg instanceof Expr_1.NumberLiteralExpr)) {
        throw new Error(`missing expected number of elements`);
    }
    const length = arg.value;
    if (array.length !== length) {
        throw new Error(`the array must have ${length} element(s)`);
    }
}
function checkArray(context, arg) {
    const value = context.evaluate(arg);
    if (!Array.isArray(value)) {
        throw new Error(`'${value}' is not an array`);
    }
    return value;
}
const operators = {
    array: {
        call: (context, call) => {
            switch (call.args.length) {
                case 0:
                    throw new Error("not enough arguments");
                case 1:
                    return checkArray(context, call.args[0]);
                case 2: {
                    const array = checkArray(context, call.args[1]);
                    checkElementTypes(call.args[0], array);
                    return array;
                }
                case 3: {
                    const array = checkArray(context, call.args[2]);
                    checkArrayLength(call.args[1], array);
                    checkElementTypes(call.args[0], array);
                    return array;
                }
                default:
                    throw new Error("too many arguments");
            }
        }
    },
    "make-array": {
        call: (context, call) => {
            if (call.args.length === 0) {
                throw new Error("not enough arguments");
            }
            return [...call.args.map(arg => context.evaluate(arg))];
        }
    },
    at: {
        call: (context, call) => {
            const args = call.args;
            const index = context.evaluate(args[0]);
            if (typeof index !== "number") {
                throw new Error(`expected the index of the element to retrieve`);
            }
            const value = context.evaluate(args[1]);
            if (!Array.isArray(value)) {
                throw new Error(`expected an array`);
            }
            return index >= 0 && index < value.length ? value[index] : null;
        }
    }
};
exports.ArrayOperators = operators;
//# sourceMappingURL=ArrayOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CastOperators = void 0;
const operators = {
    "to-boolean": {
        call: (context, call) => {
            return Boolean(context.evaluate(call.args[0]));
        }
    },
    "to-string": {
        call: (context, call) => {
            return String(context.evaluate(call.args[0]));
        }
    },
    "to-number": {
        call: (context, call) => {
            for (const arg of call.args) {
                const value = Number(context.evaluate(arg));
                if (!isNaN(value)) {
                    return value;
                }
            }
            throw new Error("cannot convert the value to a number");
        }
    }
};
exports.CastOperators = operators;
//# sourceMappingURL=CastOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorOperators = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js");
const StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js");
const operators = {
    alpha: {
        call: (context, call) => {
            let color = context.evaluate(call.args[0]);
            if (typeof color === "string") {
                color = StringEncodedNumeral_1.parseStringEncodedColor(color);
            }
            const alpha = typeof color === "number" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;
            return alpha;
        }
    },
    rgba: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            const a = context.evaluate(call.args[3]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                typeof a === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0 &&
                a >= 0 &&
                a <= 1) {
                return rgbaToHex(r, g, b, a);
            }
            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);
        }
    },
    rgb: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0) {
                return rgbToHex(r, g, b);
            }
            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);
        }
    },
    // Hsl operator contains angle modulated to <0, 360> range, percent of
    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)
    hsl: {
        call: (context, call) => {
            const h = context.evaluate(call.args[0]);
            const s = context.evaluate(call.args[1]);
            const l = context.evaluate(call.args[2]);
            if (typeof h === "number" &&
                typeof s === "number" &&
                typeof l === "number" &&
                h >= 0 &&
                s >= 0 &&
                l >= 0) {
                return hslToHex(h, s, l);
            }
            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);
        }
    }
};
function rgbaToHex(r, g, b, a) {
    // We decode rgba color channels using custom hex format with transparency.
    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255, THREE.MathUtils.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.MathUtils.euclideanModulo(h, 360) / 360, THREE.MathUtils.clamp(s, 0, 100) / 100, THREE.MathUtils.clamp(l, 0, 100) / 100);
}
exports.ColorOperators = operators;
//# sourceMappingURL=ColorOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComparisonOperators = void 0;
function compare(context, call, strict = false) {
    const left = context.evaluate(call.args[0]);
    const right = context.evaluate(call.args[1]);
    if (!((typeof left === "number" && typeof right === "number") ||
        (typeof left === "string" && typeof right === "string"))) {
        if (strict) {
            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);
        }
    }
    switch (call.op) {
        case "<":
            return left < right;
        case ">":
            return left > right;
        case "<=":
            return left <= right;
        case ">=":
            return left >= right;
        default:
            throw new Error(`invalid comparison operator '${call.op}'`);
    }
}
const operators = {
    "!": {
        call: (context, call) => {
            return !context.evaluate(call.args[0]);
        }
    },
    "==": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left === right;
        }
    },
    "!=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left !== right;
        }
    },
    "<": { call: (context, call) => compare(context, call) },
    ">": { call: (context, call) => compare(context, call) },
    "<=": { call: (context, call) => compare(context, call) },
    ">=": { call: (context, call) => compare(context, call) }
};
exports.ComparisonOperators = operators;
//# sourceMappingURL=ComparisonOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureOperators = void 0;
const Env_1 = __webpack_require__(/*! ../Env */ "./node_modules/@here/harp-datasource-protocol/lib/Env.js");
const Expr_1 = __webpack_require__(/*! ../Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const operators = {
    "geometry-type": {
        call: (context, call) => {
            const geometryType = context.env.lookup("$geometryType");
            switch (geometryType) {
                case "point":
                    return "Point";
                case "line":
                    return "LineString";
                case "polygon":
                    return "Polygon";
                default:
                    return null;
            }
        }
    },
    "feature-state": {
        isDynamicOperator: () => true,
        call: (context, call) => {
            var _a, _b;
            if (context.scope !== Expr_1.ExprScope.Dynamic) {
                throw new Error("feature-state cannot be used in this context");
            }
            const property = context.evaluate(call.args[0]);
            if (typeof property !== "string") {
                throw new Error(`expected the name of the property of the feature state`);
            }
            const state = context.env.lookup("$state");
            if (Env_1.Env.isEnv(state)) {
                return (_a = state.lookup(property)) !== null && _a !== void 0 ? _a : null;
            }
            else if (state instanceof Map) {
                return (_b = state.get(property)) !== null && _b !== void 0 ? _b : null;
            }
            return null;
        }
    },
    id: {
        call: (context, call) => {
            var _a;
            return (_a = context.env.lookup("$id")) !== null && _a !== void 0 ? _a : null;
        }
    }
};
exports.FeatureOperators = operators;
//# sourceMappingURL=FeatureOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowOperators = void 0;
function conditionalCast(context, type, args) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            for (const childExpr of args) {
                const value = context.evaluate(childExpr);
                if (typeof value === type) {
                    return value;
                }
            }
            throw new Error(`expected a '${type}'`);
        default:
            throw new Error(`invalid type '${type}'`);
    } // switch
}
const operators = {
    all: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (!context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    any: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return true;
                }
            }
            return false;
        }
    },
    none: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    boolean: {
        call: (context, call) => {
            return conditionalCast(context, "boolean", call.args);
        }
    },
    number: {
        call: (context, call) => {
            return conditionalCast(context, "number", call.args);
        }
    },
    string: {
        call: (context, call) => {
            return conditionalCast(context, "string", call.args);
        }
    }
};
exports.FlowOperators = operators;
//# sourceMappingURL=FlowOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const operators = {
    "ppi-scale": {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            return value * scaleFactor;
        }
    },
    "world-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);
            const v = pixels * zoomWidth * scaleFactor;
            return v;
        }
    },
    "world-discrete-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidthDiscrete = Math.pow(2, 17.8) / Math.pow(2, Math.floor(zoom));
            const v = pixels * zoomWidthDiscrete * scaleFactor;
            return v;
        }
    },
    ppi: {
        call: (context) => {
            const ppi = context.env.lookup("$ppi");
            if (typeof ppi === "number") {
                return ppi;
            }
            return 72;
        }
    },
    zoom: {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            var _a;
            if (context.scope === Expr_1.ExprScope.Value) {
                return call;
            }
            return (_a = context.env.lookup("$zoom")) !== null && _a !== void 0 ? _a : null;
        }
    }
};
exports.MapOperators = operators;
//# sourceMappingURL=MapOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathOperators = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const operators = {
    "^": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);
            }
            return Math.pow(a, b);
        }
    },
    "-": {
        call: (context, call) => {
            if (call.args.length === 1) {
                const value = context.evaluate(call.args[0]);
                if (typeof value !== "number") {
                    throw new Error(`nvalid operand '${typeof value} for operator '-'`);
                }
                return -value;
            }
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);
            }
            return a - b;
        }
    },
    "/": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);
            }
            return a / b;
        }
    },
    "%": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                // tslint:disable-next-line: max-line-length
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);
            }
            return a % b;
        }
    },
    "+": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);
        }
    },
    "*": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);
        }
    },
    abs: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'abs'`);
            }
            return Math.abs(value);
        }
    },
    acos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'acos'`);
            }
            return Math.acos(value);
        }
    },
    asin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'asin'`);
            }
            return Math.asin(value);
        }
    },
    atan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'atan'`);
            }
            return Math.atan(value);
        }
    },
    ceil: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ceil'`);
            }
            return Math.ceil(value);
        }
    },
    cos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'cos'`);
            }
            return Math.cos(value);
        }
    },
    e: {
        call: () => {
            return Math.E;
        }
    },
    floor: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'floor'`);
            }
            return Math.floor(value);
        }
    },
    ln: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln'`);
            }
            return Math.log(value);
        }
    },
    ln2: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln2'`);
            }
            return Math.log2(value);
        }
    },
    log10: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'log10'`);
            }
            return Math.log10(value);
        }
    },
    max: {
        call: (context, call) => {
            return Math.max(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    min: {
        call: (context, call) => {
            return Math.min(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    /**
     * Clamp numeric value to given range, inclusive.
     *
     * Synopsis:
     * ```
     * ["clamp", v: number, min: number, max: number]`
     * ```
     */
    clamp: {
        call: (context, call) => {
            const v = context.evaluate(call.args[0]);
            const min = context.evaluate(call.args[1]);
            const max = context.evaluate(call.args[2]);
            if (typeof v !== "number" || typeof min !== "number" || typeof max !== "number") {
                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);
            }
            return THREE.MathUtils.clamp(v, min, max);
        }
    },
    pi: {
        call: () => {
            return Math.PI;
        }
    },
    round: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'round'`);
            }
            return Math.round(value);
        }
    },
    sin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sin'`);
            }
            return Math.sin(value);
        }
    },
    sqrt: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);
            }
            return Math.sqrt(value);
        }
    },
    tan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'tan'`);
            }
            return Math.tan(value);
        }
    }
};
exports.MathOperators = operators;
//# sourceMappingURL=MathOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiscOperators = void 0;
const operators = {
    length: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (Array.isArray(value) || typeof value === "string") {
                return value.length;
            }
            throw new Error(`invalid operand '${value}' for operator 'length'`);
        }
    },
    coalesce: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                const value = context.evaluate(childExpr);
                if (value !== null) {
                    return value;
                }
            }
            return null;
        }
    }
};
exports.MiscOperators = operators;
//# sourceMappingURL=MiscOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const Env_1 = __webpack_require__(/*! ../Env */ "./node_modules/@here/harp-datasource-protocol/lib/Env.js");
const hasOwnProperty = Object.prototype.hasOwnProperty;
var LookupMode;
(function (LookupMode) {
    LookupMode[LookupMode["get"] = 0] = "get";
    LookupMode[LookupMode["has"] = 1] = "has";
})(LookupMode || (LookupMode = {}));
function lookupMember(context, args, lookupMode) {
    var _a;
    const memberName = context.evaluate(args[0]);
    if (typeof memberName !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    const object = context.evaluate(args[1]);
    if (object && typeof object === "object") {
        if (Env_1.Env.isEnv(object)) {
            const value = (_a = object.lookup(memberName)) !== null && _a !== void 0 ? _a : null;
            return lookupMode === LookupMode.get ? value : value !== null;
        }
        if (hasOwnProperty.call(object, memberName)) {
            return lookupMode === LookupMode.get ? object[memberName] : true;
        }
    }
    return lookupMode === LookupMode.get ? null : false;
}
const operators = {
    in: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const object = context.evaluate(call.args[1]);
            if (typeof value === "string" && typeof object === "string") {
                return object.includes(value);
            }
            else if (Array.isArray(object)) {
                return object.includes(value);
            }
            return false;
        }
    },
    get: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.get)
    },
    has: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.has)
    },
    "dynamic-properties": {
        isDynamicOperator: () => true,
        call: (context, call) => {
            if (context.scope === Expr_1.ExprScope.Dynamic) {
                return context.env;
            }
            return call;
        }
    }
};
exports.ObjectOperators = operators;
//# sourceMappingURL=ObjectOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringOperators = void 0;
const operators = {
    concat: {
        call: (context, call) => {
            return "".concat(...call.args.map(a => String(context.evaluate(a))));
        }
    },
    downcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleLowerCase();
        }
    },
    upcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleUpperCase();
        }
    },
    "~=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.indexOf(right) !== -1;
            }
            return false;
        }
    },
    "^=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.startsWith(right);
            }
            return false;
        }
    },
    "$=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.endsWith(right);
            }
            return false;
        }
    }
};
exports.StringOperators = operators;
//# sourceMappingURL=StringOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeOperators = void 0;
const operators = {
    typeof: {
        call: (context, call) => {
            return typeof context.evaluate(call.args[0]);
        }
    }
};
exports.TypeOperators = operators;
//# sourceMappingURL=TypeOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/VectorOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
function isVector(context, call, type) {
    let ctor;
    switch (type) {
        case "vector2":
            ctor = THREE.Vector2;
            break;
        case "vector3":
            ctor = THREE.Vector3;
            break;
        case "vector4":
            ctor = THREE.Vector4;
            break;
    }
    for (const childExpr of call.args) {
        const value = context.evaluate(childExpr);
        if (value instanceof ctor) {
            return value;
        }
    }
    throw new Error(`expected a "${type}"`);
}
function toVector(context, call, type) {
    let VectorCtor;
    let components;
    switch (type) {
        case "vector2":
            VectorCtor = THREE.Vector2;
            components = 2;
            break;
        case "vector3":
            VectorCtor = THREE.Vector3;
            components = 3;
            break;
        case "vector4":
            VectorCtor = THREE.Vector4;
            components = 4;
            break;
    }
    for (const childExpr of call.args) {
        const value = context.evaluate(childExpr);
        if (value instanceof VectorCtor) {
            return value;
        }
        else if (Array.isArray(value) &&
            value.length === components &&
            value.every(v => typeof v === "number")) {
            return new VectorCtor().fromArray(value);
        }
    }
    throw new Error(`expected a "${type}"`);
}
const operators = {
    "make-vector": {
        call: (context, call) => {
            if (call._value !== undefined) {
                return call._value;
            }
            if (call.args.length < 2) {
                throw new Error("not enough arguments");
            }
            else if (call.args.length > 4) {
                throw new Error("too many arguments");
            }
            const components = call.args.map(arg => context.evaluate(arg));
            components.forEach((element, index) => {
                if (typeof element !== "number") {
                    throw new Error(`expected vector component at index ${index} to have type "number"`);
                }
            });
            let result;
            switch (components.length) {
                case 2:
                    result = new THREE.Vector2().fromArray(components);
                    break;
                case 3:
                    result = new THREE.Vector3().fromArray(components);
                    break;
                case 4:
                    result = new THREE.Vector4().fromArray(components);
                    break;
                default:
                    throw new Error("too many arguments");
            }
            if (call.args.every(arg => arg instanceof Expr_1.NumberLiteralExpr)) {
                call._value = result;
            }
            return result;
        }
    },
    vector2: {
        call: (context, call) => isVector(context, call, "vector2")
    },
    vector3: {
        call: (context, call) => isVector(context, call, "vector3")
    },
    vector4: {
        call: (context, call) => isVector(context, call, "vector4")
    },
    "to-vector2": {
        call: (context, call) => toVector(context, call, "vector2")
    },
    "to-vector3": {
        call: (context, call) => toVector(context, call, "vector3")
    },
    "to-vector4": {
        call: (context, call) => toVector(context, call, "vector4")
    }
};
exports.VectorOperators = operators;
//# sourceMappingURL=VectorOperators.js.map

/***/ }),

/***/ "./node_modules/@here/harp-fetch/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-fetch/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.web.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeLengthGeometrySubdivisionModifier = exports.SubdivisionMode = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3()];
var SubdivisionMode;
(function (SubdivisionMode) {
    /**
     * Subdivide all edges
     */
    SubdivisionMode[SubdivisionMode["All"] = 0] = "All";
    /**
     * Only subdivide horizontal and vertical edges
     */
    SubdivisionMode[SubdivisionMode["NoDiagonals"] = 1] = "NoDiagonals";
})(SubdivisionMode = exports.SubdivisionMode || (exports.SubdivisionMode = {}));
/**
 * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on
 * length of edges.
 */
class EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].
     *
     * @param subdivision - The subdivision factor
     * @param geoBox - The geo bounding box of a tile
     * @param subdivisionMode - Configures what edges to divide
     * @param projection - The projection that defines the world space of this geometry.
     */
    constructor(subdivision, geoBox, subdivisionMode = SubdivisionMode.All, projection) {
        super();
        this.subdivision = subdivision;
        this.geoBox = geoBox;
        this.subdivisionMode = subdivisionMode;
        this.projection = projection;
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Planar, "EdgeLengthGeometrySubdivisionModifier only supports planar projections");
        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);
        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);
        this.m_projectedBox = {
            min: {
                x: Math.min(northEast.x, southWest.x),
                y: Math.min(northEast.y, southWest.y),
                z: Math.min(northEast.z, southWest.z)
            },
            max: {
                x: Math.max(northEast.x, southWest.x),
                y: Math.max(northEast.y, southWest.y),
                z: Math.max(northEast.z, southWest.z)
            }
        };
        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;
        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;
        // Increase max length slightly to account for precision errors
        if (this.subdivisionMode === SubdivisionMode.All) {
            this.m_maxLengthX *= 1.1;
            this.m_maxLengthY *= 1.1;
        }
        this.m_maxLength = Math.sqrt(this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY);
    }
    /**
     * Return upper bound for length of diagonal edges
     */
    get maxLength() {
        return this.m_maxLength;
    }
    /**
     * Return upper bound for edge length in x direction
     */
    get maxLengthX() {
        return this.m_maxLengthX;
    }
    /**
     * Return upper bound for edge length in y direction
     */
    get maxLengthY() {
        return this.m_maxLengthY;
    }
    /** @override */
    shouldSplitTriangle(a, b, c) {
        const shouldSplitAB = this.shouldSplitEdge(a, b);
        const shouldSplitBC = this.shouldSplitEdge(b, c);
        const shouldSplitCA = this.shouldSplitEdge(c, a);
        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;
        if (!shouldSplit) {
            return;
        }
        const ab = a.distanceTo(b);
        const bc = b.distanceTo(c);
        const ca = c.distanceTo(a);
        const maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);
        if (ab === maxDistance) {
            return 0;
        }
        else if (bc === maxDistance) {
            return 1;
        }
        else if (ca === maxDistance) {
            return 2;
        }
        throw new Error("Could not split triangle.");
    }
    shouldSplitEdge(a, b) {
        switch (this.subdivisionMode) {
            case SubdivisionMode.All:
                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||
                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||
                    a.distanceTo(b) > this.m_maxLength);
            case SubdivisionMode.NoDiagonals:
                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||
                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY));
        }
    }
}
exports.EdgeLengthGeometrySubdivisionModifier = EdgeLengthGeometrySubdivisionModifier;
//# sourceMappingURL=EdgeLengthGeometrySubdivisionModifier.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SphericalGeometrySubdivisionModifier = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];
/**
 * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned
 * on the surface of a sphere centered at `(0, 0, 0)`.
 */
class SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[SphericalGeometrySubdivisionModifier]].
     *
     * @param angle - The maximum angle in radians between two vertices and the origin.
     * @param projection - The projection that defines the world space of this geometry.
     */
    constructor(angle, projection = harp_geoutils_1.sphereProjection) {
        super();
        this.angle = angle;
        this.projection = projection;
    }
    /** @override */
    shouldSplitTriangle(a, b, c) {
        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);
        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);
        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);
        const alpha = aa.angleTo(bb);
        const beta = bb.angleTo(cc);
        const gamma = cc.angleTo(aa);
        // find the maximum angle
        const m = Math.max(alpha, Math.max(beta, gamma));
        // split the triangle if needed.
        if (m < this.angle) {
            return undefined;
        }
        if (m === alpha) {
            return 0;
        }
        else if (m === beta) {
            return 1;
        }
        else if (m === gamma) {
            return 2;
        }
        throw new Error("failed to split triangle");
    }
}
exports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;
//# sourceMappingURL=SphericalGeometrySubdivisionModifier.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubdivisionModifier = void 0;
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const tmpVectorA = new three_1.Vector3();
const tmpVectorB = new three_1.Vector3();
const tmpVectorC = new three_1.Vector3();
/**
 * The [[SubdivisionModifier]] subdivides triangle mesh geometries.
 */
class SubdivisionModifier {
    /**
     * Constructs a new [[SubdivisionModifier]].
     */
    constructor() {
        // nothing to do
    }
    /**
     * Subdivides the faces of the given [[THREE.BufferGeometry]].
     *
     * This method modifies (in-place) the vertices and the faces of the geometry.
     * Please note that only the vertex position and their UV coordinates are subdivided.
     * Normals, vertex colors and other attributes are left unmodified.
     *
     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.
     */
    modify(geometry) {
        const positionAttr = geometry.getAttribute("position");
        const position = Array.from(positionAttr.array);
        const uvAttr = geometry.getAttribute("uv");
        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;
        const edgeAttr = geometry.getAttribute("edge");
        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;
        const wallAttr = geometry.getAttribute("wall");
        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;
        const indexAttr = geometry.getIndex();
        const indices = Array.from(indexAttr.array);
        // A cache containing the indices of the vertices added
        // when subdiving the faces of the geometry.
        const cache = new Map();
        /**
         * Returns the index of the vertex positioned in the middle of the given vertices.
         */
        function middleVertex(i, j) {
            // Build a unique `key` for the pair of indices `(i, j)`.
            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
            const h = cache.get(key);
            if (h !== undefined) {
                // Nothing to do, a vertex in the middle of (i, j) was already created.
                return h;
            }
            // The position of the new vertex.
            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
            // The index of the new vertex.
            const index = position.length / 3;
            position.push(...tmpVectorC.toArray());
            // Cache the position of the new vertex.
            cache.set(key, index);
            // The uvs of the new vertex.
            if (uv !== undefined) {
                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                uv.push(tmpVectorC.x, tmpVectorC.y);
            }
            // The edge and wall attributes of the new vertex.
            // If a new vertex has been introduced between i and j, connect the elements
            // accordingly.
            if (edge !== undefined) {
                if (edge[i] === j) {
                    edge.push(j);
                    edge[i] = index;
                }
                else if (edge[j] === i) {
                    edge.push(i);
                    edge[j] = index;
                }
                else {
                    edge.push(-1);
                }
            }
            if (wall !== undefined) {
                if (wall[i] === j) {
                    wall.push(j);
                    wall[i] = index;
                }
                else if (wall[j] === i) {
                    wall.push(i);
                    wall[j] = index;
                }
                else {
                    wall.push(-1);
                }
            }
            return index;
        }
        const newIndices = [];
        while (indices.length >= 3) {
            const v0 = indices.shift();
            const v1 = indices.shift();
            const v2 = indices.shift();
            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
            switch (edgeToSplit) {
                case 0: {
                    const v3 = middleVertex(v0, v1);
                    indices.push(v0, v3, v2, v3, v1, v2);
                    break;
                }
                case 1: {
                    const v3 = middleVertex(v1, v2);
                    indices.push(v0, v1, v3, v0, v3, v2);
                    break;
                }
                case 2: {
                    const v3 = middleVertex(v2, v0);
                    indices.push(v0, v1, v3, v3, v1, v2);
                    break;
                }
                case undefined: {
                    newIndices.push(v0, v1, v2);
                    break;
                }
                default:
                    throw new Error("failed to subdivide the given geometry");
            }
        }
        positionAttr.array = new Float32Array(position);
        positionAttr.count = position.length / positionAttr.itemSize;
        positionAttr.needsUpdate = true;
        geometry.setIndex(newIndices);
        if (uv !== undefined) {
            uvAttr.array = new Float32Array(uv);
            uvAttr.count = uv.length / uvAttr.itemSize;
            uvAttr.needsUpdate = true;
        }
        if (edge !== undefined) {
            edgeAttr.array = new Float32Array(edge);
            edgeAttr.count = edge.length / edgeAttr.itemSize;
            edgeAttr.needsUpdate = true;
        }
        return geometry;
    }
}
exports.SubdivisionModifier = SubdivisionModifier;
//# sourceMappingURL=SubdivisionModifier.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Utility classes for working with geospatial data.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBoxExtentLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/IdentityProjection */ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/SphereProjection */ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTree */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/SubTiles */ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/SubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/Vector3Like */ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/TransformLike */ "./node_modules/@here/harp-geoutils/lib/math/TransformLike.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3 */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoBox = void 0;
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * `GeoBox` is used to represent a bounding box in geo coordinates.
 */
class GeoBox {
    /**
     * Constructs a new `GeoBox` with the given geo coordinates.
     *
     * @param southWest - The south west position in geo coordinates.
     * @param northEast - The north east position in geo coordinates.
     */
    constructor(southWest, northEast) {
        this.southWest = southWest;
        this.northEast = northEast;
    }
    /**
     * Returns a `GeoBox` with the given geo coordinates.
     *
     * @param southWest - The south west position in geo coordinates.
     * @param northEast - The north east position in geo coordinates.
     */
    static fromCoordinates(southWest, northEast) {
        return new GeoBox(southWest, northEast);
    }
    /**
     * Returns a `GeoBox` with the given center and dimensions.
     *
     * @param center - The center position of geo box.
     * @param extent - Box latitude and logitude span
     */
    static fromCenterAndExtents(center, extent) {
        return new GeoBox(new GeoCoordinates_1.GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates_1.GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));
    }
    /**
     * Returns the minimum altitude or `undefined`.
     */
    get minAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.min(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the maximum altitude or `undefined`.
     */
    get maxAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.max(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the south latitude in degrees of this `GeoBox`.
     */
    get south() {
        return this.southWest.latitude;
    }
    /**
     * Returns the north altitude in degrees of this `GeoBox`.
     */
    get north() {
        return this.northEast.latitude;
    }
    /**
     * Returns the west longitude in degrees of this `GeoBox`.
     */
    get west() {
        return this.southWest.longitude;
    }
    /**
     * Returns the east longitude in degrees of this `GeoBox`.
     */
    get east() {
        return this.northEast.longitude;
    }
    /**
     * Returns the center of this `GeoBox`.
     */
    get center() {
        const latitude = (this.south + this.north) * 0.5;
        const { west, east } = this;
        const { minAltitude, altitudeSpan } = this;
        let altitude;
        if (minAltitude !== undefined && altitudeSpan !== undefined) {
            altitude = minAltitude + altitudeSpan * 0.5;
        }
        if (west < east) {
            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);
        }
        let longitude = (360 + east + west) * 0.5;
        if (longitude > 360) {
            longitude -= 360;
        }
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns the latitude span in radians.
     */
    get latitudeSpanInRadians() {
        return THREE.MathUtils.degToRad(this.latitudeSpan);
    }
    /**
     * Returns the longitude span in radians.
     */
    get longitudeSpanInRadians() {
        return THREE.MathUtils.degToRad(this.longitudeSpan);
    }
    /**
     * Returns the latitude span in degrees.
     */
    get latitudeSpan() {
        return this.north - this.south;
    }
    get altitudeSpan() {
        if (this.maxAltitude === undefined || this.minAltitude === undefined) {
            return undefined;
        }
        return this.maxAltitude - this.minAltitude;
    }
    /**
     * Returns the longitude span in degrees.
     */
    get longitudeSpan() {
        let width = this.northEast.longitude - this.southWest.longitude;
        if (width < 0) {
            width += 360;
        }
        return width;
    }
    /**
     * Returns the latitude span in degrees.
     * @deprecated Use [[latitudeSpan]] instead.
     */
    get latitudeSpanInDegrees() {
        return this.latitudeSpan;
    }
    /**
     * Returns the longitude span in degrees.
     * @deprecated Use [[longitudeSpan]] instead.
     */
    get longitudeSpanInDegrees() {
        return this.longitudeSpan;
    }
    /**
     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.
     *
     * @param point - The geo coordinates.
     */
    contains(point) {
        if (point.altitude === undefined ||
            this.minAltitude === undefined ||
            this.maxAltitude === undefined) {
            return this.containsHelper(point);
        }
        const isFlat = this.minAltitude === this.maxAltitude;
        const isSameAltitude = this.minAltitude === point.altitude;
        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
        // If box is flat, we should check the altitude and containment,
        // otherwise we should check also altitude difference where we consider
        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!
        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
            return this.containsHelper(point);
        }
        return false;
    }
    /**
     * Clones this `GeoBox` instance.
     */
    clone() {
        return new GeoBox(this.southWest, this.northEast);
    }
    /**
     * Update the bounding box by considering a given point.
     *
     * @param point - The point that may expand the bounding box.
     */
    growToContain(point) {
        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
        this.southWest.altitude =
            this.southWest.altitude !== undefined && point.altitude !== undefined
                ? Math.min(this.southWest.altitude, point.altitude)
                : this.southWest.altitude !== undefined
                    ? this.southWest.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
        this.northEast.altitude =
            this.northEast.altitude !== undefined && point.altitude !== undefined
                ? Math.max(this.northEast.altitude, point.altitude)
                : this.northEast.altitude !== undefined
                    ? this.northEast.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
    }
    containsHelper(point) {
        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
            return false;
        }
        const { west, east } = this;
        if (east > west) {
            return point.longitude >= west && point.longitude < east;
        }
        return point.longitude > east || point.longitude <= west;
    }
}
exports.GeoBox = GeoBox;
//# sourceMappingURL=GeoBox.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGeoBoxExtentLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.
 */
function isGeoBoxExtentLike(obj) {
    return (obj &&
        typeof obj === "object" &&
        typeof obj.latitudeSpan === "number" &&
        typeof obj.longitudeSpan === "number");
}
exports.isGeoBoxExtentLike = isGeoBoxExtentLike;
//# sourceMappingURL=GeoBoxExtentLike.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoCoordinates = void 0;
const GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js");
const GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js");
const LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
class GeoCoordinates {
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    constructor(latitude, longitude, altitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    static fromDegrees(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in radians.
     * @param longitude - Longitude in radians.
     * @param altitude - Altitude in meters.
     */
    static fromRadians(latitude, longitude, altitude) {
        return new GeoCoordinates(THREE.MathUtils.radToDeg(latitude), THREE.MathUtils.radToDeg(longitude), altitude);
    }
    /**
     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.
     * ```typescript
     * const center = { lat: 53.3, lng: 13.4 };
     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
     * ```
     * @param latLng - A {@link LatLngLike} object literal.
     */
    static fromLatLng(latLng) {
        return new GeoCoordinates(latLng.lat, latLng.lng);
    }
    /**
     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.
     *
     * Example:
     * ```typescript
     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);
     *
     * let geoCoords: number[] = ...;
     *
     * if (isGeoPointLike(geoCoords)) {
     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);
     * }
     * ```
     * @param geoPoint - An [[Array]] of at least two elements following the order
     * longitude, latitude, altitude.
     */
    static fromGeoPoint(geoPoint) {
        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);
    }
    /**
     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.
     *
     * Example:
     * ```typescript
     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);
     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });
     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));
     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });
     * ```
     *
     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}
     * or {@link LatLngLike} object literal.
     */
    static fromObject(geoPoint) {
        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {
            return GeoCoordinates.fromGeoPoint(geoPoint);
        }
        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);
        }
        else if (LatLngLike_1.isLatLngLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);
        }
        throw new Error("Invalid input coordinate format.");
    }
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians() {
        return THREE.MathUtils.degToRad(this.latitude);
    }
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians() {
        return THREE.MathUtils.degToRad(this.longitude);
    }
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees() {
        return this.latitude;
    } // compat api
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees() {
        return this.longitude;
    } // compat api
    /**
     * The latitude in the degrees.
     */
    get lat() {
        return this.latitude;
    }
    /**
     * The longitude in the degrees.
     */
    get lng() {
        return this.longitude;
    }
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid() {
        return !isNaN(this.latitude) && !isNaN(this.longitude);
    }
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized() {
        let { latitude, longitude } = this;
        if (isNaN(latitude) || isNaN(longitude)) {
            return this;
        }
        if (latitude > 90) {
            let wrapped = (latitude + 90) % 360;
            if (wrapped >= 180) {
                longitude += 180;
                wrapped = 360 - wrapped;
            }
            latitude = wrapped - 90;
        }
        if (latitude < -90) {
            let wrapped = (latitude - 90) % 360;
            if (wrapped <= -180) {
                longitude += 180;
                wrapped = -360 - wrapped;
            }
            latitude = wrapped + 90;
        }
        if (longitude < -180 || longitude > 180) {
            const sign = Math.sign(longitude);
            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;
        }
        if (latitude === this.latitude && longitude === this.longitude) {
            return this;
        }
        return new GeoCoordinates(latitude, longitude, this.altitude);
    }
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other - GeoCoordinatesLike to compare to.
     */
    equals(other) {
        return (this.latitude === other.latitude &&
            this.longitude === other.longitude &&
            this.altitude === other.altitude);
    }
    /**
     * Copy values from the other.
     *
     * @param other - GeoCoordinatesLike to copy all values from.
     */
    copy(other) {
        this.latitude = other.latitude;
        this.longitude = other.longitude;
        this.altitude = other.altitude;
        return this;
    }
    /**
     * Clones this `GeoCoordinates`.
     */
    clone() {
        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
    }
    /**
     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.
     */
    toLatLng() {
        return { lat: this.latitude, lng: this.longitude };
    }
    /**
     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].
     */
    toGeoPoint() {
        return this.altitude !== undefined
            ? [this.longitude, this.latitude, this.altitude]
            : [this.longitude, this.latitude];
    }
}
exports.GeoCoordinates = GeoCoordinates;
//# sourceMappingURL=GeoCoordinates.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGeoCoordinatesLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.
 */
function isGeoCoordinatesLike(object) {
    return (object &&
        typeof object.latitude === "number" &&
        typeof object.longitude === "number" &&
        (typeof object.altitude === "number" || typeof object.altitude === "undefined"));
}
exports.isGeoCoordinatesLike = isGeoCoordinatesLike;
//# sourceMappingURL=GeoCoordinatesLike.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGeoPointLike = void 0;
/**
 * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.
 */
function isGeoPointLike(geoPoint) {
    if (Array.isArray(geoPoint)) {
        const [longitude, latitude, altitude] = geoPoint;
        return (typeof longitude === "number" &&
            typeof latitude === "number" &&
            (altitude === undefined || typeof altitude === "number"));
    }
    return false;
}
exports.isGeoPointLike = isGeoPointLike;
//# sourceMappingURL=GeoPointLike.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLatLngLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link LatLngLike} interface.
 */
function isLatLngLike(object) {
    return object && typeof object.lat === "number" && typeof object.lng === "number";
}
exports.isLatLngLike = isLatLngLike;
//# sourceMappingURL=LatLngLike.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Box3Like.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBox3Like = void 0;
/**
 * Returns true if the given object implements the {@link Box3Like} interface.
 *
 * @param object - A valid object.
 */
function isBox3Like(object) {
    const box3 = object;
    return box3.min !== undefined && box3.max !== undefined;
}
exports.isBox3Like = isBox3Like;
//# sourceMappingURL=Box3Like.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/MathUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathUtils = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var MathUtils;
(function (MathUtils) {
    /**
     * Creates a new empty bounding box.
     *
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.
     */
    function newEmptyBox3() {
        return {
            min: { x: Infinity, y: Infinity, z: Infinity },
            max: { x: -Infinity, y: -Infinity, z: -Infinity }
        };
    }
    MathUtils.newEmptyBox3 = newEmptyBox3;
    /**
     * Set the components of the given [Vector3Like] instance.
     *
     * @param x - The x component.
     * @param y - The y component.
     * @param z - The z component.
     * @param v - The [Vector3Like]
     */
    function newVector3(x, y, z, v) {
        if (v === undefined) {
            return { x, y, z };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    }
    MathUtils.newVector3 = newVector3;
    /**
     * Copies the vector across.
     *
     * @param from - The vector to copy from.
     * @param to - The resulting [Vector3Like] instance, with the contents copied from from
     */
    function copyVector3(from, to) {
        to.x = from.x;
        to.y = from.y;
        to.z = from.z;
        return to;
    }
    MathUtils.copyVector3 = copyVector3;
    /**
     * Converts an angle measured in degrees to an equivalent value in radians.
     *
     * @param degrees - Value in degrees.
     * @returns Value in radians.
     * @deprecated use THREE.MathUtils.degToRad instead
     */
    MathUtils.degToRad = THREE.MathUtils.degToRad;
    /**
     * Converts an angle measured in radians to an equivalent value in degrees.
     *
     * @param degrees - Value in radians.
     * @returns Value in degrees.
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg
     *                | THREE.MathUtils.radToDeg}.
     */
    MathUtils.radToDeg = THREE.MathUtils.radToDeg;
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     * @returns Clamped value.
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp
     *                | THREE.MathUtils.clamp}.
     */
    MathUtils.clamp = THREE.MathUtils.clamp;
    /**
     * Normalize angle in degrees to range `[0, 360)`.
     *
     * @param a - Angle in degrees.
     * @returns Angle in degrees in range `[0, 360)`.
     */
    function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    }
    MathUtils.normalizeAngleDeg = normalizeAngleDeg;
    /**
     * Normalize latitude angle in degrees to range `[-180, 180]`.
     *
     * @param a - Latitude angle in degrees.
     * @returns Latitude angle in degrees in range `[-180, 180]`.
     */
    function normalizeLongitudeDeg(a) {
        a = normalizeAngleDeg(a);
        if (a > 180) {
            a = a - 360;
        }
        return a;
    }
    MathUtils.normalizeLongitudeDeg = normalizeLongitudeDeg;
    /**
     * Return the minimal delta between angles `a` and `b` given in degrees.
     *
     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed
     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.
     *
     * Useful when interpolating between `b` and `a` in angle space.
     *
     * @param a - Start angle in degrees.
     * @param b - End angle in degrees.
     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.
     */
    function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        const d = a - b;
        if (d > 180) {
            return d - 360;
        }
        else if (d <= -180) {
            return d + 360;
        }
        else {
            return d;
        }
    }
    MathUtils.angleDistanceDeg = angleDistanceDeg;
    /**
     * Interpolate linearly between two angles given in degrees.
     *
     * @param p0 - Angle from in degrees
     * @param p1 - Angle to in degrees
     * @param t - Interpolation factor (alpha), in range `0-1`.
     */
    function interpolateAnglesDeg(p0, p1, t) {
        // hand crafted version,
        // see stack for maybe better versions:
        //    https://stackoverflow.com/questions/2708476/rotation-interpolation
        const d = angleDistanceDeg(p1, p0);
        const r = (p0 + d * t) % 360;
        return r;
    }
    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));
//# sourceMappingURL=MathUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrientedBox3 = void 0;
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
function intersectsSlab(rayDir, p, axis, extent, t) {
    const epsilon = 1e-20;
    const e = axis.dot(p);
    const f = axis.dot(rayDir);
    if (Math.abs(f) < epsilon) {
        // ray parallel to near/far slab lines.
        return Math.abs(e) <= extent;
    }
    // ray intersects near/far slab lines.
    const finv = 1 / f;
    const t1 = (e + extent) * finv;
    const t2 = (e - extent) * finv;
    if (t1 > t2) {
        // t1 is far intersect, t2 is near.
        if (t2 > t.min) {
            t.min = t2;
        }
        if (t1 < t.max) {
            t.max = t1;
        }
    }
    else {
        // t1 is near intersect, t2 is far.
        if (t1 > t.min) {
            t.min = t1;
        }
        if (t2 < t.max) {
            t.max = t2;
        }
    }
    return t.min <= t.max && t.max >= 0;
}
const tmpVec = new three_1.Vector3();
const tmpT = { min: -Infinity, max: Infinity };
class OrientedBox3 {
    /**
     * Creates a new `OrientedBox3`.
     *
     * @hideconstructor
     */
    constructor(position, rotationMatrix, extents) {
        /**
         * The position of the center of this `OrientedBox3`.
         */
        this.position = new three_1.Vector3();
        /**
         * The x-axis of this `OrientedBox3`.
         */
        this.xAxis = new three_1.Vector3(1, 0, 0);
        /**
         * The y-axis of this `OrientedBox3`.
         */
        this.yAxis = new three_1.Vector3(0, 1, 0);
        /**
         * The z-axis of this `OrientedBox3`.
         */
        this.zAxis = new three_1.Vector3(0, 0, 1);
        /**
         * The extents of this `OrientedBox3`.
         */
        this.extents = new three_1.Vector3();
        if (position !== undefined) {
            this.position.copy(position);
        }
        if (rotationMatrix !== undefined) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== undefined) {
            this.extents.copy(extents);
        }
    }
    /**
     * Create a copy of this [[OrientedBoundingBox]].
     */
    clone() {
        const newBox = new OrientedBox3();
        newBox.copy(this);
        return newBox;
    }
    /**
     * Copies the values of `other` to this {@link OrientedBox3}.
     * @param other - The other {@link OrientedBox3} to copy.
     */
    copy(other) {
        this.position.copy(other.position);
        this.xAxis.copy(other.xAxis);
        this.yAxis.copy(other.yAxis);
        this.zAxis.copy(other.zAxis);
        this.extents.copy(other.extents);
    }
    /**
     * Gets the center position of this {@link OrientedBox3}.
     *
     * @param center - The returned center position.
     */
    getCenter(center = new three_1.Vector3()) {
        return center.copy(this.position);
    }
    /**
     * Gets the size of this {@link OrientedBox3}.
     *
     * @param size - The returned size.
     */
    getSize(size = new three_1.Vector3()) {
        return size.copy(this.extents).multiplyScalar(2);
    }
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix - The output orientation matrix.
     */
    getRotationMatrix(matrix = new three_1.Matrix4()) {
        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes - Frustum or array of planes.
     */
    intersects(frustumOrPlanes) {
        const planes = Array.isArray(frustumOrPlanes)
            ? frustumOrPlanes
            : frustumOrPlanes.planes;
        for (const plane of planes) {
            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +
                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +
                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
            const d = plane.distanceToPoint(this.position);
            if (d + r < 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks intersection with the given ray.
     *
     * @param ray - The ray to test.
     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.
     */
    intersectsRay(ray) {
        // Slabs intersection algorithm.
        tmpT.min = -Infinity;
        tmpT.max = Infinity;
        tmpVec.copy(this.position).sub(ray.origin);
        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {
            return undefined;
        }
        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {
            return undefined;
        }
        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {
            return undefined;
        }
        return tmpT.min > 0 ? tmpT.min : tmpT.max;
    }
    /**
     * Returns true if this {@link OrientedBox3} contains the given point.
     *
     * @param point - A valid point.
     */
    contains(point) {
        const dx = point.x - this.position.x;
        const dy = point.y - this.position.y;
        const dz = point.z - this.position.z;
        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);
        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);
        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);
        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPoint(point) {
        return Math.sqrt(this.distanceToPointSquared(point));
    }
    /**
     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPointSquared(point) {
        const d = new three_1.Vector3();
        d.subVectors(point, this.position);
        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];
        let result = 0;
        for (let i = 0; i < 3; ++i) {
            const length = lengths[i];
            const extent = this.extents.getComponent(i);
            if (length < -extent) {
                const dd = extent + length;
                result += dd * dd;
            }
            else if (length > extent) {
                const dd = length - extent;
                result += dd * dd;
            }
        }
        return result;
    }
}
exports.OrientedBox3 = OrientedBox3;
//# sourceMappingURL=OrientedBox3.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isOrientedBox3Like = void 0;
/**
 * Returns true if the given object implements the interface {@link OrientedBox3Like}.
 *
 * @param object - The object.
 */
function isOrientedBox3Like(object) {
    const obb = object;
    return (obb.position !== undefined &&
        obb.xAxis !== undefined &&
        obb.yAxis !== undefined &&
        obb.zAxis !== undefined &&
        obb.extents !== undefined);
}
exports.isOrientedBox3Like = isOrientedBox3Like;
//# sourceMappingURL=OrientedBox3Like.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/TransformLike.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/TransformLike.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTransformLike = void 0;
/**
 * Returns true if the given object implements the interface {@link TransformLike}.
 *
 * @param object - The object.
 */
function isTransformLike(object) {
    const transform = object;
    return (transform.position !== undefined &&
        transform.xAxis !== undefined &&
        transform.yAxis !== undefined &&
        transform.zAxis !== undefined);
}
exports.isTransformLike = isTransformLike;
//# sourceMappingURL=TransformLike.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVector3Like = void 0;
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
exports.isVector3Like = isVector3Like;
//# sourceMappingURL=Vector3Like.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EarthConstants = void 0;
let EarthConstants = /** @class */ (() => {
    class EarthConstants {
    }
    /** The equatorial circumference in meters. */
    EarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;
    /** The equatorial radius in meters. */
    EarthConstants.EQUATORIAL_RADIUS = 6378137.0;
    /** The lowest point on earth (Dead Sea) in meters. */
    EarthConstants.MIN_ELEVATION = -433.0;
    /** The highest point on earth (Mt. Everest) in meters. */
    EarthConstants.MAX_ELEVATION = 8848.0;
    /** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */
    EarthConstants.MAX_BUILDING_HEIGHT = 828;
    return EarthConstants;
})();
exports.EarthConstants = EarthConstants;
//# sourceMappingURL=EarthConstants.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.equirectangularProjection = exports.normalizedEquirectangularProjection = void 0;
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
let EquirectangularProjection = /** @class */ (() => {
    class EquirectangularProjection extends Projection_1.Projection {
        constructor() {
            super(...arguments);
            /** @override */
            this.type = Projection_1.ProjectionType.Planar;
        }
        /** @override */
        getScaleFactor(_worldPoint) {
            return 1;
        }
        /** @override */
        worldExtent(minAltitude, maxAltitude, result) {
            if (!result) {
                result = new THREE.Box3();
            }
            result.min.x = 0.0;
            result.min.y = 0.0;
            result.min.z = minAltitude;
            result.max.x = this.unitScale;
            result.max.y = this.unitScale / 2;
            result.max.z = maxAltitude;
            return result;
        }
        /** @override */
        projectPoint(geoPoint, result) {
            if (result === undefined) {
                /*
                 * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
                 * might be a concrete class which is not available at runtime.
                 * Consider the following example:
                 *
                 *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
                 *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
                 *
                 * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
                 */
                // tslint:disable-next-line:no-object-literal-type-assertion
                result = { x: 0, y: 0, z: 0 };
            }
            result.x =
                (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *
                    EquirectangularProjection.geoToWorldScale *
                    this.unitScale;
            result.y =
                (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *
                    EquirectangularProjection.geoToWorldScale *
                    this.unitScale;
            result.z = geoPoint.altitude || 0;
            return result;
        }
        /** @override */
        unprojectPoint(worldPoint) {
            const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -
                Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);
            return geoPoint;
        }
        /** @override */
        unprojectAltitude(worldPoint) {
            return worldPoint.z;
        }
        /** @override */
        projectBox(geoBox, result) {
            const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
            const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
            const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
            const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
            if (!result) {
                result = new THREE.Box3();
            }
            if (Box3Like_1.isBox3Like(result)) {
                result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
                result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
                result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
                result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
                if (altitudeSpan !== undefined) {
                    result.min.z = worldCenter.z - altitudeSpan * 0.5;
                    result.max.z = worldCenter.z + altitudeSpan * 0.5;
                }
                else {
                    result.min.z = 0;
                    result.max.z = 0;
                }
            }
            else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = worldCenter.x;
                result.position.y = worldCenter.y;
                result.position.z = worldCenter.z;
                result.extents.x = sizeX * 0.5 * this.unitScale;
                result.extents.y = sizeY * 0.5 * this.unitScale;
                result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);
            }
            return result;
        }
        /** @override */
        unprojectBox(worldBox) {
            const minGeo = this.unprojectPoint(worldBox.min);
            const maxGeo = this.unprojectPoint(worldBox.max);
            return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        }
        /** @override */
        groundDistance(worldPoint) {
            return worldPoint.z;
        }
        /** @override */
        scalePointToSurface(worldPoint) {
            worldPoint.z = 0;
            return worldPoint;
        }
        /** @override */
        surfaceNormal(_worldPoint, normal) {
            if (normal === undefined) {
                normal = { x: 0, y: 0, z: 1 };
            }
            else {
                normal.x = 0;
                normal.y = 0;
                normal.z = 1;
            }
            return normal;
        }
    }
    EquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);
    EquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;
    return EquirectangularProjection;
})();
/**
 * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice
 * versa.
 */
exports.normalizedEquirectangularProjection = new EquirectangularProjection(1);
/**
 * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice
 * versa.
 */
exports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
//# sourceMappingURL=EquirectangularProjection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.identityProjection = void 0;
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
class IdentityProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = -Math.PI;
        result.min.y = -Math.PI * 0.5;
        result.min.z = minAltitude;
        result.max.x = Math.PI;
        result.max.y = Math.PI * 0.5;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);
        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));
        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = min.x;
            result.min.y = min.y;
            result.min.z = min.z;
            result.max.x = max.x;
            result.max.y = max.y;
            result.max.z = max.z;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (min.x + max.x) * 0.5;
            result.position.y = (min.y + max.y) * 0.5;
            result.position.z = (min.z + max.z) * 0.5;
            result.extents.x = (max.x - min.x) * 0.5;
            result.extents.y = (max.y - min.y) * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
/**
 * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.
 */
exports.identityProjection = new IdentityProjection(1);
//# sourceMappingURL=IdentityProjection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.webMercatorProjection = exports.mercatorProjection = exports.MercatorConstants = void 0;
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
class MercatorProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    static clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    static latitudeClamp(latitude) {
        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);
    }
    static latitudeProject(latitude) {
        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
    }
    static latitudeClampProject(latitude) {
        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
    }
    static unprojectLatitude(y) {
        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        result.y =
            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *
                this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(geoBox.center);
        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldYCenter = (worldNorth + worldSouth) * 0.5;
        worldCenter.y = worldYCenter;
        const latitudeSpan = worldNorth - worldSouth;
        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;
        if (!result) {
            result = new THREE.Box3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - longitudeSpan * 0.5;
            result.min.y = worldCenter.y - latitudeSpan * 0.5;
            result.max.x = worldCenter.x + longitudeSpan * 0.5;
            result.max.y = worldCenter.y + latitudeSpan * 0.5;
            const altitudeSpan = geoBox.altitudeSpan;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = longitudeSpan * 0.5;
            result.extents.y = latitudeSpan * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        // this implementation of [[reprojectPoint]] supports both
        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only
        // difference betweeen these two variants of WEB Mercator
        // is in the orientation of the Y axis, so we just flip Y coordinates
        // when reprojecting between them.
        if (sourceProjection !== this &&
            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = worldPos.x;
            result.y = this.unitScale - worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
class WebMercatorProjection extends MercatorProjection {
    /** @override */
    projectPoint(geoPointLike, result) {
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        /*
         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
         * might be a concrete class which is not available at runtime.
         * Consider the following example:
         *
         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
         *
         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
         */
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const x = worldPoint.x / this.unitScale - 0.5;
        const y = 0.5 - worldPoint.y / this.unitScale;
        const longitude = 360 * x;
        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);
    }
    /** @override */
    projectBox(geoBox, result) {
        const r = super.projectBox(geoBox, result);
        if (Box3Like_1.isBox3Like(r)) {
            // Invert the y axis for web mercator, this means that max => min & min => max
            const maxY = r.max.y;
            r.max.y = this.unitScale - r.min.y;
            r.min.y = this.unitScale - maxY;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);
            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);
            r.position.y = this.unitScale - r.position.y;
        }
        return r;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
        return geoBox;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
    /** @override */
    localTangentSpace(point, result) {
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
        }
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);
        return result;
    }
}
let MercatorConstants = /** @class */ (() => {
    class MercatorConstants {
    }
    // Math.atan(Math.sinh(Math.PI))
    MercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;
    return MercatorConstants;
})();
exports.MercatorConstants = MercatorConstants;
/**
 * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.
 */
exports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
/**
 * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates
 * and vice versa.
 */
exports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
//# sourceMappingURL=MercatorProjection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/Projection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Projection = exports.ProjectionType = void 0;
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
/**
 * The type of projection.
 */
var ProjectionType;
(function (ProjectionType) {
    /**
     * A type of [Projection] with zero curvature.
     */
    ProjectionType[ProjectionType["Planar"] = 0] = "Planar";
    /**
     * A spherical [Projection].
     */
    ProjectionType[ProjectionType["Spherical"] = 1] = "Spherical";
})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));
/**
 * `Projection` is used to convert positions from geo coordinates to world coordinates and vice
 * versa.
 */
class Projection {
    /**
     * Constructs the Projection
     *
     * @param unitScale - How to transform the projected coordinates to world units.
     */
    constructor(unitScale) {
        this.unitScale = unitScale;
        //Prevent empty constructor error.
    }
    /**
     * Gets the {@link TransformLike} of the local tangent space at the given point.
     *
     * @param point - The geo / world coordinates.
     * @param result - The {@link TransformLike}.
     */
    localTangentSpace(point, result) {
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
        }
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
        return result;
    }
    /**
     * Reproject a world position from the given source {@link Projection}.
     * Implementations should be aware of worldPos and result may be one object
     *
     * @param sourceProjection - The source projection.
     * @param worldPos - A valid position in the world space defined by the source projection.
     * @param result - The resulting position reprojected using this {@link Projection}.
     * @hidden
     */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === this) {
            if (result === undefined) {
                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
            }
            result.x = worldPos.x;
            result.y = worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
    }
}
exports.Projection = Projection;
//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sphereProjection = void 0;
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Transforms the given vector using the provided basis.
 */
function apply(xAxis, yAxis, zAxis, v) {
    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
/**
 * Returns the quadrants for the given longitude. The quadrant is defined as:
 *  - quadrant(+Math.PI * -1.0) = 0
 *  - quadrant(+Math.PI * -0.5) = 1
 *  - quadrant(+Math.PI *  0.0) = 2
 *  - quadrant(+Math.PI *  0.5) = 3
 *  - quadrant(+Math.PI *  1.0) = 4
 *
 * @param longitude - The longitude in radians.
 */
function getLongitudeQuadrant(longitude) {
    const oneOverPI = 1 / Math.PI;
    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
/**
 * Creates a Box3 enclosing the geobox.
 *
 * @param geoBox - Ghe given geobox
 * @param worldBox - The resulting axis aligned bounding box.
 */
function makeBox3(geoBox, worldBox, unitScale) {
    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;
    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);
    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);
    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    let xMin = Math.cos(minLongitude);
    let xMax = xMin;
    let yMin = Math.sin(minLongitude);
    let yMax = yMin;
    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
        // tslint:disable-next-line: no-bitwise
        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        // tslint:disable-next-line: no-bitwise
        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    const cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    const sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    const xCenter = (xMax + xMin) * halfEquatorialRadius;
    const xExtent = (xMax - xMin) * halfEquatorialRadius;
    const yCenter = (yMax + yMin) * halfEquatorialRadius;
    const yExtent = (yMax - yMin) * halfEquatorialRadius;
    // Calculate Z boundaries.
    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);
    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);
    const zMax = Math.sin(maxLatutide);
    const zMin = Math.sin(minLatitude);
    const zCenter = (zMax + zMin) * halfEquatorialRadius;
    const zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
/**
 * Computes the spherical projection of the given geo coordinates.
 *
 * @param geoPoint - The geo coordinates.
 * @param worldpoint - The resulting world coordinates.
 */
function project(geoPoint, worldpoint, unitScale) {
    const radius = unitScale + (geoPoint.altitude || 0);
    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);
    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);
    const cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
class SphereProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Spherical;
    }
    /** @override */
    worldExtent(_minElevation, maxElevation, result = new THREE.Box3()) {
        const radius = this.unitScale + maxElevation;
        result.min.x = -radius;
        result.min.y = -radius;
        result.min.z = -radius;
        result.max.x = radius;
        result.max.y = radius;
        result.max.z = radius;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {
        return project(geoPoint, result, this.unitScale);
    }
    /** @override */
    unprojectPoint(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y;
        const parallelRadius = Math.sqrt(parallelRadiusSq);
        const v = point.z / parallelRadius;
        if (isNaN(v)) {
            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);
        }
        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
    }
    /** @override */
    unprojectAltitude(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
    }
    /** @override */
    projectBox(geoBox, result = new THREE.Box3()) {
        if (Box3Like_1.isBox3Like(result)) {
            return makeBox3(geoBox, result, this.unitScale);
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            if (geoBox.longitudeSpan >= 90) {
                const bounds = makeBox3(geoBox, new THREE.Box3(), this.unitScale);
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                return result;
            }
            const { south, west, north, east, center: mid } = geoBox;
            const midX = mid.longitude;
            const midY = mid.latitude;
            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));
            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));
            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));
            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));
            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));
            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));
            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));
            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));
            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));
            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));
            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));
            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));
            // Build the orientation of the OBB using the normal vector and its partial derivates.
            // the sperical coordinates of the mid point of the geobox.
            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
            // the partial derivates of the normal vector.
            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
            let width;
            let minY;
            let maxY;
            if (south >= 0) {
                // abs(dot(southWest - southEast, xAxis))
                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                // dot(south, yAxis)
                minY = cosMidY * sinSouth - sinMidY * cosSouth;
                // dot(northEast, zAxis)
                maxY =
                    cosMidY * sinNorth -
                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            else {
                if (north <= 0) {
                    // abs(dot(northWest - northEast, xAxis))
                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                    // dot(north, yAxis)
                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                }
                else {
                    // abs(dot(west - east, xAxis))
                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                    // dot(northEast, yAxis)
                    maxY =
                        cosMidY * sinNorth -
                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                }
                // dot(southEast, yAxis)
                minY =
                    cosMidY * sinSouth -
                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;
            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;
            // min(dot(southEast, zAxis), dot(northEast, zAxis))
            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
            apply(result.xAxis, result.yAxis, result.zAxis, result.position);
            result.position.x = result.position.x - result.zAxis.x * result.extents.z;
            result.position.y = result.position.y - result.zAxis.y * result.extents.z;
            result.position.z = result.position.z - result.zAxis.z * result.extents.z;
            return result;
        }
        throw new Error("Invalid bounding box");
    }
    /** @override */
    unprojectBox(_worldBox) {
        throw new Error("Method not implemented.");
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    groundDistance(worldPoint) {
        return lengthOfVector3(worldPoint) - this.unitScale;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
        worldPoint.x *= scale;
        worldPoint.y *= scale;
        worldPoint.z *= scale;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 0 };
        }
        const scale = 1 / (lengthOfVector3(worldPoint) || 1);
        normal.x = worldPoint.x * scale;
        normal.y = worldPoint.y * scale;
        normal.z = worldPoint.z * scale;
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {
            const { x, y, z } = worldPos;
            const r = this.unitScale;
            const mx = x / r - Math.PI;
            const my = y / r - Math.PI;
            const w = Math.exp(my);
            const d = w * w;
            const gx = (2 * w) / (d + 1);
            const gy = (d - 1) / (d + 1);
            const scale = r + z;
            if (result === undefined) {
                // tslint:disable-next-line: no-object-literal-type-assertion
                result = {};
            }
            result.x = Math.cos(mx) * gx * scale;
            result.y = Math.sin(mx) * gx * scale;
            result.z = gy * scale;
            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {
                result.z = -result.z;
            }
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
    /** @override */
    localTangentSpace(point, result) {
        let geoPoint;
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
            geoPoint = point;
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
            geoPoint = this.unprojectPoint(point);
        }
        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);
        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);
        const cosLongitude = Math.cos(longitude);
        const sinLongitude = Math.sin(longitude);
        const cosLatitude = Math.cos(latitude);
        const sinLatitude = Math.sin(latitude);
        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
        return result;
    }
}
exports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
//# sourceMappingURL=SphereProjection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.transverseMercatorProjection = exports.TransverseMercatorUtils = void 0;
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const Projection_1 = __webpack_require__(/*! ./Projection */ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 *
 * https://en.wikipedia.org/wiki/Transverse_Mercator_projection
 * http://mathworld.wolfram.com/MercatorProjection.html
 *
 */
class TransverseMercatorProjection extends Projection_1.Projection {
    constructor(unitScale) {
        super(unitScale);
        this.unitScale = unitScale;
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
        this.m_phi0 = 0;
        this.m_lambda0 = 0;
    }
    /**
     * Like in regular Mercator projection, there are two points on sphere
     * with radius about 5 degrees, that is out of projected space.
     *
     *
     * in regular Mercator these points are:
     *     (90, any), (-90, any)
     *
     * and in transverse Mercator:
     *     (0, 90), (0, -90)
     *
     * So, in transverse we need to compute distnce to poles, and clamp if
     * radius is exceeded
     */
    static clampGeoPoint(geoPoint, _unitScale) {
        const lat = geoPoint.latitude;
        const lon = geoPoint.longitude;
        const r = TransverseMercatorUtils.POLE_RADIUS;
        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;
        const nearestQuarter = Math.round(lon / 90);
        const deltaLon = nearestQuarter * 90 - lon;
        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {
            return geoPoint;
        }
        const deltaLat = lat - 0;
        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;
        if (distanceToPoleSq < rsq) {
            const distanceToPole = Math.sqrt(distanceToPoleSq);
            const scale = (r - distanceToPole) / distanceToPole;
            // const quarter = ((nearestQuarter % 4) + 4) % 4;
            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;
            const dir = 1;
            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;
            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);
        }
        return geoPoint;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        if (!result) {
            // tslint:disable-next-line:no-object-literal-type-assertion
            result = { x: 0, y: 0, z: 0 };
        }
        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);
        const normalLon = clamped.longitude / 360 + 0.5;
        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);
        const phi = THREE.MathUtils.degToRad(clamped.latitude);
        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;
        const B = Math.cos(phi) * Math.sin(lambda);
        // result.x = 1/2 * Math.log((1 + B) / (1 - B));
        result.x = Math.atanh(B);
        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;
        const outScale = 0.5 / Math.PI;
        result.x =
            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);
        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);
        result.z = geoPoint.altitude || 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const tau = Math.PI * 2;
        const nx = worldPoint.x / this.unitScale;
        const ny = worldPoint.y / this.unitScale;
        const offset = nx === 1 ? 0 : Math.floor(nx);
        const x = tau * (nx - 0.5 - offset);
        const y = tau * (ny - 0.5);
        const z = worldPoint.z || 0;
        const D = y + this.m_phi0;
        const phi = Math.asin(Math.sin(D) / Math.cosh(x));
        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);
        return geoPoint;
    }
    /** @override */
    projectBox(geoBox, result) {
        const { north, south, east, west } = geoBox;
        const pointsToCheck = [
            geoBox.center,
            geoBox.northEast,
            geoBox.southWest,
            new GeoCoordinates_1.GeoCoordinates(south, east),
            new GeoCoordinates_1.GeoCoordinates(north, west)
        ];
        const E = TransverseMercatorUtils.POLE_EDGE_DEG;
        const containsWestCut = west < -90 && east > -90;
        const containsEastCut = west < 90 && east > 90;
        const containsCenterX = west < 0 && east > 0;
        const containsCenterY = west < E && east > -E && north > 0 && south < 0;
        if (containsWestCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));
        }
        if (containsEastCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));
        }
        if (containsCenterX) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));
        }
        if (containsCenterY) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));
        }
        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);
        const projected = pointsToCheck.map(p => this.projectPoint(p));
        const vx = projected.map(p => p.x);
        const vy = projected.map(p => p.y);
        const vz = projected.map(p => p.z);
        const minX = Math.min(...vx);
        const minY = Math.min(...vy);
        const minZ = Math.min(...vz);
        const maxX = Math.max(...vx);
        const maxY = Math.max(...vy);
        const maxZ = Math.max(...vz);
        if (!result) {
            result = new THREE.Box3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = minX;
            result.min.y = minY;
            result.min.z = minZ;
            result.max.x = maxX;
            result.max.y = maxY;
            result.max.z = maxZ;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (minX + maxX) / 2;
            result.position.y = (minY + maxY) / 2;
            result.position.z = (minZ + maxZ) / 2;
            result.extents.x = (maxX - minX) / 2;
            result.extents.y = (maxY - minY) / 2;
            result.extents.z = (maxZ - minZ) / 2;
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /**
     * There are 8 sub-regions on entire projection space
     * where both longitude and latitude preserve direction.
     * If bounding box hits more than one region, it should be splitted
     * into sub-boxes by regions, (un)projected and then united again.
     *
     *
     * directions in form [latitude / longitude]:
     *    1 |
     *       dr / dl | dl / ul 
     * 0.75 ----------|----------
     *       ur / dr | ul / ur 
     * 0.5  ----------|----------
     *       ul / ur | ur / dr 
     * 0.25 ----------|----------
     *       dl / ul | dr / dl 
     *      |
     *     0         0.5        1
     *     @override
     */
    unprojectBox(worldBox) {
        const s = this.unitScale;
        const min = worldBox.min;
        const max = worldBox.max;
        const pointsToCheck = [
            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },
            min,
            max,
            { x: min.x, y: max.y, z: 0 },
            { x: max.x, y: min.y, z: 0 }
        ];
        const center = 0.5 * s;
        const lowerQ = 0.25 * s;
        const upperQ = 0.75 * s;
        const containsCenterX = min.x < center && max.x > center;
        const containsCenterY = min.y < center && max.y > center;
        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;
        const containsUpperQY = min.y < upperQ && max.y > upperQ;
        if (containsCenterY) {
            pointsToCheck.push({ x: min.x, y: center, z: 0 });
            pointsToCheck.push({ x: max.x, y: center, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: center, z: 0 });
            }
        }
        if (containsLowerQY) {
            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });
            }
        }
        if (containsUpperQY) {
            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: upperQ, z: 0 });
            }
        }
        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));
        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);
        const latitudes = geoPoints.map(g => g.latitude);
        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);
        const altitudes = geoPoints.map(g => g.altitude || 0);
        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));
        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
}
let TransverseMercatorUtils = /** @class */ (() => {
    class TransverseMercatorUtils {
        /**
         * There are two regions on projected space that have same geo coordinates,
         * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }
         * they both have geo coordinates of   (0, [-90..+90])
         * and should be aligned somehow to fall into first or second region
         * to make proper bounding boxes, tile bounds, etc.
         */
        static alignLatitude(points, referencePoint) {
            const EPSILON = 1e-9;
            for (const point of points) {
                if (point.latitude === 0) {
                    point.latitude = referencePoint.latitude * EPSILON;
                }
            }
        }
        /**
         * There are two regions on projected plane,
         * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }
         * that represent longitude edge where -180 and +180 met.
         * Points falling in this regions should be aligned to get proper boxes etc.
         */
        static alignLongitude(points, referencePoint) {
            const bad = referencePoint.longitude < 0 ? 180 : -180;
            const good = referencePoint.longitude < 0 ? -180 : 180;
            for (const point of points) {
                if (point.longitude === bad) {
                    point.longitude = good;
                }
            }
        }
    }
    TransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;
    TransverseMercatorUtils.POLE_EDGE_DEG = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);
    TransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;
    TransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);
    return TransverseMercatorUtils;
})();
exports.TransverseMercatorUtils = TransverseMercatorUtils;
/**
 * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates
 * and vice versa.
 */
exports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
//# sourceMappingURL=TransverseMercatorProjection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlatTileBoundingBoxGenerator = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given
 * TilingScheme.
 */
class FlatTileBoundingBoxGenerator {
    /**
     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given
     * TilingScheme.
     *
     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.
     * @param minElevation - The minimum elevation in meters.
     * @param maxElevation - The maximum elevation in meters.
     */
    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        const { min, max } = this.m_worldBox;
        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };
    }
    /**
     * Returns the {@link Projection} of the {@link TilingScheme}.
     */
    get projection() {
        return this.m_tilingScheme.projection;
    }
    /**
     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.
     */
    get subdivisionScheme() {
        return this.m_tilingScheme.subdivisionScheme;
    }
    /**
     * Returns the bounding box in world coordinates of the given {@link TileKey}.
     *
     * Example:
     * ```typescript
     * const worldBounds = new THREE.Box3();
     * generator.getWorldBox(geoBox, worldBounds);
     * console.log(worldBounds.getCenter());
     * ```
     *
     * @param tileKey - The TileKey.
     * @param result - The optional object used to store the resulting bounding box in world
     * coordinates.
     */
    getWorldBox(tileKey, result) {
        const level = tileKey.level;
        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
        const sizeX = this.m_worldDimensions.x / levelDimensionX;
        const sizeY = this.m_worldDimensions.y / levelDimensionY;
        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = originX;
        result.min.y = originY;
        result.min.z = this.m_worldBox.min.z;
        result.max.x = originX + sizeX;
        result.max.y = originY + sizeY;
        result.max.z = this.m_worldBox.max.z;
        return result;
    }
    /**
     * Returns the bounding box in geo coordinates for the given {@link TileKey}.
     *
     * Example:
     * ```typescript
     * const geoBox = generator.getGeoBox(worldBounds);
     * console.log(geoBox.center);
     * ```
     *
     * @param tileKey - The {@link TileKey}.
     */
    getGeoBox(tileKey) {
        const worldBox = this.getWorldBox(tileKey);
        return this.projection.unprojectBox(worldBox);
    }
}
exports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;
//# sourceMappingURL=FlatTileBoundingBoxGenerator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.halfQuadTreeSubdivisionScheme = void 0;
class HalfQuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY(level) {
        return level === 0 ? 1 : 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return level !== 0 ? 1 << (level - 1) : 1;
    }
}
/**
 * A {@link SubdivisionScheme} used to represent half quadtrees.
 * This particular subdivision scheme is
 * used by the HERE tiling scheme.
 */
exports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();
//# sourceMappingURL=HalfQuadTreeSubdivisionScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.hereTilingScheme = void 0;
const EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js");
const HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * {@link TilingScheme} used by most of the data published by HERE.
 *
 * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular
 * projection.
 */
exports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);
//# sourceMappingURL=HereTilingScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mercatorTilingScheme = void 0;
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * The {@link TilingScheme} used by the HERE web tiles.
 *
 * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.
 */
exports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);
//# sourceMappingURL=MercatorTilingScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.polarTilingScheme = void 0;
const TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * A {@link TilingScheme} featuring quadtree subdivision scheme and
 * transverse Mercator projection.
 */
exports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);
//# sourceMappingURL=PolarTilingScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadTree = void 0;
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
/**
 * A class used to represent a quadtree.
 */
class QuadTree {
    /**
     * Constructs a new `QuadTree` for the given {@link TilingScheme}.
     *
     * Example:
     * ```typescript
     * const quadTree = new QuadTree(hereTilingScheme);
     * const geoBox = quadTree.getGeoBox(tileKey);
     * console.log(geoBox.center);
     * ```
     *
     * @param tilingScheme - The TilingScheme used by this `QuadTree`.
     */
    constructor(tilingScheme) {
        this.tilingScheme = tilingScheme;
    }
    /**
     * Visits this `QuadTree` and invoke the given accept method
     * with the current {@link TileKey} and
     * its bounding box in geo coordinates.
     *
     * Example:
     * ```typescript
     * const geoPos = new GeoCoordinates(latitude, longitude);
     * const quadTree = new QuadTree(hereTilingScheme);
     * quadTree.visit((tileKey, geoBox) => {
     *     if (geoBox.contains(geoPos)) {
     *         console.log("tile", tileKey, "contains", geoPos);
     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.
     *     }
     *     return false; // stop visiting the quadtree,
     *                   // the tile's geoBox doesn't contain the given coordinates.
     * });
     * ```
     *
     * @param accept - A function that takes a {@link TileKey}
     * and its bounding box in geo coordinates
     * and returns `true` if the visit of the `QuadTree`
     * should continue; otherwise `false`.
     */
    visit(accept) {
        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);
    }
    /**
     * Visits the subtree starting from the given tile.
     *
     * @param tileKey - The root of the subtree that should be visited.
     * @param accept - A function that takes a {@link TileKey}
     *                 and its bounding box in geo coordinates
     *                 and returns `true` if the visit of the
     *                 `QuadTree` should continue; otherwise `false`.
     */
    visitTileKey(tileKey, accept) {
        const geoBox = this.tilingScheme.getGeoBox(tileKey);
        if (!accept(tileKey, geoBox)) {
            return;
        }
        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {
            this.visitTileKey(subTileKey, accept);
        }
    }
}
exports.QuadTree = QuadTree;
//# sourceMappingURL=QuadTree.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.quadTreeSubdivisionScheme = void 0;
class QuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY() {
        return 2;
    }
    getLevelDimensionX(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
    getLevelDimensionY(level) {
        // tslint:disable-next-line:no-bitwise
        return 1 << level;
    }
}
/**
 * {@link SubdivisionScheme} representing a quadtree.
 */
exports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();
//# sourceMappingURL=QuadTreeSubdivisionScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubTiles = void 0;
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
class SubTiles {
    constructor(tileKey, sizeX, sizeY) {
        this.tileKey = tileKey;
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }
    [Symbol.iterator]() {
        return this.sizeX === 2 && this.sizeY === 2
            ? SubTiles.ZCurveIterator(this.tileKey)
            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
    }
}
exports.SubTiles = SubTiles;
(function (SubTiles) {
    function* RowColumnIterator(parentKey, sizeX, sizeY) {
        for (let y = 0; y < sizeY; y++) {
            for (let x = 0; x < sizeX; x++) {
                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
            }
        }
    }
    SubTiles.RowColumnIterator = RowColumnIterator;
    function* ZCurveIterator(parentKey) {
        // tslint:disable:no-bitwise
        for (let i = 0; i < 4; i++) {
            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);
        }
        // tslint:enableno-bitwise
    }
    SubTiles.ZCurveIterator = ZCurveIterator;
})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));
//# sourceMappingURL=SubTiles.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubdivisionScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SubdivisionScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileKey = void 0;
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.
];
/**
 * The `TileKey` instances are used to address a tile in a quadtree.
 *
 * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one
 * single tile. On every level, each tile is divided into four children (therefore the name
 * quadtree).
 *
 * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number
 * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only
 * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles
 * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.
 *
 * A tile key is usually created using [[fromRowColumnLevel]]() method.
 *
 * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not
 * modify the original object.
 *
 * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for
 * easy vertical navigation of the tree. The number of available rows and columns in the tile's
 * level is given with [[rowCount]]() and [[columnCount]]().
 *
 * Tile keys can be created from and converted into various alternative formats:
 *
 *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based
 *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based
 *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation
 *
 * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be
 * represented in the number representation returned by [[mortonCode]]().
 */
class TileKey {
    /**
     * Constructs a new immutable instance of a `TileKey`.
     *
     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.
     *
     * Note - row and column must not be greater than the maximum rows/columns for the given level.
     *
     * @param row - Represents the row in the quadtree.
     * @param column - Represents the column in the quadtree.
     * @param level - Represents the level in the quadtree.
     */
    constructor(row, column, level) {
        this.row = row;
        this.column = column;
        this.level = level;
    }
    /**
     * Creates a tile key.
     *
     * @param row - The requested row. Must be less than 2 to the power of level.
     * @param column - The requested column. Must be less than 2 to the power of level.
     * @param level - The requested level.
     */
    static fromRowColumnLevel(row, column, level) {
        return new TileKey(row, column, level);
    }
    /**
     * Creates a tile key from a quad string.
     *
     * The quad string can be created with [[toQuadKey]].
     *
     * @param quadkey - The quadkey to convert.
     * @returns A new instance of `TileKey`.
     */
    static fromQuadKey(quadkey) {
        const level = quadkey.length;
        let row = 0;
        let column = 0;
        // tslint:disable:no-bitwise
        for (let i = 0; i < quadkey.length; ++i) {
            const mask = 1 << i;
            const d = parseInt(quadkey.charAt(level - i - 1), 10);
            if (d & 0x1) {
                column |= mask;
            }
            if (d & 0x2) {
                row |= mask;
            }
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Creates a tile key from a numeric Morton code representation.
     *
     * You can convert a tile key into a numeric Morton code with [[mortonCode]].
     *
     * @param quadKey64 - The Morton code to be converted.
     * @returns A new instance of {@link TileKey}.
     */
    static fromMortonCode(quadKey64) {
        let level = 0;
        let row = 0;
        let column = 0;
        let quadKey = quadKey64;
        // tslint:disable:no-bitwise
        while (quadKey > 1) {
            const mask = 1 << level;
            if (quadKey & 0x1) {
                column |= mask;
            }
            if (quadKey & 0x2) {
                row |= mask;
            }
            level++;
            quadKey = (quadKey - (quadKey & 0x3)) / 4;
        }
        // tslint:enable:no-bitwise
        const result = TileKey.fromRowColumnLevel(row, column, level);
        result.m_mortonCode = quadKey64;
        return result;
    }
    /**
     * Creates a tile key from a heretile code string.
     *
     * The string can be created with [[toHereTile]].
     *
     * @param quadkey64 - The string representation of the HERE tile key.
     * @returns A new instance of `TileKey`.
     */
    static fromHereTile(quadkey64) {
        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
        result.m_hereTile = quadkey64;
        return result;
    }
    /**
     * Returns the number of available columns at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level - The level for which to return the number of columns.
     * @returns The available columns at the given level.
     */
    static columnsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the number of available rows at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level - The level for which to return the number of rows.
     * @returns The available rows at the given level.
     */
    static rowsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the closest matching `TileKey` in a cartesian coordinate system.
     *
     * @param level - The level for the tile key.
     * @param coordX - The X coordinate.
     * @param coordY - The Y coordinate.
     * @param totalWidth - The maximum X coordinate.
     * @param totalHeight - The maximum Y coordinate.
     * @returns A new tile key at the given level that includes the given coordinates.
     */
    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
    }
    /**
     * Computes the Morton code of the parent tile key of the given Morton code.
     *
     * Note: The parent key of the root key is the root key itself.
     *
     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].
     * @returns The Morton code of the parent tile.
     */
    static parentMortonCode(mortonCode) {
        return Math.floor(mortonCode / 4);
    }
    /**
     * Returns a tile key representing the parent of the tile addressed by this tile key.
     *
     * Throws an exception is this tile is already the root.
     */
    parent() {
        if (this.level === 0) {
            throw new Error("Cannot get the parent of the root tile key");
        }
        // tslint:disable-next-line:no-bitwise
        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
    }
    /**
     * Returns a new tile key at a level that differs from this tile's level by delta.
     *
     * Equivalent to `changedLevelTo(level() + delta)`.
     *
     * Note - root key is returned if `delta` is smaller than the level of this tile key.
     *
     * @param delta - The numeric difference between the current level and the requested level.
     */
    changedLevelBy(delta) {
        const level = Math.max(0, this.level + delta);
        let row = this.row;
        let column = this.column;
        // tslint:disable:no-bitwise
        if (delta >= 0) {
            row <<= delta;
            column <<= delta;
        }
        else {
            row >>>= -delta;
            column >>>= -delta;
        }
        // tslint:enable:no-bitwise
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Returns a new tile key at the requested level.
     *
     * If the requested level is smaller than the tile's level, then the key of an ancestor of this
     * tile is returned. If the requested level is larger than the tile's level, then the key of
     * first child or grandchild of this tile is returned, for example, the child with the lowest
     * row and column number. If the requested level equals this tile's level, then the tile key
     * itself is returned. If the requested level is negative, the root tile key is returned.
     *
     * @param level - The requested level.
     */
    changedLevelTo(level) {
        return this.changedLevelBy(level - this.level);
    }
    /**
     * Converts the tile key to a numeric code representation.
     *
     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].
     *
     * Note - only levels <= 26 are supported.
     */
    mortonCode() {
        if (this.m_mortonCode === undefined) {
            let column = this.column;
            let row = this.row;
            // tslint:disable:no-bitwise
            let result = powerOfTwo[this.level << 1];
            for (let i = 0; i < this.level; ++i) {
                if (column & 0x1) {
                    result += powerOfTwo[2 * i];
                }
                if (row & 0x1) {
                    result += powerOfTwo[2 * i + 1];
                }
                column >>>= 1;
                row >>>= 1;
            }
            // tslint:enable:no-bitwise
            this.m_mortonCode = result;
        }
        return this.m_mortonCode;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * The string is a quadkey Morton code representation as a string.
     *
     * You can convert back from a quadkey string with [[fromHereTile]].
     */
    toHereTile() {
        if (this.m_hereTile === undefined) {
            this.m_hereTile = this.mortonCode().toString();
        }
        return this.m_hereTile;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the
     * base of 4, but without the leading 1, with the following properties:
     *  1. the number of digits equals the level.
     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3
     *     to a quadkey string gives the tiles's children.
     *
     * You can convert back from a quadkey string with [[fromQuadKey]].
     */
    toQuadKey() {
        let result = "";
        // tslint:disable:no-bitwise
        for (let i = this.level; i > 0; --i) {
            const mask = 1 << (i - 1);
            const col = (this.column & mask) !== 0;
            const row = (this.row & mask) !== 0;
            if (col && row) {
                result += "3";
            }
            else if (row) {
                result += "2";
            }
            else if (col) {
                result += "1";
            }
            else {
                result += "0";
            }
        }
        // tslint:enable:no-bitwise
        return result;
    }
    /**
     * Equality operator.
     *
     * @param qnr - The tile key to compare to.
     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.
     */
    equals(qnr) {
        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub quadkey.
     *
     * @param sub - The sub key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubKey(sub) {
        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub HERE tile key.
     *
     * @param sub - The sub HERE key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubHereTile(sub) {
        const subQuad = TileKey.fromHereTile(sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns a sub quadkey that is relative to its parent.
     *
     * This function can be used to generate sub keys that are relative to a parent that is delta
     * levels up in the quadtree.
     *
     * This function can be used to create shortened keys for quads on lower levels if the parent is
     * known.
     *
     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If
     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.
     *
     * Deltas larger than 16 are not supported.
     *
     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal
     * to 0 and smaller than 16.
     * @returns The quadkey relative to its parent that is `delta` levels up the tree.
     */
    getSubHereTile(delta) {
        const key = this.mortonCode();
        // tslint:disable-next-line:no-bitwise
        const msb = 1 << (delta * 2);
        const mask = msb - 1;
        // tslint:disable-next-line:no-bitwise
        const result = (key & mask) | msb;
        return result.toString();
    }
    /**
     * Returns the number of available rows in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    rowCount() {
        return TileKey.rowsAtLevel(this.level);
    }
    /**
     * Returns the number of available columns in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    columnCount() {
        return TileKey.columnsAtLevel(this.level);
    }
}
exports.TileKey = TileKey;
//# sourceMappingURL=TileKey.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileKeyUtils = void 0;
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js");
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js");
class TileKeyUtils {
    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        const projection = tilingScheme.projection;
        const worldPoint = projection.projectPoint(geoPoint);
        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);
    }
    static worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {
        const projection = tilingScheme.projection;
        const subdivisionScheme = tilingScheme.subdivisionScheme;
        const cx = subdivisionScheme.getLevelDimensionX(level);
        const cy = subdivisionScheme.getLevelDimensionY(level);
        const { min, max } = projection.worldExtent(0, 0);
        const worldSizeX = max.x - min.x;
        const worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));
        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));
        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);
    }
    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        const wrap = (value, lower, upper) => {
            if (value < lower) {
                return upper - ((lower - value) % (upper - lower));
            }
            return lower + ((value - lower) % (upper - lower));
        };
        const clamp = (x, minVal, maxVal) => {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        // Clamp at the poles and wrap around the international date line.
        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        const minColumn = minTileKey.column;
        let maxColumn = maxTileKey.column;
        // wrap around case
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            }
            else {
                // do not duplicate
                maxColumn += columnCount - 1;
            }
        }
        const minRow = Math.min(minTileKey.row, maxTileKey.row);
        const maxRow = Math.max(minTileKey.row, maxTileKey.row);
        const keys = new Array();
        for (let row = minRow; row <= maxRow; ++row) {
            for (let column = minColumn; column <= maxColumn; ++column) {
                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    }
}
exports.TileKeyUtils = TileKeyUtils;
//# sourceMappingURL=TileKeyUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileTreeTraverse = void 0;
const SubTiles_1 = __webpack_require__(/*! ./SubTiles */ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js");
class TileTreeTraverse {
    constructor(subdivisionScheme) {
        this.m_subdivisionScheme = subdivisionScheme;
    }
    subTiles(tileKey) {
        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
        return new SubTiles_1.SubTiles(tileKey, divX, divY);
    }
}
exports.TileTreeTraverse = TileTreeTraverse;
//# sourceMappingURL=TileTreeTraverse.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilingScheme = void 0;
const FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js");
const TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js");
const TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js");
/**
 * The `TilingScheme` represents how the data is tiled.
 */
class TilingScheme {
    /**
     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.
     *
     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.
     * @param projection - The projection used by this `TilingScheme`.
     */
    constructor(subdivisionScheme, projection) {
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);
    }
    /**
     * Returns the sub tile keys of the given tile.
     *
     * @param tileKey - The {@link TileKey}.
     * @returns The list of the sub tile keys.
     */
    getSubTileKeys(tileKey) {
        return this.tileTreeTraverse.subTiles(tileKey);
    }
    /**
     * Gets the {@link TileKey} from the given geo position and level.
     *
     * @param geoPoint - The position in geo coordinates.
     * @param level - The level of the resulting `TileKey`.
     */
    getTileKey(geoPoint, level) {
        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
    }
    /**
     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.
     *
     * @param geoBox - The bounding box in geo coordinates.
     * @param level - The level of the resulting `TileKey`.
     */
    getTileKeys(geoBox, level) {
        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
    }
    /**
     * Returns the bounding box in geo coordinates for the given {@link TileKey}.
     *
     * @param tileKey - The `TileKey`.
     */
    getGeoBox(tileKey) {
        return this.boundingBoxGenerator.getGeoBox(tileKey);
    }
    /**
     * Returns the bounding box in world coordinates.
     *
     * @param tileKey - The `TileKey`.
     * @param result - The optional object that will contain the resulting bounding box.
     */
    getWorldBox(tileKey, result) {
        return this.boundingBoxGenerator.getWorldBox(tileKey, result);
    }
}
exports.TilingScheme = TilingScheme;
//# sourceMappingURL=TilingScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.webMercatorTilingScheme = void 0;
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js");
/**
 * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.
 */
exports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);
//# sourceMappingURL=WebMercatorTilingScheme.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/index.js":
/*!************************************************!*\
  !*** ./node_modules/@here/harp-lines/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./lib/Lines */ "./node_modules/@here/harp-lines/lib/Lines.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TriangulateLines */ "./node_modules/@here/harp-lines/lib/TriangulateLines.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLines */ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionLines.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighPrecisionLine = exports.HighPrecisionWireFrameLine = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js");
/**
 * Class used to render high-precision wireframe lines.
 */
class HighPrecisionWireFrameLine extends THREE.Line {
    /**
     * Creates a `HighPrecisionWireFrameLine` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions - Array of 2D/3D positions.
     * @param color - Color of the rendered line.
     * @param opacity - Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;
/**
 * Class used to render high-precision lines.
 */
class HighPrecisionLine extends THREE.Mesh {
    /**
     * Creates a `HighPrecisionLine` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions - Array of 2D/3D positions.
     * @param color - Color of the rendered line.
     * @param opacity - Opacity of the rendered line.
     */
    constructor(geometry, material, positions, color, opacity) {
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionLineMaterial({
                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY
            });
        }
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionLine = HighPrecisionLine;
//# sourceMappingURL=HighPrecisionLines.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighPrecisionPoints = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions - Array of 2D/3D positions.
     * @param color - Color of the rendered point.
     * @param opacity - Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;
//# sourceMappingURL=HighPrecisionPoints.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighPrecisionUtils = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const HPL = __webpack_require__(/*! ./HighPrecisionLines */ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js");
const HPP = __webpack_require__(/*! ./HighPrecisionPoints */ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js");
const TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ "./node_modules/@here/harp-lines/lib/TriangulateLines.js");
var HighPrecisionUtils;
(function (HighPrecisionUtils) {
    /**
     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.
     * precision.
     *
     * @param v -
     */
    function doubleToFloatVec(v) {
        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    }
    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;
    /**
     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the
     * difference of the double elements and their float counterparts.
     *
     * @param v - Vector3 to convert to float IN-PLACE!
     */
    function makeFloatVec(v) {
        const majorX = Math.fround(v.x);
        const majorY = Math.fround(v.y);
        const majorZ = Math.fround(v.z);
        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    }
    HighPrecisionUtils.makeFloatVec = makeFloatVec;
    /**
     * Calculate high-precision camera position used in vertex shader of high-precision materials.
     *
     * @param camera - Camera used to get the high-precision position.
     * @param objectInverseWorldMatrix - Inverse World Matrix of the rendered
     *                                   [[HighPrecisionObject]].
     */
    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);
        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        // split the double float vector into hi and lo parts
        const eyePosFloat = doubleToFloatVec(eyePos);
        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo
        };
    }
    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    /**
     * Updates the high-precision uniform data of a material used to render a
     * [[HighPrecisionObject]].
     *
     * @param object - [[HighPrecisionObject]] used for rendering.
     * @param camera - Camera used to get the high-precision position.
     * @param shaderMaterial - Material which uniforms will be updated.
     */
    function updateHpUniforms(object, camera, shaderMaterial) {
        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        const mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_mvp &&
                shaderMaterial.uniforms.u_eyepos &&
                shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            }
            else {
                throw Error("High pecision material has missing uniforms");
            }
        }
        else {
            throw Error("High pecision line has no high precision material");
        }
    }
    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;
    /**
     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].
     *
     * @param positions - Array of positions.
     */
    function createAttributes(positions) {
        if (positions.length > 0) {
            const v = positions[0];
            if (v === undefined || v === null) {
                throw Error("Empty element in positions");
            }
            const positionVec = new Array();
            const positionVecLow = new Array();
            const addHPValue = (...values) => {
                for (const value of values) {
                    const major = Math.fround(value);
                    positionVecLow.push(value - major);
                    positionVec.push(major);
                }
            };
            const addHPVector = (vec) => {
                addHPValue(vec.x, vec.y, vec.z);
            };
            const vAny = v;
            if (vAny.z !== undefined) {
                positions.forEach(vec => {
                    addHPVector(vec);
                });
            }
            else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                positions.forEach((n) => {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),
                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)
            };
        }
        else {
            return {
                positionHigh: new three_1.Float32BufferAttribute([], 3),
                positionLow: new three_1.Float32BufferAttribute([], 3)
            };
        }
    }
    HighPrecisionUtils.createAttributes = createAttributes;
    /**
     * Assembles an interleaved buffer containing the position attribute data for a
     * [[HighPrecisionObject]].
     *
     * @param positions - Array of positions.
     * @param stride - Stride of the elements in the `positions` array.
     * @param positionOffset - Offset into the `positions` array.
     */
    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
        const newPositions = new Array();
        const end = positions.length;
        for (let i = 0; i < end; i += stride) {
            for (let j = 0; j < positionOffset; j++) {
                newPositions.push(positions[i + j]);
            }
            const x = positions[i + positionOffset];
            const y = positions[i + positionOffset + 1];
            const z = positions[i + positionOffset + 2];
            const majorX = Math.fround(x);
            const minorX = x - majorX;
            const majorY = Math.fround(y);
            const minorY = y - majorY;
            const majorZ = Math.fround(z);
            const minorZ = z - majorZ;
            // insert values in interleaved buffer
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for (let j = positionOffset + 3; j < stride; j++) {
                newPositions.push(positions[i + j]);
            }
        }
        return newPositions;
    }
    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;
    /**
     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].
     *
     * @param object - [[HighPrecisionObject]] which position attribute will be set.
     * @param positions - Array of positions.
     */
    function setPositions(object, positions) {
        const attributes = createAttributes(positions);
        object.bufferGeometry.setAttribute("position", attributes.positionHigh);
        object.bufferGeometry.setAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    }
    HighPrecisionUtils.setPositions = setPositions;
    /**
     * Convert positions from `Array<Vector3>` to `Array<number>`.
     *
     * @param positions - Array of positions.
     */
    function convertPositions(positions) {
        if (positions.length <= 0) {
            return { positions: [] };
        }
        const v = positions[0];
        if (v === undefined || v === null) {
            throw Error("Empty element in positions");
        }
        const vAny = v;
        if (vAny.y === undefined && vAny.z === undefined) {
            return { positions: positions };
        }
        const returnPositions = new Array();
        positions.forEach(vec => {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return { positions: returnPositions };
    }
    HighPrecisionUtils.convertPositions = convertPositions;
    /**
     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.
     *
     * @param linePositions - Array of 2D/3D positions.
     * @param params - Parameters used to configure the created [[HighPrecisionObject]].
     */
    function createLine(linePositions, params) {
        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;
        const addCircles = params.addCircles !== undefined ? params.addCircles : false;
        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;
        const positions = [];
        const indices = [];
        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        const hpLineGeometry = new three_1.BufferGeometry();
        const hpPositions = addInterleavedAttributes3(positions, 3);
        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);
        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);
        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.setAttribute("position", positionAttribute);
        hpLineGeometry.setAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));
        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);
        const lineObject = wireFrame
            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)
            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    }
    HighPrecisionUtils.createLine = createLine;
    /**
     * Creates a group of [[HighPrecisionPoints]].
     *
     * @param pointPositions - Array of 2D/3D positions.
     * @param materialParameters - Parameters used to configure the material used to render the
     * created [[HighPrecisionPoints]].
     */
    function createPoints(pointPositions, materialParameters) {
        const indices = [];
        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface
        for (let i = 0; i < pointPositions.length; i++) {
            indices.push(indices.length / 3);
        }
        const hpPointsGeometry = new three_1.BufferGeometry();
        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)
            ? materialParameters
            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);
        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    }
    HighPrecisionUtils.createPoints = createPoints;
})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));
//# sourceMappingURL=HighPrecisionUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/Lines.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/Lines.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineGroup = exports.createSimpleLineGeometry = exports.createLineGeometry = exports.LineGeometry = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
// Preallocate temp variables used during line generation.
const tmpV = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpTangent0 = new THREE.Vector3();
const tmpTangent1 = new THREE.Vector3();
const tmpBitangent = new THREE.Vector3();
const SEGMENT_OFFSET = 0.1;
/**
 * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].
 */
/** Base line vertex attributes. */
const LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        // The "extrusionCoord" is a vec4 which represents:
        // xy: Extrusion coordinates
        // sign(xy): Extrusion direction
        // z: Line length
        { name: "extrusionCoord", itemSize: 3, offset: 0 },
        { name: "position", itemSize: 3, offset: 3 },
        { name: "tangent", itemSize: 3, offset: 6 },
        { name: "bitangent", itemSize: 4, offset: 9 }
    ],
    stride: 13
};
/** Optional normal and uv coordinates. */
const NORMAL_UV_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "uv", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },
        { name: "normal", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }
    ],
    stride: 5
};
/** Base line vertex attributes plus normals and uv coordinates. */
const LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Declares all the vertex attributes used for rendering a line using the
 * [[HighPrecisionLineMaterial]].
 */
const HP_LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "extrusionCoord", itemSize: 2, offset: 0 },
        { name: "position", itemSize: 3, offset: 2 },
        { name: "positionLow", itemSize: 3, offset: 5 },
        { name: "tangent", itemSize: 3, offset: 8 },
        { name: "bitangent", itemSize: 4, offset: 11 }
    ],
    stride: 15
};
/** High precision line vertex attributes plus normals and uv coordinates. */
const HP_LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [
        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,
        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes
    ],
    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Class that holds the vertex and index attributes for a [[Lines]] object.
 */
class LineGeometry {
    constructor() {
        this.vertices = [];
        this.vertexColors = [];
        this.indices = [];
    }
}
exports.LineGeometry = LineGeometry;
function getVertexDescriptor(hasNormalsAndUvs, highPrecision) {
    if (highPrecision) {
        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;
    }
    else {
        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;
    }
}
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param center - Center of the polyline.
 * @param polyline - Array of `numbers` describing a polyline.
 * @param offsets - Array of `numbers` representing line segment offsets.
 * @param uvs - Array of `numbers` representing texture coordinates.
 * @param colors - Array of `numbers` describing a polyline's colors.
 * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.
 * @param highPrecision - If `true` will create high-precision vertex information.
 */
function createLineGeometry(center, polyline, projection, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {
    if (polyline.length === 0) {
        return geometry;
    }
    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;
    const pointCount = polyline.length / 3;
    const segments = new Array(pointCount);
    const tangents = new Array(polyline.length - 3);
    const baseVertex = geometry.vertices.length / stride;
    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;
    const hasTexCoords = uvs !== undefined && uvs.length > 0;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);
    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);
    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);
    // Compute segments and tangents.
    let sum = SEGMENT_OFFSET;
    segments[0] = sum;
    for (let i = 0; i < pointCount - 1; ++i) {
        let sqrLength = 0;
        for (let j = 0; j < 3; ++j) {
            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];
            tangents[i * 3 + j] = d;
            sqrLength += d * d;
        }
        const len = Math.sqrt(sqrLength);
        sum = sum + len;
        segments[i + 1] = sum;
    }
    const lineCoverage = hasSegmentOffsets
        ? Math.abs(offsets[offsets.length - 1] - offsets[0])
        : 1.0;
    const lineLength = segments[segments.length - 1] / lineCoverage;
    // Override the segments if offsets are explicitly provided.
    if (hasSegmentOffsets) {
        for (let i = 0; i < pointCount; ++i) {
            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;
        }
    }
    // Check if we're working with a closed line.
    let isClosed = true;
    for (let j = 0; j < 3; ++j) {
        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];
    }
    const tmpVertices = [];
    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {
        tmpVertices.length = 0;
        // Store the segment and extrusionCoord attributes.
        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);
        tmpVertices.push(segment, extrusionCoord * 1, lineLength);
        // Store the position attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            if (!highPrecision) {
                geometry.vertices.push(polyline[i * 3 + j]);
                tmpVertices.push(polyline[i * 3 + j]);
            }
            else {
                const highComp = Math.fround(polyline[i * 3 + j]);
                const lowComp = polyline[i * 3 + j] - highComp;
                geometry.vertices.push(highComp, lowComp);
                tmpVertices.push(highComp, lowComp);
            }
            tmpNormal.setComponent(j, polyline[i * 3 + j]);
        }
        // Store the bitangent attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            tmpTangent0.setComponent(j, tangents[T1 + j]);
            tmpTangent1.setComponent(j, tangents[T2 + j]);
        }
        tmpTangent0.normalize();
        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpNormal.add(center); // tmpNormal contains world position
        projection.surfaceNormal(tmpNormal, tmpNormal);
        const angle = computeBitangent(tmpNormal, tmpTangent0, tmpTangent1.normalize(), tmpBitangent);
        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        if (hasTexCoords) {
            // uvs
            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            // normals
            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
        }
        geometry.vertices.push(...tmpVertices);
        // Add vertex colors (if supplied).
        if (vertexColors) {
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
        }
    };
    for (let i = 0; i < pointCount; ++i) {
        // Retrieve the per-point tangents.
        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;
        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);
        // Process v0 and v1.
        if (i > 0) {
            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);
        }
        // Process v2 and v3.
        if (i + 1 < pointCount) {
            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);
        }
    }
    // Store the triangle indices in the final index buffer.
    for (let i = 0; i < pointCount - 1; ++i) {
        const base = baseVertex + i * 4;
        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);
    }
    return geometry;
}
exports.createLineGeometry = createLineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param polyline - Array of `numbers` describing a polyline.
 * @param colors - Array of `numbers` describing a polyline's colors.
 * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.
 */
function createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {
    if (polyline.length === 0) {
        return geometry;
    }
    const pointCount = polyline.length / 3;
    let index = geometry.vertices.length / 3;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    for (let i = 0; i < pointCount; ++i, index++) {
        if (i > 0) {
            geometry.indices.push(index);
        }
        if (i < pointCount - 1) {
            geometry.indices.push(index);
        }
        for (let j = 0; j < 3; ++j) {
            geometry.vertices.push(polyline[i * 3 + j]);
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3 + j]);
            }
        }
    }
    return geometry;
}
exports.createSimpleLineGeometry = createSimpleLineGeometry;
/**
 * Class used to render groups (or batches) of width-variable lines (in the same tile).
 */
class LineGroup {
    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        this.hasNormalsAndUvs = hasNormalsAndUvs;
        this.highPrecision = highPrecision;
        this.isSimple = isSimple;
        this.m_geometry = new LineGeometry();
    }
    /**
     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.
     *
     * @param vertices - Array of vertex attributes.
     * @param colors - Array of vertex colors.
     * @param indices - Array of vertex indices.
     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.
     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.
     * @param highPrecision - If `true` will create high-precision vertex information.
     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.
     */
    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        if (isSimple) {
            geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
        else {
            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);
            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);
            vertexDescriptor.attributes.forEach(descr => {
                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);
                geometry.setAttribute(descr.name, attribute);
            });
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
    }
    /**
     * Clears the list of line strips.
     */
    clear() {
        this.m_geometry.vertices = [];
        this.m_geometry.vertexColors = [];
        this.m_geometry.indices = [];
    }
    /**
     * Add the given points to this line group.
     *
     * @param center - World center of the provided points.
     * @param points - Sequence of (x,y,z) coordinates.
     * @param offsets - Sequence of line segment offsets.
     * @param uvs - Sequence of (u,v) texture coordinates.
     * @param colors - Sequence of (r,g,b) color components.
     */
    add(center, points, projection, offsets, uvs, colors) {
        if (!this.isSimple) {
            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);
            createLineGeometry(center, points, projection, offsets, uvs, colors, this.m_geometry, this.highPrecision);
        }
        else {
            createSimpleLineGeometry(points, colors, this.m_geometry);
        }
        return this;
    }
    /**
     * Returns the list of vertices.
     */
    get vertices() {
        return this.m_geometry.vertices;
    }
    /**
     * Returns the list of vertex colors.
     */
    get vertexColors() {
        return this.m_geometry.vertexColors;
    }
    /**
     * Returns the list of indices.
     */
    get indices() {
        return this.m_geometry.indices;
    }
    /**
     * Returns the list of [[VertexAttributeDescriptor]]s.
     */
    get vertexAttributes() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;
    }
    /**
     * Returns the vertex attribute stride.
     */
    get stride() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;
    }
    /**
     * Creates a three.js geometry.
     */
    createGeometry(geometry) {
        if (geometry === undefined) {
            geometry = new THREE.BufferGeometry();
        }
        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);
    }
}
exports.LineGroup = LineGroup;
function computeBitangent(n, t0, t1, bt) {
    let angle = 0;
    if (!t0.equals(t1)) {
        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));
        if (Number.isNaN(angle)) {
            angle = 0;
        }
    }
    bt.copy(t0)
        .add(t1)
        .normalize()
        .cross(n)
        .normalize();
    return angle;
}
//# sourceMappingURL=Lines.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/TriangulateLines.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/TriangulateLines.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructLineWidth = exports.reconstructLine = exports.triangulateLine = exports.numCirclePoints = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const UNIT_Z = new THREE.Vector3(0, 0, 1);
const POINTS = [0, 1, 2, 1, 3, 2];
const BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
const SECTORS_IN_CIRCLE = 8;
const STEP = Math.PI / SECTORS_IN_CIRCLE;
/**
 * Adds a half-circle geometry to original line
 *
 * @param x - The line end X (used as circle center X)
 * @param y - The line end Y (used as circle center Y)
 * @param lineAngle - The cap incline angle
 * @param radius - The cap (circle) radius
 * @param vertices - The input vertex buffer (cap vertices are added there)
 * @param indices - The input index buffer (cap indices are is added there)
 */
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    const baseVertex = vertices.length / 3;
    // Add cap center to vertices directly (it doesn't need rotation)
    vertices.push(x, y, 0);
    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);
    }
}
/**
 * Returns the number of points in circle used for caps.
 *
 * @param lineWidth - Width of line.
 */
// tslint:disable-next-line:no-unused-variable
function numCirclePoints(lineWidth) {
    return SECTORS_IN_CIRCLE + 1;
}
exports.numCirclePoints = numCirclePoints;
/**
 * Create a triangle mesh from the given polyline.
 *
 * @param points - Sequence of (x,y,z) coordinates.
 * @param width - The width of the extruded line.
 * @param vertices - The output vertex buffer.
 * @param indices - The output index buffer.
 * @param startWithCircle - `true` if the line should start will a circle.
 * @param endWithCircle - `true` if the line should end with a circle.
 */
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
    if (points.length < 3) {
        return;
    }
    // This vector is used for computing cap angle
    const angleVec = new THREE.Vector2();
    if (startWithCircle) {
        // Define lineAngle as (direction - origin) vector angle to X axis
        const lineAngle = points.length !== 3
            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()
            : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    const baseVertex = vertices.length / 3;
    // bt = Bitangent (i.e. extrusion vector)
    const prevBt = new THREE.Vector3();
    const p = new THREE.Vector3(); // current point
    const n = new THREE.Vector3(); // next point
    const bt = new THREE.Vector3();
    const averageBt = new THREE.Vector3();
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const p3 = new THREE.Vector3();
    const N = points.length / 3;
    let vertexOffset = 0;
    for (let i = 0; i < N; ++i) {
        let useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n)
                .sub(p)
                .normalize()
                .cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(-inclineWidth)
                        .add(p);
                    p1.copy(prevBt)
                        .multiplyScalar(width)
                        .add(p);
                    // p2 is used for "miter" connections
                    p2.copy(bt)
                        .add(prevBt)
                        .normalize()
                        .multiplyScalar(inclineWidth)
                        .add(p);
                    p3.copy(bt)
                        .multiplyScalar(width)
                        .add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            }
            else {
                p0.copy(averageBt)
                    .multiplyScalar(-width)
                    .add(p);
                p1.copy(averageBt)
                    .multiplyScalar(width)
                    .add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        }
        else {
            p0.copy(prevBt)
                .multiplyScalar(-width)
                .add(p);
            p1.copy(prevBt)
                .multiplyScalar(width)
                .add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        const lineAngle = points.length !== 2
            ? angleVec
                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])
                .angle()
            : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
    }
}
exports.triangulateLine = triangulateLine;
/**
 * Reconstruct the original points of a line from the vertices of the triangulated line.
 *
 * @param inBuffer - Buffer with vertices.
 * @param startOffset - Start index, will differ from `0` if the line has caps.
 * @returns Buffer containing the original points of the triangulated line.
 */
function reconstructLine(inBuffer, startOffset) {
    const outBuffer = new Float32Array(inBuffer.length / 2);
    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {
        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;
        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;
        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;
    }
    return outBuffer;
}
exports.reconstructLine = reconstructLine;
/**
 * Extract the line width from a triangulated line.
 *
 * @param inBuffer - Array of vertex elements of a triangulated line.
 * @param startIndex - Start index, will differ from `0` if the line has caps.
 */
function reconstructLineWidth(inBuffer, startIndex) {
    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
exports.reconstructLineWidth = reconstructLineWidth;
//# sourceMappingURL=TriangulateLines.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * LRU cache.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/LRUCache */ "./node_modules/@here/harp-lrucache/lib/LRUCache.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/lib/LRUCache.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/lib/LRUCache.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LRUCache = exports.Entry = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/** @hidden */
class Entry {
    constructor(key, value, size, newer, older) {
        this.key = key;
        this.value = value;
        this.size = size;
        this.newer = newer;
        this.older = older;
    }
}
exports.Entry = Entry;
/**
 * Fixed size cache that evicts its entries in least-recently-used order when it overflows.
 * Modeled after standard JavaScript `Map` otherwise.
 */
class LRUCache {
    /**
     * Creates a new instance of `LRUCache`.
     *
     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached
     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if
     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum
     * number of elements stored.
     *
     * @param cacheCapacity - Number used to configure the maximum cache size, may express
     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].
     * @param sizeFunction - A function determining the size per element.
     */
    constructor(cacheCapacity, sizeFunction = () => 1) {
        this.m_size = 0;
        /**
         * The internal map object that keeps the key-value pairs and their order.
         */
        this.m_map = new Map();
        /**
         * The newest entry, i.e. the most recently used item.
         */
        this.m_newest = null;
        /**
         * The oldest entry, i.e. the least recently used item.
         */
        this.m_oldest = null;
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    /**
     * Iterates over all items from the most recently used item to the least recently used one.
     *
     * **Note**: Results are undefined if the entire cache is modified during iteration. You may
     * although modify the current element in [[callbackfn]] function.
     *
     * @param callbackfn - The callback to call for each item.
     * @param thisArg - Optional this argument for the callback.
     */
    forEach(callbackfn, thisArg) {
        let entry = this.m_newest;
        while (entry !== null) {
            const older = entry.older;
            callbackfn.call(thisArg, entry.value, entry.key, this);
            entry = older;
        }
    }
    /**
     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.
     *
     * @returns The size of the cache.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache
     * can contain or the total amount of memory that may be consumed by cache if element size
     * function was specified in cache c-tor.
     *
     * @returns The capacity of the cache.
     */
    get capacity() {
        return this.m_capacity;
    }
    /**
     * @deprecated - DO NOT USE. Will be removed in future versions.
     *
     * Returns the internal map object that keeps the key-value pairs and their order.
     *
     * @returns The internal map object.
     */
    get map() {
        // ### TODO - remove me. Cache must not expose its internal object,
        // modifications to it are fatal for the internal state machine.
        return this.m_map;
    }
    /**
     * Returns the newest entry in the cache.
     *
     * @returns Newest entry in the cache.
     */
    get newest() {
        return this.m_newest;
    }
    /**
     * Returns the oldest entry in the cache.
     *
     * Note: Does not promote the oldest item as most recently used item.
     *
     * @returns Oldest entry in the cache.
     */
    get oldest() {
        return this.m_oldest;
    }
    /**
     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,
     * all items will be evicted until the cache shrinks to `newCapacity`.
     *
     * @param newCapacity - The new capacity of this cache.
     */
    setCapacity(newCapacity) {
        this.m_capacity = newCapacity;
        this.evict();
    }
    /**
     * Resets the cache capacity and function used to measure the element size.
     *
     * @param newCapacity - The new capacity masured in units returned from [[sizeMeasure]] funtion.
     * @param sizeMeasure - Function that defines the size of element, if you want to measure
     * number of elements only always return 1 from this function (default), you may also
     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.
     */
    setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {
        this.m_capacity = newCapacity;
        this.m_sizeFunction = sizeMeasure;
        this.shrinkToCapacity();
    }
    /**
     * Updates the size of all elements in this cache. If their aggregated size is larger than the
     * capacity, items will be evicted until the cache shrinks to fit the capacity.
     */
    shrinkToCapacity() {
        let size = 0;
        const sizeFunction = this.m_sizeFunction;
        let entry = this.m_newest;
        while (entry !== null) {
            const entrySize = sizeFunction(entry.value);
            entry.size = entrySize;
            size += entrySize;
            entry = entry.older;
        }
        this.m_size = size;
        this.evict();
    }
    /**
     * Inserts or updates a key/value pair in the cache.
     *
     * If the key already existed in the cache, it will be updated and promoted to the most recently
     * used item.
     *
     * If the key didn't exist in the cache, it will be inserted as most recently used item. An
     * eviction of the least recently used item takes place if the cache exceeded its capacity.
     *
     * @param key - The key for the key-value pair to insert or update.
     * @param value - The value for the key-value pair to insert or update.
     */
    set(key, value) {
        const valueSize = this.m_sizeFunction(value);
        let entry = this.m_map.get(key);
        if (entry !== undefined) {
            this.m_size = this.m_size - entry.size + valueSize;
            entry.value = value;
            entry.size = valueSize;
            this.promoteEntry(entry);
            this.evict();
        }
        else {
            if (valueSize > this.m_capacity) {
                return; // single item too big to cache
            }
            entry = new Entry(key, value, valueSize, null, null);
            if (this.m_map.size === 0) {
                this.m_newest = this.m_oldest = entry;
            }
            else {
                harp_utils_1.assert(this.m_newest !== null);
                const newest = this.m_newest;
                entry.older = this.m_newest;
                newest.newer = entry;
                this.m_newest = entry;
            }
            this.m_map.set(key, entry);
            this.m_size += valueSize;
            this.evict();
        }
    }
    /**
     * Looks up key in the cache and returns the associated value.
     *
     * @param key - The key to look up.
     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.
     */
    get(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        this.promoteEntry(entry);
        return entry.value;
    }
    /**
     * Test if a key/value pair is in the cache.
     *
     * @param key - The key to look up.
     * @returns `true` if the key-value pair is in the cache, `false` otherwise.
     */
    has(key) {
        return this.m_map.has(key);
    }
    /**
     * Clears the cache and removes all stored key-value pairs.
     *
     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the
     * eviction callback.
     */
    clear() {
        this.m_newest = this.m_oldest = null;
        this.m_size = 0;
        this.m_map.clear();
    }
    /**
     * Evicts all items from the cache, calling the eviction callback on each item.
     *
     * Use [[clear]] to remove all items without calling the eviction callback.
     */
    evictAll() {
        const cb = this.evictionCallback;
        if (cb !== undefined) {
            this.forEach((value, key) => cb(key, value));
        }
        this.clear();
    }
    /**
     * Evict selected elements from the cache using [[selector]] function.
     *
     * @param selector - The function for selecting elements for eviction.
     * @param thisArg - Optional _this_ object reference.
     */
    evictSelected(selector, thisArg) {
        const cb = this.evictionCallback;
        let entry = this.m_newest;
        while (entry !== null) {
            const entryOlder = entry.older;
            if (selector.call(thisArg, entry.value, entry.key)) {
                if (cb !== undefined) {
                    cb(entry.key, entry.value);
                }
                this.deleteEntry(entry);
                this.m_map.delete(entry.key);
            }
            entry = entryOlder;
        }
    }
    /**
     * Explicitly removes a key-value pair from the cache.
     *
     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.
     *
     * @param key - The key of the key-value pair to delete.
     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.
     */
    delete(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return false;
        }
        this.deleteEntry(entry);
        return this.m_map.delete(key);
    }
    evict() {
        while (this.m_oldest !== null && this.m_size > this.m_capacity) {
            const evicted = this.evictOldest();
            if (evicted === undefined) {
                return;
            }
        }
    }
    evictOldest() {
        harp_utils_1.assert(this.m_oldest !== null);
        const oldest = this.m_oldest;
        harp_utils_1.assert(oldest.older === null);
        let itemToRemove = oldest;
        if (this.canEvict !== undefined) {
            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
                if (itemToRemove.newer === null) {
                    return undefined;
                }
                itemToRemove = itemToRemove.newer;
            }
        }
        if (itemToRemove === oldest) {
            this.m_oldest = itemToRemove.newer;
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = null;
            }
        }
        else {
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = itemToRemove.older;
                if (itemToRemove.older !== null) {
                    itemToRemove.older.newer = itemToRemove.newer;
                }
            }
            else {
                return undefined;
            }
        }
        const isOk = this.m_map.delete(itemToRemove.key);
        harp_utils_1.assert(isOk === true);
        if (isOk && this.evictionCallback !== undefined) {
            this.evictionCallback(itemToRemove.key, itemToRemove.value);
        }
        this.m_size -= itemToRemove.size;
        return itemToRemove;
    }
    deleteEntry(entry) {
        if (entry === this.m_newest) {
            this.m_newest = entry.older;
        }
        else if (entry.newer) {
            entry.newer.older = entry.older;
        }
        else {
            harp_utils_1.assert(false);
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        else if (entry.older) {
            entry.older.newer = entry.newer;
        }
        else {
            harp_utils_1.assert(false);
        }
        this.m_size -= entry.size;
    }
    promoteEntry(entry) {
        if (entry === this.m_newest) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        if (entry.newer) {
            harp_utils_1.assert(entry.newer.older === entry);
            entry.newer.older = entry.older;
        }
        if (entry.older) {
            harp_utils_1.assert(entry.older.newer === entry);
            entry.older.newer = entry.newer;
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        // re-link ourselves
        entry.newer = null;
        entry.older = this.m_newest;
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newest !== null);
        const newest = this.m_newest;
        harp_utils_1.assert(newest.newer === null);
        newest.newer = entry;
        this.m_newest = entry;
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=LRUCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Camera controller which implements a common default set of camera functionality in a map context.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/MapControls */ "./node_modules/@here/harp-map-controls/lib/MapControls.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapControlsUI */ "./node_modules/@here/harp-map-controls/lib/MapControlsUI.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/LongPressHandler */ "./node_modules/@here/harp-map-controls/lib/LongPressHandler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Utils */ "./node_modules/@here/harp-map-controls/lib/Utils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapAnimations */ "./node_modules/@here/harp-map-controls/lib/MapAnimations.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/CameraKeyTrackAnimation */ "./node_modules/@here/harp-map-controls/lib/CameraKeyTrackAnimation.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/CameraAnimationBuilder */ "./node_modules/@here/harp-map-controls/lib/CameraAnimationBuilder.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/CameraAnimationBuilder.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/CameraAnimationBuilder.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraAnimationBuilder = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const CameraKeyTrackAnimation_1 = __webpack_require__(/*! ./CameraKeyTrackAnimation */ "./node_modules/@here/harp-map-controls/lib/CameraKeyTrackAnimation.js");
/**
 * A Utility class for the creation of Camera Animations
 * @beta
 */
class CameraAnimationBuilder {
    /**
     * Get the current [[LookAtParams]] from [[MapView]]
     * @beta
     *
     * @param mapView - The MapView
     */
    static getLookAtFromView(mapView) {
        return {
            target: mapView.target,
            heading: mapView.heading,
            tilt: mapView.tilt,
            distance: mapView.targetDistance
        };
    }
    /**
     * Appends a [[ControlPoint]] to [[CameraKeyTrackAnimationOptions]]
     * @beta
     *
     * @param options - The [[CameraKeyTrackAnimationOptions]] that the [[ControlPoint]] should be
     * appended to
     * @param point - The [[ControlPoint]] to append.
     * @param appendTime - The time it should take from the former end of the animation to the
     * appended [[ControlPoint]] in seconds, per default takes the controlpoints timestamp
     */
    static appendControlPoint(options, point, appendTime) {
        appendTime = appendTime !== null && appendTime !== void 0 ? appendTime : 10;
        if (options.controlPoints.length > 0 &&
            (point.timestamp === undefined ||
                point.timestamp <=
                    options.controlPoints[options.controlPoints.length - 1].timestamp)) {
            point.timestamp =
                options.controlPoints[options.controlPoints.length - 1].timestamp + appendTime;
        }
        options.controlPoints.push(point);
    }
    /**
     * Adds a [[ControlPoint]] to the beginning of an [[CameraKeyTrackAnimationOptions]]
     * @beta
     *
     * @param options -
     * @param point -
     * @param prependTime - The time the animation from the inserted key to the next should take,
     *  in seconds, @default 10 seconds
     */
    static prependControlPoint(options, point, prependTime) {
        prependTime = prependTime !== undefined ? prependTime : 10;
        for (const controlPoint of options.controlPoints) {
            controlPoint.timestamp += prependTime;
        }
        point.timestamp = 0;
        options.controlPoints.unshift(point);
    }
    /**
     *
     * Creates Options for a Bow Animation from the start to the target [[ControlPoint]]
     * @beta
     *
     * @param mapView -
     * @param startControlPoint -
     * @param targetControlPoint -
     * @param altitude - The maximal altitude the bow should have, defaults to twice the start to
     * target distance
     * @param duration - The duration of the Animation in seconds, @default 10
     */
    static createBowFlyToOptions(mapView, startControlPoint, targetControlPoint, altitude, duration = 10) {
        const controlPoints = [startControlPoint];
        const startWorldTarget = new THREE.Vector3();
        mapView.projection.projectPoint(startControlPoint.target, startWorldTarget);
        let maxAltitude = altitude ||
            2 *
                startWorldTarget.distanceTo(mapView.projection.projectPoint(targetControlPoint.target));
        // use a minimum altitude of the sum of distances to
        // actually create a bow for small distance CP
        maxAltitude = Math.max(startControlPoint.distance + targetControlPoint.distance, maxAltitude);
        //calculate two ControlPoints on the maximal altitude in between the start and target points
        const midCoord0 = this.geoCoordLerp(startControlPoint.target, targetControlPoint.target, 0.25);
        const midPoint0 = new CameraKeyTrackAnimation_1.ControlPoint({
            target: midCoord0,
            distance: maxAltitude,
            timestamp: duration / 3,
            tilt: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.25),
            heading: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.25)
        });
        controlPoints.push(midPoint0);
        const midCoord1 = this.geoCoordLerp(startControlPoint.target, targetControlPoint.target, 0.75);
        const midPoint1 = new CameraKeyTrackAnimation_1.ControlPoint({
            target: midCoord1,
            distance: maxAltitude,
            timestamp: (duration / 3) * 2,
            tilt: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.75),
            heading: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.75)
        });
        controlPoints.push(midPoint1);
        targetControlPoint.timestamp = duration;
        controlPoints.push(targetControlPoint);
        return { controlPoints };
    }
    /**
     * Creates [[CameraKeyTrackAnimationOptions]] for an Orbit Animation
     * @beta
     *
     * @param startControlPoint -
     * @param duration -
     */
    static createOrbitOptions(startControlPoint, duration = 10) {
        const amountOfKeys = 4;
        const controlPoints = [startControlPoint];
        const steps = amountOfKeys - 1;
        const headingStep = 360 / steps;
        const timeStep = duration / steps;
        for (let n = 1; n < amountOfKeys; n++) {
            const prev = controlPoints[n - 1];
            controlPoints.push(Object.assign(Object.assign({}, prev), { heading: prev.heading - headingStep, timestamp: prev.timestamp + timeStep }));
        }
        return { controlPoints };
    }
    static geoCoordLerp(g0, g1, factor) {
        const v0 = new THREE.Vector3(g0.lat, g0.longitude, g0.altitude);
        const v1 = new THREE.Vector3(g1.lat, g1.longitude, g1.altitude);
        v0.lerp(v1, factor);
        return new harp_geoutils_1.GeoCoordinates(v0.x, v0.y, v0.z);
    }
}
exports.CameraAnimationBuilder = CameraAnimationBuilder;
//# sourceMappingURL=CameraAnimationBuilder.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/CameraKeyTrackAnimation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/CameraKeyTrackAnimation.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraKeyTrackAnimation = exports.ControlPoint = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const logger = harp_utils_1.LoggerManager.instance.create("CameraKeyTrackAnimation");
/**
 * A ControlPoint used to defined the Track of the [[CameraKeyTrackAnimation]]
 * @beta
 */
class ControlPoint {
    constructor(options) {
        var _a, _b, _c, _d;
        /**
         * The time, when this ControlPoint should be reached in the animation flow, in seconds.
         */
        this.timestamp = 0;
        this.timestamp = options.timestamp;
        this.target = options.target
            ? harp_geoutils_1.GeoCoordinates.fromObject(options.target)
            : new harp_geoutils_1.GeoCoordinates(0, 0);
        this.tilt = (_a = options.tilt) !== null && _a !== void 0 ? _a : 0;
        this.heading = (_b = options.heading) !== null && _b !== void 0 ? _b : 0;
        this.distance = (_c = options.distance) !== null && _c !== void 0 ? _c : 0;
        this.name = (_d = options.name) !== null && _d !== void 0 ? _d : Date.now().toString();
    }
}
exports.ControlPoint = ControlPoint;
/**
 * The KeyFrameTracks from THREE.js used in this animation are directly bound to an
 * [[THREE.Object3D]] to manipulate its properties.
 * Therefore this Dummy object is used, the animation manipulates its properties, which then are
 * used to set the actual paramters of [[MapView]]
 */
class AnimationDummy extends THREE.Object3D {
    constructor(name) {
        super();
        this.distance = 0;
        this.name = name;
    }
}
/**
 * A [[CameraAnimation]] along of a set of [[ControlPoint]]s
 * @beta
 */
class CameraKeyTrackAnimation {
    constructor(m_mapView, m_options) {
        var _a, _b, _c;
        this.m_mapView = m_mapView;
        this.m_options = m_options;
        this.m_dummy = new AnimationDummy("dummy");
        this.m_azimuthAxis = new THREE.Vector3(0, 0, 1);
        this.m_altitudeAxis = new THREE.Vector3(1, 0, 0);
        this.m_running = false;
        this.m_lastFrameTime = 0;
        const interpolation = this.m_options.interpolation !== undefined
            ? this.m_options.interpolation
            : THREE.InterpolateSmooth;
        this.m_options.loop = (_a = this.m_options.loop) !== null && _a !== void 0 ? _a : THREE.LoopOnce;
        this.m_options.repetitions = (_b = this.m_options.repetitions) !== null && _b !== void 0 ? _b : 1;
        this.m_options.rotateOnlyClockwise = (_c = this.m_options.rotateOnlyClockwise) !== null && _c !== void 0 ? _c : true;
        this.m_name = this.m_options.name || "CameraKeyTrackAnimation" + Date.now();
        const timestamps = this.m_options.controlPoints.map(point => {
            return point.timestamp;
        });
        const posValues = [];
        const rotValues = [];
        this.m_options.controlPoints.map(point => {
            const worldPos = this.m_mapView.projection.projectPoint(point.target);
            posValues.push(worldPos.x);
            posValues.push(worldPos.y);
            posValues.push(worldPos.z);
            const rot = new THREE.Quaternion();
            rot.setFromAxisAngle(this.m_azimuthAxis, THREE.MathUtils.degToRad(point.heading));
            rot.multiply(new THREE.Quaternion().setFromAxisAngle(this.m_altitudeAxis, THREE.MathUtils.degToRad(point.tilt)));
            rotValues.push(rot.x);
            rotValues.push(rot.y);
            rotValues.push(rot.z);
            rotValues.push(rot.w);
        });
        const lookAtTrack = new THREE.VectorKeyframeTrack(".position", timestamps, posValues, interpolation);
        const rotationTrack = new THREE.QuaternionKeyframeTrack(".quaternion", timestamps, rotValues, interpolation);
        const distanceTrack = new THREE.NumberKeyframeTrack(".distance", timestamps, this.m_options.controlPoints.map(point => {
            return point.distance;
        }), interpolation);
        this.m_animationClip = new THREE.AnimationClip("cameraflyoveranimation", -1, [
            lookAtTrack,
            rotationTrack,
            distanceTrack
        ]);
        if (!this.m_animationClip.validate()) {
            logger.error("Review the entered controlpoints for: ", this.m_name, ", The Animation was provided with invalid track data");
        }
        this.m_animationClip.resetDuration();
        this.m_animationClip.trim();
        this.m_animationMixer = new THREE.AnimationMixer(this.m_dummy);
        this.m_animationAction = this.m_animationMixer.clipAction(this.m_animationClip);
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
        this.m_animationAction.clampWhenFinished = true;
        this.m_animateCb = this.animate.bind(this);
        this.m_animationMixer.addEventListener("finished", this.stop.bind(this));
    }
    set loop(value) {
        this.m_options.loop = value;
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
    }
    set repetitions(value) {
        this.m_options.repetitions = value;
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
    }
    set rotateOnlyClockwise(value) {
        this.m_options.rotateOnlyClockwise = value;
    }
    /**
     * Start the Animation
     */
    start(time, onFinished) {
        if (this.m_running) {
            this.stop();
        }
        this.m_onFinished = onFinished;
        this.m_animationAction.play();
        this.m_lastFrameTime = Date.now();
        this.m_mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_animateCb);
        this.m_mapView.beginAnimation();
        this.m_running = true;
    }
    /**
     * Stop the Animation
     */
    stop() {
        this.m_mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_animateCb);
        this.m_mapView.endAnimation();
        if (this.m_onFinished !== undefined) {
            this.m_onFinished();
        }
        this.m_running = false;
    }
    isRunning() {
        return this.m_running;
    }
    updateCameraFromDummy() {
        let tilt = THREE.MathUtils.radToDeg(this.m_azimuthAxis
            .clone()
            .applyQuaternion(this.m_dummy.quaternion)
            .angleTo(this.m_azimuthAxis));
        tilt = THREE.MathUtils.clamp(tilt, 0, harp_mapview_1.MapViewUtils.MAX_TILT_DEG);
        const vec0 = this.m_altitudeAxis.clone().applyQuaternion(this.m_dummy.quaternion);
        let angle = vec0.angleTo(this.m_altitudeAxis);
        if (this.m_options.rotateOnlyClockwise) {
            const direction = this.m_azimuthAxis.dot(vec0.normalize().cross(this.m_altitudeAxis));
            if (direction >= 0) {
                angle = 2 * Math.PI - angle;
            }
        }
        const heading = THREE.MathUtils.radToDeg(angle);
        const target = this.m_mapView.projection.unprojectPoint(this.m_dummy.position);
        const distance = Math.max(0, this.m_dummy.distance);
        if (isNaN(tilt) || isNaN(heading) || isNaN(distance) || !target.isValid()) {
            logger.error("Cannot update due to invalid data", tilt, heading, distance, target);
        }
        this.m_mapView.lookAt({ target, distance, tilt, heading });
    }
    animate(event) {
        const deltaTime = (Date.now() - this.m_lastFrameTime) / 1000;
        this.m_animationMixer.update(deltaTime);
        this.m_lastFrameTime = Date.now();
        this.updateCameraFromDummy();
    }
}
exports.CameraKeyTrackAnimation = CameraKeyTrackAnimation;
//# sourceMappingURL=CameraKeyTrackAnimation.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/LongPressHandler.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/LongPressHandler.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LongPressHandler = void 0;
/**
 * Class that can be used to track long presses on an HTML Element. A long press is a press that
 * lasts a minimum duration (see the [[timeout]] member) while the mouse is not moved more than a
 * certain threshold (see the [[moveThreshold]] member).
 */
class LongPressHandler {
    /**
     * Default constructor.
     *
     * @param element - The HTML element to track.
     * @param onLongPress - The callback to call when a long press occurred.
     */
    constructor(element, onLongPress) {
        this.element = element;
        this.onLongPress = onLongPress;
        /**
         * How long to wait (in ms) until a press is considered a long press.
         */
        this.timeout = 500;
        /**
         * If the cursor moves more than the given number of pixels, it is not a long-press, but a pan.
         */
        this.moveThreshold = 5;
        /**
         * Button id that should be handled by this event.
         */
        this.buttonId = 0;
        this.m_mouseDownEvent = undefined;
        this.m_timerId = undefined;
        this.m_moveHandlerRegistered = false;
        // workaround - need to bind 'this' for our dynamic mouse move handler
        this.m_boundMouseMoveHandler = this.onMouseMove.bind(this);
        this.m_boundMouseDownHandler = this.onMousedown.bind(this);
        this.m_boundMouseUpHandler = this.onMouseup.bind(this);
        this.element.addEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.addEventListener("mouseup", this.m_boundMouseUpHandler);
    }
    /**
     * Removes all events listeners. No more events will be sent.
     */
    dispose() {
        this.cancel();
        this.element.removeEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.removeEventListener("mouseup", this.m_boundMouseUpHandler);
    }
    onMousedown(event) {
        if (event.button !== this.buttonId) {
            return;
        }
        this.cancelTimer();
        this.m_mouseDownEvent = event;
        this.m_timerId = setTimeout(() => this.onTimeout(), this.timeout);
        this.addMouseMoveHandler();
    }
    onMouseup(event) {
        if (event.button !== this.buttonId) {
            return;
        }
        this.cancel();
    }
    onMouseMove(event) {
        if (this.m_mouseDownEvent === undefined) {
            return; // Must not happen
        }
        const manhattanLength = Math.abs(event.clientX - this.m_mouseDownEvent.clientX) +
            Math.abs(event.clientY - this.m_mouseDownEvent.clientY);
        if (manhattanLength >= this.moveThreshold) {
            this.cancel();
        }
    }
    cancel() {
        this.m_mouseDownEvent = undefined;
        this.cancelTimer();
        this.removeMouseMoveHandler();
    }
    cancelTimer() {
        if (this.m_timerId === undefined) {
            return;
        }
        clearTimeout(this.m_timerId);
        this.m_timerId = undefined;
    }
    addMouseMoveHandler() {
        if (this.m_moveHandlerRegistered) {
            return;
        }
        this.element.addEventListener("mousemove", this.m_boundMouseMoveHandler);
        this.m_moveHandlerRegistered = true;
    }
    removeMouseMoveHandler() {
        if (!this.m_moveHandlerRegistered) {
            return;
        }
        this.element.removeEventListener("mousemove", this.m_boundMouseMoveHandler);
        this.m_moveHandlerRegistered = false;
    }
    onTimeout() {
        const event = this.m_mouseDownEvent;
        this.m_timerId = undefined;
        this.cancel();
        if (event !== undefined) {
            this.onLongPress(event);
        }
    }
}
exports.LongPressHandler = LongPressHandler;
//# sourceMappingURL=LongPressHandler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapAnimations.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapAnimations.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraPanAnimation = exports.CameraRotationAnimation = exports.CameraAnimation = exports.InterpolationFunction = exports.EasingFunction = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const MapControls_1 = __webpack_require__(/*! ./MapControls */ "./node_modules/@here/harp-map-controls/lib/MapControls.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/src/Tween.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Functions used for specifying animations' speed.
 */
var EasingFunction;
(function (EasingFunction) {
    EasingFunction[EasingFunction["Linear"] = 0] = "Linear";
    EasingFunction[EasingFunction["QuadraticIn"] = 1] = "QuadraticIn";
    EasingFunction[EasingFunction["QuadraticOut"] = 2] = "QuadraticOut";
    EasingFunction[EasingFunction["QuadraticInOut"] = 3] = "QuadraticInOut";
    EasingFunction[EasingFunction["CubicIn"] = 4] = "CubicIn";
    EasingFunction[EasingFunction["CubicOut"] = 5] = "CubicOut";
    EasingFunction[EasingFunction["CubicInOut"] = 6] = "CubicInOut";
    EasingFunction[EasingFunction["QuarticIn"] = 7] = "QuarticIn";
    EasingFunction[EasingFunction["QuarticOut"] = 8] = "QuarticOut";
    EasingFunction[EasingFunction["QuarticInOut"] = 9] = "QuarticInOut";
    EasingFunction[EasingFunction["QuinticIn"] = 10] = "QuinticIn";
    EasingFunction[EasingFunction["QuinticOut"] = 11] = "QuinticOut";
    EasingFunction[EasingFunction["QuinticInOut"] = 12] = "QuinticInOut";
    EasingFunction[EasingFunction["SinusoidalIn"] = 13] = "SinusoidalIn";
    EasingFunction[EasingFunction["SinusoidalOut"] = 14] = "SinusoidalOut";
    EasingFunction[EasingFunction["SinusoidalInOut"] = 15] = "SinusoidalInOut";
    EasingFunction[EasingFunction["ExponentialIn"] = 16] = "ExponentialIn";
    EasingFunction[EasingFunction["ExponentialOut"] = 17] = "ExponentialOut";
    EasingFunction[EasingFunction["ExponentialInOut"] = 18] = "ExponentialInOut";
    EasingFunction[EasingFunction["CircularIn"] = 19] = "CircularIn";
    EasingFunction[EasingFunction["CircularOut"] = 20] = "CircularOut";
    EasingFunction[EasingFunction["CircularInOut"] = 21] = "CircularInOut";
    EasingFunction[EasingFunction["ElasticIn"] = 22] = "ElasticIn";
    EasingFunction[EasingFunction["ElasticOut"] = 23] = "ElasticOut";
    EasingFunction[EasingFunction["ElasticInOut"] = 24] = "ElasticInOut";
    EasingFunction[EasingFunction["BackIn"] = 25] = "BackIn";
    EasingFunction[EasingFunction["BackOut"] = 26] = "BackOut";
    EasingFunction[EasingFunction["BackInOut"] = 27] = "BackInOut";
    EasingFunction[EasingFunction["BounceIn"] = 28] = "BounceIn";
    EasingFunction[EasingFunction["BounceOut"] = 29] = "BounceOut";
    EasingFunction[EasingFunction["BounceInOut"] = 30] = "BounceInOut";
})(EasingFunction = exports.EasingFunction || (exports.EasingFunction = {}));
/**
 * Functions used to generate intermediate animation values.
 */
var InterpolationFunction;
(function (InterpolationFunction) {
    InterpolationFunction[InterpolationFunction["Linear"] = 0] = "Linear";
    InterpolationFunction[InterpolationFunction["Bezier"] = 1] = "Bezier";
    InterpolationFunction[InterpolationFunction["CatmullRom"] = 2] = "CatmullRom";
})(InterpolationFunction = exports.InterpolationFunction || (exports.InterpolationFunction = {}));
/**
 * Abstract class used as base to define camera animations.
 */
class CameraAnimation {
    /**
     * Creates a new `CameraAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param name - Animation's name.
     */
    constructor(mapView, name) {
        this.mapView = mapView;
        this.name = name;
        /**
         * `True` if animation is being played.
         */
        this.running = false;
        /**
         * `True` if the animation has been interrupted.
         */
        this.stopped = false;
        /**
         * Duration of a whole animation in milliseconds. Defaults to `10` seconds.
         */
        this.duration = 10000;
        /**
         * Number of times the animation should be repeated. Defaults to `0`.
         */
        this.repeat = 0;
        /**
         * Easing function that control acceleration. Defaults to [[EasingFunction.Linear]].
         */
        this.easing = TWEEN.Easing.Linear.None;
        checkSetupTween();
    }
    /**
     * Update function is to be called before the next frame is rendered.
     */
    update(time) {
        if (this.tween) {
            return this.tween.update(time || harp_utils_1.PerformanceTimer.now());
        }
        return false;
    }
    /**
     * Returns `true` if the animation is being played.
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraAnimation = CameraAnimation;
/**
 * Create an animation around the Z-axis of the camera.
 */
class CameraRotationAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraRotationAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param m_mapControls - [[MapControls]] this animation will be taking control of.
     * @param options - Animation's options.
     * @param name - Animation's name.
     */
    constructor(mapView, m_mapControls, options, name) {
        super(mapView, name);
        this.m_mapControls = m_mapControls;
        /**
         * Initial camera rotation (in the Z-axis).
         */
        this.startAngle = 0;
        /**
         * Final camera rotation (in the Z-axis).
         */
        this.endAngle = 360;
        // tslint:disable-next-line:no-unused-variable
        this.m_axis = new THREE.Vector3(0, 0, 1);
        this.beginInteractionListener = () => {
            if (!this.stopped) {
                this.stopTween();
            }
        };
        this.endInteractionListener = () => {
            if (!this.stopped) {
                this.startTween();
            }
        };
        if (options.axis !== undefined) {
            this.m_axis = options.axis;
        }
        if (options.startAngle !== undefined) {
            this.startAngle = options.startAngle;
        }
        if (options.endAngle !== undefined) {
            this.endAngle = options.endAngle;
        }
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;
        }
        this.m_lastRotationValue = this.startAngle;
    }
    /**
     * Start the animation.
     *
     * @param time - Duration of the animation in milliseconds.
     * @param onFinished - Callback that gets triggered once the animation ends.
     * @override
     */
    start(time, onFinished) {
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.running = true;
        this.onFinished = onFinished;
        this.stopped = false;
        if (this.m_mapControls) {
            this.m_mapControls.addEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.addEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
        this.startTween(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     * @override
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.stopped = true;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
        if (this.m_mapControls) {
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
    }
    /**
     * Internal start of tween. Required because the tween may be interrupted by the
     * [[MapControls]].
     */
    startTween(time) {
        const rotZ = new THREE.Quaternion();
        this.m_userCamerRotation = new THREE.Quaternion();
        this.mapView.camera.getWorldQuaternion(this.m_userCamerRotation);
        // Create a tween to animate the camera rotation around the Z axis.
        //
        // make this a relative rotation, always starting from 0. Take into account the
        // lastRotationValue which may be a leftover from the previous run of "this" tween.
        this.tween = new TWEEN.Tween({ rotation: 0 })
            .to({ rotation: this.endAngle - this.m_lastRotationValue }, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ rotation }) => {
            this.m_lastRotationValue = rotation;
            rotZ.setFromEuler(new THREE.Euler(0, 0, THREE.MathUtils.degToRad(rotation)));
            if (this.m_userCamerRotation !== undefined) {
                rotZ.multiply(this.m_userCamerRotation);
            }
            this.mapView.camera.quaternion.copy(rotZ);
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.start(time);
    }
    /**
     * Internal stop of tween. Required because the tween may be interrupted by the [[MapControls]].
     */
    stopTween() {
        if (this.tween) {
            this.tween.stop();
        }
    }
}
exports.CameraRotationAnimation = CameraRotationAnimation;
/**
 * Class to pan between the specified geo coordinates. Height can be specified to move the camera in
 * and out.
 */
class CameraPanAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraPanAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param options - Animation's options.
     * @param name - Animation's name.
     */
    constructor(mapView, options, name) {
        super(mapView, name);
        this.name = name;
        /**
         * Specifies interpolation. Defaults to [[InterpolationFunction.CatmullRom]]
         */
        this.interpolation = TWEEN.Interpolation.CatmullRom;
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;
        }
        if (options.interpolation !== undefined) {
            this.interpolation =
                typeof options.interpolation === "function"
                    ? options.interpolation
                    : interpolationMap.get(options.interpolation) || TWEEN.Interpolation.Linear;
        }
        this.m_geoCoordinates = options.geoCoordinates !== undefined ? options.geoCoordinates : [];
    }
    /**
     * Add a geo coordinate that should be visited.
     *
     * @param geoPos - Geographical coordinate to animate to.
     */
    addPosition(geoPos) {
        this.m_geoCoordinates.push(geoPos);
    }
    /**
     * Start the animation.
     *
     * @param time - Duration of the animation in milliseconds.
     * @param onFinished - Callback that gets triggered once the animation ends.
     * @override
     */
    start(time, onFinished) {
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.onFinished = onFinished;
        this.running = true;
        const from = new harp_geoutils_1.GeoCoordinates(this.mapView.geoCenter.latitude, this.mapView.geoCenter.longitude, this.mapView.camera.position.z);
        const to = {
            latitude: new Array(),
            longitude: new Array(),
            altitude: new Array()
        };
        for (const pos of this.m_geoCoordinates) {
            to.latitude.push(pos.latitude);
            to.longitude.push(pos.longitude);
            to.altitude.push(pos.altitude || this.mapView.camera.position.z);
        }
        this.tween = new TWEEN.Tween(from)
            .to(to, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ latitude, longitude, altitude }) => {
            this.mapView.geoCenter = new harp_geoutils_1.GeoCoordinates(latitude, longitude, altitude);
            this.mapView.camera.position.z = altitude;
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.interpolation(this.interpolation);
        this.tween.start(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     * @override
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
    }
    /**
     * Returns `true` if the animation is being played.
     * @override
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraPanAnimation = CameraPanAnimation;
// Cannot use enum as map index in a typesave manner, otherwise I would love to make it more
// elegant...
let easingMap;
let interpolationMap;
function checkSetupTween() {
    if (easingMap !== undefined) {
        return;
    }
    easingMap = new Map();
    interpolationMap = new Map();
    easingMap.set(EasingFunction.Linear, TWEEN.Easing.Linear.None);
    easingMap.set(EasingFunction.QuadraticIn, TWEEN.Easing.Quadratic.In);
    easingMap.set(EasingFunction.QuadraticOut, TWEEN.Easing.Quadratic.Out);
    easingMap.set(EasingFunction.QuadraticInOut, TWEEN.Easing.Quadratic.InOut);
    easingMap.set(EasingFunction.CubicIn, TWEEN.Easing.Cubic.In);
    easingMap.set(EasingFunction.CubicOut, TWEEN.Easing.Cubic.Out);
    easingMap.set(EasingFunction.CubicInOut, TWEEN.Easing.Cubic.InOut);
    easingMap.set(EasingFunction.QuarticIn, TWEEN.Easing.Quartic.In);
    easingMap.set(EasingFunction.QuarticOut, TWEEN.Easing.Quartic.Out);
    easingMap.set(EasingFunction.QuarticInOut, TWEEN.Easing.Quartic.InOut);
    easingMap.set(EasingFunction.QuinticIn, TWEEN.Easing.Quintic.In);
    easingMap.set(EasingFunction.QuinticOut, TWEEN.Easing.Quintic.Out);
    easingMap.set(EasingFunction.QuinticInOut, TWEEN.Easing.Quintic.InOut);
    easingMap.set(EasingFunction.SinusoidalIn, TWEEN.Easing.Sinusoidal.In);
    easingMap.set(EasingFunction.SinusoidalOut, TWEEN.Easing.Sinusoidal.Out);
    easingMap.set(EasingFunction.SinusoidalInOut, TWEEN.Easing.Sinusoidal.InOut);
    easingMap.set(EasingFunction.ExponentialIn, TWEEN.Easing.Exponential.In);
    easingMap.set(EasingFunction.ExponentialOut, TWEEN.Easing.Exponential.Out);
    easingMap.set(EasingFunction.ExponentialInOut, TWEEN.Easing.Exponential.InOut);
    easingMap.set(EasingFunction.CircularIn, TWEEN.Easing.Circular.In);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.Out);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.InOut);
    easingMap.set(EasingFunction.ElasticIn, TWEEN.Easing.Elastic.In);
    easingMap.set(EasingFunction.ElasticOut, TWEEN.Easing.Elastic.Out);
    easingMap.set(EasingFunction.ElasticInOut, TWEEN.Easing.Elastic.InOut);
    easingMap.set(EasingFunction.BackIn, TWEEN.Easing.Back.In);
    easingMap.set(EasingFunction.BackOut, TWEEN.Easing.Back.Out);
    easingMap.set(EasingFunction.BackInOut, TWEEN.Easing.Back.InOut);
    easingMap.set(EasingFunction.BounceIn, TWEEN.Easing.Bounce.In);
    easingMap.set(EasingFunction.BounceOut, TWEEN.Easing.Bounce.Out);
    easingMap.set(EasingFunction.BounceInOut, TWEEN.Easing.Bounce.InOut);
    interpolationMap.set(InterpolationFunction.Linear, TWEEN.Interpolation.Linear);
    interpolationMap.set(InterpolationFunction.Bezier, TWEEN.Interpolation.Bezier);
    interpolationMap.set(InterpolationFunction.CatmullRom, TWEEN.Interpolation.CatmullRom);
}
//# sourceMappingURL=MapAnimations.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControls.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControls.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapControls = exports.EventNames = exports.TiltState = void 0;
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const utils = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-map-controls/lib/Utils.js");
var State;
(function (State) {
    State[State["NONE"] = 0] = "NONE";
    State[State["PAN"] = 1] = "PAN";
    State[State["ROTATE"] = 2] = "ROTATE";
    State[State["ORBIT"] = 3] = "ORBIT";
    State[State["TOUCH"] = 4] = "TOUCH";
})(State || (State = {}));
var TiltState;
(function (TiltState) {
    TiltState[TiltState["Tilted"] = 0] = "Tilted";
    TiltState[TiltState["Down"] = 1] = "Down";
})(TiltState = exports.TiltState || (exports.TiltState = {}));
/**
 * Map interaction events' names.
 */
var EventNames;
(function (EventNames) {
    EventNames["Update"] = "update";
    EventNames["BeginInteraction"] = "begin-interaction";
    EventNames["EndInteraction"] = "end-interaction";
})(EventNames = exports.EventNames || (exports.EventNames = {}));
// cast needed to workaround wrong three.js typings.
const MAPCONTROL_EVENT = { type: EventNames.Update };
const MAPCONTROL_EVENT_BEGIN_INTERACTION = {
    type: EventNames.BeginInteraction
};
const MAPCONTROL_EVENT_END_INTERACTION = {
    type: EventNames.EndInteraction
};
/**
 * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.
 */
const USER_INPUTS_TO_CONSIDER = 5;
/**
 * The default maximum for the camera tilt. This value avoids seeing the horizon.
 */
const DEFAULT_MAX_TILT_ANGLE = Math.PI / 4;
/**
 * Epsilon value to rule out when a number can be considered 0.
 */
const EPSILON = 0.01;
/**
 * Maximum duration between start and end touch events to define a finger tap.
 */
const MAX_TAP_DURATION = 120;
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
class MapControls extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView - [[MapView]] this controller modifies.Z
     */
    constructor(mapView) {
        super();
        this.mapView = mapView;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset for the rotation then.
         * Default value is `0.1`.
         */
        this.rotationMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current touch pointer position and the last
         * touch pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingTouchDeltaFactor = 0.1;
        /**
         * Set to `true` to enable input handling through this map control, `false` to disable input
         * handling. Even when disabling input handling, you can manually use the public functions to
         * change the view to the current map.
         */
        this.enabled = true;
        /**
         * Set to `true` to enable zooming through these controls, `false` otherwise.
         */
        this.zoomEnabled = true;
        /**
         * Set to `true` to enable panning through these controls, `false` otherwise.
         */
        this.panEnabled = true;
        /**
         * Set to `true` to enable orbiting and tilting through these controls, `false` otherwise.
         */
        this.tiltEnabled = true;
        /**
         * Set to `true` to enable rotation through this map control, `false` to disable rotation.
         */
        this.rotateEnabled = true;
        /**
         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
         */
        this.inertiaEnabled = true;
        /**
         * Inertia damping duration for the zoom, in seconds.
         */
        this.zoomInertiaDampingDuration = 0.5;
        /**
         * Inertia damping duration for the panning, in seconds.
         */
        this.panInertiaDampingDuration = 1.0;
        /**
         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
         * inertia.
         */
        this.tiltToggleDuration = 0.5;
        /**
         * Camera tilt to the target when tilting from the `toggleTilt` public method.
         */
        this.tiltAngle = Math.PI / 4;
        /**
         * Duration of the animation to reset the camera to looking north, in seconds. Independent of
         * inertia.
         */
        this.northResetAnimationDuration = 1.5;
        /**
         * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
         * movement the current zoom level will be added or subtracted by this value. The default value
         * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.
         *
         * **Note**: To reverse the zoom direction, you can provide a negative value.
         */
        this.zoomLevelDeltaOnMouseWheel = 0.2;
        /**
         * Zoom level delta when using the UI controls.
         */
        this.zoomLevelDeltaOnControl = 1.0;
        /**
         * Determines the minimum zoom level we can zoom to.
         */
        this.minZoomLevel = 0;
        /**
         * Determines the maximum zoom level we can zoom to.
         */
        this.maxZoomLevel = 20;
        /**
         * Determines the minimum camera height in meter.
         */
        this.minCameraHeight = 3;
        /**
         * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.
         */
        this.zoomLevelDeltaOnDoubleClick = 1.0;
        /**
         * Double click uses the OS delay through the double click event. Tapping is implemented locally
         * here in `MapControls` with this duration setting the maximum delay to define a double tap.
         * The value is in seconds. `300ms` is picked as the default value as jQuery does.
         */
        this.doubleTapTime = 0.3;
        this.m_currentViewDirection = new THREE.Vector3();
        this.m_lastMousePosition = new THREE.Vector2(0, 0);
        this.m_mouseDelta = new THREE.Vector2(0, 0);
        this.m_needsRenderLastFrame = true;
        // Internal variables for animating panning (planar + spherical panning).
        this.m_panIsAnimated = false;
        this.m_panDistanceFrameDelta = new THREE.Vector3();
        this.m_panAnimationTime = 0;
        this.m_panAnimationStartTime = 0;
        this.m_lastAveragedPanDistanceOrAngle = 0;
        this.m_currentInertialPanningSpeed = 0;
        this.m_lastPanVector = new THREE.Vector3();
        this.m_rotateGlobeQuaternion = new THREE.Quaternion();
        this.m_lastRotateGlobeAxis = new THREE.Vector3();
        this.m_lastRotateGlobeAngle = 0;
        this.m_lastRotateGlobeFromVector = new THREE.Vector3();
        this.m_recentPanDistancesOrAngles = [
            0,
            0,
            0,
            0,
            0
        ];
        this.m_currentPanDistanceOrAngleIndex = 0;
        // Internal variables for animating zoom.
        this.m_zoomIsAnimated = false;
        this.m_zoomDeltaRequested = 0;
        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();
        this.m_zoomAnimationTime = 0;
        this.m_zoomAnimationStartTime = 0;
        this.m_startZoom = 0;
        // Internal variables for animating tilt.
        this.m_tiltIsAnimated = false;
        this.m_tiltRequested = undefined;
        this.m_tiltAnimationTime = 0;
        this.m_tiltAnimationStartTime = 0;
        this.m_startTilt = 0;
        this.m_state = State.NONE;
        this.m_tmpVector2 = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        // Internal variables for animating double tap.
        this.m_tapStartTime = 0;
        this.m_lastSingleTapTime = 0;
        this.m_fingerMoved = false;
        this.m_isDoubleTap = false;
        // Internal variables for animating the movement resetting the north.
        this.m_resetNorthStartTime = 0;
        this.m_resetNorthIsAnimated = false;
        this.m_resetNorthAnimationDuration = 0;
        this.m_currentAzimuth = 0;
        this.m_lastAzimuth = 0;
        this.m_startAzimuth = 0;
        /**
         * Determines the maximum angle the camera can tilt to. It is defined in radians.
         */
        this.m_maxTiltAngle = DEFAULT_MAX_TILT_ANGLE;
        this.m_touchState = {
            touches: [],
            currentRotation: 0,
            initialRotation: 0
        };
        /**
         * Destroy this `MapControls` instance.
         *
         * Unregisters all global event handlers used. This is method should be called when you stop
         * using `MapControls`.
         */
        this.dispose = () => {
            // replaced with real code in bindInputEvents
        };
        this.camera = mapView.camera;
        this.domElement = mapView.renderer.domElement;
        this.maxZoomLevel = mapView.maxZoomLevel;
        this.minZoomLevel = mapView.minZoomLevel;
        this.minCameraHeight = mapView.minCameraHeight;
        this.bindInputEvents(this.domElement);
        this.handleZoom = this.handleZoom.bind(this);
        this.handlePan = this.handlePan.bind(this);
        this.tilt = this.tilt.bind(this);
        this.resetNorth = this.resetNorth.bind(this);
        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);
    }
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     */
    static create(mapView) {
        return new MapControls(mapView);
    }
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get attitude() {
        const attitude = harp_mapview_1.MapViewUtils.extractAttitude(this.mapView, this.camera);
        return {
            yaw: THREE.MathUtils.radToDeg(attitude.yaw),
            pitch: THREE.MathUtils.radToDeg(attitude.pitch),
            roll: THREE.MathUtils.radToDeg(attitude.roll)
        };
    }
    /**
     * Moves the camera along the view direction in meters.
     * A positive value will move the camera further away from the point where the camera looks at.
     * A negative value will move the camera near to the point where the camera looks at.
     *
     * @param amount - Amount to move along the view direction in meters.
     */
    moveAlongTheViewDirection(amount) {
        // TODO: What about zoom disabled?
        if (amount === 0) {
            return;
        }
        this.camera.getWorldDirection(this.m_currentViewDirection);
        let maxDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.minZoomLevel);
        let minDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.maxZoomLevel);
        this.m_currentViewDirection.multiplyScalar(amount);
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            const distance = THREE.MathUtils.clamp(this.camera.position.z + this.m_currentViewDirection.z, minDistance, maxDistance);
            this.camera.position.z = distance;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            const zOnVertical = Math.cos(this.camera.position.angleTo(this.m_currentViewDirection)) *
                this.m_currentViewDirection.length();
            minDistance += geoUtils.EarthConstants.EQUATORIAL_RADIUS;
            maxDistance += geoUtils.EarthConstants.EQUATORIAL_RADIUS;
            const distance = THREE.MathUtils.clamp(this.camera.position.length() + zOnVertical, minDistance, maxDistance);
            this.camera.position.setLength(distance);
        }
        // In sphere, we may have to also orbit the camera around the position located at the
        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change
        // this tilt by changing the camera's height above.
        if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical &&
            this.m_maxTiltAngle !== undefined) {
            // Use pre-calculated camera target, otherwise we could get it via:
            // centerScreenTarget = MapViewUtils.getTargetPositionFromCamera(camera, projection)
            // and convert to geo-coordinates via:
            // this.mapView.projection.unprojectPoint(centerScreenTarget)
            const tilt = harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.target).tilt;
            const deltaTilt = tilt - this.m_maxTiltAngle;
            if (deltaTilt > 0) {
                harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, 0, deltaTilt, this.m_maxTiltAngle);
            }
        }
        this.updateMapView();
        this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    /**
     * Reset the camera to looking north, in an orbiting movement around the target point instead
     * of changing the yaw (which would be the camera rotating on itself).
     */
    pointToNorth() {
        // Use pre-calculated target coordinates, otherwise we could call utility method to evaluate
        // geo-coordinates here:
        // targetGeoCoords = MapViewUtils.getTargetCoordinatesFromCamera(camera, projection)
        this.m_startAzimuth =
            Math.PI +
                harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.target).azimuth;
        // Wrap between -PI and PI.
        this.m_startAzimuth = Math.atan2(Math.sin(this.m_startAzimuth), Math.cos(this.m_startAzimuth));
        if (this.m_startAzimuth === 0) {
            return;
        }
        this.stopExistingAnimations();
        this.m_resetNorthAnimationDuration = this.northResetAnimationDuration;
        this.m_currentAzimuth = this.m_startAzimuth;
        this.m_resetNorthStartTime = performance.now();
        this.resetNorth();
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC - Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC - Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, this.m_maxTiltAngle);
    }
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel - Zoom level.
     * @param screenTarget - Zoom target on screen.
     */
    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        // Register the zoom request
        this.m_startZoom = this.currentZoom;
        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_zoomAnimationStartTime = performance.now();
        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);
        this.handleZoom();
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    /**
     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt() {
        if (!this.enabled || !this.tiltEnabled) {
            return;
        }
        this.stopExistingAnimations();
        this.m_startTilt = this.currentTilt;
        const aimTilt = this.m_startTilt < EPSILON;
        this.m_tiltRequested = aimTilt ? this.tiltAngle : 0;
        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;
        this.m_tiltAnimationStartTime = performance.now();
        this.tilt();
    }
    /**
     * Set the camera height.
     */
    set cameraHeight(height) {
        //Set the cameras height according to the given zoom level.
        this.camera.position.setZ(height);
        this.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Get the current camera height.
     */
    get cameraHeight() {
        // ### Sync with the way geoviz is computing the zoom level.
        return this.mapView.camera.position.z;
    }
    /**
     * Set camera max tilt angle. The value is clamped between 0 and 90 degrees. In sphere
     * projection, at runtime, the value is also clamped so that the camera does not look above the
     * horizon.
     *
     * @param angle - Angle in degrees.
     */
    set maxTiltAngle(angle) {
        this.m_maxTiltAngle = Math.max(0, Math.min(90, THREE.MathUtils.degToRad(angle)));
    }
    /**
     * Get the camera max tilt angle in degrees.
     */
    get maxTiltAngle() {
        return THREE.MathUtils.radToDeg(this.m_maxTiltAngle);
    }
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted() {
        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;
    }
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState() {
        if (this.m_tiltState === undefined) {
            this.m_tiltState =
                this.currentTilt < EPSILON || this.m_tiltState === TiltState.Down
                    ? TiltState.Tilted
                    : TiltState.Down;
        }
        return this.m_tiltState;
    }
    set currentZoom(zoom) {
        this.m_currentZoom = zoom;
    }
    get currentZoom() {
        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;
    }
    set currentTilt(tilt) {
        this.m_currentTilt = tilt;
    }
    get currentTilt() {
        return THREE.MathUtils.degToRad(this.mapView.tilt);
    }
    get targetedTilt() {
        return this.m_targetedTilt === undefined
            ? this.m_currentTilt === undefined
                ? this.currentTilt
                : this.m_currentTilt
            : this.m_targetedTilt;
    }
    assignZoomAfterTouchZoomRender() {
        this.m_currentZoom = this.mapView.zoomLevel;
        this.m_targetedZoom = this.mapView.zoomLevel;
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    stopExistingAnimations() {
        this.stopResetNorth();
        this.stopZoom();
        this.stopPan();
        this.stopTilt();
    }
    resetNorth() {
        const currentTime = performance.now();
        const animationTime = (currentTime - this.m_resetNorthStartTime) / 1000;
        if (this.inertiaEnabled) {
            if (!this.m_resetNorthIsAnimated) {
                this.m_resetNorthIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
            }
            const resetNorthFinished = animationTime > this.m_resetNorthAnimationDuration;
            if (resetNorthFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.stopResetNorth();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_lastAzimuth = this.m_currentAzimuth;
        this.m_currentAzimuth = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startAzimuth, 0, Math.min(1, animationTime / this.m_resetNorthAnimationDuration))
            : 0;
        const deltaAzimuth = this.m_currentAzimuth - this.m_lastAzimuth;
        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, THREE.MathUtils.radToDeg(deltaAzimuth), 0, this.m_maxTiltAngle);
        this.updateMapView();
    }
    stopResetNorth() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
        this.m_resetNorthIsAnimated = false;
    }
    tilt() {
        if (this.m_tiltRequested !== undefined) {
            this.m_targetedTilt = Math.max(Math.min(this.m_tiltRequested, this.maxTiltAngle), 0);
            this.m_tiltRequested = undefined;
        }
        if (this.inertiaEnabled) {
            if (!this.m_tiltIsAnimated) {
                this.m_tiltIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
            }
            const currentTime = performance.now();
            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;
            const tiltFinished = this.m_tiltAnimationTime > this.tiltToggleDuration;
            if (tiltFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_tiltAnimationTime = this.tiltToggleDuration;
                    this.stopTilt();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_currentTilt = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startTilt, this.targetedTilt, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))
            : this.targetedTilt;
        const initialTilt = this.currentTilt;
        const deltaAngle = this.m_currentTilt - initialTilt;
        const oldCameraDistance = this.mapView.camera.position.z / Math.cos(initialTilt);
        const newHeight = Math.cos(initialTilt) * oldCameraDistance;
        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, newHeight - this.camera.position.z, THREE.MathUtils.radToDeg(deltaAngle), this.m_maxTiltAngle);
        this.updateMapView();
    }
    stopTilt() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
        this.m_tiltIsAnimated = false;
        this.m_targetedTilt = this.m_currentTilt = undefined;
    }
    easeOutCubic(startValue, endValue, time) {
        return startValue + (endValue - startValue) * (--time * time * time + 1);
    }
    handleZoom() {
        let resetZoomState = false;
        if (this.m_zoomDeltaRequested !== 0) {
            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);
            this.m_zoomDeltaRequested = 0;
        }
        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {
            if (!this.m_zoomIsAnimated) {
                this.m_zoomIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
            }
            const currentTime = performance.now();
            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;
            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;
            if (zoomFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;
                    resetZoomState = true;
                    this.stopZoom();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.currentZoom =
            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON
                ? this.zoomLevelTargeted
                : this.easeOutCubic(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom, this.m_maxTiltAngle);
        if (resetZoomState) {
            this.m_targetedZoom = undefined;
            this.m_currentZoom = undefined;
        }
        this.updateMapView();
    }
    stopZoom() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
        this.m_zoomIsAnimated = false;
    }
    /**
     * Method to flip crpes.
     */
    handlePan() {
        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {
            return;
        }
        if (this.inertiaEnabled && !this.m_panIsAnimated) {
            this.m_panIsAnimated = true;
            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
        }
        const applyInertia = this.inertiaEnabled &&
            this.panInertiaDampingDuration > 0 &&
            this.m_state === State.NONE &&
            this.m_lastAveragedPanDistanceOrAngle > 0;
        if (applyInertia) {
            const currentTime = performance.now();
            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;
            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;
            if (panFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_panAnimationTime = this.panInertiaDampingDuration;
                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
                    this.m_panIsAnimated = false;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;
            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistanceOrAngle, 0, Math.min(1, animationTime));
            if (this.m_currentInertialPanningSpeed === 0) {
                this.m_lastAveragedPanDistanceOrAngle = 0;
            }
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                this.m_panDistanceFrameDelta
                    .copy(this.m_lastPanVector)
                    .setLength(this.m_currentInertialPanningSpeed);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                this.m_rotateGlobeQuaternion
                    .setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_currentInertialPanningSpeed)
                    .normalize();
            }
        }
        else {
            let panDistanceOrAngle = 0;
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                panDistanceOrAngle = this.m_lastPanVector
                    .copy(this.m_panDistanceFrameDelta)
                    .length();
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                panDistanceOrAngle = this.m_lastRotateGlobeAngle;
                this.m_rotateGlobeQuaternion.setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_lastRotateGlobeAngle);
                this.m_rotateGlobeQuaternion.normalize();
            }
            this.m_currentPanDistanceOrAngleIndex =
                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;
            this.m_recentPanDistancesOrAngles[this.m_currentPanDistanceOrAngleIndex] = panDistanceOrAngle;
            this.m_lastAveragedPanDistanceOrAngle =
                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            harp_mapview_1.MapViewUtils.panCameraAroundGlobe(this.mapView, this.m_lastRotateGlobeFromVector, this.m_tmpVector3
                .copy(this.m_lastRotateGlobeFromVector)
                .applyQuaternion(this.m_rotateGlobeQuaternion));
        }
        if (!applyInertia) {
            this.m_panDistanceFrameDelta.set(0, 0, 0);
            this.m_lastRotateGlobeAngle = 0;
        }
        this.updateMapView();
    }
    stopPan() {
        this.m_panDistanceFrameDelta.set(0, 0, 0);
        this.m_lastAveragedPanDistanceOrAngle = 0;
    }
    bindInputEvents(domElement) {
        const onContextMenu = this.contextMenu.bind(this);
        const onMouseDown = this.mouseDown.bind(this);
        const onMouseWheel = this.mouseWheel.bind(this);
        const onTouchStart = this.touchStart.bind(this);
        const onTouchEnd = this.touchEnd.bind(this);
        const onTouchMove = this.touchMove.bind(this);
        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);
        domElement.addEventListener("dblclick", onMouseDoubleClick, false);
        domElement.addEventListener("contextmenu", onContextMenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", onTouchStart, false);
        domElement.addEventListener("touchend", onTouchEnd, false);
        domElement.addEventListener("touchmove", onTouchMove, false);
        this.dispose = () => {
            domElement.removeEventListener("dblclick", onMouseDoubleClick, false);
            domElement.removeEventListener("contextmenu", onContextMenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("touchstart", onTouchStart, false);
            domElement.removeEventListener("touchend", onTouchEnd, false);
            domElement.removeEventListener("touchmove", onTouchMove, false);
        };
    }
    updateMapView() {
        this.dispatchEvent(MAPCONTROL_EVENT);
        this.mapView.update();
    }
    mouseDoubleClick(event) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        const mousePos = this.getPointerPosition(event);
        this.zoomOnDoubleClickOrTap(mousePos.x, mousePos.y);
    }
    mouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.shiftKey || event.ctrlKey) {
            return;
        }
        event.stopPropagation();
        if (this.m_state !== State.NONE) {
            return;
        }
        if (event.button === 0 && this.panEnabled) {
            this.m_state = State.PAN;
        }
        else if (event.button === 1) {
            this.m_state = State.ROTATE;
        }
        else if (event.button === 2 && this.tiltEnabled) {
            this.m_state = State.ORBIT;
        }
        else {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        const mousePos = this.getPointerPosition(event);
        this.m_lastMousePosition.setX(mousePos.x);
        this.m_lastMousePosition.setY(mousePos.y);
        const onMouseMove = this.mouseMove.bind(this);
        const onMouseUp = this.mouseUp.bind(this);
        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mouseup", onMouseUp, false);
        this.m_cleanupMouseEventListeners = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
        };
    }
    mouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        const mousePos = this.getPointerPosition(event);
        this.m_mouseDelta.set(mousePos.x - this.m_lastMousePosition.x, mousePos.y - this.m_lastMousePosition.y);
        if (this.m_state === State.PAN) {
            const vectors = this.getWorldPositionWithElevation(this.m_lastMousePosition.x, this.m_lastMousePosition.y, mousePos.x, mousePos.y);
            if (vectors === undefined) {
                return;
            }
            const { fromWorld, toWorld } = vectors;
            this.panFromTo(fromWorld, toWorld);
        }
        else if (this.m_state === State.ROTATE) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.rotate(this.mapView, -this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);
        }
        else if (this.m_state === State.ORBIT) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingMouseDeltaFactor * this.m_mouseDelta.x, -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);
        }
        this.m_lastMousePosition.set(mousePos.x, mousePos.y);
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    mouseUp(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
        this.m_state = State.NONE;
        if (this.m_cleanupMouseEventListeners) {
            this.m_cleanupMouseEventListeners();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    mouseWheel(event) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);
        this.setZoomLevel(this.zoomLevelTargeted + this.zoomLevelDeltaOnMouseWheel * (event.deltaY > 0 ? -1 : 1), screenTarget);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    updateCurrentRotation() {
        if (this.m_touchState.touches.length < 2 ||
            this.m_touchState.touches[1].currentWorldPosition.length() === 0 ||
            this.m_touchState.touches[0].currentWorldPosition.length() === 0) {
            return;
        }
        let x = 0;
        let y = 0;
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            // Planar uses world space coordinates to return the angle of the vector between the two
            // fingers' locations from the north direction.
            x =
                this.m_touchState.touches[1].currentWorldPosition.x -
                    this.m_touchState.touches[0].currentWorldPosition.x;
            y =
                this.m_touchState.touches[1].currentWorldPosition.y -
                    this.m_touchState.touches[0].currentWorldPosition.y;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            // Globe uses screen space coordinates, as the 3d coordinate system cannot define a
            // reference rotation scalar for the vector between the two fingers' locations.
            x =
                this.m_touchState.touches[1].currentTouchPoint.x -
                    this.m_touchState.touches[0].currentTouchPoint.x;
            // Below the subtraction is inverted, because the Y coordinate in screen space in HTML
            // has its origin at the top and increases downwards.
            y =
                this.m_touchState.touches[0].currentTouchPoint.y -
                    this.m_touchState.touches[1].currentTouchPoint.y;
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
        this.m_touchState.currentRotation = Math.atan2(y, x);
    }
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    calculatePinchDistanceInWorldSpace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const previousDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)
            .length();
        const currentDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)
            .length();
        return currentDistance - previousDistance;
    }
    convertTouchPoint(touch, oldTouchState) {
        // Acquire touch coordinates relative to canvas, this coordinates
        // are then used to calculate NDC values.
        const newTouchPoint = this.getPointerPosition(touch);
        if (oldTouchState !== undefined) {
            const oldTouchPoint = oldTouchState.currentTouchPoint;
            const vectors = this.getWorldPositionWithElevation(oldTouchPoint.x, oldTouchPoint.y, newTouchPoint.x, newTouchPoint.y);
            const toWorld = vectors === undefined ? new THREE.Vector3() : vectors.toWorld;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
        else {
            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
            const to = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);
            const result = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
            const toWorld = result === null ? new THREE.Vector3() : result;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
    }
    setTouchState(touches) {
        this.m_touchState.touches = [];
        // TouchList doesn't conform to iterator interface so we cannot use 'for of'
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < touches.length; ++i) {
            const touchState = this.convertTouchPoint(touches[i]);
            if (touchState !== undefined) {
                this.m_touchState.touches.push(touchState);
            }
        }
        if (this.m_touchState.touches.length !== 0) {
            this.updateCurrentRotation();
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
    }
    updateTouches(touches) {
        const length = Math.min(touches.length, this.m_touchState.touches.length);
        for (let i = 0; i < length; ++i) {
            const oldTouchState = this.m_touchState.touches[i];
            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);
            if (newTouchState !== undefined && oldTouchState !== undefined) {
                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;
                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;
                this.m_touchState.touches[i] = newTouchState;
            }
        }
    }
    zoomOnDoubleClickOrTap(x, y) {
        if (this.zoomLevelDeltaOnDoubleClick === 0) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);
        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);
    }
    touchStart(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_tapStartTime = performance.now();
        this.m_fingerMoved = false;
        this.m_state = State.TOUCH;
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.setTouchState(event.touches);
        this.updateTouches(event.touches);
        event.preventDefault();
        event.stopPropagation();
    }
    touchMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_fingerMoved = true;
        this.updateTouches(event.touches);
        if (this.panEnabled &&
            this.m_touchState.touches.length <= 2 &&
            this.m_touchState.touches[0] !== undefined) {
            this.panFromTo(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);
        }
        if (this.zoomEnabled && this.m_touchState.touches.length === 2) {
            const pinchDistance = this.calculatePinchDistanceInWorldSpace();
            if (Math.abs(pinchDistance) < EPSILON) {
                return;
            }
            this.updateCurrentRotation();
            const deltaRotation = this.m_touchState.currentRotation - this.m_touchState.initialRotation;
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.rotate(this.mapView, THREE.MathUtils.radToDeg(deltaRotation));
            this.moveAlongTheViewDirection(pinchDistance);
        }
        // Tilting
        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {
            const firstTouch = this.m_touchState.touches[0];
            const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingTouchDeltaFactor * diff.x, -this.orbitingTouchDeltaFactor * diff.y, this.m_maxTiltAngle);
        }
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    touchEnd(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.NONE;
        this.handleDoubleTap();
        this.setTouchState(event.touches);
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    handleDoubleTap() {
        // Continue only if no touchmove happened and zoom's enabled.
        if (this.m_fingerMoved || !this.zoomEnabled) {
            return;
        }
        const now = performance.now();
        const tapDuration = now - this.m_tapStartTime;
        // Continue only if proper tap.
        if (tapDuration > MAX_TAP_DURATION) {
            return;
        }
        // Continue only if this is the second valid tap.
        if (!this.m_isDoubleTap) {
            this.m_isDoubleTap = true;
            this.m_lastSingleTapTime = now;
            return;
        }
        // Continue only if the delay between the two taps is short enough.
        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {
            // If too long, restart double tap validator too.
            this.m_isDoubleTap = false;
            return;
        }
        this.zoomOnDoubleClickOrTap(this.m_touchState.touches[0].currentTouchPoint.x, this.m_touchState.touches[0].currentTouchPoint.y);
        // Prevent a string of X valid taps and only consider pairs.
        this.m_isDoubleTap = false;
    }
    contextMenu(event) {
        event.preventDefault();
    }
    getWorldPositionWithElevation(fromX, fromY, toX, toY) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);
        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);
        let toWorld;
        let fromWorld;
        let elevationProviderResult;
        if (this.mapView.elevationProvider !== undefined) {
            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);
        }
        if (elevationProviderResult === undefined) {
            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
        }
        else {
            fromWorld = elevationProviderResult;
            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);
            // We can ensure that points under the mouse stay there by projecting the to point onto
            // a plane with the altitude based on the initial point.
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);
        }
        if (fromWorld === null || toWorld === null) {
            return;
        }
        return { fromWorld, toWorld };
    }
    panFromTo(fromWorld, toWorld) {
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_panAnimationStartTime = performance.now();
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            this.m_lastRotateGlobeFromVector.copy(fromWorld);
            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();
            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);
            // When fromWorld and toWorld are too close, there is a risk of getting an NaN
            // value. The following ensures that the controls don't break.
            if (isNaN(this.m_lastRotateGlobeAngle)) {
                this.m_lastRotateGlobeAngle = 0;
            }
        }
        this.handlePan();
    }
    /**
     * Acquire mouse or touch pointer position relative to canvas for `MouseEvent` or `Touch` event.
     *
     * Function takes into account canvas position in client space (including scrolling) as also
     * canvas scaling factor.
     *
     * @param event - The mouse event.
     * @returns [[THREE.Vector2]] containing _x_, _y_ mouse pointer position.
     */
    getPointerPosition(event) {
        const canvasSize = utils.getWidthAndHeightFromCanvas(this.domElement);
        // Absolute size of a canvas
        const rect = this.domElement.getBoundingClientRect();
        // TODO: Test if scaling is needed and works on HiDPI devices.
        const scaleX = Math.round(rect.width) / canvasSize.width;
        const scaleY = Math.round(rect.height) / canvasSize.height;
        // Scale mouse coordinates after they have, been adjusted to be relative to element.
        return new THREE.Vector2((event.clientX - Math.floor(rect.left)) * scaleX, (event.clientY - Math.floor(rect.top)) * scaleY);
    }
}
exports.MapControls = MapControls;
//# sourceMappingURL=MapControls.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControlsUI.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControlsUI.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapControlsUI = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Base class to handle UI overlay elements.
 */
class MapControlsUI {
    /**
     * Constructor of the UI.
     *
     * @param controls - Controls referencing a [[MapView]].
     */
    constructor(controls, options = {}) {
        this.controls = controls;
        /**
         * The DOM node containing the UI.
         */
        this.domElement = document.createElement("div");
        this.m_buttonsElement = document.createElement("div");
        /**
         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.
         */
        this.m_zoomLevelElement = null;
        /**
         * Displays zoom level if [[MapControlsUIOptions.projectionSwitch]] is defined.
         */
        this.m_projectionSwitchElement = null;
        this.m_onMapViewRenderEvent = () => {
            if (this.m_zoomLevelElement === null) {
                return;
            }
            const zoom = this.controls.zoomLevelTargeted.toFixed(1);
            if (this.m_zoomLevelElement.tagName === "INPUT") {
                this.m_zoomLevelElement.value = zoom;
            }
            else {
                this.m_zoomLevelElement.innerHTML = zoom;
            }
        };
        this.m_onWindowClick = (event) => {
            const input = this.m_zoomLevelElement;
            if (!event ||
                !event.target ||
                !event.target.contains ||
                event.target === input ||
                event.target.contains(input)) {
                return;
            }
            input.blur();
        };
        // Empty element to dynamically align the controls vertically, depending on which buttons
        // are enabled. Avoids unreliable style computations in the script.
        const verticalAligner = document.createElement("span");
        verticalAligner.className = "harp-gl_v-align";
        this.domElement.appendChild(verticalAligner);
        // This element will receive the controls and ensure the vertical alignment in the CSS.
        this.m_buttonsElement = document.createElement("div");
        this.m_buttonsElement.className = "harp-gl_v-aligned";
        this.domElement.appendChild(this.m_buttonsElement);
        const zoomInButton = document.createElement("button");
        zoomInButton.innerText = "+";
        zoomInButton.className = "harp-gl_controls_button-top";
        zoomInButton.classList.add("harp-gl_controls-button");
        const zoomOutButton = document.createElement("button");
        zoomOutButton.innerText = "-";
        zoomOutButton.className = "harp-gl_controls_button-bottom";
        zoomOutButton.classList.add("harp-gl_controls-button");
        const tiltButton = document.createElement("button");
        tiltButton.innerText = "3D";
        tiltButton.id = "harp-gl_controls_tilt-button-ui";
        tiltButton.title = "Toggle tilt";
        tiltButton.classList.add("harp-gl_controls-button");
        tiltButton.classList.add("harp-gl_controls_button-bottom");
        const compassButton = document.createElement("button");
        compassButton.id = "harp-gl_controls-button_compass";
        compassButton.title = "Reset North";
        compassButton.classList.add("harp-gl_controls-button");
        compassButton.classList.add("harp-gl_controls_button-top");
        const compass = document.createElement("span");
        compass.id = "harp-gl_controls_compass";
        compassButton.appendChild(compass);
        // Optional zoom level displaying
        if (options.zoomLevel === "show") {
            this.m_zoomLevelElement = document.createElement("div");
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        }
        else if (options.zoomLevel === "input") {
            const input = document.createElement("input");
            input.type = "number";
            input.step = "0.1"; // Avoids messages in the UI on hovering, when a tenth value exists.
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            const updateZoom = (event) => {
                controls.setZoomLevel(parseFloat(input.value));
                event.preventDefault();
            };
            input.addEventListener("blur", updateZoom);
            input.addEventListener("keypress", event => {
                if (event.key === "Enter") {
                    updateZoom(event);
                }
            });
            window.addEventListener("click", this.m_onWindowClick);
            this.m_zoomLevelElement = input;
        }
        if (options.projectionSwitch) {
            const switcher = document.createElement("button");
            switcher.id = "harp-gl_controls_switch_projection";
            switcher.classList.add("harp-gl_controls-button");
            const getTitle = () => {
                return `Switch to ${this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? "flat"
                    : "globe"} projection`;
            };
            switcher.title = getTitle();
            const globeSVG = getGlobeSVG();
            const flatMapSVG = getFlatMapSVG();
            switcher.innerHTML =
                this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? flatMapSVG
                    : globeSVG;
            switcher.addEventListener("click", () => {
                this.controls.mapView.projection =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? harp_geoutils_1.mercatorProjection
                        : harp_geoutils_1.sphereProjection;
                switcher.title = getTitle();
                switcher.innerHTML =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? flatMapSVG
                        : globeSVG;
            });
            this.m_projectionSwitchElement = switcher;
        }
        this.m_buttonsElement.appendChild(zoomInButton);
        if (this.m_zoomLevelElement !== null) {
            this.m_buttonsElement.appendChild(this.m_zoomLevelElement);
        }
        this.m_buttonsElement.appendChild(zoomOutButton);
        this.m_buttonsElement.appendChild(compassButton);
        this.m_buttonsElement.appendChild(tiltButton);
        if (this.m_projectionSwitchElement !== null) {
            this.m_buttonsElement.appendChild(this.m_projectionSwitchElement);
        }
        zoomInButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomInButton.addEventListener("dblclick", event => {
            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers
            // when a zoom button is quickly clicked multiple times.
            event.stopPropagation();
        });
        zoomOutButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomOutButton.addEventListener("dblclick", event => {
            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers
            // when a zoom button is quickly clicked multiple times.
            event.stopPropagation();
        });
        tiltButton.addEventListener("click", event => {
            controls.toggleTilt();
        });
        compassButton.addEventListener("click", event => {
            controls.pointToNorth();
        });
        controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, () => {
            compass.style.transform = `rotate(${THREE.MathUtils.radToDeg(harp_mapview_1.MapViewUtils.extractAttitude(controls.mapView, controls.mapView.camera).yaw)}deg)`;
        });
        this.domElement.className = "harp-gl_controls";
        if (this.m_zoomLevelElement !== null) {
            this.m_zoomLevelElement.classList.add("harp-gl_controls_zoom-level");
        }
        if (options.disableDefaultStyle !== true) {
            this.initStyle();
            this.domElement.style.cssText = `
                position: absolute;
                right: 5px;
                top: 0;
                height: 100%; /* Vertical alignment is done dynamically, in the rest of the CSS. */
                pointer-events: none; /* Allows to click the map even though height is 100%. */
            `;
        }
        return this;
    }
    /**
     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method
     * should be called when you stop using [[MapControlsUI]].
     */
    dispose() {
        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === "INPUT") {
            window.removeEventListener("click", this.m_onWindowClick);
        }
        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        this.domElement.remove();
    }
    initStyle() {
        if (document.getElementById("here-harp-controls.map-controls-ui-styles") !== null) {
            return;
        }
        const style = document.createElement("style");
        style.id = "here-harp-controls.map-controls-ui-styles";
        style.appendChild(document.createTextNode(getTextStyle()));
        document.head.appendChild(style);
    }
}
exports.MapControlsUI = MapControlsUI;
function getTextStyle() {
    return `
        /* CSS trick to align another div dynamically. */
        .harp-gl_v-align{
            height: 100%;
            display: inline-block;
            vertical-align: middle;
        }
        /* The target element to align vertically with vertical-align. */
        .harp-gl_v-aligned{
            pointer-events: all;
            vertical-align: middle;
            display: inline-block;
        }
        .harp-gl_controls-button {
            display: block;
            background-color: #272d37;
            width: 40px;
            height: 40px;
            font-size: 22px;
            font-weight: bold;
            outline: none;
            margin:0;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0px 0px 5px 0 hsl(220, 4%, 40%);
            transition: all 0.1s;
            padding: 0 0 1px 1px;
            user-select: none;
            position:relative;
        }
        #harp-gl_controls_tilt-button-ui {
            font-size: 16px;
        }
        .harp-gl_controls-button:active {
            background-color: #37afaa;
            color: #eee;
        }
        .harp-gl_controls-button:focus {
            outline:none;
        }
        .harp-gl_controls_button-top{
            margin-bottom:0;
            border-bottom-right-radius:0;
            border-bottom-left-radius:0;
        }
        .harp-gl_controls_button-bottom{
            margin-top:1px;
            border-top-right-radius:0;
            border-top-left-radius:0;
        }
        .harp-gl_controls_zoom-level {
            display: block;
            background-color: #fff;
            width: 40px;
            height: 20px;
            font-size: 12px;
            font-weight: bold;
            outline: none;
            border: none;
            color: #555;
            opacity: 0.87;
            box-shadow: 0px 0px 4px #aaa;
            padding: 2px 0 0;
            text-align: center;
            user-select: text;
        }
        input.harp-gl_controls_zoom-level::-webkit-outer-spin-button,
        input.harp-gl_controls_zoom-level::-webkit-inner-spin-button {
            /* display: none; <- Crashes Chrome on hover */
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }
        input.harp-gl_controls_zoom-level[type=number] {
            -moz-appearance:textfield; /* Firefox */
        }
        #harp-gl_controls-button_compass{
            overflow: hidden;
            margin: 5px 0 0 0;
        }
        #harp-gl_controls_compass{
            pointer-events:none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin:0
        }
        #harp-gl_controls_compass::after{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top: -18px;
            border:solid 3px rgba(0,0,0,0);
            border-bottom:solid 15px #a34f2e;
        }
        #harp-gl_controls_compass::before{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top:0px;
            border:solid 3px rgba(0,0,0,0);
            border-top:solid 15px #eee;
        }
        #harp-gl_controls_switch_projection{
            margin-top:5px;
        }
        .harp-gl_controls_switch_svg{
            width: 25px;
            height: 25px;
            stroke: #d4d5d7;
            fill: #d4d5d7;
        }
    `;
}
// tslint:disable:max-line-length
function getFlatMapSVG() {
    return `
    <svg style="margin-top:5px;" class="harp-gl_controls_switch_svg" width="25" height="25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <rect id="svg_1" stroke-width="2" height="13.51524" width="18.35821" y="5.80349" x="3.21307" fill="none"/>
        <path id="svg_14" d="m9.52018,7.71815l1.2357,-0.0032l-0.61945,1.18258l-0.61625,-1.17938z"/>
        <path id="svg_15" d="m4.11409,7.32396l3.65718,-0.0032l0.28156,2.13991l-2.59042,1.57678l0.50682,1.80203l2.25254,0.8447l-0.90101,2.0836l0.28157,2.25254l-3.26619,-3.04093l0.67576,-2.02728l-0.61945,-1.97097l-1.01364,-3.15356l0.73528,-0.50362z"/>
        <path id="svg_17" d="m13.23688,7.4929l2.02409,-0.0032l0.78839,1.29521l2.47779,-1.35152l2.75936,0.78839l0,1.57678l-0.73208,0.61945l-0.28157,1.97097c0,0 -0.67256,0.8479 -0.72888,0.90422c-0.05631,0.05631 0.28157,1.06996 0.33788,1.18258c0.05631,0.11263 -1.68941,-1.35152 -1.6926,-1.35472c-0.0032,-0.0032 -0.16574,1.29841 -0.16894,1.29521c-0.0032,-0.0032 -1.57358,-1.34832 -1.57678,-1.35152c-0.0032,-0.0032 -0.72888,0.67896 -0.73208,0.67576c-0.0032,-0.0032 -0.8415,-0.67256 -0.8447,-0.67576c-0.0032,-0.0032 0.73528,2.0868 0.79159,2.0868c0.05631,0 -0.50682,3.20987 -0.51002,3.20667c-0.0032,-0.0032 -1.2357,-0.16574 -1.34832,-0.16574c-0.11263,0 -0.95733,-1.52046 -0.90102,-1.57678c0.05631,-0.05631 0,-1.80203 -0.0032,-1.80523c-0.0032,-0.0032 -1.40464,-0.33468 -1.40784,-0.33788c-0.0032,-0.0032 -0.05311,-1.74252 -0.05631,-1.74572c-0.0032,-0.0032 1.18578,-0.8415 1.18258,-0.8447c-0.0032,-0.0032 1.69261,-0.16574 1.74892,-0.16574c0.05631,0 1.2389,-1.06996 1.2357,-1.07316c-0.0032,-0.0032 -1.91146,-0.10943 -1.91466,-0.11263c-0.0032,-0.0032 -1.96777,0.17214 -1.97097,0.16894c-0.0032,-0.0032 1.52366,-3.20667 1.52366,-3.20667z"/>
    </svg>`;
}
function getGlobeSVG() {
    return `
    <svg style="margin-top:5px;" stroke-width="2" class="harp-gl_controls_switch_svg" width="50" height="50" viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <ellipse ry="9.79855" rx="4.56139" id="svg_6" cy="11.99798" cx="11.99798" fill="none"/>
        <line id="svg_8" y2="8.16866" x2="21.12086" y1="8.16866" x1="3.10044"/>
        <line id="svg_9" y2="16.10887" x2="21.0645" y1="16.10887" x1="3.04409"/>
        <ellipse id="svg_11" ry="9.79855" rx="9.82671" cy="11.94167" cx="12.02614" fill="none"/>
    </svg>`;
}
//# sourceMappingURL=MapControlsUI.js.map

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/Utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/Utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWidthAndHeightFromCanvas = exports.safeParseDecimalInt = exports.azimuthAltitudeToDirection = exports.calculateNormalizedDeviceCoordinates = void 0;
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Transforms the given point in screen space into NDC space by taking the given screen dimension
 * into account.
 *
 * @param screenCoordinateX - X coordinate in screen space.
 * @param screenCoordinateY - Y coordinate in screen space.
 * @param screenSizeX - Width of the reference screen size.
 * @param screenSizeY - Height of the reference screen size.
 */
function calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {
    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);
}
exports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;
/**
 * Returns the direction vector that is described by the given azimuth and altitude.
 *
 * @param azimuth - Azimuth in radians.
 * @param altitude - Altitude in radians.
 */
function azimuthAltitudeToDirection(azimuth, altitude) {
    azimuth = azimuth;
    altitude = altitude;
    //Shamelessly copied from Jan ;)
    const result = new three_1.Vector3();
    const cosAltitude = Math.cos(altitude);
    result.setX(Math.sin(azimuth) * cosAltitude);
    result.setY(Math.cos(azimuth) * cosAltitude);
    result.setZ(Math.sin(altitude));
    return result;
}
exports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;
/**
 * Safely parses decimal value into `number`.
 *
 * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings
 * with characters other than digits.
 *
 * @param text - Number as a text to be parsed.
 * @param fallback - Default value, which is returned if `text` doesn't represent a valid number.
 */
function safeParseDecimalInt(text, fallback) {
    if (text === null || text === undefined || text === "") {
        return fallback;
    }
    if (!text.match(integerRe)) {
        return fallback;
    }
    const result = Number.parseInt(text, 10);
    if (isNaN(result)) {
        return fallback;
    }
    return result;
}
exports.safeParseDecimalInt = safeParseDecimalInt;
const integerRe = /^\d+$/;
/**
 * Extracts the CSS width and height of the given canvas if available, or width and height of the
 * canvas otherwise.
 *
 * @param canvas - The canvas.
 */
function getWidthAndHeightFromCanvas(canvas) {
    return {
        //use clientWidth and clientHeight to support HiDPI devices
        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),
        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)
    };
}
exports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Decoder worker for {@ref MapView}.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/DataProvider */ "./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileDataSource */ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileLoader */ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/DataProvider.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
//# sourceMappingURL=DataProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDataSource = exports.TileFactory = void 0;
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const TileLoader_1 = __webpack_require__(/*! ./TileLoader */ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource - [[Datasource]] this class belongs to.
     * @param tileKey - Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        return new this.m_modelConstructor(dataSource, tileKey);
    }
}
exports.TileFactory = TileFactory;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory - Factory to create the [[Tile]] instances.
     * @param m_options - Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        super({
            name: m_options.name,
            styleSetName: m_options.styleSetName,
            // tslint:disable-next-line: deprecation
            minZoomLevel: m_options.minZoomLevel,
            // tslint:disable-next-line: deprecation
            maxZoomLevel: m_options.maxZoomLevel,
            minDataLevel: m_options.minDataLevel,
            maxDataLevel: m_options.maxDataLevel,
            minDisplayLevel: m_options.minDisplayLevel,
            maxDisplayLevel: m_options.maxDisplayLevel,
            storageLevelOffset: m_options.storageLevelOffset,
            allowOverlappingTiles: m_options.allowOverlappingTiles
        });
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.useGeometryLoader = true;
        this.cacheable = true;
    }
    /** @override */
    dispose() {
        this.decoder.dispose();
    }
    /** @override */
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    /** @override */
    async connect() {
        await Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);
        this.m_isReady = true;
        this.m_decoder.configure(undefined, undefined, undefined, {
            storageLevelOffset: this.m_options.storageLevelOffset
        });
    }
    /** @override */
    setStyleSet(styleSet, definitions, languages) {
        this.m_decoder.configure(styleSet, definitions, languages);
        this.mapView.markTilesDirty(this);
    }
    /**
     * Apply the [[Theme]] to this data source.
     *
     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see
     * `styleSetName` property) is found in `theme`.
     * @override
     */
    setTheme(theme, languages) {
        const styleSet = this.styleSetName !== undefined && theme.styles
            ? theme.styles[this.styleSetName]
            : undefined;
        if (styleSet !== undefined) {
            this.setStyleSet(styleSet, theme.definitions, languages);
        }
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    /** @override */
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is
     * initialized with default copyrights, concatenated with copyrights from copyright provider of
     * this data source.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @override
     */
    getTile(tileKey) {
        const tile = this.m_tileFactory.create(this, tileKey);
        tile.tileLoader = new TileLoader_1.TileLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
        tile.copyrightInfo = this.m_options.copyrightInfo;
        if (this.m_options.copyrightProvider !== undefined) {
            this.m_options.copyrightProvider
                .getCopyrights(tile.geoBox, tileKey.level)
                .then(copyrightInfo => {
                tile.copyrightInfo =
                    tile.copyrightInfo === undefined
                        ? copyrightInfo
                        : [...tile.copyrightInfo, ...copyrightInfo];
                this.requestUpdate();
            });
        }
        tile.load();
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
}
exports.TileDataSource = TileDataSource;
//# sourceMappingURL=TileDataSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TileInfoLoader = exports.TileLoader = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * Logger to write to console etc.
 */
const logger = harp_utils_1.LoggerManager.instance.create("TileLoader");
/**
 * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by
 * the [[TileDataSource]].
 */
class TileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource - The [[DataSource]] the tile belongs to.
     * @param tileKey - The quadtree address of a [[Tile]].
     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.
     * @param tileDecoder - The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].
     * @param priority - The priority given to the loading job. Highest number will be served first.
     */
    constructor(dataSource, tileKey, dataProvider, tileDecoder, priority) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.dataProvider = dataProvider;
        this.tileDecoder = tileDecoder;
        this.priority = priority;
        /**
         * Current state of `TileLoader`.
         */
        this.state = harp_mapview_1.TileLoaderState.Initialized;
        /**
         * The abort controller notifying the [[DataProvider]] to cancel loading.
         */
        this.loadAbortController = new AbortController();
    }
    /**
     * Start loading and/or proceed through the various states of loading of this tile.
     *
     * @returns A promise which resolves the [[TileLoaderState]].
     */
    loadAndDecode() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
            case harp_mapview_1.TileLoaderState.Loaded:
            case harp_mapview_1.TileLoaderState.Decoding:
                // tile is already loading
                return this.donePromise;
            case harp_mapview_1.TileLoaderState.Ready:
            case harp_mapview_1.TileLoaderState.Failed:
            case harp_mapview_1.TileLoaderState.Initialized:
            case harp_mapview_1.TileLoaderState.Canceled:
                // restart loading
                this.startLoading();
                return this.donePromise;
        }
    }
    /**
     * Return the current state in form of a promise. Caller can then wait for the promise to be
     * resolved.
     *
     * @returns A promise which resolves the current [[TileLoaderState]].
     */
    waitSettled() {
        if (!this.donePromise) {
            return Promise.resolve(this.state);
        }
        return this.donePromise;
    }
    /**
     * Cancel loading of the [[Tile]].
     * Cancellation token is notified, an internal state is cleaned up.
     */
    cancel() {
        switch (this.state) {
            case harp_mapview_1.TileLoaderState.Loading:
                this.loadAbortController.abort();
                this.loadAbortController = new AbortController();
                break;
            case harp_mapview_1.TileLoaderState.Decoding:
                if (this.requestController) {
                    this.requestController.abort();
                    this.requestController = undefined;
                }
                break;
        }
        this.onDone(harp_mapview_1.TileLoaderState.Canceled);
    }
    /**
     * Return `true` if [[Tile]] is still loading, `false` otherwise.
     */
    get isFinished() {
        return (this.state === harp_mapview_1.TileLoaderState.Ready ||
            this.state === harp_mapview_1.TileLoaderState.Canceled ||
            this.state === harp_mapview_1.TileLoaderState.Failed);
    }
    /**
     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests
     * in the request queue (used during heavy load).
     */
    updatePriority(priority) {
        this.priority = priority;
        if (this.requestController !== undefined) {
            this.requestController.priority = priority;
        }
    }
    /**
     * Start loading. Only call if loading did not start yet.
     */
    startLoading() {
        const myLoadCancellationToken = this.loadAbortController.signal;
        this.dataProvider
            .getTile(this.tileKey, myLoadCancellationToken)
            .then(payload => {
            if (myLoadCancellationToken.aborted) {
                // safety belt if getTile doesn't really support cancellation tokens
                const err = new Error("Aborted");
                err.name = "AbortError";
                throw err;
            }
            this.onLoaded(payload);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                return;
            }
            this.onError(error);
        });
        if (this.donePromise === undefined) {
            this.donePromise = new Promise((resolve, reject) => {
                this.resolveDonePromise = resolve;
                this.rejectedDonePromise = reject;
            });
        }
        this.state = harp_mapview_1.TileLoaderState.Loading;
    }
    /**
     * Called when binary data has been loaded. The loading state is now progressing to decoding.
     *
     * @param payload - Binary data in form of [[ArrayBufferLike]], or any object.
     */
    onLoaded(payload) {
        this.state = harp_mapview_1.TileLoaderState.Loaded;
        this.payload = payload;
        const byteLength = payload.byteLength;
        if (byteLength === 0 ||
            (payload.constructor === Object && Object.keys(payload).length === 0)) {
            // Object is empty
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
            return;
        }
        // TBD: we might suspend decode if tile is not visible ... ?
        this.startDecodeTile();
    }
    /**
     * Start decoding the payload.
     */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)
            .then(decodedTile => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.onDecoded(decodedTile);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
    /**
     * Called when the decoding is finished, and the [[DecodedTile]] has been created.
     *
     * @param decodedTile - The [[DecodedTile]].
     */
    onDecoded(decodedTile) {
        this.decodedTile = decodedTile;
        this.onDone(harp_mapview_1.TileLoaderState.Ready);
    }
    /**
     * Cancel the decoding process.
     */
    cancelDecoding() {
        if (this.requestController !== undefined) {
            // we should cancel any decodes already in progress!
            this.requestController.abort();
            this.requestController = undefined;
        }
    }
    /**
     * Called when loading and decoding has finished successfully. Resolves loading promise if the
     * state is Ready, otherwise it rejects the promise with the supplied state.
     *
     * @param doneState - The latest state of loading.
     */
    onDone(doneState) {
        if (this.resolveDonePromise && doneState === harp_mapview_1.TileLoaderState.Ready) {
            this.resolveDonePromise(doneState);
        }
        else if (this.rejectedDonePromise) {
            this.rejectedDonePromise(doneState);
        }
        this.resolveDonePromise = undefined;
        this.rejectedDonePromise = undefined;
        this.donePromise = undefined;
        this.state = doneState;
    }
    /**
     * Called when loading or decoding has finished with an error.
     *
     * @param error - Error object describing the failing.
     */
    onError(error) {
        if (this.state === harp_mapview_1.TileLoaderState.Canceled) {
            // If we're canceled, we should simply ignore any state transitions and errors from
            // underlying load/decode ops.
            return;
        }
        const dataSource = this.dataSource;
        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);
        this.error = error;
        this.onDone(harp_mapview_1.TileLoaderState.Failed);
    }
}
exports.TileLoader = TileLoader;
/**
 * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta
 * data, not the tile data itself.
 */
class TileInfoLoader extends TileLoader {
    /** @override */
    startDecodeTile() {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileInfoLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = harp_mapview_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)
            .then(tileInfo => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.tileInfo = tileInfo;
            this.onDone(harp_mapview_1.TileLoaderState.Ready);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            this.onError(error);
        });
    }
}
exports.TileInfoLoader = TileInfoLoader;
//# sourceMappingURL=TileLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@here/harp-mapview/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Functionality needed to render a map.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/CameraMovementDetector */ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ClipPlanesEvaluator */ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/composing */ "./node_modules/@here/harp-mapview/lib/composing/index.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightElementHandler */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightProvider */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightCoverageProvider */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/UrlCopyrightProvider */ "./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DataSource */ "./node_modules/@here/harp-mapview/lib/DataSource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/PolarTileDataSource */ "./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DepthPrePass */ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DisplacementMap */ "./node_modules/@here/harp-mapview/lib/DisplacementMap.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ElevationProvider */ "./node_modules/@here/harp-mapview/lib/ElevationProvider.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ElevationRangeSource */ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/Image */ "./node_modules/@here/harp-mapview/lib/image/Image.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/ImageCache */ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/MapViewImageCache */ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapAnchors */ "./node_modules/@here/harp-mapview/lib/MapAnchors.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewAtmosphere */ "./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewFog */ "./node_modules/@here/harp-mapview/lib/MapViewFog.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/poi/Poi */ "./node_modules/@here/harp-mapview/lib/poi/Poi.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/poi/PoiManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/poi/PoiTableManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TextureLoader */ "./node_modules/@here/harp-mapview/lib/TextureLoader.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThemeLoader */ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/geometry/TileGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/VisibleTileSet */ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerBasedTiler */ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/workers/WorkerLoader */ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimatedExtrusionHandler = exports.AnimatedExtrusionState = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * Animation states for extrusion effect
 */
var AnimatedExtrusionState;
(function (AnimatedExtrusionState) {
    AnimatedExtrusionState[AnimatedExtrusionState["None"] = 0] = "None";
    AnimatedExtrusionState[AnimatedExtrusionState["Started"] = 1] = "Started";
    AnimatedExtrusionState[AnimatedExtrusionState["Finished"] = 2] = "Finished";
})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));
const DEFAULT_EXTRUSION_DURATION = 750; // milliseconds
const DEFAULT_MIN_ZOOM_LEVEL = 16;
/**
 * Handles animated extrusion effect of the buildings in {@link MapView}.
 */
class AnimatedExtrusionHandler {
    /**
     * Creates an {@link AnimatedExtrusionHandler} in {@link MapView}.
     *
     * @param m_mapView - Instance of {@link MapView} on which the animation will run.
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
        /**
         * Animate the extrusion of the buildings if set to `true`.
         */
        this.enabled = true;
        /**
         * Duration of the building's extrusion in milliseconds
         */
        this.duration = DEFAULT_EXTRUSION_DURATION;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_forceEnabled = false;
        // key is tile's morton code.
        this.m_tileMap = new Map();
        this.m_state = AnimatedExtrusionState.None;
        this.m_startTime = -1;
    }
    /**
     * Returns whether the extrusion animation is force enabled or not.
     */
    get forceEnabled() {
        return this.m_forceEnabled;
    }
    /**
     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`
     * values from [[extrudedPolygonTechnique]] will be ignored and
     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used
     */
    set forceEnabled(force) {
        this.m_forceEnabled = force;
        this.duration = DEFAULT_EXTRUSION_DURATION;
    }
    /**
     * Gets min zoom level at which extruded animation is enabled.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * Sets the extrusion animation properties obtained from a given technique.
     * @internal
     * @param technique - The technique where the extrusion animation properties are defined.
     * @param env - The environment used to evaluate technique properties.
     * @returns True if the technique has animation enabled (or animation is forced), false
     * otherwise.
     */
    setAnimationProperties(technique, env) {
        if (!harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
            return false;
        }
        if ("minZoomLevel" in technique) {
            this.m_minZoomLevel = technique.minZoomLevel;
        }
        if (this.forceEnabled) {
            return this.enabled;
        }
        if (technique.animateExtrusionDuration !== undefined) {
            this.duration = technique.animateExtrusionDuration;
        }
        const animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, env);
        if (animateExtrusionValue === null) {
            return this.enabled;
        }
        return typeof animateExtrusionValue === "boolean"
            ? animateExtrusionValue
            : typeof animateExtrusionValue === "number"
                ? animateExtrusionValue !== 0
                : false;
    }
    /**
     * Updates the extrusion animation for every frame.
     * @internal
     */
    update(zoomLevel) {
        const extrusionVisible = this.m_tileMap.size > 0 && zoomLevel >= this.m_minZoomLevel;
        if (this.m_state === AnimatedExtrusionState.None && extrusionVisible) {
            this.m_state = AnimatedExtrusionState.Started;
        }
        else if (this.m_state !== AnimatedExtrusionState.None && !extrusionVisible) {
            this.resetAnimation(true);
        }
        this.animateExtrusion();
    }
    /**
     * Adds a tile to be animated.
     * @internal
     * @param tile - The tile to be animated.
     * @param materials - Extruded materials belonging to the tile.
     */
    add(tile, materials) {
        tile.addDisposeCallback(this.removeTile.bind(this));
        let animated = false;
        if (this.m_state !== AnimatedExtrusionState.None) {
            animated = this.skipAnimation(tile);
            if (animated) {
                // Set extrusion ratio to 1 if the tile skips the animation.
                this.setTileExtrusionRatio(materials, 1);
            }
            else if (this.m_state === AnimatedExtrusionState.Finished) {
                // Otherwise, if animation was finished, restart animation but leave already
                //  animated tiles untouched.
                this.resetAnimation(false);
            }
        }
        this.m_tileMap.set(tile.tileKey.mortonCode(), { materials, animated });
    }
    /**
     * Is `true` if there's any extrusion animation ongoing.
     */
    get isAnimating() {
        return (this.m_state !== AnimatedExtrusionState.Finished &&
            this.m_state !== AnimatedExtrusionState.None);
    }
    skipAnimation(tile) {
        return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);
    }
    wasAnyAncestorAnimated(tile) {
        var _a, _b;
        const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);
        const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);
        const levelsUp = Math.min(distanceToMinLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp);
        let lastTileKey = tile.tileKey;
        for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {
            lastTileKey = lastTileKey.parent();
            if ((_b = (_a = this.m_tileMap.get(lastTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {
                return true;
            }
        }
        return false;
    }
    wasAnyDescendantAnimated(tile) {
        var _a, _b;
        const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;
        const levelsDown = Math.min(distanceToMaxLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown);
        const tilingScheme = tile.dataSource.getTilingScheme();
        let nextTileKeys = [tile.tileKey];
        let childTileKeys = [];
        for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {
            childTileKeys.length = 0;
            for (const tileKey of nextTileKeys) {
                for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                    if ((_b = (_a = this.m_tileMap.get(childTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {
                        return true;
                    }
                    childTileKeys.push(childTileKey);
                }
            }
            // swap
            [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];
        }
        return false;
    }
    removeTile(tile) {
        this.m_tileMap.delete(tile.tileKey.mortonCode());
    }
    animateExtrusion() {
        if (this.m_state !== AnimatedExtrusionState.Started) {
            return;
        }
        const currentTime = Date.now();
        if (this.m_startTime < 0) {
            this.m_startTime = currentTime;
        }
        const duration = this.duration;
        const timeProgress = Math.min(currentTime - this.m_startTime, duration);
        const extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / duration);
        this.setExtrusionRatio(extrusionRatio);
        if (timeProgress >= duration) {
            this.m_state = AnimatedExtrusionState.Finished;
        }
        this.m_mapView.update();
    }
    resetAnimation(resetTiles) {
        this.m_state = AnimatedExtrusionState.None;
        this.m_startTime = -1;
        if (resetTiles) {
            this.m_tileMap.forEach(state => {
                state.animated = false;
            });
        }
    }
    setExtrusionRatio(value) {
        this.m_tileMap.forEach(state => {
            if (!state.animated) {
                this.setTileExtrusionRatio(state.materials, value);
                if (value >= 1) {
                    state.animated = true;
                }
            }
        });
    }
    setTileExtrusionRatio(materials, value) {
        materials.forEach(material => {
            material.extrusionRatio = value;
        });
    }
}
exports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;
//# sourceMappingURL=AnimatedExtrusionHandler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundDataSource = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "./node_modules/@here/harp-mapview/lib/DataSource.js");
const TileGeometryCreator_1 = __webpack_require__(/*! ./geometry/TileGeometryCreator */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js");
/**
 * Provides background geometry for all tiles.
 */
let BackgroundDataSource = /** @class */ (() => {
    class BackgroundDataSource extends DataSource_1.DataSource {
        constructor() {
            super({ name: "background" });
            this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;
            this.cacheable = true;
            this.addGroundPlane = true;
        }
        updateStorageLevelOffset() {
            let storageLevelOffset;
            this.mapView.dataSources.forEach(ds => {
                if (ds === this) {
                    return;
                }
                const tilingScheme = ds.getTilingScheme();
                if (tilingScheme === this.m_tilingScheme) {
                    storageLevelOffset =
                        storageLevelOffset === undefined
                            ? ds.storageLevelOffset
                            : Math.max(storageLevelOffset, ds.storageLevelOffset);
                }
            });
            if (storageLevelOffset === undefined) {
                storageLevelOffset = 0;
            }
            if (storageLevelOffset !== this.storageLevelOffset) {
                this.storageLevelOffset = storageLevelOffset;
                this.mapView.clearTileCache(this.name);
            }
        }
        /** @override */
        setTheme(theme, languages) {
            this.mapView.clearTileCache(this.name);
        }
        setTilingScheme(tilingScheme) {
            const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;
            if (newScheme === this.m_tilingScheme) {
                return;
            }
            this.m_tilingScheme = newScheme;
            this.updateStorageLevelOffset();
            this.mapView.clearTileCache(this.name);
        }
        /** @override */
        getTilingScheme() {
            return this.m_tilingScheme;
        }
        /** @override */
        getTile(tileKey) {
            const tile = new Tile_1.Tile(this, tileKey);
            tile.forceHasGeometry(true);
            tile.removeDecodedTile(); // Skip geometry loading.
            TileGeometryCreator_1.TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);
            return tile;
        }
    }
    BackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;
    return BackgroundDataSource;
})();
exports.BackgroundDataSource = BackgroundDataSource;
//# sourceMappingURL=BackgroundDataSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraMovementDetector = void 0;
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
/**
 * The default value for camera movement throttling, in milliseconds.
 */
const DEFAULT_THROTTLING_TIMEOUT = 300;
/**
 * The `CameraMovementDetector` class checks for changes in camera position and orientation, to
 * detect continuous movements without the animation mode activated in {@link MapView}. If the
 * interaction is not continuous enough, you can use a throttling timer to reduce the number of
 * callbacks.
 */
class CameraMovementDetector {
    /**
     * Initializes the detector with timeout value and callbacks. {@link MapView} also provides
     * events for client code to be notified when these cues occur.
     *
     * @param m_throttlingTimeout - The delay, in milliseconds, between the last user interaction
     * detected and the call to `m_movementFinishedFunc`; the default is `300`.
     * @param m_movementStartedFunc - Callback function, called when the user starts interacting.
     * @param m_movementFinishedFunc - Callback function, called when the user stops interacting.
     */
    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        this.m_lastCameraPos = new three_1.Vector3();
        this.m_newCameraPos = new three_1.Vector3();
        this.m_throttlingTimerId = undefined;
        this.m_movementDetectorDeadline = 0;
        this.onDeadlineTimer = () => {
            this.m_throttlingTimerId = undefined;
            const now = performance.now();
            if (now >= this.m_movementDetectorDeadline) {
                this.movementFinished();
            }
            else {
                this.startMovementFinishedTimer(now);
            }
        };
        if (this.m_throttlingTimeout === undefined) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    /**
     * Checks if the camera has moved since the last time it was checked. The
     * `m_movementStartedFunc` is called when a movement starts. If no movement
     * is detected, a timer for `m_movementFinishedFunc` starts.
     *
     * @param mapView - [[Mapview]]'s position and camera are checked for modifications.
     */
    checkCameraMoved(mapView, now) {
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        if (this.m_lastAttitude === undefined) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
            return false;
        }
        const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) ||
            newAttitude.yaw !== this.m_lastAttitude.yaw ||
            newAttitude.pitch !== this.m_lastAttitude.pitch ||
            newAttitude.roll !== this.m_lastAttitude.roll;
        if (cameraMoved) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
        }
        if (cameraMoved !== this.m_cameraMovedLastFrame) {
            if (cameraMoved) {
                this.movementStarted();
            }
            this.m_cameraMovedLastFrame = cameraMoved;
        }
        if (cameraMoved) {
            // Start timer
            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;
            this.startMovementFinishedTimer(now);
        }
        return this.m_cameraMovedLastFrame;
    }
    /**
     * Reset the saved camera position. Next time checkCameraMoved is called, it will return
     * `false`.
     */
    clear(mapView) {
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        this.m_lastAttitude = newAttitude;
    }
    /**
     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.
     */
    forceMoved() {
        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
    }
    /**
     * Returns `true` if the camera of this {@link MapView} is currently moving. In this case the
     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.
     */
    get cameraIsMoving() {
        return this.m_throttlingTimerId !== undefined;
    }
    /**
     * Disposes resources and kills the throttling timer.
     */
    dispose() {
        this.removeMovementFinishedTimer();
        this.m_movementStartedFunc = undefined;
        this.m_movementFinishedFunc = undefined;
    }
    /**
     * Returns `true` if the camera has moved in the last frame.
     */
    get cameraMovedLastFrame() {
        return this.m_cameraMovedLastFrame === true;
    }
    movementStarted() {
        if (this.m_movementStartedFunc !== undefined) {
            this.m_movementStartedFunc();
        }
    }
    movementFinished() {
        this.removeMovementFinishedTimer();
        if (this.m_movementFinishedFunc !== undefined) {
            this.m_movementFinishedFunc();
        }
    }
    startMovementFinishedTimer(now) {
        if (this.m_throttlingTimerId === undefined) {
            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);
            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
        }
    }
    removeMovementFinishedTimer() {
        if (this.m_throttlingTimerId !== undefined) {
            clearTimeout(this.m_throttlingTimerId);
            this.m_throttlingTimerId = undefined;
        }
    }
}
exports.CameraMovementDetector = CameraMovementDetector;
//# sourceMappingURL=CameraMovementDetector.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDefaultClipPlanesEvaluator = exports.FixedClipPlanesEvaluator = exports.TiltViewClipPlanesEvaluator = exports.TopViewClipPlanesEvaluator = exports.ElevationBasedClipPlanesEvaluator = exports.InterpolatedClipPlanesEvaluator = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
const epsilon = 0.000001;
/**
 * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.
 *
 * At general ground distance to camera along the surface normal is used as reference point for
 * planes evaluation, where near plane distance is set as fraction of this distance refereed as
 * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],
 * which is applied to near plane and offset giving finally far plane distance.
 * This evaluator supports both planar and spherical projections, although it's behavior is
 * slightly different in each case. General algorithm sets near plane between camera and
 * ground level, while far plane is just calculated using scale and bias approach with far offset
 * and multiplier.
 * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which
 * is widely used in examples thus is still kept for backward compatibility and comparisons.
 */
class InterpolatedClipPlanesEvaluator {
    constructor(nearMin = 0.1, nearMultiplier = 0.1, nearFarMultiplier = 50.0, farOffset = 200.0) {
        this.nearMin = nearMin;
        this.nearMultiplier = nearMultiplier;
        this.nearFarMultiplier = nearFarMultiplier;
        this.farOffset = farOffset;
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMultiplier >= 0);
        harp_utils_1.assert(farOffset >= 0);
        this.farMin = nearMin * nearFarMultiplier + farOffset;
    }
    // tslint:disable-next-line: no-empty
    set minElevation(elevation) { }
    get minElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    // tslint:disable-next-line: no-empty
    set maxElevation(elevation) { }
    get maxElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    evaluateClipPlanes(camera, projection, elevationProvider) {
        let nearPlane = this.nearMin;
        let farPlane = this.farMin;
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // near and far plane for a set up where
            // the camera is looking at the center of the scene.
            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
            const d = camera.position.length();
            const alpha = Math.asin(r / d);
            // Extract X, Y, Z axes into tmp vectors array.
            camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
            // Setup quaternion based on X axis.
            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);
            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).
            const fwd = this.m_tmpVectors[2].negate();
            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].
            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);
            // Store camera position tmpVectors[0] and reference it with p.
            const p = this.m_tmpVectors[0].copy(camera.position);
            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));
            farPlane = p.sub(camera.position).dot(fwd) + this.farOffset;
            nearPlane = Math.max(this.nearMin, projection.groundDistance(camera.position) * this.nearMultiplier);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const groundDistance = projection.groundDistance(camera.position);
            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);
            // Will be already clamped to minFar due to clamping above.
            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;
        }
        else {
            harp_utils_1.assert(false, "Unsupported projection type");
        }
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: farPlane
        };
        return viewRanges;
    }
}
exports.InterpolatedClipPlanesEvaluator = InterpolatedClipPlanesEvaluator;
/**
 * Abstract evaluator class that adds support for elevation constraints.
 *
 * Classes derived from this should implement algorithms that takes into account rendered
 * features height (elevations), such as ground plane is no more flat (or spherical), but
 * contains geometry that should be overlapped by frustum planes.
 */
class ElevationBasedClipPlanesEvaluator {
    constructor(maxElevation, minElevation) {
        harp_utils_1.assert(maxElevation >= minElevation);
        this.m_minElevation = minElevation;
        this.m_maxElevation = maxElevation;
    }
    /**
     * Set maximum elevation above sea level to be rendered.
     *
     * @param elevation - the elevation (altitude) value in world units (meters).
     * @note If you set this exactly to the maximum rendered feature height (altitude above
     * the sea, you may notice some flickering or even polygons disappearing related to rounding
     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little
     * bit offset to your assumed maximum elevation.
     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values
     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and
     * [[EarthConstant.MAX_ELEVATION]] respectively.
     * @see minElevation for more information about precision and rounding errors.
     */
    set maxElevation(elevation) {
        this.m_maxElevation = elevation;
        // Min elevation should be at least equal or smaller to max elevation.
        this.m_minElevation = Math.min(elevation, this.m_minElevation);
    }
    /**
     * Get maximum elevation to be covered by camera frustum.
     */
    get maxElevation() {
        return this.m_maxElevation;
    }
    /**
     * Set minimum elevation to be rendered, values beneath the sea level are negative.
     *
     * @param elevation - the minimum elevation (depression) in world units (meters).
     * @note If you set this parameter to zero you may not see any features rendered if they are
     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to
     * -100m and rendered features lays exactly in such depression, you may notice that problem.
     * The errors usually come from projection precision loss and depth buffer nature (significant
     * precision loss closer to far plane). Thus is such cases either increase the margin (if you
     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].
     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes
     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is
     * the highest point our planet.
     * @see https://developer.nvidia.com/content/depth-precision-visualized
     */
    set minElevation(elevation) {
        this.m_minElevation = elevation;
        // Max elevation should be at least equal or bigger than min elevation.
        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
    }
    /**
     * Get minimum elevation to be covered by camera frustum.
     */
    get minElevation() {
        return this.m_minElevation;
    }
}
exports.ElevationBasedClipPlanesEvaluator = ElevationBasedClipPlanesEvaluator;
/**
 * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.
 *
 * This evaluator supports both planar and spherical projections, although it behavior is
 * slightly different in each case. General algorithm sets near plane and far plane close
 * to ground level, but taking into account maximum and minimum elevation of features on the ground.
 *
 * @note This evaluator supports only cameras which are always looking down the ground surface
 * (top-down view) along surface normal and does not preserve correct clip planes when
 * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera
 * settings.
 */
class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {
    /**
     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea
     * level as also minimum near plane and maximum far plane distance constraints.
     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near
     * and far planes to avoid flickering.
     * @param maxElevation - defines near plane offset from the ground in the surface normal
     * direction, positive values allows to render elevated terrain features (mountains,
     * buildings). Defaults to Burj Khalifa building height.
     * @param minElevation - defines far plane offset from the ground surface, negative values moves
     * far plane below the ground level (use it to render depressions). Default zero - sea level.
     * @param nearMin - minimum allowable near plane distance from camera, must be bigger than zero.
     * @param nearFarMarginRatio - minimum distance between near and far plane, as a ratio of
     * average near/far plane distance, it have to be significantly bigger than zero (especially if
     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when
     * rendering, or even render empty scene if frustum planes are almost equal.
     * @param farMaxRatio - maximum ratio between ground and far plane distance, allows to limit
     * viewing distance at overall. Have to be bigger than 1.0.
     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation
     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],
     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires
     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes
     * anyway.
     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and
     * minimum renderable elevation respectively along the surface normal, when camera is
     * constantly looking downwards (top-down view). If you need {@link ClipPlanesEvaluator} for
     * cameras that support tilt or yaw please use {@link TiltViewClipPlanesEvaluator}.
     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,
     * the algorithm used there estimates distance to point on tangent where line from camera
     * touches the sphere horizon and there is no reason to clamp it.
     */
    constructor(maxElevation = harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1.0, nearFarMarginRatio = 0.05, farMaxRatio = 6.0) {
        super(maxElevation, minElevation);
        this.nearMin = nearMin;
        this.nearFarMarginRatio = nearFarMarginRatio;
        this.farMaxRatio = farMaxRatio;
        /**
         * Helper for reducing number of objects created at runtime.
         */
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        /**
         * Helper object for reducing performance impact.
         */
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMarginRatio > epsilon);
        harp_utils_1.assert(farMaxRatio > 1.0);
        const nearFarMargin = nearFarMarginRatio * nearMin;
        this.m_minimumViewRange = {
            near: nearMin,
            far: nearMin + nearFarMargin,
            minimum: this.nearMin,
            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
        };
    }
    /** @override */
    evaluateClipPlanes(camera, projection, elevationProvider) {
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            return this.evaluateDistanceSphericalProj(camera, projection, elevationProvider);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            return this.evaluateDistancePlanarProj(camera, projection, elevationProvider);
        }
        harp_utils_1.assert(false, "Unsupported projection type");
        return Object.assign({}, this.minimumViewRange);
    }
    /**
     * Get minimum view range that is possible to achieve with current evaluator settings.
     * @note This value will not change after evaluator is constructed.
     */
    get minimumViewRange() {
        return this.m_minimumViewRange;
    }
    /**
     * Calculate camera altitude (closest distance) to ground level in world units.
     * @param camera -
     * @param projection -
     */
    getCameraAltitude(camera, projection) {
        return projection.groundDistance(camera.position);
    }
    evaluateDistancePlanarProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // Calculate distance to closest point on the ground.
        const groundDistance = this.getCameraAltitude(camera, projection);
        const farMax = groundDistance * this.farMaxRatio;
        // We could at least try to keep margins along the eye vector (center of the view) in
        // tact with pitch angle changes, but this does not solve all tilt angle problems,
        // rather use more sophisticated evaluator.
        nearPlane = groundDistance - this.maxElevation;
        farPlane = groundDistance - this.minElevation;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.min(farPlane, farMax);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: Math.max(farMax, farPlane)
        };
        return viewRanges;
    }
    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // The near plane calculus is quite straight forward and works the same as for planar
        // projections. We simply search for the closest point of the ground just above
        // the camera, then we apply margin (elevation) to it along the sphere surface normal:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        nearPlane = cameraAltitude - this.maxElevation;
        // Far plane calculation requires different approaches depending from camera projection:
        // - perspective
        // - orthographic
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        let d = camera.position.length();
        d = d === 0 ? epsilon : d;
        if (camera.type === "PerspectiveCamera") {
            // This solution computes near and far plane for a set up where
            // the camera is looking at the center of the scene.
            // The far plane distance calculus requires finding the sphere tangent line that is
            // co-linear with (goes thru) camera position, such tangent creates right angle
            // with sphere diameter where it touches its surface (point T). Given that sphere is
            // always at world origin and camera orbits around it we have (see
            // #getTangentBasedFarPlane):
            // angle(OTC) = 90
            // sin(OCT) = sin(alpha) = r / d
            // alpha = asin(r / d)
            const alpha = Math.asin(r / d);
            // If alpha it bigger than half fov angle, our visibility limit is set by tangent
            // line, otherwise we need to find top (or right) plane intersection with sphere,
            // which is definitely closer than the tangent point mentioned above.
            const cam = camera;
            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:
            const aspect = cam.aspect > 1 ? cam.aspect : 1 / cam.aspect;
            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);
            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);
            farPlane =
                halfFovAngle > alpha
                    ? farTangent
                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);
        }
        // Orthographic camera projection
        else {
            farPlane = this.getOrthoBasedFarPlane(d, r);
        }
        // In extreme cases the largest depression assumed may be further than tangent
        // based far plane distance, take it into account
        const farMin = cameraAltitude - this.minElevation;
        const farMax = cameraAltitude * this.farMaxRatio;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.max(farPlane, farMin);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: farMax
        };
        return viewRanges;
    }
    /**
     * Calculate distance from a point to the tangent point of a sphere.
     *
     * Returns zero if point is below surface or only very slightly above surface of sphere.
     * @param d - Distance from point to center of sphere
     * @param r - Radius of sphere
     */
    getTangentDistance(d, r) {
        // There may be situations when maximum elevation still remains below sea level
        // (elevation < 0) or it is negligible (elevation ~ epsilon)
        if (d - r < epsilon) {
            return 0;
        }
        // The distance to tangent point may be described as:
        // t = sqrt(d^2 - r^2)
        return Math.sqrt(d * d - r * r);
    }
    /**
     * Calculate far plane depending on furthest visible distance from camera position.
     *
     * Furthest visible distance is assumed to be distance from camera to horizon
     * plus distance from elevated geometry to horizon(so that high objects behind horizon
     * remain visible).
     * @param camera - The camera of the mapview
     * @param d - Distance from camera to origin
     * @param r - Radius of earth
     * @param alpha - Angle between camera eye vector and tangent
     */
    getTangentBasedFarPlane(camera, d, r, alpha) {
        // Find tangent point intersection distance
        //         , - ~ ~ ~ - ,
        //     , '               ' ,        E
        //   ,           .           ,    . ' far + elev
        //  ,            .   r + e   , '   /
        // ,             .     ,  '    ,  /
        // ,             . O '         , / te
        // ,             | .           ,/
        //  ,            |   .  r     ,/
        //   ,           |      .    ,
        //     ,         |        , '_____ far
        //       ' -_, _ | _ ,  ' / T
        //     near      |      /
        //               |    / t
        //             d |  /
        //               |/
        //               C
        const t = this.getTangentDistance(d, r);
        // Because we would like to see elevated geometry that may be visible beyond
        // the tangent point on ground surface, we need to extend viewing distance along
        // the tangent line by te (see graph above).
        const te = this.getTangentDistance(r + this.maxElevation, r);
        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector
        // to get maximum camera far plane distance.
        //
        // Knowing that:
        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).
        // where:
        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te
        // Formula simplifies to:
        const far = Math.cos(alpha) * (t + te);
        return far;
    }
    getFovBasedFarPlane(camera, d, r, fovAngle, projection) {
        // Find intersection point that is closer to tangent point.
        //
        //         , - ~ ~ ~ - ,
        //     , '               ' ,
        //   ,           .           ,
        //  ,            .     r     ,' T1
        // ,             .     ,  '  / ,
        // ,             . O.'  a   /  ,
        // ,             | .  `  . /   ,
        //  ,            |   .  r / TA,
        //   ,           |    .  /   ,
        //     ,         |     ./  ,'_____ far
        //       ' -_, _ | _ , /' T0
        //     near      |    /
        //               |   / t
        //             d | /
        //               |/
        //               C
        //
        // See:
        // tslint:disable-next-line: max-line-length
        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
        // Vector from camera to world center
        const dVec = camera.position;
        // Extract camera X, Y, Z orientation axes into tmp vectors array.
        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.
        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);
        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).
        const cameraFwdVec = this.m_tmpVectors[2];
        // Apply quaternion to forward vector, creating intersection vector, which is
        // parallel to top or right frustum plane (depending on the aspect ratio).
        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);
        // Calculate camera to origin vector projection onto frustum plane (top or right).
        // This gives us the length of CTA segment:
        const cta = dVec.dot(tVec);
        // If it is negative, it means that the dVec and the tVec points in
        // opposite directions - there is no intersection - or intersection could
        // potentially be behind the intersection ray's origin (camera position).
        if (cta < 0) {
            // Intersection points are behind camera, camera looks in wrong direction.
            const groundDistance = this.getCameraAltitude(camera, projection);
            // Setup far plane to maximum distance.
            return groundDistance * this.farMaxRatio;
        }
        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|
        // segment from it to get far plane distance.
        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to
        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:
        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta
        // a^2 = d^2 - cta^2
        const a2 = dVec.dot(dVec) - cta * cta;
        // Note that if a is greater than sphere radius the ray misses the sphere and
        // thus there is no intersection at all.
        const r2 = r * r;
        harp_utils_1.assert(a2 <= r2, "Please use this evaluator only for top view camera poses.");
        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle
        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is
        // equal to |T1TA|, and |OT0| segment is simply sphere radius.
        // In order to find |T0TA| length we again use Pythagorean theorem, which says:
        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a
        // |T0TA|^2 = r^2 - a^2
        const tota = Math.sqrt(r2 - a2);
        // Finally our far plane (intersection point) is defined as:
        return cta - tota;
    }
    getOrthoBasedFarPlane(d, r) {
        //         , - ~ ~ ~ - ,
        //     , '               ' ,     E
        //   ,            .--------- ,-.'- far + elev
        // | ,            .   r + e , `, |
        // |,             .     , '     ,| te
        // |,             . O '.........,|..
        // |,             |        r    ,|  far
        // | ,            |            , |
        // |  ,           |           ,  | t
        // |    ,         |        , '   |
        // |      ' -_, _ | _ ,  '       |
        // |    near      | \/___________| near - elev
        // |              |              |
        // |            d |              |
        // |              |              |
        //                C
        // The distance to tangent point may be described as:
        const t = d;
        // Tangent extension due to terrain elevation behind the horizon may be calculated
        // based on the right triangle:
        // (r+maxElev)^2 = r^2 + te^2
        // te = sqrt((r+maxElev)^2 - r^2)
        // although we may not calculate it if elevation is negligible:
        const te = this.maxElevation < epsilon
            ? 0
            : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;
        // Both near and far planes distances are directly applied to frustum, because tangents'
        // lines are parallel to camera look at vector.
        // Now far plane distance is constituted with:
        return t + te;
    }
}
exports.TopViewClipPlanesEvaluator = TopViewClipPlanesEvaluator;
/**
 * Evaluates camera clipping planes taking into account ground distance and camera angles.
 *
 * This evaluator provides support for camera with varying tilt (pitch) angle, the angle
 * between camera __look at__ vector and the ground surface normal.
 */
class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {
    /**
     * Calculate the lengths of frustum planes intersection with the ground plane.
     * This evaluates distances between eye vector (or eye plane in orthographic projection) and
     * ground intersections of top and bottom frustum planes.
     * @note This method assumes the world surface (ground) to be flat and
     * works only with planar projections.
     *
     * @param camera - The [[THREE.Camera]] instance in use,
     * @param projection - The geo-projection used to convert geographic to world coordinates.
     */
    getFrustumGroundIntersectionDist(camera, projection) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        // This algorithm computes the length of frustum planes before intersecting with a flat
        // ground surface. Entire computation is split over two projections method and performed
        // for top and bottom plane, with addition of terrain (ground) elevation which is taken
        // into account.
        // The following diagram may help explain the algorithm below.
        //   
        //   C
        //   |\
        //   |.\ .
        //   | . \  . t
        // z |  .  \   .c2
        //   |  c1.  \e ___. max elev
        //   |     .   \      .
        //___|a___D1.____\E1_____.D2______ g
        //   C1      .     \ __. min elev
        //            .      \.E2
        //          b  .    .
        //              . .
        //               .
        // Where:
        // - C gives the camera position.
        // - z is the height of the camera above the ground.
        // - z1 == z2 == z, for perspective camera all planes origin its the same
        // - a is a right angle.
        // - e is the look at vector of the camera.
        // - t and b are the frustum planes of the camera (top and bottom respectively).
        // - angle between c1 to c2 is the fov.
        // - c1, c2 - vectors from camera to the ground along frustum planes.
        // - angles between c1 and e or e and c2 splits fov on equal halves.
        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.
        // - angle between z and e is the pitch of the camera.
        // - angle between g and e is the tilt angle.
        // - g is the ground/world surface
        //
        // The goal is to find distance for top/bottom planes intersections of frustum with ground
        // plane.
        // This are the distances from C->D1 and C->D2, and are described as
        // c1 and c2. Then we may compensate/correct those distances with actual
        // ground elevations, which is done by simply offsetting camera altitude, as it is
        // opposite to elevating ground level.
        const halfPiLimit = Math.PI / 2 - epsilon;
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        // tslint:disable-next-line: deprecation
        const cameraTilt = Utils_1.MapViewUtils.extractCameraTilt(camera, projection);
        // Angle between z and c2
        let topAngleRad;
        // Angle between z and c1
        let bottomAngleRad;
        // Bottom plane origin altitude
        let z1;
        // Top plane origin altitude
        let z2;
        // For perspective projection:
        if (camera.type === "PerspectiveCamera") {
            const cam = camera;
            // Angle between z and c2, note, the fov is vertical, otherwise we would need to
            // translate it using aspect ratio:
            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
            const aspect = 1;
            // Half fov angle in radians
            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);
            topAngleRad = THREE.MathUtils.clamp(cameraTilt + halfFovAngle, -halfPiLimit, halfPiLimit);
            bottomAngleRad = THREE.MathUtils.clamp(cameraTilt - halfFovAngle, -halfPiLimit, halfPiLimit);
            z1 = z2 = cameraAltitude;
        }
        // For orthographic projection:
        else {
            const cam = camera;
            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV
            // the top/bottom planes are simply parallel to the eye vector:
            topAngleRad = bottomAngleRad = cameraTilt;
            // Although the ray origin is not always the same (eye position) as for
            // the perspective projections, thus we need to compensate for ortho-cube
            // dimensions:
            // sin(tilt) = zc2 / top
            // sin(tilt) = zc1 / bottom
            // zc2 = sin(tilt) * top
            // zc1 = sin(tilt) * bottom
            const sinBeta = Math.sin(cameraTilt);
            z2 = cameraAltitude + sinBeta * cam.top;
            z1 = cameraAltitude - sinBeta * cam.bottom;
        }
        // Distance along the top plane to the ground - c2
        // cos(topAngle) = (z2 - minElev) / |c2|
        // |c2| = (z2 - minElev) / cos(topAngle)
        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);
        // Distance along the bottom plane to the ground - c1
        // cos(bottomAngle) = (z - minElev) / |c1|
        // |c1| = (z - minElev) / cos(bottomAngle)
        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);
        return {
            top: Math.max(topDist, 0),
            bottom: Math.max(bottomDist, 0)
        };
    }
    /** @override */
    evaluateDistancePlanarProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        // Generally near/far planes are set to keep top/bottom planes intersection distance.
        // Then elevations margins are applied. Here margins (min/max elevations) are meant to
        // be defined as distance along the ground normal vector thus during camera
        // tilt they may affect near/far planes positions differently.
        const planesDist = this.getFrustumGroundIntersectionDist(camera, projection);
        // Project clipping plane distances for the top/bottom frustum planes (edges), but
        // only if we deal with perspective camera type, this step is not required
        // for orthographic projections, cause all clip planes are parallel to eye vector.
        if (camera.type === "PerspectiveCamera") {
            const cam = camera;
            // Angle between z and c2, note, the fov is vertical, otherwise we would need to
            // translate it using aspect ratio:
            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
            const aspect = 1;
            // Half fov angle in radians
            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);
            const cosHalfFov = Math.cos(halfFovAngle);
            // cos(halfFov) = near / bottomDist
            // near = cos(halfFov) * bottomDist
            viewRanges.near = planesDist.bottom * cosHalfFov;
            // cos(halfFov) = far / topDist
            // far = cos(halfFov) * topDist
            viewRanges.far = planesDist.top * cosHalfFov;
        }
        // Orthographic camera projection.
        else {
            viewRanges.near = planesDist.bottom;
            viewRanges.far = planesDist.top;
        }
        // Compute target (focus) point distance.
        // tslint:disable-next-line: deprecation
        const { distance } = Utils_1.MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);
        // Clamp values to constraints.
        const farMax = distance * this.farMaxRatio;
        viewRanges.near = Math.max(viewRanges.near, this.nearMin);
        viewRanges.far = Math.min(viewRanges.far, farMax);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;
        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
        viewRanges.minimum = this.nearMin;
        viewRanges.maximum = farMax;
        return viewRanges;
    }
    /** @override */
    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        // Near plane calculus is pretty straightforward and does not depend on camera tilt:
        const cameraAltitude = this.getCameraAltitude(camera, projection);
        viewRanges.near = cameraAltitude - this.maxElevation;
        let halfFovAngle = 0;
        if (camera instanceof THREE.PerspectiveCamera) {
            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:
            const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
            halfFovAngle = THREE.MathUtils.degToRad((camera.fov * aspect) / 2);
            // Now we need to account for camera tilt and frustum volume, so the longest
            // frustum edge does not intersects with sphere, it takes the worst case
            // scenario regardless of camera tilt, so may be improved little bit with more
            // sophisticated algorithm.
            viewRanges.near *= Math.cos(halfFovAngle);
        }
        // Far plane calculation requires different approaches depending from camera projection:
        // - perspective
        // - orthographic
        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const d = cameraToOrigin.length();
        let farPlane;
        if (camera instanceof THREE.PerspectiveCamera) {
            // Step-wise calculate angle between camera eye vector and tangent
            // Calculate angle between surface normal(below camera position) and tangent.
            const alpha = Math.asin(r / d);
            // Calculate angle between look at and surface normal(below camera position)
            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);
            // Calculate angle between camera eye vector and tangent.
            const modifiedAlpha = Math.abs(alpha - cameraPitch);
            // Use tangent based far plane if horizon is within field of view
            const farTangent = this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha);
            farPlane =
                halfFovAngle >= modifiedAlpha
                    ? farTangent
                    : this.getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch);
        }
        else {
            farPlane = this.getOrthoBasedFarPlane(d, r);
        }
        viewRanges.far = farPlane;
        // Compute the focus point (target) distance for current camera and projection setup,
        // in a same way the MapView component does.
        // tslint:disable-next-line: deprecation
        const { distance } = Utils_1.MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);
        // Apply the constraints.
        const farMin = cameraAltitude - this.minElevation;
        const farMax = distance * this.farMaxRatio;
        viewRanges.near = Math.max(viewRanges.near, this.nearMin);
        viewRanges.far = THREE.MathUtils.clamp(viewRanges.far, farMin, farMax);
        // Apply margins.
        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;
        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
        // Set minimum and maximum view range.
        viewRanges.minimum = this.nearMin;
        viewRanges.maximum = farMax;
        return viewRanges;
    }
    getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch) {
        // Find intersection point that is closer to tangent point.
        //
        //         , - ~ ~ ~ - ,
        //     , '               ' ,
        //   ,           .           ,
        //  ,            .     r     ,' T1
        // ,             .     ,  '  / ,
        // ,             . O.'  a   /  ,
        // ,             | .  `  . /   ,
        //  ,            |   .  r / TA,
        //   ,           |    .  /   ,
        //     ,         |     ./  ,'_____ far
        //       ' -_, _ | _ , /' T0
        //     near      |    /
        //               |   / t
        //             d | /
        //               |/
        //               C
        //
        // See:
        // tslint:disable-next-line: max-line-length
        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
        // compute length of t (distance to fov intersection with sphere)
        // with law of cosines:
        // r = d + t - 2dt * cos(alpha)
        // solved for t:
        // t0 = d * cos(alpha) - sqrt(d*cos(alpha) - d + r)  <-- first intersection
        // t1 = d * cos(alpha) + sqrt(d*cos(alpha) - d + r)  <-- second intersection
        // Use first intersection:
        const cosAlpha = Math.cos(cameraPitch + halfFovAngle);
        const dSqr = d * d;
        const t = d * cosAlpha - Math.sqrt(dSqr * cosAlpha * cosAlpha - dSqr + r * r);
        harp_utils_1.assert(!isNaN(t), "Field of view does not intersect sphere. Use tangent based far plane instead.");
        // project t onto camera fwd vector
        const far = Math.cos(halfFovAngle) * t;
        return far;
    }
    getCameraPitch(cameraToOrigin, camera) {
        cameraToOrigin.normalize();
        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();
        const cosAlpha1 = cameraToOrigin.dot(lookAt);
        const cameraPitch = Math.acos(THREE.MathUtils.clamp(cosAlpha1, -1.0, 1.0));
        return cameraPitch;
    }
}
exports.TiltViewClipPlanesEvaluator = TiltViewClipPlanesEvaluator;
/**
 * Provides the most basic evaluation concept giving fixed values with some constraints.
 */
class FixedClipPlanesEvaluator {
    constructor(minNear = 1, minFarOffset = 10) {
        this.minNear = minNear;
        this.minFarOffset = minFarOffset;
        this.minFar = minNear + minFarOffset;
        this.m_nearPlane = minNear;
        this.m_farPlane = this.minFar;
    }
    get nearPlane() {
        return this.m_nearPlane;
    }
    set nearPlane(fixedNear) {
        this.invalidatePlanes(fixedNear, this.m_farPlane);
    }
    get farPlane() {
        return this.m_farPlane;
    }
    set farPlane(fixedFar) {
        this.invalidatePlanes(this.m_nearPlane, fixedFar);
    }
    // tslint:disable-next-line: no-empty
    set minElevation(elevation) { }
    get minElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    // tslint:disable-next-line: no-empty
    set maxElevation(elevation) { }
    get maxElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    /** @override */
    evaluateClipPlanes(camera, projection, elevationProvider) {
        // We do not need to perform actual evaluation cause results are precomputed and
        // kept stable until somebody changes the properties.
        const viewRanges = {
            near: this.m_nearPlane,
            far: this.m_farPlane,
            minimum: this.minNear,
            maximum: this.m_farPlane
        };
        return viewRanges;
    }
    invalidatePlanes(near, far) {
        // When clamping prefer to extend far plane at about minimum distance, giving
        // near distance setup priority over far.
        const nearDist = Math.max(this.minNear, near);
        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
        this.m_nearPlane = nearDist;
        this.m_farPlane = farDist;
    }
}
exports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;
/**
 * Factory function that creates default {@link ClipPlanesEvaluator}
 * that calculates near plane based
 * on ground distance and camera orientation.
 *
 * Creates {@link TiltViewClipPlanesEvaluator}.
 */
exports.createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();
//# sourceMappingURL=ClipPlanesEvaluator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ColorCache.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ColorCache.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorCache = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Use `ColorCache` to reuse a color specified by name and save allocation as well as
 * setup time.
 *
 * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.
 */
let ColorCache = /** @class */ (() => {
    class ColorCache {
        constructor() {
            this.m_map = new Map();
        }
        /**
         * Return instance of `ColorCache`.
         */
        static get instance() {
            return this.m_instance;
        }
        /**
         * Returns the color for the given `colorCode`. This function may reuse a previously generated
         * color, so you cannot modify the contents of the color.
         *
         * @param colorCode - ThreeJS color code or name. You must provide a valid color code or name,
         * as this function does not do any validation.
         */
        getColor(colorCode) {
            if (typeof colorCode === "number") {
                colorCode = "#" + colorCode.toString(16).padStart(6, "0");
            }
            let color = this.m_map.get(colorCode);
            if (color !== undefined) {
                return color;
            }
            color = new THREE.Color(colorCode);
            this.m_map.set(colorCode, color);
            return color;
        }
        /**
         * Returns the number of elements in the cache.
         */
        get size() {
            return this.m_map.size;
        }
        /**
         * Clears the cache. Only references to the THREE.Color are removed from the cache.
         * Consequently, clearing the cache does not cause any negative visual impact.
         */
        clear() {
            this.m_map.clear();
        }
    }
    ColorCache.m_instance = new ColorCache();
    return ColorCache;
})();
exports.ColorCache = ColorCache;
//# sourceMappingURL=ColorCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrentDecoderFacade = void 0;
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js");
const WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js");
/**
 * Default concurrent decoder helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to {@link WorkerBasedDecoder}s for data sources.
 */
let ConcurrentDecoderFacade = /** @class */ (() => {
    class ConcurrentDecoderFacade {
        /**
         * Returns a {@link WorkerBasedDecoder} instance.
         *
         * @param decoderServiceType - The name of the decoder service type.
         * @param scriptUrl - The optional URL with the workers' script.
         * @param workerCount - The number of web workers to use.
         */
        static getTileDecoder(decoderServiceType, scriptUrl, workerCount) {
            const workerSet = this.getWorkerSet(scriptUrl, workerCount);
            return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);
        }
        /**
         * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
         *
         * @param scriptUrl - The optional URL with the workers' script. If not specified,
         * the function uses [[defaultScriptUrl]] instead.
         * @param workerCount - The number of web workers to use.
         */
        static getWorkerSet(scriptUrl, workerCount) {
            if (scriptUrl === undefined) {
                scriptUrl = this.defaultScriptUrl;
            }
            let workerSet = this.workerSets[scriptUrl];
            if (workerSet === undefined) {
                workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                    scriptUrl,
                    workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
                });
                this.workerSets[scriptUrl] = workerSet;
            }
            return workerSet;
        }
        /**
         * Destroys a [[ConcurrentWorkerSet]] instance.
         *
         * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].
         */
        static destroyWorkerSet(scriptUrl) {
            const workerSet = this.workerSets[scriptUrl];
            if (workerSet !== undefined) {
                workerSet.destroy();
                delete this.workerSets[scriptUrl];
            }
        }
        /**
         * Destroys all managed [[ConcurrentWorkerSet]]s.
         */
        static destroy() {
            Object.keys(this.workerSets).forEach(name => {
                this.workerSets[name].destroy();
            });
            this.workerSets = {};
        }
    }
    /**
     * The URL containing a script to fall back (default) to when looking for worker sets
     * and decoders.
     */
    ConcurrentDecoderFacade.defaultScriptUrl = "./decoder.bundle.js";
    /**
     * The default number of workers.
     */
    ConcurrentDecoderFacade.defaultWorkerCount = undefined;
    /**
     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
     */
    ConcurrentDecoderFacade.workerSets = {};
    return ConcurrentDecoderFacade;
})();
exports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;
//# sourceMappingURL=ConcurrentDecoderFacade.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrentTilerFacade = void 0;
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js");
const WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js");
/**
 * Default concurrent tiler helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to {@link WorkerBasedTiler}s for data sources.
 */
let ConcurrentTilerFacade = /** @class */ (() => {
    class ConcurrentTilerFacade {
        /**
         * Returns a {@link WorkerBasedTiler} instance.
         *
         * @param tilerServiceType - The name of the tiler service type.
         * @param scriptUrl - The optional URL with the workers' script.
         * @param workerCount - The number of web workers to use.
         */
        static getTiler(tilerServiceType, scriptUrl, workerCount) {
            const workerSet = this.getWorkerSet(scriptUrl, workerCount);
            return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);
        }
        /**
         * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
         *
         * @param scriptUrl - The optional URL with the workers' script. If not specified,
         * the function uses [[defaultScriptUrl]] instead.
         * @param workerCount - The number of web workers to use.
         */
        static getWorkerSet(scriptUrl, workerCount) {
            if (scriptUrl === undefined) {
                scriptUrl = this.defaultScriptUrl;
            }
            let workerSet = this.workerSets[scriptUrl];
            if (workerSet === undefined) {
                workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                    scriptUrl,
                    workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount
                });
                this.workerSets[scriptUrl] = workerSet;
            }
            return workerSet;
        }
        /**
         * Destroys a [[ConcurrentWorkerSet]] instance.
         *
         * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].
         */
        static destroyWorkerSet(scriptUrl) {
            const workerSet = this.workerSets[scriptUrl];
            if (workerSet !== undefined) {
                workerSet.destroy();
                delete this.workerSets[scriptUrl];
            }
        }
        /**
         * Destroys all managed [[ConcurrentWorkerSet]]s.
         */
        static destroy() {
            Object.keys(this.workerSets).forEach(name => {
                this.workerSets[name].destroy();
            });
            this.workerSets = {};
        }
    }
    /**
     * The URL containing a script to fall back (default) to when looking for worker sets
     * and tilers.
     */
    ConcurrentTilerFacade.defaultScriptUrl = "./decoder.bundle.js";
    /**
     * The default number of workers.
     */
    ConcurrentTilerFacade.defaultWorkerCount = 1;
    /**
     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
     */
    ConcurrentTilerFacade.workerSets = {};
    return ConcurrentTilerFacade;
})();
exports.ConcurrentTilerFacade = ConcurrentTilerFacade;
//# sourceMappingURL=ConcurrentTilerFacade.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrentWorkerSet = exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = exports.isLoggingMessage = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const logger = harp_utils_1.LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;
}
exports.isLoggingMessage = isLoggingMessage;
/**
 * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.
 */
const DEFAULT_WORKER_COUNT = 2;
/**
 * The default timeout for first message from worker.
 *
 * @see {@link WorkerLoader.startWorker}
 */
exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;
/**
 * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances
 * running in Web Workers.
 *
 * Starts and manages a certain number of web workers and provides a means to communicate
 * with them using various communication schemes, such as:
 *  - [[addEventListener]] : receive a unidirectional messages
 *  - [[broadcastMessage]] : send unidirectional broadcast message
 *  - [[invokeRequest]] : send a request that waits for a response, with load balancing
 *  - [[postMessage]] : send a unidirectional message, with load balancing
 *
 * The request queue holds all requests before they are stuffed into the event queue, allows for
 * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage
 * when they return their previous result, or if they are idle. When they are idle, they are stored
 * in m_availableWorkers.
 */
class ConcurrentWorkerSet {
    /**
     * Creates a new `ConcurrentWorkerSet`.
     *
     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided
     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in
     * `navigator.hardwareConcurrency` is used instead.
     *
     * The worker set is implicitly started when constructed.
     */
    constructor(m_options) {
        this.m_options = m_options;
        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create("WorkerChannel");
        this.m_eventListeners = new Map();
        this.m_workers = new Array();
        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce
        // memory consumption in idle workers.
        this.m_availableWorkers = new Array();
        this.m_workerPromises = new Array();
        this.m_readyPromises = new Map();
        this.m_requests = new Map();
        this.m_workerRequestQueue = [];
        this.m_nextMessageId = 0;
        this.m_stopped = true;
        this.m_referenceCount = 0;
        /**
         * Handles messages received from workers. This method is protected so that the message
         * reception can be simulated through an extended class, to avoid relying on real workers.
         *
         * @param workerId - The workerId of the web worker.
         * @param event - The event to dispatch.
         */
        this.onWorkerMessage = (workerId, event) => {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {
                const response = event.data;
                if (response.messageId === null) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
                    return;
                }
                const entry = this.m_requests.get(response.messageId);
                if (entry === undefined) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
                    return;
                }
                if (workerId >= 0 && workerId < this.m_workers.length) {
                    const worker = this.m_workers[workerId];
                    this.m_availableWorkers.push(worker);
                    // Check if any new work has been put into the queue.
                    this.checkWorkerRequestQueue();
                }
                else {
                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
                }
                if (response.errorMessage !== undefined) {
                    const error = new Error(response.errorMessage);
                    if (response.errorStack !== undefined) {
                        error.stack = response.errorStack;
                    }
                    entry.resolver(error);
                }
                else {
                    entry.resolver(undefined, response.response);
                }
            }
            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {
                const readyPromise = this.getReadyPromise(event.data.service);
                if (++readyPromise.count === this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            }
            else if (isLoggingMessage(event.data)) {
                switch (event.data.level) {
                    case harp_utils_1.LogLevel.Trace:
                        this.m_workerChannelLogger.trace(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Debug:
                        this.m_workerChannelLogger.debug(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Log:
                        this.m_workerChannelLogger.log(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Info:
                        this.m_workerChannelLogger.info(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Warn:
                        this.m_workerChannelLogger.warn(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Error:
                        this.m_workerChannelLogger.error(...event.data.message);
                        break;
                }
            }
            else {
                this.eventHandler(event);
            }
        };
        this.start();
    }
    /**
     * Adds an external reference and increments the internal reference counter by one.
     *
     * To implement a reference-count based automatic resource cleanup, use this function with
     * [[removeReference]].
     */
    addReference() {
        this.m_referenceCount += 1;
        if (this.m_referenceCount === 1 && this.m_stopped) {
            this.start();
        }
    }
    /**
     * Decrements the internal reference counter by 1.
     *
     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the
     * resources.
     *
     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.
     */
    removeReference() {
        this.m_referenceCount -= 1;
        if (this.m_referenceCount === 0) {
            this.destroy();
        }
    }
    /**
     * Starts workers.
     *
     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.
     *
     * Note: The worker set is implicitly started on construction - no need to call [[start]] on
     * fresh instance.
     *
     * @param options - optional, new worker set options
     */
    start(options) {
        if (options !== undefined) {
            this.m_options = options;
        }
        if (!this.m_stopped) {
            throw new Error("ConcurrentWorker set already started");
        }
        this.m_workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== undefined
            ? // We need to have at least one worker
                THREE.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2)
            : undefined, DEFAULT_WORKER_COUNT);
        // Initialize the workers. The workers now have an ID to identify specific workers and
        // handle their busy state.
        const timeout = harp_utils_1.getOptionValue(this.m_options.workerConnectionTimeout, exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT);
        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {
            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(worker => {
                const listener = (evt) => {
                    this.onWorkerMessage(workerId, evt);
                };
                worker.addEventListener("message", listener);
                this.m_workers.push(worker);
                this.m_availableWorkers.push(worker);
                return {
                    worker,
                    listener
                };
            });
            this.m_workerPromises.push(workerPromise);
        }
        this.m_stopped = false;
    }
    /**
     * The number of workers started for this worker set. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.m_workerCount;
    }
    /**
     * Stops workers.
     *
     * Waits for all pending requests to be finished and stops all workers.
     *
     * Use [[start]] to start this worker again.
     *
     * @returns `Promise` that resolves when all workers are destroyed.
     */
    async stop() {
        this.m_stopped = true;
        await this.waitForAllResponses().then(() => {
            this.terminateWorkers();
        });
    }
    /**
     * Destroys all workers immediately.
     *
     * Resolves all pending request promises with a `worker destroyed` error.
     *
     * Use [[start]] to start this worker again.
     */
    destroy() {
        this.m_stopped = true;
        // respond with all pending request
        this.m_requests.forEach(entry => {
            entry.resolver(new Error("worker destroyed"));
        });
        this.m_requests.clear();
        this.m_workerRequestQueue = [];
        this.terminateWorkers();
        // clean other stuff
        this.m_eventListeners.clear();
    }
    /**
     * Waits for `service` to be initialized in all workers.
     *
     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that
     * it has started successfully. This method resolves when all workers in a set have
     * `service` initialized.
     *
     * Promise is rejected if any of worker fails to start.
     *
     * @param serviceId - The service identifier.
     */
    async connect(serviceId) {
        this.ensureStarted();
        await Promise.all(this.m_workerPromises);
        return this.getReadyPromise(serviceId).promise;
    }
    /**
     * Registers an event listener for events that originated in a web worker, for a given
     * `serviceId`. You can only set one event listener per `serviceId`.
     *
     * @param serviceId - The service to listen to.
     * @param callback - The callback to invoke for matching events.
     */
    addEventListener(serviceId, callback) {
        this.m_eventListeners.set(serviceId, callback);
    }
    /**
     * Removes a previously set event listener for the given `serviceId`.
     *
     * @param serviceId - The service from which to remove the event listeners.
     */
    removeEventListener(serviceId) {
        this.m_eventListeners.delete(serviceId);
    }
    /**
     * Invokes a request that expects a response from a random worker.
     *
     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from
     * workers. Use this function when interfacing with "RPC-like" calls to services.
     *
     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.
     * @param request - The request to process.
     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.
     * @param requestController - An optional [[RequestController]] to store state of cancelling.
     *
     * @returns A `Promise` that resolves with a response from the service.
     */
    invokeRequest(serviceId, request, transferList, requestController) {
        this.ensureStarted();
        const messageId = this.m_nextMessageId++;
        let resolver;
        const promise = new Promise((resolve, reject) => {
            resolver = (error, response) => {
                this.m_requests.delete(messageId);
                if (error !== undefined) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            };
        });
        this.m_requests.set(messageId, {
            promise,
            resolver: resolver
        });
        const message = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
            messageId,
            request
        };
        this.postRequestMessage(message, transferList, requestController);
        return promise;
    }
    /**
     * Invokes a request that expects responses from all workers.
     *
     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching
     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers
     * before proceeding (like synchronous worker service creation).
     *
     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.
     * @param request - The request to process.
     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.
     *
     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified
     * order).
     */
    broadcastRequest(serviceId, request, transferList) {
        this.ensureStarted();
        const promises = [];
        for (const worker of this.m_workers) {
            const messageId = this.m_nextMessageId++;
            let resolver;
            const promise = new Promise((resolve, reject) => {
                resolver = (error, response) => {
                    this.m_requests.delete(messageId);
                    if (error !== undefined) {
                        reject(error);
                    }
                    else {
                        resolve(response);
                    }
                };
            });
            promises.push(promise);
            this.m_requests.set(messageId, {
                promise,
                resolver: resolver
            });
            const message = {
                service: serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
                messageId,
                request
            };
            if (transferList !== undefined) {
                worker.postMessage(message, transferList);
            }
            else {
                worker.postMessage(message);
            }
        }
        return Promise.all(promises);
    }
    /**
     * Posts a message to all workers.
     *
     * @param message - The message to send.
     * @param buffers - Optional buffers to transfer to the workers.
     */
    broadcastMessage(message, buffers) {
        this.ensureStarted();
        if (buffers !== undefined) {
            this.m_workers.forEach(worker => worker.postMessage(message, buffers));
        }
        else {
            this.m_workers.forEach(worker => worker.postMessage(message));
        }
    }
    /**
     * The size of the request queue for debugging and profiling.
     */
    get requestQueueSize() {
        return this.m_workerRequestQueue.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numWorkers() {
        return this.m_workers.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numIdleWorkers() {
        return this.m_availableWorkers.length;
    }
    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event - The event to dispatch.
     */
    eventHandler(event) {
        if (typeof event.data.type !== "string") {
            return; // not an event generated by us, ignore.
        }
        this.dispatchEvent(event.data.type, event);
    }
    /**
     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is
     * available, the request is put into a queue.
     *
     * @param message - The message to send.
     * @param buffers - Optional buffers to transfer to the worker.
     * @param requestController - An optional [[RequestController]] to store state of cancelling.
     */
    postRequestMessage(message, buffers, requestController) {
        this.ensureStarted();
        if (this.m_workers.length === 0) {
            throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
        }
        // Check if the requestController has received the abort signal, in which case the request
        // is ignored.
        if (requestController !== undefined && requestController.signal.aborted) {
            const entry = this.m_requests.get(message.messageId);
            if (entry === undefined) {
                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);
                return;
            }
            const err = new Error("Aborted");
            err.name = "AbortError";
            entry.resolver(err, undefined);
            return;
        }
        if (this.m_availableWorkers.length > 0) {
            const worker = this.m_availableWorkers.pop();
            if (buffers !== undefined) {
                worker.postMessage(message, buffers);
            }
            else {
                worker.postMessage(message);
            }
        }
        else {
            // We need a priority to keep sorting stable, so we have to add a RequestController.
            if (requestController === undefined) {
                requestController = new harp_datasource_protocol_1.RequestController(0);
            }
            if (requestController.priority === 0) {
                // If the requests do not get a priority, they should keep their sorting order.
                requestController.priority = -this.m_nextMessageId;
            }
            this.m_workerRequestQueue.unshift({
                message,
                buffers,
                requestController
            });
        }
    }
    ensureStarted() {
        if (this.m_stopped) {
            throw new Error("ConcurrentWorkerSet stopped");
        }
    }
    async waitForAllResponses() {
        const promises = new Array();
        this.m_requests.forEach(entry => {
            promises.push(entry.promise);
        });
        await Promise.all(promises);
    }
    dispatchEvent(id, message) {
        const callback = this.m_eventListeners.get(id);
        if (callback === undefined) {
            return;
        } // unknown event, ignore.
        callback(message);
    }
    terminateWorkers() {
        // terminate all workers
        this.m_workerPromises.forEach(workerPromise => {
            workerPromise.then(workerEntry => {
                if (workerEntry === undefined) {
                    return;
                }
                workerEntry.worker.removeEventListener("message", workerEntry.listener);
                workerEntry.worker.terminate();
            });
        });
        this.m_workers = [];
        this.m_workerPromises = [];
        this.m_availableWorkers = [];
        this.m_readyPromises.clear();
    }
    getReadyPromise(id) {
        const readyPromise = this.m_readyPromises.get(id);
        if (readyPromise !== undefined) {
            return readyPromise;
        }
        const newPromise = {
            count: 0,
            promise: undefined,
            resolve: () => {
                /* placeholder */
            },
            reject: (error) => {
                newPromise.error = error;
            },
            error: undefined
        };
        newPromise.promise = new Promise((resolve, reject) => {
            const that = newPromise;
            if (that.error !== undefined) {
                reject(that.error);
            }
            else if (that.count === this.m_workerPromises.length) {
                resolve();
            }
            that.resolve = resolve;
            that.reject = reject;
        });
        this.m_readyPromises.set(id, newPromise);
        return newPromise;
    }
    /**
     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,
     * they will be executed with postRequestMessage. The requests in the queue are sorted before
     * the request with the highest priority is selected for processing.
     */
    checkWorkerRequestQueue() {
        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
            return;
        }
        this.m_workerRequestQueue.sort((a, b) => {
            return a.requestController.priority - b.requestController.priority;
        });
        // Get the request with the highest priority and send it (again).
        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
            const request = this.m_workerRequestQueue.pop();
            this.postRequestMessage(request.message, request.buffers, request.requestController);
        }
    }
}
exports.ConcurrentWorkerSet = ConcurrentWorkerSet;
//# sourceMappingURL=ConcurrentWorkerSet.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DataSource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DataSource.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSource = void 0;
const ExprPool_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ExprPool */ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const logger = harp_utils_1.LoggerManager.instance.create("DataSource");
const UPDATE_EVENT = { type: "update" };
/**
 * Derive a class from `DataSource` to contribute data and geometries to the {@link MapView}.
 */
let DataSource = /** @class */ (() => {
    class DataSource extends THREE.EventDispatcher {
        /**
         * Constructs a new `DataSource`.
         *
         * @param options - The options to create the data source.
         */
        constructor(options = {}) {
            super();
            /**
             * Set to `true` if this `DataSource` is enabled; `false` otherwise.
             */
            this.enabled = true;
            /**
             * Set to `true` if the {@link MapView} can cache tiles produced by this `DataSource`.
             */
            this.cacheable = false;
            /**
             * Set to `true` if the loader should be used to get the tile contents.
             */
            this.useGeometryLoader = false;
            /**
             * Whether the datasource should have a ground plane (this plane covers the tile entirely and
             * has the minimum possible renderOrder), this can be required in some cases when fallback
             * parent tiles need to be covered by the children, otherwise the content will overlap.
             * Default is false
             */
            this.addGroundPlane = false;
            /**
             * The minimum zoom level at which data is available.
             */
            this.minDataLevel = 1;
            /**
             * The maximum zoom level at which data is available.
             */
            this.maxDataLevel = 20;
            /**
             * The minimum zoom level at which {@link DataSource} is displayed.
             */
            this.minDisplayLevel = 1;
            /**
             * The maximum zoom level at which {@link DataSource} is displayed.
             */
            this.maxDisplayLevel = 20;
            this.allowOverlappingTiles = true;
            /**
             * @internal
             * @hidden
             */
            this.exprPool = new ExprPool_1.ExprPool();
            /**
             * Current value of [[maxGeometryHeight]] property.
             */
            this.m_maxGeometryHeight = 0;
            /**
             * Storage level offset applied to this `DataSource`.
             */
            this.m_storageLevelOffset = 0;
            this.m_featureStateMap = new Map();
            let { name } = options;
            const { styleSetName, 
            // tslint:disable-next-line: deprecation
            minZoomLevel, 
            // tslint:disable-next-line: deprecation
            maxZoomLevel, minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset, allowOverlappingTiles } = options;
            if (name === undefined || name.length === 0) {
                name = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;
            }
            this.name = name;
            this.styleSetName = styleSetName;
            if (minDataLevel !== undefined) {
                this.minDataLevel = minDataLevel;
            }
            if (maxDataLevel !== undefined) {
                this.maxDataLevel = maxDataLevel;
            }
            if (minZoomLevel !== undefined) {
                // tslint:disable-next-line: deprecation
                this.minZoomLevel = minZoomLevel;
            }
            if (maxZoomLevel !== undefined) {
                // tslint:disable-next-line: deprecation
                this.maxZoomLevel = maxZoomLevel;
            }
            if (minDisplayLevel !== undefined) {
                this.minDisplayLevel = minDisplayLevel;
            }
            if (maxDisplayLevel !== undefined) {
                this.maxDisplayLevel = maxDisplayLevel;
            }
            if (storageLevelOffset !== undefined) {
                this.m_storageLevelOffset = storageLevelOffset;
            }
            if (allowOverlappingTiles !== undefined) {
                this.allowOverlappingTiles = allowOverlappingTiles;
            }
        }
        /**
         * Gets the state of the given feature id.
         *
         * @param featureId - The id of the feature.
         */
        getFeatureState(featureId) {
            return this.m_featureStateMap.get(featureId);
        }
        /**
         * Clears the state of all the features of this {@link DataSource}.
         */
        clearFeatureState() {
            this.m_featureStateMap.clear();
        }
        /**
         * Sets the state of the given feature id.
         *
         * ```typescript
         * dataSource.setFeatureState(featureId, { enabled: true });
         * ```
         *
         * @param featureId - The id of the feature.
         * @param state - The new state of the feature.
         */
        setFeatureState(featureId, state) {
            this.m_featureStateMap.set(featureId, state);
        }
        /**
         * Removes the state associated to the given feature.
         *
         * @param featureId - The id of the feature.
         */
        removeFeatureState(featureId) {
            this.m_featureStateMap.delete(featureId);
        }
        /**
         * Returns the name of the [[StyleSet]] to use for the decoding.
         */
        get styleSetName() {
            return this.m_styleSetName;
        }
        /**
         * Sets the name of the [[StyleSet]] to use for the decoding.
         * If this {@link DataSource} is already
         * attached to a {@link MapView}, this setter then reapplies
         * [[StyleSet]] with this name found in
         * {@link MapView}s theme.
         */
        set styleSetName(styleSetName) {
            this.m_styleSetName = styleSetName;
            if (this.m_mapView !== undefined && styleSetName !== undefined) {
                this.setTheme(this.m_mapView.theme);
            }
        }
        /**
         * Destroys this `DataSource`.
         */
        dispose() {
            // to be overloaded by subclasses
        }
        /**
         * Purges all the caching done by this `DataSource`
         */
        clearCache() {
            // to be overloaded by subclasses
        }
        /**
         * Boolean which says whether a {@link DataSource} produces
         * tiles that fully cover the tile, i.e.
         * tiles underneath are completely hidden. Must be
         * overriden for {@link DataSource}'s that don't
         * have a ground plane, but which still fully
         * cover the tile, e.g. web tiles.
         */
        isFullyCovering() {
            return this.addGroundPlane;
        }
        /**
         * Returns `true` if this `DataSource` is ready
         * and the {@link MapView} can invoke `getTile()` to
         * start requesting data.
         */
        ready() {
            return true;
        }
        /**
         * The {@link MapView} that is holding this `DataSource`.
         */
        get mapView() {
            if (this.m_mapView === undefined) {
                throw new Error("This DataSource was not added to MapView");
            }
            return this.m_mapView;
        }
        /**
         * The {@link @here/harp-geoutils#Projection} used by
         * the {@link MapView} that is holding this `DataSource`.
         *
         * An `Error` is thrown if you call this method
         * before this `DataSource` has been added
         * to a {@link MapView}.
         */
        get projection() {
            return this.mapView.projection;
        }
        /**
         * This method is called when the `DataSource` is added to a {@link MapView}. Reimplement this
         * method to provide any custom initialization, such as, to establish a network connection,
         * or to initialize complex data structures.
         */
        async connect() {
            // to be overloaded by subclasses
        }
        /**
         * This method is called when this `DataSource` is added to a {@link MapView}.
         *
         * Reimplementations of this method must invoke the definition of the super class.
         *
         * @param mapView - The instance of the {@link MapView}.
         */
        attach(mapView) {
            this.m_mapView = mapView;
        }
        /**
         * This method is called when this `DataSource` is removed from a {@link MapView}.
         *
         * Reimplementations of this method must invoke the definition of the super class.
         *
         * @param mapView - The instance of the {@link MapView}.
         */
        detach(mapView) {
            harp_utils_1.assert(this.m_mapView === mapView);
            this.m_mapView = undefined;
        }
        /**
         * Invoked by {@link MapView} to notify when the
         * {@link @here/harp-datasource-protocol#Theme} has been changed.
         *
         * @remarks
         * If `DataSource` depends on a `styleSet` or `languages`, it must update its tiles' geometry.
         *
         * @deprecated Use [[setTheme]].
         *
         * @param styleSet - The new theme that {@link MapView} uses.
         * @param languages - An optional list of languages for the `DataSource`.
         */
        // tslint:disable-next-line:no-unused-variable
        setStyleSet(styleSet, definitions, languages) {
            // to be overwritten by subclasses
        }
        /**
         * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.
         *
         * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update
         * its tiles' geometry.
         *
         * @param languages -
         */
        setTheme(theme, languages) {
            // to be overwritten by subclasses
        }
        /**
         * Used to configure the languages used by the `DataSource` according to priority;
         * the first language in the array has the highest priority.
         *
         * @param languages - An array of ISO 639-1 language codes.
         */
        setLanguages(languages) {
            // to be overloaded by subclasses
        }
        /**
         * Used to express different country point of view (political view).
         *
         * @note Set to `undefined` (or empty string) if you want to reset to default point of view.
         * @param pov - The country code which point of view should be presented in lower-case
         * ISO 3166-1 alpha-2 format.
         */
        setPoliticalView(pov) {
            // to be overloaded by subclasses
        }
        /**
         * This method is called by {@link MapView} before the
         * tile needs to be updated, for example after
         * a theme change.
         *
         * @param tile - The {@link Tile} to update.
         */
        // tslint:disable-next-line:no-unused-variable
        updateTile(tile) {
            // to be overloaded by subclasses
        }
        /**
         * This method is called by the {@link MapView} to determine if the content of the surrounding
         * tiles must be preloaded.
         *
         * @returns `true` if the {@link MapView} should try to preload tiles surrounding the visible
         * tiles; `false` otherwise. The default is `false`.
         */
        shouldPreloadTiles() {
            return false;
        }
        /**
         * The minimum zoom level at which data is available or displayed at
         * (depending on {@link DataSource} subclass).
         * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.
         */
        get minZoomLevel() {
            logger.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.");
            return this.minDataLevel;
        }
        set minZoomLevel(level) {
            logger.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.");
            this.minDataLevel = level;
        }
        /**
         * The maximum zoom level at which data is available or displayed at
         * (depending on {@link DataSource} subclass).
         * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.
         */
        get maxZoomLevel() {
            logger.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
            return this.maxDataLevel;
        }
        set maxZoomLevel(level) {
            logger.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
            this.maxDataLevel = level;
        }
        /**
         * Maximum geometry height above ground level this `DataSource` can produce.
         *
         * Used in first stage of frustum culling before
         * {@link Tile.maxGeometryHeight} data is available.
         *
         * @default 0.
         */
        get maxGeometryHeight() {
            return this.m_maxGeometryHeight;
        }
        set maxGeometryHeight(value) {
            this.m_maxGeometryHeight = value;
        }
        /**
         * The difference between storage level and display level of tile.
         *
         * Storage level offset is a value applied (added) to current zoom level giving
         * a final tile level being displayed. This way we may differentate current
         * zoom level from the storage level that is displayed, giving fine grained
         * control over the tiles being decoded an displayed.
         */
        get storageLevelOffset() {
            return this.m_storageLevelOffset;
        }
        /**
         * Setup the relative offset between storage level and display level of tile.
         *
         * @param levelOffset - Difference between zoom level and display level.
         */
        set storageLevelOffset(levelOffset) {
            this.m_storageLevelOffset = levelOffset;
        }
        /**
         * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources
         * supporting this feature.
         *
         * @param value - True to enable, false to disable.
         */
        setEnableElevationOverlay(enable) {
            // to be overloaded by subclasses
        }
        /**
         * Computes the data zoom level to use.
         *
         * @param zoomLevel - The zoom level of the {@link MapView}.
         * @returns The data zoom level to use.
         */
        getDataZoomLevel(zoomLevel) {
            return THREE.MathUtils.clamp(zoomLevel + this.m_storageLevelOffset, this.minDataLevel, this.maxDataLevel);
        }
        /**
         * Returns `true` if {@link DataSource} should be displayed for the zoom level.
         * @param zoomLevel - The zoom level of the {@link MapView}.
         */
        isVisible(zoomLevel) {
            return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;
        }
        /**
         * Returns `true` if {@link DataSource} can load tile with
         * given {@link @here/harp-geoutils#TileKey} and zoom level.
         *
         * @param zoomLevel - The zoom level of the {@link MapView}.
         * @param tileKey - The unique identifier for a map tile.
         * @returns `true` if the tile for the given {@link @here/harp-geoutils#TileKey} can be loaded.
         */
        canGetTile(zoomLevel, tileKey) {
            return tileKey.level <= zoomLevel;
        }
        /**
         * Returns `true` if {@link MapView} should traverse tiles
         * further with given {@link @here/harp-geoutils#TileKey} and
         * zoom level.
         *
         * @param zoomLevel - The zoom level of the {@link MapView}.
         * @param tileKey - The unique identifier for a map tile.
         * @returns `true` if the subtiles of the given {@link @here/harp-geoutils#TileKey} should be
         * checked for collisions.
         */
        shouldSubdivide(zoomLevel, tileKey) {
            return tileKey.level <= zoomLevel;
        }
        /**
         * Returns `true` if {@link MapView} should render the text
         * elements with the given {@link @here/harp-geoutils#TileKey} and
         * zoom level.
         *
         * @remarks
         * This is an additional check for the tiles that are already selected for rendering so the
         * default implementation returns `true`.
         *
         * @param zoomLevel - The zoom level.
         * @param tileKey - The unique identifier for a map tile.
         * @returns `true` if the text elements created for the
         *          given {@link @here/harp-geoutils#TileKey} should be rendered.
         */
        // tslint:disable-next-line:no-unused-variable
        shouldRenderText(zoomLevel, tileKey) {
            return true;
        }
        /**
         * Sends a request to the {@link MapView} to redraw the scene.
         */
        requestUpdate() {
            this.dispatchEvent(UPDATE_EVENT);
        }
    }
    /**
     * A counter to generate unique names for each `DataSource`, if no name is provided in the
     * constructor.
     */
    DataSource.uniqueNameCounter = 0;
    return DataSource;
})();
exports.DataSource = DataSource;
//# sourceMappingURL=DataSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DebugContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DebugContext.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugContext = exports.DebugContext = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const isNode = typeof window === "undefined";
/**
 * A `DebugOption` is a pair that consists of an option value and an array of change listeners.
 * Listeners are called up when setting the option's value.
 */
let DebugOption = /** @class */ (() => {
    class DebugOption extends THREE.EventDispatcher {
        /**
         * Constructs the `DebugOption`.
         *
         * @param value - The value of the option.
         */
        constructor(value) {
            super();
            this.value = value;
        }
        /**
         * Updates the value of a given option.
         *
         * @param value - The new value for the option.
         * @param name - The name of the option to set.
         */
        set(value, name) {
            this.value = value;
            this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });
        }
    }
    DebugOption.SET_EVENT_TYPE = "set";
    return DebugOption;
})();
/**
 * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their
 * names.
 */
class DebugContext {
    /**
     * Builds a `DebugContext`.
     */
    constructor() {
        this.m_optionsMap = new Map();
        // If we have a `window` object, we store the context in it to make it available in the
        // console.
        if (!isNode && typeof window !== "undefined" && window) {
            const debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    /**
     * Sets the value of an option. Calls change listeners of that option, even if the value has
     * not been changed. The change listeners provided here are not called during this set
     * operation.
     *
     * @param name - Name of the option.
     * @param value - Value of the option.
     */
    setValue(name, value) {
        let opt = this.m_optionsMap.get(name);
        if (!opt) {
            opt = new DebugOption(value);
            this.m_optionsMap.set(name, opt);
        }
        else {
            opt.set(value, name);
        }
    }
    /**
     * Gets the option value.
     *
     * @param name - Name of option.
     */
    getValue(name) {
        const opt = this.m_optionsMap.get(name);
        return opt ? opt.value : undefined;
    }
    /**
     * Determines if the option is registered.
     *
     * @param name - Name of option.
     */
    hasOption(name) {
        return this.m_optionsMap.get(name) !== undefined;
    }
    /**
     * Adds a listener to a debug option.
     *
     * @param name - Name of the option that requires a listener.
     * @param listener - The listener function to add.
     */
    addEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Checks for a listener in a debug option.
     *
     * @param name - Name of the option to check for.
     * @param listener - The listener function to check for.
     */
    hasEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Removes a listener from a debug option.
     *
     * @param name - Name of the option from which to remove a listener.
     * @param listener - The listener function to remove.
     */
    removeEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Provides access to the options map. This method is useful for creating an automatic
     * browser GUI.
     */
    get options() {
        return this.m_optionsMap;
    }
    /**
     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API
     * to remove all event listeners.
     */
    clear() {
        this.m_optionsMap.forEach(option => {
            option.set(undefined, "");
        });
    }
}
exports.DebugContext = DebugContext;
exports.debugContext = new DebugContext();
//# sourceMappingURL=DebugContext.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateColorProperty = exports.applyBaseColorToMaterial = exports.applySecondaryColorToMaterial = exports.evaluateBaseColorProperty = exports.buildMetricValueEvaluator = exports.getMaterialConstructor = exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = exports.buildObject = exports.usesObject3D = exports.getBufferAttribute = exports.createMaterial = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DisplacedMesh_1 = __webpack_require__(/*! ./geometry/DisplacedMesh */ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js");
const SolidLineMesh_1 = __webpack_require__(/*! ./geometry/SolidLineMesh */ "./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js");
const MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ "./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js");
const logger = harp_utils_1.LoggerManager.instance.create("DecodedTileHelpers");
/**
 * Create a material, depending on the rendering technique provided in the options.
 *
 * @param options - The material options the subsequent functions need.
 * @param materialUpdateCallback - Optional callback when the material gets updated,
 *                               e.g. after texture loading.
 *
 * @returns new material instance that matches `technique.name`
 */
function createMaterial(options, textureReadyCallback) {
    const technique = options.technique;
    const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);
    const settings = {};
    if (Constructor === undefined) {
        return undefined;
    }
    if (Constructor.prototype instanceof THREE.RawShaderMaterial &&
        Constructor !== harp_materials_1.HighPrecisionLineMaterial) {
        settings.fog = options.fog;
    }
    if (options.shadowsEnabled === true && technique.name === "fill") {
        settings.removeDiffuseLight = true;
    }
    const material = new Constructor(settings);
    if (technique.id !== undefined) {
        material.name = technique.id;
    }
    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        material.flatShading = true;
    }
    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||
        harp_datasource_protocol_1.isTerrainTechnique(technique) ||
        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
            const textureProperty = technique[texturePropertyName];
            if (textureProperty === undefined) {
                return;
            }
            const onLoad = (texture) => {
                const properties = technique[texturePropertyName + "Properties"];
                if (properties !== undefined) {
                    if (properties.wrapS !== undefined) {
                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);
                    }
                    if (properties.wrapT !== undefined) {
                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);
                    }
                    if (properties.magFilter !== undefined) {
                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);
                    }
                    if (properties.minFilter !== undefined) {
                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);
                    }
                    if (properties.flipY !== undefined) {
                        texture.flipY = properties.flipY;
                    }
                    if (properties.repeatU !== undefined) {
                        texture.repeat.x = properties.repeatU;
                    }
                    if (properties.repeatV !== undefined) {
                        texture.repeat.y = properties.repeatV;
                    }
                }
                material[texturePropertyName] = texture;
                texture.needsUpdate = true;
                material.needsUpdate = true;
                if (textureReadyCallback) {
                    textureReadyCallback(texture);
                }
            };
            const onError = (error) => {
                logger.error("#createMaterial: Failed to load texture: ", error);
            };
            let textureUrl;
            if (typeof textureProperty === "string") {
                textureUrl = textureProperty;
            }
            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.type === "image/raw") {
                    const properties = textureProperty.dataTextureProperties;
                    if (properties !== undefined) {
                        const textureDataType = properties.type
                            ? ThemeHelpers_1.toTextureDataType(properties.type)
                            : undefined;
                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);
                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);
                        onLoad(texture);
                    }
                    else {
                        onError("no data texture properties provided.");
                    }
                }
                else {
                    const textureBlob = new Blob([textureProperty.buffer], {
                        type: textureProperty.type
                    });
                    textureUrl = URL.createObjectURL(textureBlob);
                }
            }
            if (textureUrl) {
                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress
                onError);
            }
        });
    }
    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {
        // Special case for ShaderTechnique.
        applyShaderTechniqueToMaterial(technique, material);
    }
    else {
        MapMaterialAdapter_1.MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));
    }
    return material;
}
exports.createMaterial = createMaterial;
/**
 * Returns a [[THREE.BufferAttribute]] created from a provided
 * {@link @here/harp-datasource-protocol#BufferAttribute} object.
 *
 * @param attribute - BufferAttribute a WebGL compliant buffer
 */
function getBufferAttribute(attribute) {
    switch (attribute.type) {
        case "float":
            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint8":
            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint16":
            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint32":
            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int8":
            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int16":
            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int32":
            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        default:
            throw new Error(`unsupported buffer of type ${attribute.type}`);
    } // switch
}
exports.getBufferAttribute = getBufferAttribute;
/**
 * Determines if a technique uses THREE.Object3D instances.
 * @param technique - The technique to check.
 * @returns true if technique uses THREE.Object3D, false otherwise.
 */
function usesObject3D(technique) {
    const name = technique.name;
    return (name !== undefined &&
        name !== "text" &&
        name !== "labeled-icon" &&
        name !== "line-marker" &&
        name !== "label-rejection-line");
}
exports.usesObject3D = usesObject3D;
/**
 * Builds the object associated with the given technique.
 *
 * @param technique - The technique.
 * @param geometry - The object's geometry.
 * @param material - The object's material.
 * @param tile - The tile where the object is located.
 * @param elevationEnabled - True if elevation is enabled, false otherwise.
 */
function buildObject(technique, geometry, material, tile, elevationEnabled) {
    harp_utils_1.assert(technique.name !== undefined);
    switch (technique.name) {
        case "extruded-line":
        case "standard":
        case "extruded-polygon":
        case "fill":
            return elevationEnabled
                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                }))
                : new THREE.Mesh(geometry, material);
        case "terrain":
            return new THREE.Mesh(geometry, material);
        case "dashed-line":
        case "solid-line":
            return elevationEnabled
                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                }), SolidLineMesh_1.SolidLineMesh.raycast)
                : new SolidLineMesh_1.SolidLineMesh(geometry, material);
        case "circles":
            return new MapViewPoints_1.Circles(geometry, material);
        case "squares":
            return new MapViewPoints_1.Squares(geometry, material);
        case "line":
            return new THREE.LineSegments(geometry, material);
        case "segments":
            return new THREE.LineSegments(geometry, material);
        case "shader": {
            harp_utils_1.assert(harp_datasource_protocol_1.isShaderTechnique(technique), "Invalid technique");
            switch (technique.primitive) {
                case "line":
                    return new THREE.Line(geometry, material);
                case "segments":
                    return new THREE.LineSegments(geometry, material);
                case "point":
                    return new THREE.Points(geometry, material);
                case "mesh":
                    return new THREE.Mesh(geometry, material);
            }
        }
    }
    harp_utils_1.assert(false, "Invalid technique");
    return new THREE.Object3D();
}
exports.buildObject = buildObject;
/**
 * Non material properties of [[BaseTechnique]]
 */
exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = ["name", "id", "renderOrder", "transient"];
/**
 * Returns a [[MaterialConstructor]] basing on provided technique object.
 *
 * @param technique - [[Technique]] object which the material will be based on.
 * @param shadowsEnabled - Whether the material can accept shadows, this is required for some
 * techniques to decide which material to create.
 */
function getMaterialConstructor(technique, shadowsEnabled) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard"
                ? harp_materials_1.MapMeshStandardMaterial
                : harp_materials_1.MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return harp_materials_1.MapMeshStandardMaterial;
        case "dashed-line":
        case "solid-line":
            return harp_materials_1.SolidLineMaterial;
        case "fill":
            return shadowsEnabled ? harp_materials_1.MapMeshStandardMaterial : harp_materials_1.MapMeshBasicMaterial;
        case "squares":
            return THREE.PointsMaterial;
        case "circles":
            return harp_materials_1.CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE.LineBasicMaterial;
        case "shader":
            return THREE.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
        case "label-rejection-line":
            return undefined;
    }
}
exports.getMaterialConstructor = getMaterialConstructor;
/**
 * Styled properties of main material (created by [[createMaterial]]) managed by
 * [[MapObjectAdapter]].
 */
function getMainMaterialStyledProps(technique) {
    var _a;
    switch (technique.name) {
        case "dashed-line":
        case "solid-line": {
            const baseProps = harp_utils_1.pick(technique, [
                "color",
                "outlineColor",
                "transparent",
                "opacity",
                "caps",
                "drawRangeStart",
                "drawRangeEnd",
                "dashes",
                "dashColor",
                "polygonOffset",
                "polygonOffsetFactor",
                "polygonOffsetUnits"
            ]);
            baseProps.lineWidth = buildMetricValueEvaluator((_a = technique.lineWidth) !== null && _a !== void 0 ? _a : 0, // Compatibility: `undefined` lineWidth means hidden.
            // tslint:disable-next-line: deprecation
            technique.metricUnit);
            baseProps.outlineWidth = buildMetricValueEvaluator(technique.outlineWidth, 
            // tslint:disable-next-line: deprecation
            technique.metricUnit);
            baseProps.dashSize = buildMetricValueEvaluator(technique.dashSize, 
            // tslint:disable-next-line: deprecation
            technique.metricUnit);
            baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, 
            // tslint:disable-next-line: deprecation
            technique.metricUnit);
            baseProps.offset = buildMetricValueEvaluator(technique.offset, 
            // tslint:disable-next-line: deprecation
            technique.metricUnit);
            return baseProps;
        }
        case "fill":
            return harp_utils_1.pick(technique, [
                "color",
                "transparent",
                "opacity",
                "polygonOffset",
                "polygonOffsetFactor",
                "polygonOffsetUnits"
            ]);
        case "standard":
        case "terrain":
        case "extruded-polygon": {
            const baseProps = harp_utils_1.pick(technique, [
                "vertexColors",
                "wireframe",
                "roughness",
                "metalness",
                "alphaTest",
                "depthTest",
                "transparent",
                "opacity",
                "emissive",
                "emissiveIntensity",
                "refractionRatio",
                "normalMapType"
                // All texture related properties are skipped as for now as they are handled by
                // [[createMaterial]] directly without possibility for them to be dynamic.
                // TODO: move handling of texture-like params to [[MapMaterialAdapter]] with proper
                // support for dynamic params
            ]);
            if (technique.vertexColors !== true) {
                baseProps.color = technique.color;
            }
            return baseProps;
        }
        case "circles":
        case "squares":
            return harp_utils_1.pick(technique, ["color", "size", "opacity", "transparent"]);
        case "extruded-line":
            return harp_utils_1.pick(technique, [
                "color",
                "wireframe",
                "transparent",
                "opacity",
                "polygonOffset",
                "polygonOffsetFactor",
                "polygonOffsetUnits"
            ]);
        case "line":
        case "segments":
            return harp_utils_1.pick(technique, ["color", "transparent", "opacity"]);
        default:
            return {};
    }
}
/**
 * Convert metric style property to expression that accounts {@link MapView.pixelToWorld} if
 * `metricUnit === 'Pixel'`.
 */
function buildMetricValueEvaluator(value, metricUnit) {
    if (value === undefined || value === null) {
        return value;
    }
    if (typeof value === "string") {
        if (value.endsWith("px")) {
            metricUnit = "Pixel";
            value = Number.parseFloat(value);
        }
        else if (value.endsWith("m")) {
            value = Number.parseFloat(value);
        }
    }
    if (metricUnit === "Pixel") {
        return (context) => {
            var _a;
            const pixelToWorld = (_a = context.env.lookup("$pixelToMeters")) !== null && _a !== void 0 ? _a : 1;
            const evaluated = harp_datasource_protocol_1.getPropertyValue(value, context.env);
            return pixelToWorld * evaluated;
        };
    }
    else {
        return value;
    }
}
exports.buildMetricValueEvaluator = buildMetricValueEvaluator;
/**
 * Allows to easy parse/encode technique's base color property value as number coded color.
 *
 * Function takes care about property parsing, interpolation and encoding if neccessary.
 *
 * @see ColorUtils
 * @param technique - the technique where we search for base (transparency) color value
 * @param env - {@link @here/harp-datasource-protocol#Env} instance
 *              used to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of [[Technique]]
 * @returns [[number]] encoded color value (in custom #TTRRGGBB) format or `undefined` if
 * base color property is not defined in the technique passed.
 */
function evaluateBaseColorProperty(technique, env) {
    const baseColorProp = getBaseColorProp(technique);
    if (baseColorProp !== undefined) {
        return evaluateColorProperty(baseColorProp, env);
    }
    return undefined;
}
exports.evaluateBaseColorProperty = evaluateBaseColorProperty;
/**
 * Apply [[ShaderTechnique]] parameters to material.
 *
 * @param technique - the [[ShaderTechnique]] which requires special handling
 * @param material - material to which technique will be applied
 */
function applyShaderTechniqueToMaterial(technique, material) {
    if (technique.transparent) {
        harp_materials_1.enableBlending(material);
    }
    else {
        harp_materials_1.disableBlending(material);
    }
    // The shader technique takes the argument from its `params' member.
    const params = technique.params;
    // Remove base color and transparency properties from the processed set.
    const baseColorPropName = getBaseColorPropName(technique);
    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;
    const props = Object.getOwnPropertyNames(params).filter(propertyName => {
        // Omit base color and related transparency attributes if its defined in technique
        if (baseColorPropName === propertyName ||
            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)) {
            return false;
        }
        const prop = propertyName;
        if (prop === "name") {
            // skip reserved property names
            return false;
        }
        return true;
    });
    // Apply all technique properties omitting base color and transparency attributes.
    props.forEach(propertyName => {
        // TODO: Check if properties values should not be interpolated, possible bug in old code!
        // This behavior is kept in the new version too, level is set to undefined.
        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);
    });
    if (hasBaseColor) {
        const propColor = baseColorPropName;
        // Finally apply base color and related properties to material (opacity, transparent)
        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);
    }
}
/**
 * Apply single and generic technique property to corresponding material parameter.
 *
 * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it
 * does not provide constructor that would take [[string]] or [[number]] values.
 *
 * @param material - target material
 * @param propertyName - material and technique parameter name (or index) that is to be transferred
 * @param techniqueAttrValue - technique property value which will be applied to material attribute
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of [[Technique]]
 */
function applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {
    const m = material;
    if (m[propertyName] instanceof THREE.Color) {
        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);
    }
    else {
        const value = evaluateProperty(techniqueAttrValue, env);
        if (value !== null) {
            m[propertyName] = value;
        }
    }
}
/**
 * Apply technique color to material taking special care with transparent (RGBA) colors.
 *
 * @note This function is intended to be used with secondary, triary etc. technique colors,
 * not the base ones that may contain transparency information. Such colors should be processed
 * with [[applyTechniqueBaseColorToMaterial]] function.
 *
 * @param technique - an technique the applied color comes from
 * @param material - the material to which color is applied
 * @param prop - technique property (color) name
 * @param value - color value
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of [[Technique]]
 */
function applySecondaryColorToMaterial(materialColor, techniqueColor, env) {
    let value = evaluateColorProperty(techniqueColor, env);
    if (value === undefined) {
        return;
    }
    if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(value)) {
        logger.warn("Used RGBA value for technique color without transparency support!");
        // Just for clarity remove transparency component, even if that would be ignored
        // by THREE.Color.setHex() function.
        value = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(value);
    }
    materialColor.setHex(value);
}
exports.applySecondaryColorToMaterial = applySecondaryColorToMaterial;
/**
 * Apply technique base color (transparency support) to material with modifying material opacity.
 *
 * This method applies main (or base) technique color with transparency support to the corresponding
 * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__
 * attributes.
 *
 * @note Transparent colors should be processed as the very last technique attributes,
 * since their effect on material properties like [[THREE.Material.opacity]] and
 * [[THREE.Material.transparent]] could be overridden by corresponding technique params.
 *
 * @param technique - an technique the applied color comes from
 * @param material - the material to which color is applied
 * @param prop - technique property (color) name
 * @param value - color value in custom number format
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 */
function applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {
    const colorValue = evaluateColorProperty(techniqueColor, env);
    if (colorValue === undefined) {
        return;
    }
    const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(colorValue);
    // Override material opacity and blending by mixing technique defined opacity
    // with main color transparency
    const tech = technique;
    let opacity = a;
    if (tech.opacity !== undefined) {
        opacity *= evaluateProperty(tech.opacity, env);
    }
    opacity = THREE.MathUtils.clamp(opacity, 0, 1);
    material.opacity = opacity;
    materialColor.setRGB(r, g, b);
    const opaque = opacity >= 1.0;
    if (!opaque) {
        harp_materials_1.enableBlending(material);
    }
    else {
        harp_materials_1.disableBlending(material);
    }
}
exports.applyBaseColorToMaterial = applyBaseColorToMaterial;
/**
 * Calculates the value of the technique defined property.
 *
 * Function takes care about property interpolation (when @param `env` is set) as also parsing
 * string encoded numbers.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value - the value of color property defined in technique
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 */
function evaluateProperty(value, env) {
    if (env !== undefined && harp_datasource_protocol_1.Expr.isExpr(value)) {
        value = harp_datasource_protocol_1.getPropertyValue(value, env);
    }
    return value;
}
/**
 * Calculates the numerical value of the technique defined color property.
 *
 * Function takes care about color interpolation (when @param `env is set) as also parsing
 * string encoded colors.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value - the value of color property defined in technique
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 */
function evaluateColorProperty(value, env) {
    value = evaluateProperty(value, env);
    if (value === undefined || value === null) {
        return undefined;
    }
    if (typeof value === "number") {
        return value;
    }
    if (typeof value === "string") {
        const parsed = harp_datasource_protocol_1.parseStringEncodedColor(value);
        if (parsed !== undefined) {
            return parsed;
        }
    }
    logger.error(`Unsupported color format: '${value}'`);
    return undefined;
}
exports.evaluateColorProperty = evaluateColorProperty;
/**
 * Allows to access base color property value for given technique.
 *
 * The color value may be encoded in [[number]], [[string]] or even as
 * [[InterpolateProperty]].
 *
 * @param technique - The techniqe where we seach for base color property.
 * @returns The value of technique color used to apply transparency.
 */
function getBaseColorProp(technique) {
    const baseColorPropName = getBaseColorPropName(technique);
    if (baseColorPropName !== undefined) {
        if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
            const propColor = baseColorPropName;
            return technique[propColor];
        }
        else {
            const params = technique.params;
            const propColor = baseColorPropName;
            return params[propColor];
        }
    }
    return undefined;
}
function getBaseColorPropName(technique) {
    const techDescriptor = harp_datasource_protocol_1.techniqueDescriptors[technique.name];
    return techDescriptor !== undefined ? techDescriptor.attrTransparencyColor : undefined;
}
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === undefined) {
        return new Uint8Array(buffer);
    }
    switch (textureDataType) {
        case THREE.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE.ByteType:
            return new Int8Array(buffer);
        case THREE.ShortType:
            return new Int16Array(buffer);
        case THREE.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE.IntType:
            return new Int32Array(buffer);
        case THREE.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE.FloatType:
            return new Float32Array(buffer);
        case THREE.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}
//# sourceMappingURL=DecodedTileHelpers.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DepthPrePass.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDepthPrePassStencil = exports.createDepthPrePassMesh = exports.createDepthPrePassMaterial = exports.isRenderDepthPrePassEnabled = exports.DEPTH_PRE_PASS_STENCIL_MASK = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ColorUtils_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ColorUtils */ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
/**
 * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position
 * from rendering color.
 */
exports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;
/**
 * Render order offset for the depth pre-pass to ensure that it's rendered first.
 */
const DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;
/**
 * Check if technique requires (and not disables) use of depth prepass.
 *
 * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly
 * disabled by `enableDepthPrePass` option.
 *
 * @param technique - [[BaseStandardTechnique]] instance to be checked
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of [[Technique]]
 */
function isRenderDepthPrePassEnabled(technique, env) {
    // Depth pass explicitly disabled
    if (technique.enableDepthPrePass === false) {
        return false;
    }
    let transparent = technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;
    // If not opaque then check if transparency may be modified via alpha in base color.
    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,
    // will always produce some transparency effect.
    if (!transparent) {
        // We do not support switching depth pass during alpha interpolation, ignore zoom level
        // when calculating base color value.
        const color = DecodedTileHelpers_1.evaluateBaseColorProperty(technique, env);
        if (color !== undefined) {
            const alpha = ColorUtils_1.ColorUtils.getAlphaFromHex(color);
            transparent = alpha > 0.0 && alpha < 1.0;
        }
    }
    return transparent;
}
exports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;
/**
 * Creates material for depth prepass.
 *
 * Creates material that writes only to the z-buffer. Updates the original material instance, to
 * support depth prepass.
 *
 * @param baseMaterial - The base material of mesh that is updated to work with depth prepass
 *     and then used. This parameter is a template for depth prepass material that is returned.
 * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.
 */
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE.EqualDepth;
    baseMaterial.colorWrite = true;
    harp_materials_1.enforceBlending(baseMaterial);
    const depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.isDepthPrepassMaterial = true;
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.opacity = 1.0;
    depthPassMaterial.blending = THREE.NoBlending;
    return depthPassMaterial;
}
exports.createDepthPrePassMaterial = createDepthPrePassMaterial;
// tslint:disable:max-line-length
/**
 * Clones a given mesh to render it in the depth prepass with another material. Both the original
 * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass
 * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to
 * support the depth prepass. This method is usable only if the material of this mesh has an
 * opacity value in the range `(0,1)`.
 *
 * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh
 * to ensure that it's rendered first.
 *
 * @param mesh - original mesh
 * @returns `Mesh` depth pre pass
 */
// tslint:enable:max-line-length
function createDepthPrePassMesh(mesh) {
    const originalGeometry = mesh.geometry;
    if (!(originalGeometry instanceof THREE.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    const positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    const depthPassGeometry = new THREE.BufferGeometry();
    depthPassGeometry.setAttribute("position", positionAttribute);
    const uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.setAttribute("uv", uvAttribute);
    }
    const normalAttribute = originalGeometry.getAttribute("normal");
    if (normalAttribute) {
        depthPassGeometry.setAttribute("normal", normalAttribute);
    }
    const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.setAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    for (const group of originalGeometry.groups) {
        const { start, count, materialIndex } = group;
        depthPassGeometry.addGroup(start, count, materialIndex);
    }
    const depthPassMaterial = mesh.material instanceof Array
        ? mesh.material.map(createDepthPrePassMaterial)
        : createDepthPrePassMaterial(mesh.material);
    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;
    return depthPassMesh;
}
exports.createDepthPrePassMesh = createDepthPrePassMesh;
/**
 * Sets up all the needed stencil logic needed for the depth pre-pass.
 *
 * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have
 * coplanar triangles inside the same mesh.
 *
 * @param depthMesh - Mesh created by `createDepthPrePassMesh`.
 * @param colorMesh - Original mesh.
 */
function setDepthPrePassStencil(depthMesh, colorMesh) {
    // Set up depth mesh stencil logic.
    // Set the depth pre-pass stencil bit for all processed fragments. We use
    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass
    // the stencil test and write the correct depth value.
    const depthMaterial = depthMesh.material;
    depthMaterial.stencilWrite = true;
    depthMaterial.stencilFail = THREE.KeepStencilOp;
    depthMaterial.stencilZFail = THREE.KeepStencilOp;
    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;
    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;
    depthMaterial.stencilRef = 0xff;
    depthMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
    // Set up color mesh stencil logic.
    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is
    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position
    // from rendering color again.
    const colorMaterial = colorMesh.material;
    colorMaterial.stencilWrite = true;
    colorMaterial.stencilFail = THREE.KeepStencilOp;
    colorMaterial.stencilZFail = THREE.KeepStencilOp;
    colorMaterial.stencilZPass = THREE.ZeroStencilOp;
    colorMaterial.stencilFunc = THREE.EqualStencilFunc;
    colorMaterial.stencilRef = 0xff;
    colorMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
}
exports.setDepthPrePassStencil = setDepthPrePassStencil;
//# sourceMappingURL=DepthPrePass.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DisplacementMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DisplacementMap.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=DisplacementMap.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationProvider.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationProvider.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ElevationProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalculationStatus = void 0;
/**
 * Status of the elevation range calculation.
 */
var CalculationStatus;
(function (CalculationStatus) {
    // Calculated approximately. A more precise result may be available later.
    CalculationStatus[CalculationStatus["PendingApproximate"] = 0] = "PendingApproximate";
    // Calculation completed. The result is final, won't improve upon retrying.
    CalculationStatus[CalculationStatus["FinalPrecise"] = 1] = "FinalPrecise";
})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));
//# sourceMappingURL=ElevationRangeSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/FrustumIntersection.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/FrustumIntersection.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrustumIntersection = exports.TileKeyEntry = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js");
const MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
const tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];
const tmpVector4 = new THREE.Vector4();
/**
 * Represents a unique TileKey and the area it takes up on screen.
 *
 * Note, in certain tiling projections, it is possible to have an offset, which represents a tile
 * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which
 * don't require it.
 */
class TileKeyEntry {
    constructor(tileKey, area, offset = 0, minElevation = 0, maxElevation = 0, distance = 0) {
        this.tileKey = tileKey;
        this.area = area;
        this.offset = offset;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.distance = distance;
    }
}
exports.TileKeyEntry = TileKeyEntry;
function getGeoBox(tilingScheme, childTileKey, offset) {
    const geoBox = tilingScheme.getGeoBox(childTileKey);
    const longitudeOffset = 360.0 * offset;
    geoBox.northEast.longitude += longitudeOffset;
    geoBox.southWest.longitude += longitudeOffset;
    return geoBox;
}
/**
 * Computes the tiles intersected by the frustum defined by the current camera setup.
 */
class FrustumIntersection {
    constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod) {
        this.m_camera = m_camera;
        this.mapView = mapView;
        this.m_extendedFrustumCulling = m_extendedFrustumCulling;
        this.m_tileWrappingEnabled = m_tileWrappingEnabled;
        this.m_enableMixedLod = m_enableMixedLod;
        this.m_frustum = new THREE.Frustum();
        // used to project global coordinates into camera local coordinates
        this.m_viewProjectionMatrix = new THREE.Matrix4();
        this.m_rootTileKeys = [];
        this.m_tileKeyEntries = new Map();
        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);
    }
    /**
     * Return camera used for generating frustum.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * Return projection used to convert geo coordinates to world coordinates.
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * Updates the frustum to match the current camera setup.
     */
    updateFrustum(projectionMatrixOverride) {
        this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== undefined
            ? projectionMatrixOverride
            : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
        this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);
        if (this.m_extendedFrustumCulling) {
            this.m_mapTileCuller.setup();
        }
        this.computeRequiredInitialRootTileKeys(this.m_camera.position);
    }
    /**
     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].
     *
     * @param tilingScheme - The tiling scheme used to generate the tiles.
     * @param elevationRangeSource - Source of elevation range data if any.
     * @param zoomLevels - A list of zoom levels to render.
     * @param dataSources - A list of data sources to render.
     * @returns The computation result, see [[FrustumIntersection.Result]].
     */
    compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {
        this.m_tileKeyEntries.clear();
        // Compute target tile area in clip space size.
        // A tile should take up roughly 256x256 pixels on screen in accordance to
        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].
        harp_utils_1.assert(this.mapView.viewportHeight !== 0);
        const targetTileArea = Math.pow(256 / this.mapView.viewportHeight, 2);
        const useElevationRangeSource = elevationRangeSource !== undefined &&
            elevationRangeSource.getTilingScheme() === tilingScheme;
        const obbIntersections = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical || useElevationRangeSource;
        const uniqueZoomLevels = new Set(zoomLevels);
        const cache = {
            calculationFinal: true,
            tileBounds: obbIntersections ? new harp_geoutils_1.OrientedBox3() : new THREE.Box3()
        };
        // create tile key map per zoom level
        for (const zoomLevel of uniqueZoomLevels) {
            this.m_tileKeyEntries.set(zoomLevel, new Map());
        }
        for (const tileEntry of this.m_rootTileKeys) {
            const tileKey = tileEntry.tileKey;
            const offset = tileEntry.offset;
            // We even check the root tiles against the frustum b/c it can happen that
            // computeRequiredInitialRootTileKeys is producing false positives.
            const tileKeyEntry = this.getTileKeyEntry(tileKey, offset, tilingScheme, cache, useElevationRangeSource ? elevationRangeSource : undefined);
            if (tileKeyEntry !== undefined) {
                for (const zoomLevel of uniqueZoomLevels) {
                    const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                    tileKeyEntries.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset), tileKeyEntry);
                }
            }
        }
        const workList = [...this.m_rootTileKeys.values()];
        while (workList.length > 0) {
            const tileEntry = workList.pop();
            if (tileEntry === undefined) {
                break;
            }
            // Stop subdivision if hightest visible level is reached
            const tileKey = tileEntry.tileKey;
            const offset = tileEntry.offset;
            const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));
            if (!subdivide) {
                continue;
            }
            // Stop subdivision if area of tile is too small(mixed LOD only)
            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {
                continue;
            }
            const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset);
            // delete parent tile key from applicable zoom levels
            for (const zoomLevel of uniqueZoomLevels) {
                if (tileKey.level >= zoomLevel) {
                    continue;
                }
                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                tileKeyEntries.delete(tileKeyAndOffset);
            }
            for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                const subTileEntry = this.getTileKeyEntry(subTileKey, offset, tilingScheme, cache, useElevationRangeSource ? elevationRangeSource : undefined);
                if (subTileEntry !== undefined) {
                    // insert sub tile entry into tile entries map per zoom level
                    for (const zoomLevel of uniqueZoomLevels) {
                        if (subTileEntry.tileKey.level > zoomLevel) {
                            continue;
                        }
                        const subTileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(subTileKey, offset);
                        this.m_tileKeyEntries
                            .get(zoomLevel)
                            .set(subTileKeyAndOffset, subTileEntry);
                    }
                    workList.push(subTileEntry);
                }
            }
        }
        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal: cache.calculationFinal };
    }
    getTileKeyEntry(tileKey, offset, tilingScheme, cache, elevationRangeSource) {
        const geoBox = getGeoBox(tilingScheme, tileKey, offset);
        // For tiles without elevation range source, default 0 (getGeoBox always
        // returns box with altitude min/max equal to zero) will be propagated as
        // min and max elevation, these tiles most probably contains features that
        // lays directly on the ground surface.
        if (elevationRangeSource !== undefined) {
            const range = elevationRangeSource.getElevationRange(tileKey);
            geoBox.southWest.altitude = range.minElevation;
            geoBox.northEast.altitude = range.maxElevation;
            cache.calculationFinal =
                cache.calculationFinal &&
                    range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;
        }
        this.mapView.projection.projectBox(geoBox, cache.tileBounds);
        const { area, distance } = this.computeTileAreaAndDistance(cache.tileBounds);
        if (area > 0) {
            return new TileKeyEntry(tileKey, area, offset, geoBox.southWest.altitude, // minElevation
            geoBox.northEast.altitude, // maxElevation
            distance);
        }
        return undefined;
    }
    /**
     * Estimate screen space area of tile and distance to center of tile
     * @param tileBounds - The bounding volume of a tile
     * @return Area estimate and distance to tile center in clip space
     */
    computeTileAreaAndDistance(tileBounds) {
        if (tileBounds instanceof THREE.Box3) {
            if ((this.m_extendedFrustumCulling &&
                !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||
                !this.m_frustum.intersectsBox(tileBounds)) {
                return {
                    area: 0,
                    distance: Infinity
                };
            }
        }
        else if (!tileBounds.intersects(this.m_frustum)) {
            return {
                area: 0,
                distance: Infinity
            };
        }
        // Project tile bounds center
        const center = tileBounds.getCenter(tmpVectors3[0]);
        const projectedPoint = tmpVector4
            .set(center.x, center.y, center.z, 1.0)
            .applyMatrix4(this.m_viewProjectionMatrix);
        // Estimate objects screen space size with diagonal of bounds
        // Dividing by w projects object size to screen space
        const size = tileBounds.getSize(tmpVectors3[1]);
        const objectSize = (0.5 * size.length()) / projectedPoint.w;
        return {
            area: objectSize * objectSize,
            distance: projectedPoint.z / projectedPoint.w
        };
    }
    /**
     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0
     * and have an offset (see {@link Tile}) based on:
     * - the current position [[worldCenter]].
     * - the height of the camera above the world.
     * - the field of view of the camera (the maximum value between the horizontal / vertical
     *   values)
     * - the tilt of the camera (because we see more tiles when tilted).
     *
     * @param worldCenter - The center of the camera in world space.
     */
    computeRequiredInitialRootTileKeys(worldCenter) {
        this.m_rootTileKeys = [];
        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);
        const tileWrappingEnabled = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Planar;
        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0, 0));
            return;
        }
        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);
        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);
        // This algorithm computes the number of offsets we need to test. The following diagram may
        // help explain the algorithm below.
        //
        //   |
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \b    .
        //   |     .   \      .
        //___|a___d1.____\e______.d2______f
        //
        // Where:
        // -  is the camera
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - b is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - c1 to c2 is the fov.
        // - d1 and d2 are the intersection points of the frustum with the world plane.
        // - e is the tilt/pitch of the camera.
        // - f is the world
        //
        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it
        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).
        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with
        // a->e.
        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of
        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because
        // we need the angle between e,  and d2) and using trigonometry, result is therefore:
        // (tan(a->d2) * z).
        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).
        const camera = this.m_camera;
        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this.mapView, camera).pitch;
        // Ensure that the aspect is >= 1.
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.
        const totalAngleRad = THREE.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;
        // Length a->d2
        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
        // Length a->e
        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
        // Length e -> d2
        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);
        // We multiply by SQRT2 because we need to account for a rotated view (in which case there
        // are more tiles that can be seen).
        const offsetRange = THREE.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 
        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift
        // value which is used currently in the VisibleTileSet methods) hence we can have a
        // maximum range of 7 (because 2*7+1 = 15).
        7);
        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset, 0, 0));
        }
    }
}
exports.FrustumIntersection = FrustumIntersection;
//# sourceMappingURL=FrustumIntersection.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapAnchors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapAnchors.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapAnchors = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Container holding [[MapAnchor]] objects.
 */
class MapAnchors {
    constructor() {
        this.m_anchors = [];
    }
    /**
     * All currently added [[MapAnchor]]s.
     */
    get children() {
        return this.m_anchors;
    }
    /**
     * Add a [[MapAnchor]].
     * @param mapAnchor [[MapAnchor]] instance to add.
     */
    add(mapAnchor) {
        this.m_anchors.push(mapAnchor);
    }
    /**
     * Remove a [[MapAnchor]].
     * @param mapAnchor - [[MapAnchor]] instance to remove.
     *
     * @note This method is potentially slow when removing a lot of anchors.
     * [[clear]]ing and [[add]]ing anchors should be considered in that case.
     */
    remove(mapAnchor) {
        const index = this.m_anchors.findIndex(element => element === mapAnchor);
        if (index > -1) {
            this.m_anchors.splice(index, 1);
        }
    }
    /**
     * Remove all [[MapAnchor]]s.
     */
    clear() {
        this.m_anchors.length = 0;
    }
    /**
     * Update the map anchors.
     * @param projection - Current projection
     * @param cameraPosition - Current camera position
     * @param rootNode - Node where normal anchors will be inserted.
     * @param overlayRootNode - Node where overlay anchors will be insterted.
     * @param priorities - Optional theme priority list
     *
     * @internal
     * @hidden
     */
    update(projection, cameraPosition, rootNode, overlayRootNode, priorities) {
        const worldPosition = new THREE.Vector3();
        this.m_anchors.forEach((mapAnchor) => {
            if (mapAnchor.styleSet !== undefined) {
                const priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(entry => entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category);
                if (priority !== undefined && priority !== -1) {
                    mapAnchor.renderOrder = (priority + 1) * 10;
                }
            }
            const anchor = 
            // tslint:disable-next-line: deprecation
            mapAnchor.geoPosition !== undefined ? mapAnchor.geoPosition : mapAnchor.anchor;
            if (anchor !== undefined) {
                if (harp_geoutils_1.isVector3Like(anchor)) {
                    worldPosition.set(anchor.x, anchor.y, anchor.z);
                }
                else if (harp_geoutils_1.isGeoCoordinatesLike(anchor)) {
                    projection.projectPoint(anchor, worldPosition);
                }
                mapAnchor.position.copy(worldPosition).sub(cameraPosition);
            }
            if (mapAnchor.overlay === true) {
                overlayRootNode.add(mapAnchor);
            }
            else {
                rootNode.add(mapAnchor);
            }
        });
    }
}
exports.MapAnchors = MapAnchors;
//# sourceMappingURL=MapAnchors.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapMaterialAdapter = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.
 *
 * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.
 */
class MapMaterialAdapter {
    constructor(material, styledProperties) {
        this.m_lastUpdateFrameNumber = -1;
        this.material = material;
        this.styledProperties = styledProperties;
        this.currentStyledProperties = {};
        this.m_dynamicProperties = [];
        for (const propName in styledProperties) {
            if (!styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const propDefinition = styledProperties[propName];
            if (harp_datasource_protocol_1.Expr.isExpr(propDefinition) || typeof propDefinition === "function") {
                this.m_dynamicProperties.push([propName, propDefinition]);
            }
            else {
                this.currentStyledProperties[propName] = propDefinition;
            }
        }
        this.setupStaticProperties();
    }
    /**
     * Resolve `MapMaterialAdapter` associated with `material`.
     */
    static get(material) {
        var _a;
        const mapAdapter = (_a = material.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter;
        if (mapAdapter instanceof MapMaterialAdapter) {
            return mapAdapter;
        }
        else if (mapAdapter !== undefined) {
            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains
            // stylesed etc, this can be done to rebuild previously saved scene
            return undefined;
        }
        else {
            return undefined;
        }
    }
    static install(objData) {
        if (!objData.material.userData) {
            objData.material.userData = {};
        }
        return (objData.material.userData.mapAdapter = objData);
    }
    static create(material, styledProperties) {
        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));
    }
    static ensureUpdated(material, context) {
        var _a, _b;
        return (_b = (_a = MapMaterialAdapter.get(material)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { styledProperties: this.styledProperties };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates dynamically styled properties of material by evaluating scene dependent expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateDynamicProperties(context);
    }
    /**
     * Applies static properties to target material.
     */
    setupStaticProperties() {
        var _a, _b;
        let updateBaseColor = false;
        for (const propName in this.styledProperties) {
            if (!this.styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const currentValue = this.currentStyledProperties[propName];
            if (currentValue === undefined || currentValue === null) {
                continue;
            }
            if (propName === "color" || propName === "opacity") {
                updateBaseColor = true;
            }
            else {
                this.applyMaterialGenericProp(propName, currentValue);
            }
        }
        if (updateBaseColor) {
            const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
            const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
            this.applyMaterialBaseColor(color, opacity);
        }
    }
    /**
     * Applies static properties to target material.
     */
    updateDynamicProperties(context) {
        var _a, _b;
        let somethingChanged = false;
        if (this.m_dynamicProperties.length > 0) {
            let updateBaseColor = false;
            for (const [propName, propDefinition] of this.m_dynamicProperties) {
                const newValue = harp_datasource_protocol_1.Expr.isExpr(propDefinition)
                    ? harp_datasource_protocol_1.getPropertyValue(propDefinition, context.env)
                    : propDefinition(context);
                if (newValue === this.currentStyledProperties[propName]) {
                    continue;
                }
                this.currentStyledProperties[propName] = newValue;
                // `color` and `opacity` are special properties to support RGBA
                if (propName === "color" || propName === "opacity") {
                    updateBaseColor = true;
                }
                else {
                    this.applyMaterialGenericProp(propName, newValue);
                    somethingChanged = true;
                }
            }
            if (updateBaseColor) {
                const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
                const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
                this.applyMaterialBaseColor(color, opacity);
                somethingChanged = true;
            }
        }
        return somethingChanged;
    }
    applyMaterialGenericProp(propName, value) {
        const m = this.material;
        if (m[propName] instanceof THREE.Color) {
            let colorValue = value;
            if (typeof colorValue !== "number") {
                const parsed = DecodedTileHelpers_1.evaluateColorProperty(colorValue);
                if (parsed === undefined) {
                    return;
                }
                colorValue = parsed;
            }
            const rgbValue = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(colorValue);
            m[propName].set(rgbValue);
        }
        else {
            m[propName] = value;
        }
    }
    applyMaterialBaseColor(color, opacity) {
        if (typeof color !== "number") {
            const parsed = DecodedTileHelpers_1.evaluateColorProperty(color);
            if (parsed === undefined) {
                return;
            }
            color = parsed;
        }
        const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(color !== null && color !== void 0 ? color : 0xff0000);
        const actualOpacity = a * THREE.MathUtils.clamp(opacity !== null && opacity !== void 0 ? opacity : 1, 0, 1);
        this.material.opacity = actualOpacity;
        this.material.color.setRGB(r, g, b);
        const opaque = actualOpacity >= 1.0;
        if (!opaque) {
            harp_materials_1.enableBlending(this.material);
        }
        else {
            harp_materials_1.disableBlending(this.material);
        }
    }
}
exports.MapMaterialAdapter = MapMaterialAdapter;
//# sourceMappingURL=MapMaterialAdapter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapObjectAdapter = void 0;
const MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ "./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js");
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.
 *
 * [[MapObjectAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Object3D`.
 */
class MapObjectAdapter {
    constructor(object, params) {
        this.m_lastUpdateFrameNumber = -1;
        this.m_notCompletlyTransparent = true;
        this.object = object;
        this.technique = params.technique;
        this.kind = params.kind;
        this.m_notCompletlyTransparent = this.getObjectMaterials().some(material => material.opacity > 0);
    }
    /**
     * Resolve `MapObjectAdapter` associated with `object`.
     */
    static get(object) {
        var _a;
        return ((_a = object.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter) instanceof MapObjectAdapter
            ? object.userData.mapAdapter
            : undefined;
    }
    static install(objData) {
        if (!objData.object.userData) {
            objData.object.userData = {};
        }
        return (objData.object.userData.mapAdapter = objData);
    }
    static create(object, params) {
        return MapObjectAdapter.install(new MapObjectAdapter(object, params));
    }
    static ensureUpdated(object, context) {
        var _a, _b;
        return (_b = (_a = MapObjectAdapter.get(object)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { kind: this.kind, technique: this.technique };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates object and attachments like materials to current state by evaluating scene dependent
     * expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateMaterials(context);
    }
    /**
     * Whether underlying `THREE.Object3D` is actually visible in scene.
     */
    isVisible() {
        return this.object.visible && this.m_notCompletlyTransparent;
    }
    updateMaterials(context) {
        let somethingChanged = false;
        const materials = this.getObjectMaterials();
        for (const material of materials) {
            const changed = MapMaterialAdapter_1.MapMaterialAdapter.ensureUpdated(material, context);
            somethingChanged = somethingChanged || changed;
        }
        if (somethingChanged) {
            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);
        }
        return somethingChanged;
    }
    getObjectMaterials() {
        const object = this.object;
        return Array.isArray(object.material)
            ? object.material
            : object.material !== undefined
                ? [object.material]
                : [];
    }
}
exports.MapObjectAdapter = MapObjectAdapter;
//# sourceMappingURL=MapObjectAdapter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapTileCuller.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapTileCuller = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Second step tile culling: Do additional check for intersection of box and frustum by checking if
 * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of
 * the standard frustum test, which excludes many cases where the large terrain tiles straddle the
 * planes of the frustum.
 *
 * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
 */
class MapTileCuller {
    /**
     * Constructs a `MapTileCuller`.
     *
     * @param m_camera - A `THREE.Camera`.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_globalFrustumMin = new THREE.Vector3();
        this.m_globalFrustumMax = new THREE.Vector3();
        this.m_frustumCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
    }
    /**
     * Sets up culling and computes frustum corners. You mus call this function before the culling
     * starts.
     */
    setup() {
        const frustumCorners = this.getFrustumCorners();
        const matrix = this.m_camera.matrixWorld;
        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (const frustumCorner of frustumCorners) {
            frustumCorner.applyMatrix4(matrix);
            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
        }
    }
    /**
     * Checks if the tile's bounding box intersects with the current view's frustum.
     *
     * @param tileBounds - The bounding box for the tile.
     */
    frustumIntersectsTileBox(tileBounds) {
        const globalFrustumMin = this.m_globalFrustumMin;
        const globalFrustumMax = this.m_globalFrustumMax;
        if (globalFrustumMax.x < tileBounds.min.x ||
            globalFrustumMax.y < tileBounds.min.y ||
            globalFrustumMax.z < tileBounds.min.z ||
            globalFrustumMin.x > tileBounds.max.x ||
            globalFrustumMin.y > tileBounds.max.y ||
            globalFrustumMin.z > tileBounds.max.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the eight corners of the frustum.
     */
    getFrustumCorners() {
        const frustumCorners = this.m_frustumCorners;
        const invProjMatrix = this.m_camera.projectionMatrixInverse;
        let cornerIndex = 0;
        function addPoint(x, y, z) {
            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
        }
        const w = 1;
        const h = 1;
        const n = -1;
        const f = 1;
        // near
        addPoint(-w, -h, n);
        addPoint(w, -h, n);
        addPoint(-w, h, n);
        addPoint(w, h, n);
        // far
        addPoint(-w, -h, f);
        addPoint(w, -h, f);
        addPoint(-w, h, f);
        addPoint(w, h, f);
        return frustumCorners;
    }
}
exports.MapTileCuller = MapTileCuller;
//# sourceMappingURL=MapTileCuller.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapView.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapView.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MapView = exports.MapViewPowerPreference = exports.FALLBACK_RENDER_ORDER_OFFSET = exports.MapViewEventNames = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js");
const CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js");
const composing_1 = __webpack_require__(/*! ./composing */ "./node_modules/@here/harp-mapview/lib/composing/index.js");
const ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js");
const CopyrightInfo_1 = __webpack_require__(/*! ./copyrights/CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js");
const FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ "./node_modules/@here/harp-mapview/lib/FrustumIntersection.js");
const overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ "./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js");
const TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js");
const MapAnchors_1 = __webpack_require__(/*! ./MapAnchors */ "./node_modules/@here/harp-mapview/lib/MapAnchors.js");
const MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js");
const MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ "./node_modules/@here/harp-mapview/lib/MapViewFog.js");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js");
const PickingRaycaster_1 = __webpack_require__(/*! ./PickingRaycaster */ "./node_modules/@here/harp-mapview/lib/PickingRaycaster.js");
const PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js");
const PoiRendererFactory_1 = __webpack_require__(/*! ./poi/PoiRendererFactory */ "./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js");
const PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js");
const PolarTileDataSource_1 = __webpack_require__(/*! ./PolarTileDataSource */ "./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js");
const ScreenCollisions_1 = __webpack_require__(/*! ./ScreenCollisions */ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js");
const ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js");
const SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ "./node_modules/@here/harp-mapview/lib/SkyBackground.js");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const FontCatalogLoader_1 = __webpack_require__(/*! ./text/FontCatalogLoader */ "./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js");
const MapViewState_1 = __webpack_require__(/*! ./text/MapViewState */ "./node_modules/@here/harp-mapview/lib/text/MapViewState.js");
const TextCanvasFactory_1 = __webpack_require__(/*! ./text/TextCanvasFactory */ "./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
const VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js");
// Cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
if (isProduction) {
    // In production: silence logging below error.
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Error);
}
else {
    // In dev: silence logging below log (silences "debug" and "trace" levels).
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Log);
}
var MapViewEventNames;
(function (MapViewEventNames) {
    /** Called before this `MapView` starts to render a new frame. */
    MapViewEventNames["Update"] = "update";
    /** Called when the WebGL canvas is resized. */
    MapViewEventNames["Resize"] = "resize";
    /** Called when the frame is about to be rendered. */
    MapViewEventNames["Render"] = "render";
    /** Called after a frame has been rendered. */
    MapViewEventNames["AfterRender"] = "didrender";
    /** Called after the first frame has been rendered. */
    MapViewEventNames["FirstFrame"] = "first-render";
    /** Called when the first view has all the necessary tiles loaded and rendered. */
    MapViewEventNames["FrameComplete"] = "frame-complete";
    /** Called when the theme has been loaded with the internal {@link ThemeLoader}. */
    MapViewEventNames["ThemeLoaded"] = "theme-loaded";
    /** Called when the animation mode has started. */
    MapViewEventNames["AnimationStarted"] = "animation-started";
    /** Called when the animation mode has stopped. */
    MapViewEventNames["AnimationFinished"] = "animation-finished";
    /** Called when a camera interaction has been detected. */
    MapViewEventNames["MovementStarted"] = "movement-started";
    /** Called when a camera interaction has been stopped. */
    MapViewEventNames["MovementFinished"] = "movement-finished";
    /** Called when a data source has been connected or failed to connect. */
    MapViewEventNames["DataSourceConnect"] = "datasource-connect";
    /** Emitted when copyright info of rendered map has been changed. */
    MapViewEventNames["CopyrightChanged"] = "copyright-changed";
    /** Called when the WebGL context is lost. */
    MapViewEventNames["ContextLost"] = "webglcontext-lost";
    /** Called when the WebGL context is restored. */
    MapViewEventNames["ContextRestored"] = "webglcontext-restored";
    /** Called when camera position has been changed. */
    MapViewEventNames["CameraPositionChanged"] = "camera-changed";
})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const DEFAULT_CLEAR_COLOR = 0xefe9e1;
const DEFAULT_FOV_CALCULATION = { type: "dynamic", fov: 40 };
const DEFAULT_CAM_NEAR_PLANE = 0.1;
const DEFAULT_CAM_FAR_PLANE = 4000000;
const MAX_FIELD_OF_VIEW = 140;
const MIN_FIELD_OF_VIEW = 10;
// All objects in fallback tiles are reduced by this amount.
exports.FALLBACK_RENDER_ORDER_OFFSET = 20000;
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Default maximum zoom level.
 */
const DEFAULT_MAX_ZOOM_LEVEL = 20;
/**
 * Default minimum camera height.
 */
const DEFAULT_MIN_CAMERA_HEIGHT = 20;
/**
 * Style set used by {@link PolarTileDataSource} by default.
 */
const DEFAULT_POLAR_STYLE_SET_NAME = "polar";
// Event type: cast needed to workaround wrong THREE.js typings.
const UPDATE = { type: MapViewEventNames.Update };
const RENDER_EVENT = { type: MapViewEventNames.Render };
const DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };
const FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };
const FRAME_COMPLETE_EVENT = { type: MapViewEventNames.FrameComplete };
const THEME_LOADED_EVENT = { type: MapViewEventNames.ThemeLoaded };
const ANIMATION_STARTED_EVENT = { type: MapViewEventNames.AnimationStarted };
const ANIMATION_FINISHED_EVENT = { type: MapViewEventNames.AnimationFinished };
const MOVEMENT_STARTED_EVENT = { type: MapViewEventNames.MovementStarted };
const MOVEMENT_FINISHED_EVENT = { type: MapViewEventNames.MovementFinished };
const CONTEXT_LOST_EVENT = { type: MapViewEventNames.ContextLost };
const CONTEXT_RESTORED_EVENT = { type: MapViewEventNames.ContextRestored };
const COPYRIGHT_CHANGED_EVENT = { type: MapViewEventNames.CopyrightChanged };
const cache = {
    vector2: [new THREE.Vector2()],
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    rayCaster: new THREE.Raycaster(),
    groundPlane: new THREE.Plane(),
    groundSphere: new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS),
    frustumPoints: [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
    ],
    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],
    transform: [
        {
            position: new THREE.Vector3(),
            xAxis: new THREE.Vector3(),
            yAxis: new THREE.Vector3(),
            zAxis: new THREE.Vector3()
        }
    ]
};
/**
 * Hint for the WebGL implementation on which power mode to prefer.
 *
 * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12
 */
var MapViewPowerPreference;
(function (MapViewPowerPreference) {
    /** Default value. */
    MapViewPowerPreference["Default"] = "default";
    /** Lower power mode, used to conserve energy. */
    MapViewPowerPreference["LowPower"] = "low-power";
    /** Maximum performance. */
    MapViewPowerPreference["HighPerformance"] = "high-performance";
})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));
/**
 * Default settings used by {@link MapView} collected in one place.
 * @internal
 */
const MapViewDefaults = {
    projection: harp_geoutils_1.mercatorProjection,
    addBackgroundDatasource: true,
    maxVisibleDataSourceTiles: 100,
    extendedFrustumCulling: true,
    tileCacheSize: 200,
    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== undefined
        ? window.devicePixelRatio
        : 1.0,
    target: new harp_geoutils_1.GeoCoordinates(25, 0),
    zoomLevel: 5,
    tilt: 0,
    heading: 0,
    theme: {}
};
/**
 * The core class of the library to call in order to create a map visualization. It needs to be
 * linked to datasources.
 */
class MapView extends THREE.EventDispatcher {
    /**
     * Constructs a new `MapView` with the given options or canvas element.
     *
     * @param options - The `MapView` options or the HTML canvas element used to display the map.
     */
    constructor(options) {
        super();
        this.m_renderLabels = true;
        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();
        this.m_visibleTileSetLock = false;
        this.m_tileWrappingEnabled = true;
        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
        this.m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);
        /**
         * Relative to eye camera.
         *
         * This camera is internal camera used to improve precision
         * when rendering geometries.
         */
        this.m_rteCamera = new THREE.PerspectiveCamera();
        this.m_yaw = 0;
        this.m_pitch = 0;
        this.m_roll = 0;
        this.m_focalLength = 0;
        this.m_targetDistance = 0;
        this.m_targetGeoPos = harp_geoutils_1.GeoCoordinates.fromObject(MapViewDefaults.target);
        // Focus point world coords may be calculated after setting projection, use dummy value here.
        this.m_targetWorldPos = new THREE.Vector3();
        this.m_viewRanges = {
            near: DEFAULT_CAM_NEAR_PLANE,
            far: DEFAULT_CAM_FAR_PLANE,
            minimum: DEFAULT_CAM_NEAR_PLANE,
            maximum: DEFAULT_CAM_FAR_PLANE
        };
        /** Default scene for map objects and map anchors */
        this.m_scene = new THREE.Scene();
        /** Separate scene for overlay map anchors */
        this.m_overlayScene = new THREE.Scene();
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_scene);
        /** Root node of [[m_scene]] that get's cleared every frame. */
        this.m_sceneRoot = new THREE.Object3D();
        /** Root node of [[m_overlayScene]] that get's cleared every frame. */
        this.m_overlaySceneRoot = new THREE.Object3D();
        this.m_mapAnchors = new MapAnchors_1.MapAnchors();
        this.m_animationCount = 0;
        this.m_drawing = false;
        this.m_updatePending = false;
        this.m_frameNumber = 0;
        this.m_forceCameraAspect = undefined;
        //
        // sources
        //
        this.m_tileDataSources = [];
        this.m_connectedDataSources = new Set();
        this.m_failedDataSources = new Set();
        this.m_enablePolarDataSource = true;
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        this.m_theme = {};
        this.m_themeIsLoading = false;
        this.m_firstFrameRendered = false;
        this.m_firstFrameComplete = false;
        this.m_initialTextPlacementDone = false;
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this);
        this.m_poiManager = new PoiManager_1.PoiManager(this);
        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);
        this.m_lastTileIds = "";
        this.m_copyrightInfo = [];
        this.m_env = new harp_datasource_protocol_1.MapEnv({});
        /**
         * Default handler for webglcontextlost event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent(CONTEXT_LOST_EVENT);
            logger.warn("WebGL context lost", event);
        };
        /**
         * Default handler for webglcontextrestored event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextRestored = (event) => {
            this.dispatchEvent(CONTEXT_RESTORED_EVENT);
            if (this.m_renderer !== undefined) {
                if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {
                    this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));
                }
                else {
                    this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
                }
                this.update();
            }
            logger.warn("WebGL context restored", event);
        };
        // make a copy to avoid unwanted changes to the original options.
        this.m_options = Object.assign({}, options);
        this.m_uriResolver = this.m_options.uriResolver;
        if (this.m_options.minZoomLevel !== undefined) {
            this.m_minZoomLevel = this.m_options.minZoomLevel;
        }
        if (this.m_options.maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = this.m_options.maxZoomLevel;
        }
        if (this.m_options.minCameraHeight !== undefined) {
            this.m_minCameraHeight = this.m_options.minCameraHeight;
        }
        if (this.m_options.decoderUrl !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver
                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)
                : this.m_options.decoderUrl;
        }
        if (this.m_options.decoderCount !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
        }
        this.m_visibleTileSetOptions = Object.assign(Object.assign({}, MapViewDefaults), { clipPlanesEvaluator: options.clipPlanesEvaluator !== undefined
                ? options.clipPlanesEvaluator
                : ClipPlanesEvaluator_1.createDefaultClipPlanesEvaluator() });
        if (options.projection !== undefined) {
            this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.extendedFrustumCulling !== undefined) {
            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== undefined) {
            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =
                options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== undefined) {
            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== undefined) {
            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =
                options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =
                options.quadTreeSearchDistanceDown;
        }
        if (options.enablePolarDataSource !== undefined) {
            this.m_enablePolarDataSource = options.enablePolarDataSource;
        }
        this.m_pixelRatio = options.pixelRatio;
        this.maxFps = options.maxFps === undefined ? 0 : options.maxFps;
        this.m_options.enableStatistics = this.m_options.enableStatistics === true;
        this.m_languages = this.m_options.languages;
        this.m_politicalView = this.m_options.politicalView;
        if (this.m_options.collisionDebugCanvas !== undefined &&
            this.m_options.collisionDebugCanvas !== null) {
            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;
            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_collisionDebugCanvas);
        }
        this.handleRequestAnimationFrame = this.renderLoop.bind(this);
        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enablePickTechnique === true);
        if (this.m_options.tileWrappingEnabled !== undefined) {
            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;
        }
        // Initialization of the stats
        this.setupStats(this.m_options.enableStatistics);
        this.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
        // Initialization of the renderer
        this.m_renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            context: this.m_options.context,
            antialias: this.nativeWebglAntialiasEnabled,
            alpha: this.m_options.alpha,
            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,
            powerPreference: this.m_options.powerPreference === undefined
                ? MapViewPowerPreference.Default
                : this.m_options.powerPreference
        });
        this.m_renderer.autoClear = false;
        this.m_renderer.debug.checkShaderErrors = !isProduction;
        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info
        // When using several WebGLRenderer#render calls per frame, it is the only way to get
        // correct rendering data from ThreeJS.
        this.m_renderer.info.autoReset = false;
        this.setupRenderer();
        this.m_options.fovCalculation =
            this.m_options.fovCalculation === undefined
                ? DEFAULT_FOV_CALCULATION
                : this.m_options.fovCalculation;
        this.m_options.fovCalculation.fov = THREE.MathUtils.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        // Initialization of mCamera and mVisibleTiles
        const { width, height } = this.getCanvasClientSize();
        const aspect = width / height;
        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);
        this.m_camera.up.set(0, 0, 1);
        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);
        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.
        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);
        // setup camera with initial position
        this.setupCamera();
        this.m_raycaster = new PickingRaycaster_1.PickingRaycaster(width, height);
        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        this.m_tileGeometryManager = new TileGeometryManager_1.TileGeometryManager(this);
        if (options.enableMixedLod !== undefined) {
            this.m_enableMixedLod = options.enableMixedLod;
        }
        this.m_visibleTiles = this.createVisibleTileSet();
        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);
        if (this.m_options.addBackgroundDatasource !== false) {
            this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();
            this.addDataSource(this.m_backgroundDataSource);
        }
        if (this.m_enablePolarDataSource) {
            const styleSetName = options.polarStyleSetName !== undefined
                ? options.polarStyleSetName
                : DEFAULT_POLAR_STYLE_SET_NAME;
            this.m_polarDataSource = new PolarTileDataSource_1.PolarTileDataSource({
                styleSetName,
                geometryLevelOffset: options.polarGeometryLevelOffset
            });
            this.updatePolarDataSource();
        }
        if (this.m_options.backgroundTilingScheme !== undefined &&
            this.m_backgroundDataSource !== undefined) {
            this.m_backgroundDataSource.setTilingScheme(this.m_options.backgroundTilingScheme);
        }
        this.initTheme();
        this.m_textElementsRenderer = this.createTextRenderer();
        this.update();
    }
    /**
     * @returns The lights configured by the theme, this is just a convenience method, because the
     * lights can still be accessed by traversing the children of the [[scene]].
     */
    get lights() {
        var _a;
        return (_a = this.m_createdLights) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * @returns Whether label rendering is enabled.
     */
    get renderLabels() {
        return this.m_renderLabels;
    }
    /**
     * Enables or disables rendering of labels.
     * @param value - `true` to enable labels `false` to disable them.
     */
    set renderLabels(value) {
        this.m_renderLabels = value;
    }
    /**
     * @returns Whether adding of new labels during interaction is enabled.
     */
    get delayLabelsUntilMovementFinished() {
        return this.textElementsRenderer.delayLabelsUntilMovementFinished;
    }
    /**
     * Enables or disables adding of  new labels during interaction. Has no influence on already
     * placed labels
     * @param value - `true` to enable adding `false` to disable them.
     */
    set delayLabelsUntilMovementFinished(value) {
        this.textElementsRenderer.delayLabelsUntilMovementFinished = value;
    }
    /**
     * @hidden
     * The {@link TextElementsRenderer} select the visible {@link TextElement}s and renders them.
     */
    get textElementsRenderer() {
        return this.m_textElementsRenderer;
    }
    /**
     * @hidden
     * The {@link CameraMovementDetector} detects camera movements. Made available for performance
     * measurements.
     */
    get cameraMovementDetector() {
        return this.m_movementDetector;
    }
    /**
     * The {@link AnimatedExtrusionHandler} controls animated extrusion effect
     * of the extruded objects in the {@link Tile}
     */
    get animatedExtrusionHandler() {
        return this.m_animatedExtrusionHandler;
    }
    /**
     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of
     * specified [[GeometryKind]]s.
     */
    get tileGeometryManager() {
        return this.m_tileGeometryManager;
    }
    get enableMixedLod() {
        return this.m_enableMixedLod;
    }
    set enableMixedLod(enableMixedLod) {
        // Skip unnecessary update
        if (this.m_enableMixedLod === enableMixedLod) {
            return;
        }
        this.m_enableMixedLod = enableMixedLod;
        this.m_visibleTiles = this.createVisibleTileSet();
        this.resetTextRenderer();
        this.update();
    }
    /**
     * Disposes this `MapView`.
     *
     * This function cleans the resources that are managed manually including those that exist in
     * shared caches.
     *
     * Note: This function does not try to clean objects that can be disposed off easily by
     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full
     * cleanup, you must ensure that all references to this `MapView` are removed.
     */
    dispose() {
        if (this.m_movementFinishedUpdateTimerId) {
            clearTimeout(this.m_movementFinishedUpdateTimerId);
            this.m_movementFinishedUpdateTimerId = undefined;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.canvas.removeEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.removeEventListener("webglcontextrestored", this.onWebGLContextRestored);
        for (const dataSource of this.m_tileDataSources) {
            dataSource.dispose();
        }
        this.m_visibleTiles.clearTileCache();
        this.m_textElementsRenderer.clearRenderStates();
        this.m_renderer.dispose();
        this.m_imageCache.clear();
        this.m_movementDetector.dispose();
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_visibleTiles.resourceComputationType;
    }
    set resourceComputationType(value) {
        this.m_visibleTiles.resourceComputationType = value;
    }
    /**
     * Returns the cache size.
     */
    getCacheSize() {
        return this.m_visibleTiles.getDataSourceCacheSize();
    }
    /**
     * Sets the cache size in number of tiles.
     *
     * @param size - The cache size in tiles.
     * @param numVisibleTiles - The number of tiles visible, which is size/2 by default.
     */
    setCacheSize(size, numVisibleTiles) {
        this.m_visibleTiles.setDataSourceCacheSize(size);
        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;
        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));
        this.updateImages();
        this.updateLighting();
        this.m_textElementsRenderer.invalidateCache();
        this.updateSkyBackground();
        this.update();
    }
    /**
     * Specfies whether extended frustum culling is enabled or disabled.
     */
    get extendedFrustumCulling() {
        return this.m_options.extendedFrustumCulling !== undefined
            ? this.m_visibleTileSetOptions.extendedFrustumCulling
            : true;
    }
    /**
     * Enable of disable extended frustum culling.
     */
    set extendedFrustumCulling(value) {
        this.m_visibleTileSetOptions.extendedFrustumCulling = value;
    }
    /**
     * Returns the status of frustum culling after each update.
     */
    get lockVisibleTileSet() {
        return this.m_visibleTileSetLock;
    }
    /**
     * Enable of disable frustum culling after each update.
     */
    set lockVisibleTileSet(value) {
        this.m_visibleTileSetLock = value;
    }
    /**
     * Gets the optional camera used to render the scene.
     */
    get pointOfView() {
        return this.m_pointOfView;
    }
    /**
     * Sets the optional camera used to render the scene.
     */
    set pointOfView(pointOfView) {
        this.m_pointOfView = pointOfView;
        this.update();
    }
    /**
     * Loads a post effects definition file.
     *
     * @param postEffectsFile - File URL describing the post effects.
     */
    loadPostEffects(postEffectsFile) {
        fetch(postEffectsFile)
            .then(response => response.json())
            .then((postEffects) => {
            this.m_postEffects = postEffects;
            this.setPostEffects();
        });
    }
    /**
     * The abstraction of the {@link MapRenderingManager} API for post effects.
     */
    get postEffects() {
        return this.m_postEffects;
    }
    set postEffects(postEffects) {
        this.m_postEffects = postEffects;
        this.setPostEffects();
    }
    /**
     * Gets the current `Theme` used by this `MapView` to style map elements.
     */
    get theme() {
        return this.m_theme;
    }
    /**
     * Changes the `Theme` used by this `MapView` to style map elements.
     */
    set theme(theme) {
        if (!ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {
            this.m_themeIsLoading = true;
            // If theme is not yet loaded, let's set theme asynchronously
            ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver })
                .then(loadedTheme => {
                this.m_themeIsLoading = false;
                this.theme = loadedTheme;
            })
                .catch(error => {
                this.m_themeIsLoading = false;
                logger.error(`failed to set theme: ${error}`, error);
            });
            return;
        }
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        this.updateSkyBackground();
        this.m_fog.reset(this.m_theme);
        this.m_theme.lights = theme.lights;
        this.updateLighting();
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.m_theme.clearAlpha = theme.clearAlpha;
        this.renderer.setClearColor(new THREE.Color(theme.clearColor), theme.clearAlpha);
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        this.updateImages();
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        this.loadPoiTables();
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        this.resetTextRenderer();
        if (Array.isArray(theme.priorities)) {
            this.m_theme.priorities = theme.priorities;
        }
        if (Array.isArray(theme.labelPriorities)) {
            this.m_theme.labelPriorities = theme.labelPriorities;
        }
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = {};
        }
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.setTheme(this.m_theme);
        }
        this.m_theme.styles = theme.styles || {};
        this.m_theme.definitions = theme.definitions;
        for (const dataSource of this.m_tileDataSources) {
            dataSource.setTheme(this.m_theme);
        }
        THEME_LOADED_EVENT.time = Date.now();
        this.dispatchEvent(THEME_LOADED_EVENT);
        this.update();
    }
    /**
     * {@link @here/harp-utils#UriResolver} used to resolve application/deployment
     * specific `URI`s into actual `URLs` that can be loaded with `fetch`.
     */
    get uriResolver() {
        return this.m_uriResolver;
    }
    /**
     * Gets the value of the forced custom camera aspect.
     * Every time a frame is rendered, `MapView` resets the camera aspect.
     *
     * You can disable this behavior by setting the value to `undefined`.
     */
    get forceCameraAspect() {
        return this.m_forceCameraAspect;
    }
    /**
     * Sets the custom forced camera aspect ratio to use while rendering.
     */
    set forceCameraAspect(aspect) {
        this.m_forceCameraAspect = aspect;
    }
    /**
     * Lists the ISO 639-1 language codes for DataSources to use.
     */
    get languages() {
        return this.m_languages;
    }
    /**
     * Sets the list of ISO 639-1 language codes for DataSources to use.
     */
    set languages(languages) {
        this.m_languages = languages;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setLanguages(this.m_languages);
        });
        this.update();
    }
    /**
     * Get currently presented political point of view - the country code.
     *
     * @note Country code is stored in lower-case ISO 3166-1 alpha-2 standard.
     * @return Country code or undefined if default
     * (majorly accepted) point of view is used.
     */
    get politicalView() {
        return this.m_politicalView;
    }
    /**
     * Set the political view (country code) to be used when rendering disputed features (borders).
     *
     * @note Country code should be encoded in lower-case ISO 3166-1 alpha-2 standard.
     * @param pov - The code of the country which point of view should be presented,
     * if `undefined` or empty string is set then "defacto" or most widely accepted point of view
     * will be presented.
     */
    set politicalView(pov) {
        if (this.m_politicalView === pov) {
            return;
        }
        this.m_politicalView = pov;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setPoliticalView(pov);
        });
    }
    get copyrightInfo() {
        return this.m_copyrightInfo;
    }
    /**
     * @hidden
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_textElementsRenderer.disableFading = disable;
    }
    get disableFading() {
        return this.m_textElementsRenderer.disableFading;
    }
    /**
     * @hidden
     * Return current frame number.
     */
    get frameNumber() {
        return this.m_frameNumber;
    }
    /**
     * @hidden
     * Reset the frame number to 0.
     */
    resetFrameNumber() {
        this.m_frameNumber = 0;
        this.m_previousFrameTimeStamp = undefined;
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get canvas() {
        return this.m_options.canvas;
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get collisionDebugCanvas() {
        return this.m_collisionDebugCanvas;
    }
    /**
     * The THREE.js scene used by this `MapView`.
     */
    get scene() {
        return this.m_scene;
    }
    /**
     * The THREE.js camera used by this `MapView` to render the main scene.
     * @note When modifying the camera all derived properties like:
     * - {@link MapView.target}
     * - {@link MapView.zoomLevel}
     * - {@link MapView.tilt}
     * - {@link MapView.heading}
     * could change.
     * These properties are cached internaly and will only be updated in the next animation frame.
     * FIXME: Unfortunatley THREE.js is not dispatching any events when camera properties change
     * so we should have an API for enforcing update of cached values.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * The THREE.js `WebGLRenderer` used by this scene.
     */
    get renderer() {
        return this.m_renderer;
    }
    /**
     * The color used to clear the view.
     */
    get clearColor() {
        const rendererClearColor = this.m_renderer.getClearColor();
        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
    }
    /**
     * The color used to clear the view.
     */
    set clearColor(color) {
        this.m_renderer.setClearColor(color);
    }
    /**
     * The alpha used to clear the view.
     */
    get clearAlpha() {
        const rendererClearAlpha = this.m_renderer.getClearAlpha();
        return rendererClearAlpha !== undefined ? rendererClearAlpha : 0;
    }
    /**
     * The alpha used to clear the view.
     */
    set clearAlpha(alpha) {
        this.m_renderer.setClearAlpha(alpha);
    }
    /**
     * The projection used to project geo coordinates to world coordinates.
     */
    get projection() {
        return this.m_visibleTileSetOptions.projection;
    }
    /**
     * Changes the projection at run time.
     *
     * @param projection - The {@link @here/harp-geoutils#Projection} instance to use.
     */
    set projection(projection) {
        // Remember tilt and heading before setting the projection.
        const tilt = this.tilt;
        const heading = this.heading;
        this.m_visibleTileSetOptions.projection = projection;
        this.updatePolarDataSource();
        this.clearTileCache();
        this.textElementsRenderer.clearRenderStates();
        this.m_visibleTiles = this.createVisibleTileSet();
        this.lookAtImpl({ tilt, heading });
    }
    /**
     * Get camera clipping planes evaluator used.
     */
    get clipPlanesEvaluator() {
        return this.m_visibleTileSetOptions.clipPlanesEvaluator;
    }
    /**
     * Changes the clip planes evaluator at run time.
     */
    set clipPlanesEvaluator(clipPlanesEvaluator) {
        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;
    }
    /**
     * The distance (in pixels) between the screen and the camera.
     */
    get focalLength() {
        return this.m_focalLength;
    }
    /**
     * Get geo coordinates of camera focus (target) point.
     * This point is not necessarily on the ground, i.e.:
     *  - if the tilt is high and projection is [[sphereProjection]]
     *  - if the camera was modified directly and is not pointing to the ground.
     * In any case the projection of the target point will be in the center of the screen.
     *
     * @returns geo coordinates of the camera focus point.
     */
    get target() {
        return this.m_targetGeoPos;
    }
    /** @internal
     * Get world coordinates of camera focus point.
     *
     * @note The focus point coordinates are updated with each camera update so you don't need
     * to re-calculate it, although if the camera started looking to the void, the last focus
     * point is stored.
     *
     * @returns world coordinates of the camera focus point.
     */
    get worldTarget() {
        return this.m_targetWorldPos;
    }
    /** @internal
     * Get distance from camera to the point of focus in world units.
     *
     * @note If camera does not point to any ground anymore the last focus point distance is
     * then returned.
     *
     * @returns Last known focus point distance.
     */
    get targetDistance() {
        return this.m_targetDistance;
    }
    /**
     * Get object describing frustum planes distances and min/max visibility range for actual
     * camera setup.
     * Near and far plane distance are self explanatory while minimum and maximum visibility range
     * describes the extreme near/far planes distances that may be achieved with current camera
     * settings, meaning at current zoom level (ground distance) and any possible orientation.
     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines
     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change
     * whenever zoom level changes. Distance is measured in world units which may be approximately
     * equal to meters, but this depends on the distortion related to projection type used.
     * @internal
     */
    get viewRanges() {
        return this.m_viewRanges;
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * @internal
     */
    get geoCenter() {
        return this.projection.unprojectPoint(this.m_camera.position).normalized();
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * Longitude values outside of -180 and +180 are acceptable.
     */
    set geoCenter(geoCenter) {
        if (geoCenter.altitude !== undefined) {
            this.projection.projectPoint(geoCenter, this.m_camera.position);
        }
        else {
            // Preserve the current altitude
            const altitude = this.geoCenter.altitude;
            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
        }
        this.update();
    }
    /**
     * The node in this MapView's scene containing the user [[MapAnchor]]s.
     * All (first level) children of this node will be positioned in world space according to the
     * [[MapAnchor.geoPosition]].
     * Deeper level children can be used to position custom objects relative to the anchor node.
     */
    get mapAnchors() {
        return this.m_mapAnchors;
    }
    /**
     * The position in world coordinates of the center of the scene.
     */
    get worldCenter() {
        return this.m_camera.position;
    }
    /**
     * Get the [[PickHandler]] for this `mapView`.
     */
    get pickHandler() {
        return this.m_pickHandler;
    }
    /**
     * Get the {@link ImageCache} that belongs to this `MapView`.
     */
    get imageCache() {
        return this.m_imageCache;
    }
    /**
     * @hidden
     * Get the {@link PoiManager} that belongs to this `MapView`.
     */
    get poiManager() {
        return this.m_poiManager;
    }
    /**
     * @hidden
     * Get the array of {@link PoiTableManager} that belongs to this `MapView`.
     */
    get poiTableManager() {
        return this.m_poiTableManager;
    }
    /**
     * The minimum camera height in meters.
     */
    get minCameraHeight() {
        return this.m_minCameraHeight;
    }
    /**
     * The minimum zoom level.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * The minimum zoom level.
     */
    set minZoomLevel(zoomLevel) {
        this.m_minZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The maximum zoom level. Default is 14.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    /**
     * The maximum zoom level.
     */
    set maxZoomLevel(zoomLevel) {
        this.m_maxZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * Returns the zoom level for the given camera setup.
     */
    get zoomLevel() {
        return this.m_zoomLevel;
    }
    set zoomLevel(zoomLevel) {
        this.lookAtImpl({ zoomLevel });
    }
    /**
     * Returns tilt angle in degrees.
     */
    get tilt() {
        return THREE.MathUtils.radToDeg(this.m_pitch);
    }
    /**
     * Set the tilt angle of the map.
     * @param tilt -: New tilt angle in degrees.
     */
    set tilt(tilt) {
        this.lookAtImpl({ tilt });
    }
    /**
     * Returns heading angle in degrees.
     */
    get heading() {
        return -THREE.MathUtils.radToDeg(this.m_yaw);
    }
    /**
     * Set the heading angle of the map.
     * @param heading -: New heading angle in degrees.
     */
    set heading(heading) {
        this.lookAtImpl({ heading });
    }
    /**
     * Environment used to evaluate dynamic scene expressions.
     */
    get env() {
        return this.m_env;
    }
    /**
     * Returns the storage level for the given camera setup.
     * Actual storage level of the rendered data also depends
     * on {@link DataSource.storageLevelOffset}.
     */
    get storageLevel() {
        return THREE.MathUtils.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns height of the viewport in pixels.
     */
    get viewportHeight() {
        return this.canvas.height;
    }
    /**
     * Returns `true` if the native WebGL antialiasing is enabled.
     *
     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.
     */
    get nativeWebglAntialiasEnabled() {
        return this.m_options.enableNativeWebglAntialias === undefined
            ? this.pixelRatio < 2.0
            : this.m_options.enableNativeWebglAntialias;
    }
    /**
     * Returns {@link DataSource}s displayed by this `MapView`.
     */
    get dataSources() {
        return this.m_tileDataSources;
    }
    /**
     * Set's the way in which the fov is calculated on the map view. Note, for
     * this to take visual effect, the map should be rendered after calling this
     * function.
     * @param fovCalculation - How the FOV is calculated.
     */
    setFovCalculation(fovCalculation) {
        this.m_options.fovCalculation = fovCalculation;
        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);
        this.updateCameras();
    }
    /**
     * Returns the unique {@link DataSource} matching the given name.
     */
    getDataSourceByName(dataSourceName) {
        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);
    }
    /**
     * Returns the array of {@link DataSource}s referring to the same [[StyleSet]].
     */
    getDataSourcesByStyleSetName(styleSetName) {
        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);
    }
    /**
     * Returns true if the specified {@link DataSource} is enabled.
     */
    isDataSourceEnabled(dataSource) {
        return (dataSource.enabled &&
            dataSource.ready() &&
            this.m_connectedDataSources.has(dataSource.name) &&
            dataSource.isVisible(this.zoomLevel));
    }
    /**
     * Adds a new {@link DataSource} to this `MapView`.
     * `MapView` needs at least one {@link DataSource} to
     * display something.
     *
     * @param dataSource - The data source.
     */
    addDataSource(dataSource) {
        const twinDataSource = this.getDataSourceByName(dataSource.name);
        if (twinDataSource !== undefined) {
            throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
        }
        dataSource.attach(this);
        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);
        this.m_tileDataSources.push(dataSource);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        return dataSource
            .connect()
            .then(() => {
            return new Promise(resolve => {
                if (this.theme !== undefined && this.theme.styles !== undefined) {
                    resolve();
                    return;
                }
                const resolveOnce = () => {
                    this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
                    resolve();
                };
                this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);
            });
        })
            .then(() => {
            const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;
            if (alreadyRemoved) {
                return;
            }
            dataSource.addEventListener(MapViewEventNames.Update, () => {
                this.update();
            });
            dataSource.setTheme(this.m_theme);
            this.m_connectedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name
            });
            this.update();
        })
            .catch(error => {
            logger.error(`Failed to connect to datasource ${dataSource.name}: ${error.message}`);
            this.m_failedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name,
                error
            });
        });
    }
    /**
     * Removes {@link DataSource} from this `MapView`.
     *
     * @param dataSource - The data source to be removed
     */
    removeDataSource(dataSource) {
        const dsIndex = this.m_tileDataSources.indexOf(dataSource);
        if (dsIndex === -1) {
            return;
        }
        dataSource.detach(this);
        this.m_visibleTiles.removeDataSource(dataSource);
        this.m_tileDataSources.splice(dsIndex, 1);
        this.m_connectedDataSources.delete(dataSource.name);
        this.m_failedDataSources.delete(dataSource.name);
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
        this.update();
    }
    /**
     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.
     */
    get visibleTileSet() {
        return this.m_visibleTiles;
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    addOverlayText(textElements) {
        this.m_textElementsRenderer.addOverlayText(textElements);
        this.update();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    clearOverlayText() {
        this.m_textElementsRenderer.clearOverlayText();
    }
    lookAt(targetOrParams, distance, tiltDeg, headingDeg) {
        if (harp_geoutils_1.isGeoCoordinatesLike(targetOrParams)) {
            const zoomLevel = distance !== undefined
                ? Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, distance)
                : undefined;
            const params = {
                target: targetOrParams,
                zoomLevel,
                tilt: tiltDeg,
                heading: headingDeg
            };
            this.lookAtImpl(params);
        }
        else if (typeof targetOrParams === "object") {
            this.lookAtImpl(targetOrParams);
        }
    }
    /**
     * Moves the camera to the specified {@link @here/harp-geoutils#GeoCoordinates},
     * sets the desired `zoomLevel` and
     * adjusts the yaw and pitch. The pitch of the camera is
     * always curbed so that the camera cannot
     * look above the horizon. This paradigm is necessary
     * in {@link @here/harp-map-controls#MapControls}, where the center of
     * the screen is used for the orbiting interaction (3 fingers / right mouse button).
     *
     * @param geoPos - Geolocation to move the camera to.
     * @param zoomLevel - Desired zoom level.
     * @param yawDeg - Camera yaw in degrees, counter-clockwise (as opposed to heading), starting
     * north.
     * @param pitchDeg - Camera pitch in degrees.
     * @deprecated Use {@link (MapView.lookAt:WITH_PARAMS)} instead.
     */
    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {
        this.geoCenter = geoPos;
        let limitedPitch = Math.min(Utils_1.MapViewUtils.MAX_TILT_DEG, pitchDeg);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const maxPitchRadWithCurvature = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS /
                (Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +
                    harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS));
            const maxPitchDegWithCurvature = THREE.MathUtils.radToDeg(maxPitchRadWithCurvature);
            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);
        }
        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);
        Utils_1.MapViewUtils.setRotation(this, yawDeg, limitedPitch);
        this.update();
    }
    /**
     * Updates the value of a dynamic property.
     *
     * Property names starting with a `$`-sign are reserved and any attempt to change their value
     * will result in an error.
     *
     * Themes can access dynamic properties using the `Expr` operator `["dynamic-properties"]`,
     * for example:
     *
     *   `["get", "property name", ["dynamic-properties"]]`
     *
     * @param name - The name of the property.
     * @param value - The value of the property.
     */
    setDynamicProperty(name, value) {
        if (name.startsWith("$")) {
            throw new Error(`failed to update the value of the dynamic property '${name}'`);
        }
        this.m_env.entries[name] = value;
        this.update();
    }
    /**
     * Removes the given dynamic property from this {@link MapView}.
     *
     * Property names starting with a `$`-sign are reserved and any attempt to change their value
     * will result in an error.
     *
     * @param name - The name of the property to remove.
     */
    removeDynamicProperty(name) {
        if (name.startsWith("$")) {
            throw new Error(`failed to remove the dynamic property '${name}'`);
        }
        delete this.m_env.entries[name];
        this.update();
    }
    /**
     * Returns `true` if this `MapView` is constantly redrawing the scene.
     */
    get animating() {
        return this.m_animationCount > 0;
    }
    /**
     * Begin animating the scene.
     */
    beginAnimation() {
        if (this.m_animationCount++ === 0) {
            this.update();
            ANIMATION_STARTED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_STARTED_EVENT);
        }
    }
    /**
     * Stop animating the scene.
     */
    endAnimation() {
        if (this.m_animationCount > 0) {
            --this.m_animationCount;
        }
        if (this.m_animationCount === 0) {
            ANIMATION_FINISHED_EVENT.time = Date.now();
            this.dispatchEvent(ANIMATION_FINISHED_EVENT);
        }
    }
    /**
     * Returns `true` if the camera moved in the last frame.
     */
    get cameraIsMoving() {
        return this.m_movementDetector.cameraIsMoving;
    }
    /**
     * Returns `true` if the current frame will immediately be followed by another frame.
     */
    get isDynamicFrame() {
        return (this.cameraIsMoving ||
            this.animating ||
            this.m_updatePending ||
            this.m_animatedExtrusionHandler.isAnimating);
    }
    /**
     * Returns the ratio between a pixel and a world unit for the current camera (in the center of
     * the camera projection).
     */
    get pixelToWorld() {
        if (this.m_pixelToWorld === undefined) {
            // At this point fov calculation should be always defined.
            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
            // NOTE: Look at distance is the distance to camera focus (and pivot) point.
            // In screen space this point is located in the center of canvas.
            // Given that zoom level is not modified (clamped by camera pitch), the following
            // formulas are all equivalent:
            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);
            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);
            // Here we may use precalculated target distance (once pre frame):
            const lookAtDistance = this.m_targetDistance;
            // Find world space object size that corresponds to one pixel on screen.
            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);
        }
        return this.m_pixelToWorld;
    }
    /**
     * Returns the ratio between a world and a pixel unit for the current camera (in the center of
     * the camera projection).
     */
    get worldToPixel() {
        return 1.0 / this.pixelToWorld;
    }
    get pixelRatio() {
        if (this.m_pixelRatio !== undefined) {
            return this.m_pixelRatio;
        }
        return typeof window !== "undefined" && window.devicePixelRatio !== undefined
            ? window.devicePixelRatio
            : 1.0;
    }
    /**
     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens
     * (HiDPI).
     *
     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value
     * of `1.0` will disable the use of HiDPI on all devices.
     *
     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)
     * they may appear in the wrong size now. To ensure proper display of data, a call to
     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.
     *
     * @memberof MapView
     */
    set pixelRatio(pixelRatio) {
        this.m_pixelRatio = pixelRatio;
        if (this.renderer.getPixelRatio() !== this.pixelRatio) {
            this.renderer.setPixelRatio(this.pixelRatio);
        }
    }
    /**
     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful
     * when rendering on high resolution displays with low performance GPUs that may be
     * fill-rate-limited.
     *
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. Values between 0.5 and
     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger
     * than `window.devicePixelRatio`.
     *
     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`
     * defined, visual artifacts may occur, especially with thin lines..
     *
     * @note The resolution of icons and text labels is not affected.
     *
     * @default `undefined`
     */
    set dynamicPixelRatio(ratio) {
        this.mapRenderingManager.lowResPixelRatio = ratio;
    }
    get dynamicPixelRatio() {
        return this.mapRenderingManager.lowResPixelRatio;
    }
    /**
     * Returns the screen position of the given geo coordinates.
     *
     * @param geoPos - The geo coordinates.
     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or
     * `undefined`.
     */
    getScreenPosition(geoPos) {
        this.projection.projectPoint(geoPos, cache.vector3[0]);
        const p = this.m_screenProjector.project(cache.vector3[0]);
        if (p !== undefined) {
            const { width, height } = this.getCanvasClientSize();
            p.x = p.x + width / 2;
            p.y = height - (p.y + height / 2);
        }
        return p;
    }
    /**
     * Returns a ray caster using the supplied screen positions.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     *
     * @alpha
     *
     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen
     * points.
     */
    raycasterFromScreenPoint(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);
        return this.m_raycaster;
    }
    /**
     * Returns the world space position from the given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     */
    getWorldPositionAt(x, y) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
        return this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])
            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);
    }
    /**
     * Returns the {@link @here/harp-geoutils#GeoCoordinates} from the
     * given screen position. The return value can be
     * `null`, in case the camera is facing the horizon and
     * the given `(x, y)` value is not
     * intersecting the ground plane.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     */
    getGeoCoordinatesAt(x, y) {
        const worldPosition = this.getWorldPositionAt(x, y);
        if (!worldPosition) {
            return null;
        }
        return this.projection.unprojectPoint(worldPosition);
    }
    /**
     * Returns the normalized screen coordinates from the given pixel position.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     */
    getNormalizedScreenCoordinates(x, y) {
        // use clientWidth and clientHeight as it does not apply the pixelRatio and
        // therefore supports also HiDPI devices
        const { width, height } = this.getCanvasClientSize();
        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);
    }
    /**
     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that
     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested
     * for intersection.
     *
     * Note, if a {@link DataSource} adds an [[Object3D]]
     * to a {@link Tile}, it will be only pickable once
     * {@link MapView.render} has been called, this is because
     * {@link MapView.render} method creates the
     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.
     * This method will not test for intersection custom objects added to the scene by for
     * example calling directly the [[scene.add]] method from THREE.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     * @returns The list of intersection results.
     */
    intersectMapObjects(x, y) {
        return this.m_pickHandler.intersectMapObjects(x, y);
    }
    /**
     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.
     *
     * @param width - The new width.
     * @param height - The new height.
     */
    resize(width, height) {
        this.m_renderer.setSize(width, height, false);
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        if (this.mapRenderingManager !== undefined) {
            this.mapRenderingManager.setSize(width, height);
        }
        if (this.collisionDebugCanvas !== undefined) {
            this.collisionDebugCanvas.width = width;
            this.collisionDebugCanvas.height = height;
        }
        this.updateCameras();
        this.update();
        this.dispatchEvent({
            type: MapViewEventNames.Resize,
            size: {
                width,
                height
            }
        });
    }
    /**
     * Redraws scene immediately
     *
     * @note Before using this method, set `synchronousRendering` to `true`
     * in the {@link MapViewOptions}
     *
     * @param frameStartTime - Optional timestamp for start of frame.
     * Default: [[PerformanceTimer.now()]]
     */
    renderSync(frameStartTime) {
        if (frameStartTime === undefined) {
            frameStartTime = harp_utils_1.PerformanceTimer.now();
        }
        this.render(frameStartTime);
    }
    /**
     * Requests a redraw of the scene.
     */
    update() {
        this.dispatchEvent(UPDATE);
        // Skip if update is already in progress
        if (this.m_updatePending) {
            return;
        }
        // Set update flag
        this.m_updatePending = true;
        this.startRenderLoop();
    }
    /**
     * Returns `true` if an update has already been requested, such that after a currently rendering
     * frame, the next frame will be rendered immediately.
     */
    get updatePending() {
        return this.m_updatePending;
    }
    /**
     * Requests a redraw of the scene.
     * @deprecated Use the [[update]] method instead.
     */
    requestUpdateIfNeeded() {
        this.update();
    }
    /**
     * Clear the tile cache.
     *
     * Remove the {@link Tile} objects created by cacheable
     * {@link DataSource}s. If a {@link DataSource} name is
     * provided, this method restricts the eviction the {@link DataSource} with the given name.
     *
     * @param dataSourceName - The name of the {@link DataSource}.
     */
    clearTileCache(dataSourceName) {
        if (this.m_visibleTiles === undefined) {
            // This method is called in the shadowsEnabled function, which is initialized in the
            // setupRenderer function,
            return;
        }
        if (dataSourceName !== undefined) {
            const dataSource = this.getDataSourceByName(dataSourceName);
            if (dataSource) {
                this.m_visibleTiles.clearTileCache(dataSource);
                dataSource.clearCache();
            }
        }
        else {
            this.m_visibleTiles.clearTileCache();
            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());
        }
        if (this.m_elevationProvider !== undefined) {
            this.m_elevationProvider.clearCache();
        }
    }
    /**
     * Apply visitor to all visible tiles.
     *
     * @param fun - Visitor function
     */
    forEachVisibleTile(fun) {
        this.m_visibleTiles.forEachVisibleTile(fun);
    }
    /**
     * Apply a visitor function to all tiles in the cache.
     *
     * @param visitor - Visitor function
     */
    forEachCachedTile(visitor) {
        this.m_visibleTiles.forEachCachedTile(visitor);
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance
     * are processed. If `undefined`, tiles from all {@link DataSource}s are processed.
     */
    markTilesDirty(dataSource) {
        this.m_visibleTiles.markTilesDirty(dataSource);
    }
    /**
     * Sets the DataSource which contains the elevations, the elevation range source, and the
     * elevation provider. Only a single elevation source is possible per {@link MapView}
     *
     * If the terrain-datasource is merged with this repository, we could internally construct
     * the {@link ElevationRangeSource} and the {@link ElevationProvider}
     * and access would be granted to
     * the application when it asks for it, to simplify the API.
     *
     * @param elevationSource - The datasource containing the terrain tiles.
     * @param elevationRangeSource - Allows access to the elevation min / max per tile.
     * @param elevationProvider - Allows access to the elevation at a given location or a ray
     *      from the camera.
     */
    async setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {
        // Remove previous elevation source if present
        if (this.m_elevationSource && this.m_elevationSource !== elevationSource) {
            this.removeDataSource(this.m_elevationSource);
        }
        // Add as datasource if it was not added before
        const isPresent = this.m_tileDataSources.indexOf(elevationSource) !== -1;
        if (!isPresent) {
            await this.addDataSource(elevationSource);
        }
        this.m_elevationSource = elevationSource;
        this.m_elevationRangeSource = elevationRangeSource;
        if (!this.m_elevationRangeSource.ready()) {
            await this.m_elevationRangeSource.connect();
        }
        this.m_elevationProvider = elevationProvider;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(true);
        });
        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {
            overlayOnElevation_1.overlayOnElevation(tile);
        });
        this.clearTileCache();
    }
    /**
     * Clears any elevation sources and provider previously set.
     * @param elevationSource - The datasource to be cleared.
     */
    clearElevationSource(elevationSource) {
        this.removeDataSource(elevationSource);
        this.m_elevationSource = undefined;
        this.m_elevationRangeSource = undefined;
        this.m_elevationProvider = undefined;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(false);
        });
        this.m_tileGeometryManager.setTileUpdateCallback(undefined);
        this.clearTileCache();
    }
    /**
     * Public access to {@link MapViewFog} allowing to toggle it by setting its `enabled` property.
     */
    get fog() {
        return this.m_fog;
    }
    setPostEffects() {
        // First clear all the effects, then enable them from what is specified.
        this.mapRenderingManager.bloom.enabled = false;
        this.mapRenderingManager.outline.enabled = false;
        this.mapRenderingManager.vignette.enabled = false;
        this.mapRenderingManager.sepia.enabled = false;
        if (this.m_postEffects !== undefined) {
            if (this.m_postEffects.bloom !== undefined) {
                this.mapRenderingManager.bloom = this.m_postEffects.bloom;
            }
            if (this.m_postEffects.outline !== undefined) {
                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
            }
            if (this.m_postEffects.vignette !== undefined) {
                this.mapRenderingManager.vignette = this.m_postEffects.vignette;
            }
            if (this.m_postEffects.sepia !== undefined) {
                this.mapRenderingManager.sepia = this.m_postEffects.sepia;
            }
        }
    }
    /**
     * Returns the elevation provider.
     */
    get elevationProvider() {
        return this.m_elevationProvider;
    }
    get shadowsEnabled() {
        return this.m_options.enableShadows === true;
    }
    set shadowsEnabled(enabled) {
        // shadowMap is undefined if we are testing (three.js always set it to be defined).
        if (this.m_renderer.shadowMap === undefined ||
            enabled === this.m_renderer.shadowMap.enabled) {
            return;
        }
        this.m_options.enableShadows = enabled;
        // There is a bug in three.js where this doesn't currently work once enabled.
        this.m_renderer.shadowMap.enabled = enabled;
        // TODO: Make this configurable. Note, there is currently issues when using the
        // VSMShadowMap type, this should be investigated if this type is requested.
        this.m_renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.clearTileCache();
    }
    extractAttitude() {
        const camera = this.m_camera;
        const projection = this.projection;
        const cameraPos = cache.vector3[1];
        const transform = cache.transform[0];
        const tangentSpaceMatrix = cache.matrix4[1];
        // 1. Build the matrix of the tangent space of the camera.
        cameraPos.setFromMatrixPosition(camera.matrixWorld); // Ensure using world position.
        projection.localTangentSpace(this.m_targetGeoPos, transform);
        tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.
        cache.matrix4[0].getInverse(tangentSpaceMatrix).multiply(camera.matrixWorld);
        transform.xAxis.setFromMatrixColumn(cache.matrix4[0], 0);
        transform.yAxis.setFromMatrixColumn(cache.matrix4[0], 1);
        transform.zAxis.setFromMatrixColumn(cache.matrix4[0], 2);
        // 3. Deduce orientation from the base axes.
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // Decompose rotation matrix into Z0 X Z1 Euler angles.
        const epsilon = 1e-10;
        const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));
        if (d < 1.0 - epsilon) {
            if (d > -1.0 + epsilon) {
                yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);
                pitch = Math.acos(transform.zAxis.z);
                roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);
            }
            else {
                // Looking bottom-up with space.z.z == -1.0
                yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);
                pitch = 180;
                roll = 0;
            }
        }
        else {
            // Looking top-down with space.z.z == 1.0
            yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);
            pitch = 0.0;
            roll = 0.0;
        }
        return {
            yaw,
            pitch,
            roll
        };
    }
    lookAtImpl(params) {
        const tilt = Math.min(harp_utils_1.getOptionValue(params.tilt, this.tilt), Utils_1.MapViewUtils.MAX_TILT_DEG);
        const heading = harp_utils_1.getOptionValue(params.heading, this.heading);
        let target;
        if (params.bounds !== undefined) {
            let geoPoints;
            if (params.bounds instanceof harp_geoutils_1.GeoBox) {
                target = params.target
                    ? harp_geoutils_1.GeoCoordinates.fromObject(params.target)
                    : params.bounds.center;
                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(params.bounds);
            }
            else if (harp_geoutils_1.isGeoBoxExtentLike(params.bounds)) {
                target = params.target ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;
                const box = harp_geoutils_1.GeoBox.fromCenterAndExtents(target, params.bounds);
                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(box);
            }
            else if (Array.isArray(params.bounds)) {
                geoPoints = params.bounds;
                if (params.target !== undefined) {
                    target = harp_geoutils_1.GeoCoordinates.fromObject(params.target);
                }
            }
            else {
                throw Error("#lookAt: Invalid 'bounds' value");
            }
            if (this.m_tileWrappingEnabled && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                // In flat projection, with wrap around enabled, we should detect clusters of
                // points around  antimeridian and possible move some points to sibling worlds.
                //
                // Here, we fit points into minimal geo box taking world wrapping into account.
                geoPoints = Utils_1.MapViewUtils.wrapGeoPointsToScreen(geoPoints, target);
            }
            const worldPoints = geoPoints.map(point => this.projection.projectPoint(harp_geoutils_1.GeoCoordinates.fromObject(point), new THREE.Vector3()));
            const worldTarget = new THREE.Vector3();
            if (target === undefined) {
                const box = new THREE.Box3().setFromPoints(worldPoints);
                box.getCenter(worldTarget);
                this.projection.scalePointToSurface(worldTarget);
                target = this.projection.unprojectPoint(worldTarget);
            }
            else {
                this.projection.projectPoint(target, worldTarget);
            }
            return this.lookAtImpl(Utils_1.MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {
                tilt,
                heading,
                minDistance: Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, this.maxZoomLevel),
                projection: this.projection,
                camera: this.camera
            }));
        }
        target =
            params.target !== undefined ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;
        const distance = params.zoomLevel !== undefined
            ? Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, THREE.MathUtils.clamp(params.zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel))
            : params.distance !== undefined
                ? params.distance
                : this.m_targetDistance;
        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.
        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put
        // the camera on the target, so the tilt can be passed to getRotation as a pitch.
        Utils_1.MapViewUtils.getCameraRotationAtTarget(this.projection, target, -heading, tilt, this.camera.quaternion);
        Utils_1.MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -heading, tilt, this.projection, this.camera.position);
        this.camera.updateMatrixWorld(true);
        // Make sure to update all properties that are accessable via API (e.g. zoomlevel) b/c
        // otherwise they would be updated as recently as in the next animation frame.
        this.updateLookAtSettings();
        this.update();
    }
    /**
     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise
     */
    updatePolarDataSource() {
        const dataSource = this.m_polarDataSource;
        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {
            const twinDataSource = this.getDataSourceByName(dataSource.name);
            if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                if (twinDataSource === undefined) {
                    this.addDataSource(dataSource);
                }
            }
            else {
                if (twinDataSource !== undefined) {
                    this.removeDataSource(dataSource);
                }
            }
        }
    }
    /**
     * Updates the camera and the projections and resets the screen collisions,
     * note, setupCamera must be called before this is called.
     * @param viewRanges - optional parameter that supplies new view ranges, most importantly
     * near/far clipping planes distance. If parameter is not provided view ranges will be
     * calculated from [[ClipPlaneEvaluator]] used in {@link VisibleTileSet}.
     */
    updateCameras(viewRanges) {
        // Update look at settings first, so that other components (e.g. ClipPlanesEvaluator) get
        // the up to date tilt, targetDistance, ...
        this.m_camera.updateMatrixWorld(false);
        this.updateLookAtSettings();
        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);
        this.m_camera.aspect =
            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        // When calculating clip planes account for the highest building on the earth,
        // multiplying its height by projection scaling factor. This approach assumes
        // constantHeight property of extruded polygon technique is set as default false,
        // otherwise the near plane margins will be bigger then required, but still correct.
        const projectionScale = this.projection.getScaleFactor(this.camera.position);
        const maxGeometryHeightScaled = projectionScale *
            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);
        // Copy all properties from new view ranges to our readonly object.
        // This allows to keep all view ranges references valid and keeps up-to-date
        // information within them. Works the same as copping all properties one-by-one.
        Object.assign(this.m_viewRanges, viewRanges === undefined
            ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled)
            : viewRanges);
        this.m_camera.near = this.m_viewRanges.near;
        this.m_camera.far = this.m_viewRanges.far;
        this.m_camera.updateProjectionMatrix();
        // Update the "relative to eye" camera. Copy the public camera parameters
        // and place the "relative to eye" at the world's origin.
        this.m_rteCamera.copy(this.m_camera);
        this.m_rteCamera.position.setScalar(0);
        this.m_rteCamera.updateMatrixWorld(true);
        this.m_screenCamera.left = width / -2;
        this.m_screenCamera.right = width / 2;
        this.m_screenCamera.bottom = height / -2;
        this.m_screenCamera.top = height / 2;
        this.m_screenCamera.updateProjectionMatrix();
        this.m_screenCamera.updateMatrixWorld(false);
        this.m_screenProjector.update(this.camera, width, height);
        this.m_screenCollisions.update(width, height);
        this.m_pixelToWorld = undefined;
        this.m_fog.update(this, this.m_viewRanges.maximum);
    }
    /**
     * Derive the look at settings (i.e. target, zoom, ...) from the current camera.
     */
    updateLookAtSettings() {
        // tslint:disable-next-line: deprecation
        const { target, distance } = Utils_1.MapViewUtils.getTargetAndDistance(this.projection, this.camera, this.elevationProvider);
        this.m_targetWorldPos.copy(target);
        this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);
        this.m_targetDistance = distance;
        this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);
        const { yaw, pitch, roll } = this.extractAttitude();
        this.m_yaw = yaw;
        this.m_pitch = pitch;
        this.m_roll = roll;
    }
    /**
     * Update `Env` instance used for style `Expr` evaluations.
     */
    updateEnv() {
        this.m_env.entries.$zoom = this.m_zoomLevel;
        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely
        // used in our styles.
        this.m_env.entries.$pixelToMeters = this.pixelToWorld;
        this.m_env.entries.$frameNumber = this.m_frameNumber;
    }
    /**
     * Transfer the NDC point to view space.
     * @param vector - Vector to transform.
     * @param result - Result to place calculation.
     */
    ndcToView(vector, result) {
        result
            .set(vector.x, vector.y, vector.z)
            .applyMatrix4(this.camera.projectionMatrixInverse)
            // Make sure to apply rotation, hence use the rte camera
            .applyMatrix4(this.m_rteCamera.matrixWorld);
        return result;
    }
    /**
     * Transfer from view space to camera space.
     * @param viewPos - position in view space, result is stored here.
     */
    viewToLightSpace(viewPos, camera) {
        return viewPos.applyMatrix4(camera.matrixWorldInverse);
    }
    /**
     * Update the directional light camera. Note, this requires the cameras to first be updated.
     */
    updateLights() {
        // TODO: HARP-9479 Globe doesn't support shadows.
        if (!this.shadowsEnabled ||
            this.projection.type === harp_geoutils_1.ProjectionType.Spherical ||
            this.m_createdLights === undefined ||
            this.m_createdLights.length === 0) {
            return;
        }
        const points = [
            // near plane points
            { x: -1, y: -1, z: -1 },
            { x: 1, y: -1, z: -1 },
            { x: -1, y: 1, z: -1 },
            { x: 1, y: 1, z: -1 },
            // far planes points
            { x: -1, y: -1, z: 1 },
            { x: 1, y: -1, z: 1 },
            { x: -1, y: 1, z: 1 },
            { x: 1, y: 1, z: 1 }
        ];
        const transformedPoints = points.map((p, i) => this.ndcToView(p, cache.frustumPoints[i]));
        this.m_createdLights.forEach(element => {
            const directionalLight = element;
            if (directionalLight.isDirectionalLight === true) {
                const lightDirection = cache.vector3[0];
                lightDirection.copy(directionalLight.target.position);
                lightDirection.sub(directionalLight.position);
                lightDirection.normalize();
                const normal = cache.vector3[1];
                if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                    // -Z points to the camera, we can't use Projection.surfaceNormal, because
                    // webmercator and mercator give different results.
                    normal.set(0, 0, -1);
                }
                else {
                    // Enable shadows for globe...
                    //this.projection.surfaceNormal(target, normal);
                }
                // The camera of the shadow has the same height as the map camera, and the target is
                // also the same. The position is then calculated based on the light direction and
                // the height
                // using basic trigonometry.
                const tilt = this.m_pitch;
                const cameraHeight = this.targetDistance * Math.cos(tilt);
                const lightPosHyp = cameraHeight / normal.dot(lightDirection);
                directionalLight.target.position.copy(this.worldTarget).sub(this.camera.position);
                directionalLight.position.copy(this.worldTarget);
                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);
                directionalLight.position.sub(this.camera.position);
                directionalLight.updateMatrixWorld();
                directionalLight.shadow.updateMatrices(directionalLight);
                const camera = directionalLight.shadow.camera;
                const pointsInLightSpace = transformedPoints.map(p => this.viewToLightSpace(p.clone(), camera));
                const box = new THREE.Box3();
                pointsInLightSpace.forEach(point => {
                    box.expandByPoint(point);
                });
                camera.left = box.min.x;
                camera.right = box.max.x;
                camera.top = box.max.y;
                camera.bottom = box.min.y;
                // Moving back to the light the near plane in order to catch high buildings, that
                // are not visible by the camera, but existing on the scene.
                camera.near = -box.max.z * 0.95;
                camera.far = -box.min.z;
                camera.updateProjectionMatrix();
            }
        });
    }
    /**
     * Render loop callback that should only be called by [[requestAnimationFrame]].
     * Will trigger [[requestAnimationFrame]] again if updates are pending or  animation is running.
     * @param frameStartTime - The start time of the current frame
     */
    renderLoop(frameStartTime) {
        // Render loop shouldn't run when synchronous rendering is enabled
        if (this.m_options.synchronousRendering) {
            return;
        }
        if (this.maxFps === 0) {
            // Render with max fps
            this.render(frameStartTime);
        }
        else {
            // Limit fps by skipping frames
            // Magic ingredient to compensate time flux.
            const fudgeTimeInMs = 3;
            const frameInterval = 1000 / this.maxFps;
            const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;
            const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;
            if (frameStartTime >= targetTime) {
                this.render(frameStartTime);
            }
        }
        // Continue rendering if update is pending or animation is running
        // tslint:disable-next-line: prefer-conditional-expression
        if (this.m_updatePending || this.animating) {
            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
        }
        else {
            // Stop rendering if no update is pending
            this.m_animationFrameHandle = undefined;
        }
    }
    /**
     * Start render loop if not already running.
     */
    startRenderLoop() {
        if (this.m_animationFrameHandle !== undefined || this.m_options.synchronousRendering) {
            return;
        }
        this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
    }
    /**
     * Returns the list of the enabled data sources.
     */
    getEnabledTileDataSources() {
        // ### build this list once decoders && datasources are ready
        const enabledDataSources = [];
        for (const dataSource of this.m_tileDataSources) {
            if (this.isDataSourceEnabled(dataSource)) {
                enabledDataSources.push(dataSource);
            }
        }
        return enabledDataSources;
    }
    /**
     * Renders the current frame.
     */
    render(frameStartTime) {
        if (this.m_drawing) {
            return;
        }
        RENDER_EVENT.time = frameStartTime;
        this.dispatchEvent(RENDER_EVENT);
        ++this.m_frameNumber;
        let currentFrameEvent;
        const stats = Statistics_1.PerformanceStatistics.instance;
        const gatherStatistics = stats.enabled;
        if (gatherStatistics) {
            currentFrameEvent = stats.currentFrame;
            if (this.m_previousFrameTimeStamp !== undefined) {
                // In contrast to fullFrameTime we also measure the application code
                // for the FPS. This means FPS != 1000 / fullFrameTime.
                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                currentFrameEvent.setValue("render.fps", 1000 / timeSincePreviousFrame);
            }
            // We store the last frame statistics at the beginning of the next frame b/c additional
            // work (i.e. geometry creation) is done outside of the animation frame but still needs
            // to be added to the `fullFrameTime` (see [[TileGeometryLoader]]).
            stats.storeAndClearFrameInfo();
            currentFrameEvent = currentFrameEvent;
            currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
        }
        this.m_previousFrameTimeStamp = frameStartTime;
        let setupTime;
        let cullTime;
        let textPlacementTime;
        let drawTime;
        let textDrawTime;
        let endTime;
        this.m_renderer.info.reset();
        this.m_updatePending = false;
        this.m_thisFrameTilesChanged = undefined;
        this.m_drawing = true;
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        this.updateCameras();
        this.updateEnv();
        this.updateLights();
        this.m_renderer.clear();
        // clear the scenes
        this.m_sceneRoot.children.length = 0;
        this.m_overlaySceneRoot.children.length = 0;
        if (gatherStatistics) {
            setupTime = harp_utils_1.PerformanceTimer.now();
        }
        // TBD: Update renderList only any of its params (camera, etc...) has changed.
        if (!this.lockVisibleTileSet) {
            const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_elevationRangeSource);
            // View ranges has changed due to features (with elevation) that affects clip planes
            // positioning, update cameras with new clip planes positions.
            if (viewRangesStatus.viewRangesChanged) {
                this.updateCameras(viewRangesStatus.viewRanges);
            }
        }
        if (gatherStatistics) {
            cullTime = harp_utils_1.PerformanceTimer.now();
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        // no need to check everything if we're not going to create text renderer.
        renderList.forEach(({ zoomLevel, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                this.renderTileObjects(tile, zoomLevel);
                //We know that rendered tiles are visible (in the view frustum), so we update the
                //frame number, note we don't do this for the visibleTiles because some may still be
                //loading (and therefore aren't visible in the sense of being seen on the screen).
                //Note also, this number isn't currently used anywhere so should be considered to be
                //removed in the future (though could be good for debugging purposes).
                tile.frameNumLastVisible = this.m_frameNumber;
            });
        });
        // Check if this is the time to place the labels for the first time. Pretty much everything
        // should have been loaded, and no animation should be running.
        if (!this.m_initialTextPlacementDone &&
            !this.m_firstFrameComplete &&
            !this.isDynamicFrame &&
            !this.m_themeIsLoading &&
            this.m_poiTableManager.finishedLoading &&
            this.m_visibleTiles.allVisibleTilesLoaded &&
            this.m_connectedDataSources.size + this.m_failedDataSources.size ===
                this.m_tileDataSources.length &&
            !this.m_textElementsRenderer.initializing &&
            !this.m_textElementsRenderer.loading) {
            this.m_initialTextPlacementDone = true;
        }
        this.m_mapAnchors.update(this.projection, this.camera.position, this.m_sceneRoot, this.m_overlaySceneRoot, this.m_theme.priorities);
        this.m_animatedExtrusionHandler.update(this.zoomLevel);
        if (currentFrameEvent !== undefined) {
            // Make sure the counters all have a value.
            currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
            currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
            currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
            // Increment the counters for all data sources.
            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
                currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.size);
                currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
            });
        }
        if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {
            //FIXME: Shouldn't we use target here?
            const { latitude, longitude, altitude } = this.geoCenter;
            this.dispatchEvent({
                type: MapViewEventNames.CameraPositionChanged,
                latitude,
                longitude,
                altitude,
                // FIXME: Can we remove yaw, pitch and roll
                yaw: this.m_yaw,
                pitch: this.m_pitch,
                roll: this.m_roll,
                tilt: this.tilt,
                heading: this.heading,
                zoom: this.zoomLevel
            });
        }
        // The camera used to render the scene.
        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;
        if (this.renderLabels) {
            this.prepareRenderTextElements(frameStartTime);
        }
        if (gatherStatistics) {
            textPlacementTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.m_skyBackground !== undefined && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_camera);
        }
        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
        if (gatherStatistics) {
            drawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.renderLabels) {
            this.finishRenderTextElements();
        }
        if (this.m_overlaySceneRoot.children.length > 0) {
            this.m_renderer.render(this.m_overlayScene, camera);
        }
        if (gatherStatistics) {
            textDrawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (!this.m_firstFrameRendered) {
            this.m_firstFrameRendered = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrame", frameStartTime);
            }
            FIRST_FRAME_EVENT.time = frameStartTime;
            this.dispatchEvent(FIRST_FRAME_EVENT);
        }
        this.m_visibleTiles.disposePendingTiles();
        this.m_drawing = false;
        this.checkCopyrightUpdates();
        if (currentFrameEvent !== undefined) {
            endTime = harp_utils_1.PerformanceTimer.now();
            const frameRenderTime = endTime - frameStartTime;
            currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
            currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
            currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
            currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
            currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
            currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
            currentFrameEvent.setValue("render.frameRenderTime", frameRenderTime);
            // Initialize the fullFrameTime with the frameRenderTime If we also create geometry in
            // this frame, this number will be increased in the TileGeometryLoader.
            currentFrameEvent.setValue("render.fullFrameTime", frameRenderTime);
            currentFrameEvent.setValue("render.geometryCreationTime", 0);
            // Add THREE.js statistics
            stats.addWebGLInfo(this.m_renderer.info);
            // Add memory statistics
            // FIXME:
            // This will only measure the memory of the rendering and not of the geometry creation.
            // Assuming the garbage collector is not kicking in immediately we will at least see
            // the geometry creation memory consumption acounted in the next frame.
            stats.addMemoryInfo();
        }
        DID_RENDER_EVENT.time = frameStartTime;
        this.dispatchEvent(DID_RENDER_EVENT);
        // After completely rendering this frame, it is checked if this frame was the first complete
        // frame, with no more tiles, geometry and labels waiting to be added, and no animation
        // running. The initial placement of text in this render call may have changed the loading
        // state of the TextElementsRenderer, so this has to be checked again.
        if (!this.m_firstFrameComplete &&
            this.m_initialTextPlacementDone &&
            !this.isDynamicFrame &&
            !this.textElementsRenderer.loading) {
            this.m_firstFrameComplete = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrameComplete", frameStartTime);
            }
            FRAME_COMPLETE_EVENT.time = frameStartTime;
            this.dispatchEvent(FRAME_COMPLETE_EVENT);
        }
    }
    renderTileObjects(tile, zoomLevel) {
        var _a;
        const worldOffsetX = tile.computeWorldOffsetX();
        if (tile.willRender(zoomLevel)) {
            for (const object of tile.objects) {
                const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
                if (!this.processTileObject(tile, object, mapObjectAdapter)) {
                    continue;
                }
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(this.m_camera.position);
                if (tile.localTangentSpace) {
                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                }
                object.frustumCulled = false;
                if (object._backupRenderOrder === undefined) {
                    object._backupRenderOrder = object.renderOrder;
                }
                const isBuilding = (_a = mapObjectAdapter === null || mapObjectAdapter === void 0 ? void 0 : mapObjectAdapter.kind) === null || _a === void 0 ? void 0 : _a.includes(harp_datasource_protocol_1.GeometryKind.Building);
                // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will
                // be overlaps with the already loaded tiles. Therefore all (flat) objects
                // in a fallback tile must be shifted, such that their renderOrder is less
                // than the groundPlane that each neighbouring Tile has (it has a renderOrder
                // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be
                // sure that nothing of the parent will be rendered on top of the children,
                // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.
                // This does not apply to buildings b/c they are 3d and the overlaps
                // are resolved with a depth prepass. Note we set this always to ensure that if
                // the Tile is used as a fallback, and then used normally, that we have the correct
                // renderOrder.
                object.renderOrder =
                    object._backupRenderOrder +
                        (!isBuilding && tile.levelOffset < 0
                            ? exports.FALLBACK_RENDER_ORDER_OFFSET * tile.levelOffset
                            : 0);
                this.m_sceneRoot.add(object);
            }
            tile.didRender();
        }
    }
    /**
     * Process dynamic updates of [[TileObject]]'s style.
     *
     * @returns `true` if object shall be used in scene, `false` otherwise
     */
    processTileObject(tile, object, mapObjectAdapter) {
        if (!object.visible) {
            return false;
        }
        if (!this.processTileObjectFeatures(tile, object)) {
            return false;
        }
        if (mapObjectAdapter) {
            mapObjectAdapter.ensureUpdated(this);
            if (!mapObjectAdapter.isVisible()) {
                return false;
            }
        }
        return true;
    }
    /**
     * Process the features owned by the given [[TileObject]].
     *
     * @param tile - The {@link Tile} owning the [[TileObject]]'s features.
     * @param object - The [[TileObject]] to process.
     * @returns `false` if the given [[TileObject]] should not be added to the scene.
     */
    processTileObjectFeatures(tile, object) {
        const technique = object.userData.technique;
        if (!technique || technique.enabled === undefined) {
            // Nothing to do, there's no technique.
            return true;
        }
        const feature = object.userData.feature;
        if (!feature || !harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
            return Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, this.m_env));
        }
        const { starts, objInfos } = feature;
        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {
            // Nothing to do, the object is missing feature ids and their position
            // in the index buffer.
            return true;
        }
        const geometry = object.geometry;
        if (!geometry || !geometry.isBufferGeometry) {
            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]
            // and we can't generate groups.
            return true;
        }
        const index = geometry.getIndex();
        // clear the groups.
        geometry.clearGroups();
        // The offset in the index buffer of the end of the last
        // pushed group.
        let endOfLastGroup;
        objInfos.forEach((properties, featureIndex) => {
            var _a;
            // the id of the current feature.
            const featureId = harp_datasource_protocol_1.getFeatureId(properties);
            let enabled = true;
            if (harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
                // the state of current feature.
                const featureState = tile.dataSource.getFeatureState(featureId);
                // create a new {@link @here/harp-datasource-protocol#Env} that can be used
                // to evaluate expressions that access the feature state.
                const $state = featureState ? new harp_datasource_protocol_1.MapEnv(featureState) : null;
                const parentEnv = typeof properties === "object"
                    ? new harp_datasource_protocol_1.MapEnv(properties, this.m_env)
                    : this.m_env;
                const env = new harp_datasource_protocol_1.MapEnv({ $state }, parentEnv);
                enabled = Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, env));
            }
            if (!enabled) {
                // skip this feature, it was disabled.
                return;
            }
            const start = starts[featureIndex];
            const end = (_a = starts[featureIndex + 1]) !== null && _a !== void 0 ? _a : index.count;
            const count = end - start;
            if (start === endOfLastGroup) {
                // extend the last group
                geometry.groups[geometry.groups.length - 1].count += count;
            }
            else {
                geometry.addGroup(start, count);
            }
            endOfLastGroup = start + count;
        });
        return geometry.groups.length > 0;
    }
    prepareRenderTextElements(time) {
        // Disable rendering of text elements for debug camera. TextElements are rendered using an
        // orthographic camera that covers the entire available screen space. Unfortunately, this
        // particular camera set up is not compatible with the debug camera.
        const debugCameraActive = this.m_pointOfView !== undefined;
        if (debugCameraActive) {
            return;
        }
        this.m_textElementsRenderer.placeText(this.m_visibleTiles.dataSourceTileList, time);
    }
    finishRenderTextElements() {
        const canRenderTextElements = this.m_pointOfView === undefined;
        if (canRenderTextElements) {
            // copy far value from scene camera, as the distance to the POIs matter now.
            this.m_screenCamera.far = this.m_viewRanges.maximum;
            this.m_textElementsRenderer.renderText(this.m_screenCamera);
        }
    }
    initTheme() {
        const theme = harp_utils_1.getOptionValue(this.m_options.theme, MapViewDefaults.theme);
        this.m_themeIsLoading = true;
        Promise.resolve(theme)
            // tslint:disable-next-line: no-shadowed-variable
            .then(theme => ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver }))
            // tslint:disable-next-line: no-shadowed-variable
            .then(theme => {
            this.m_themeIsLoading = false;
            this.theme = theme;
        })
            .catch(error => {
            this.m_themeIsLoading = false;
            const themeName = typeof this.m_options.theme === "string" ? ` from ${this.m_options.theme}` : "";
            logger.error(`Failed to load theme${themeName}: ${error}`, error);
        });
    }
    setupCamera() {
        const { width, height } = this.getCanvasClientSize();
        this.calculateFocalLength(height);
        this.m_visibleTiles = this.createVisibleTileSet();
        this.m_options.target = harp_geoutils_1.GeoCoordinates.fromObject(harp_utils_1.getOptionValue(this.m_options.target, MapViewDefaults.target));
        // ensure that look at target has height of 0
        this.m_options.target.altitude = 0;
        this.m_options.tilt = harp_utils_1.getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);
        this.m_options.heading = harp_utils_1.getOptionValue(this.m_options.heading, MapViewDefaults.heading);
        this.m_options.zoomLevel = harp_utils_1.getOptionValue(this.m_options.zoomLevel, MapViewDefaults.zoomLevel);
        this.lookAtImpl(this.m_options);
        // ### move & customize
        this.resize(width, height);
        this.m_screenCamera.position.z = 1;
        this.m_screenCamera.near = 0;
    }
    createVisibleTileSet() {
        const enableMixedLod = this.m_enableMixedLod === undefined
            ? this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            : this.m_enableMixedLod;
        return new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod), this.m_tileGeometryManager, this.m_visibleTileSetOptions);
    }
    updateSkyBackground() {
        if (this.m_theme === undefined) {
            return;
        }
        const theme = this.m_theme;
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);
        }
        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(theme.sky, theme.clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.projection.type, this.m_camera);
        this.m_scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.projection.type);
        }
    }
    updateLighting() {
        var _a;
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        if (theme.clearColor !== undefined) {
            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));
        }
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_scene.remove(light);
            });
        }
        (_a = this.m_overlayCreatedLights) === null || _a === void 0 ? void 0 : _a.forEach(light => {
            this.m_overlayScene.remove(light);
            if (light instanceof THREE.DirectionalLight) {
                this.m_overlayScene.remove(light.target);
            }
        });
        if (theme.lights !== undefined) {
            this.m_createdLights = [];
            this.m_overlayCreatedLights = [];
            theme.lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.warn(
                    // tslint:disable-next-line: max-line-length
                    `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_scene.add(light);
                if (light.isDirectionalLight) {
                    const directionalLight = light;
                    // This is needed so that the target is updated automatically, see:
                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target
                    this.m_scene.add(directionalLight.target);
                }
                this.m_createdLights.push(light);
                const clonedLight = light.clone();
                this.m_overlayScene.add(clonedLight);
                if (clonedLight instanceof THREE.DirectionalLight) {
                    this.m_overlayScene.add(clonedLight.target.clone());
                }
            });
        }
    }
    movementStarted() {
        this.m_textElementsRenderer.movementStarted();
        MOVEMENT_STARTED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_STARTED_EVENT);
    }
    movementFinished() {
        this.m_textElementsRenderer.movementFinished();
        MOVEMENT_FINISHED_EVENT.time = Date.now();
        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);
        // render at the next possible time.
        if (!this.animating) {
            if (this.m_movementFinishedUpdateTimerId !== undefined) {
                clearTimeout(this.m_movementFinishedUpdateTimerId);
            }
            this.m_movementFinishedUpdateTimerId = setTimeout(() => {
                this.m_movementFinishedUpdateTimerId = undefined;
                this.update();
            }, 0);
        }
    }
    /**
     * Check if the set of visible tiles changed since the last frame.
     *
     * May be called multiple times per frame.
     *
     * Equality is computed by creating a string containing the IDs of the tiles.
     */
    checkIfTilesChanged() {
        if (this.m_thisFrameTilesChanged !== undefined) {
            return this.m_thisFrameTilesChanged;
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        const tileIdList = [];
        tileIdList.length = 0;
        renderList.forEach(({ dataSource, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
            });
        });
        tileIdList.sort();
        const newTileIds = tileIdList.join("#");
        if (newTileIds !== this.m_lastTileIds) {
            this.m_lastTileIds = newTileIds;
            this.m_thisFrameTilesChanged = true;
        }
        else {
            this.m_thisFrameTilesChanged = false;
        }
        return this.m_thisFrameTilesChanged;
    }
    checkCopyrightUpdates() {
        if (!this.checkIfTilesChanged()) {
            return;
        }
        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
        if (newCopyrightInfo === this.m_copyrightInfo) {
            return;
        }
        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
            let allEqual = true;
            for (let i = 0; i < newCopyrightInfo.length; i++) {
                const a = newCopyrightInfo[i];
                const b = this.m_copyrightInfo[i];
                if (a.label !== b.label) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return;
            }
        }
        this.m_copyrightInfo = newCopyrightInfo;
        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);
    }
    getRenderedTilesCopyrightInfo() {
        let result = [];
        for (const tileList of this.m_visibleTiles.dataSourceTileList) {
            for (const tile of tileList.renderedTiles.values()) {
                const tileCopyrightInfo = tile.copyrightInfo;
                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {
                    continue;
                }
                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
            }
        }
        return result;
    }
    updateImages() {
        if (!this.m_theme) {
            return;
        }
        const theme = this.m_theme;
        this.m_imageCache.clear();
        this.poiManager.clear();
        if (theme.images !== undefined) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    this.poiManager.addTextureAtlas(name, image.atlas);
                }
            }
        }
        if (theme.imageTextures !== undefined) {
            theme.imageTextures.forEach((imageTexture) => {
                this.poiManager.addImageTexture(imageTexture);
            });
        }
    }
    loadPoiTables() {
        if (this.m_theme === undefined) {
            return;
        }
        this.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        this.poiTableManager
            .loadPoiTables(this.m_theme)
            .then(() => this.update())
            .catch(() => this.update());
    }
    setupStats(enable) {
        // tslint:disable-next-line:no-unused-expression
        new Statistics_1.PerformanceStatistics(enable, 1000);
    }
    setupRenderer() {
        var _a;
        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);
        this.m_scene.add(this.m_sceneRoot);
        this.m_overlayScene.add(this.m_overlaySceneRoot);
        this.shadowsEnabled = (_a = this.m_options.enableShadows) !== null && _a !== void 0 ? _a : false;
    }
    createTextRenderer() {
        const updateCallback = () => {
            this.update();
        };
        return new TextElementsRenderer_1.TextElementsRenderer(new MapViewState_1.MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_camera, updateCallback, this.m_screenCollisions, this.m_screenProjector, new TextCanvasFactory_1.TextCanvasFactory(this.m_renderer), this.m_poiManager, new PoiRendererFactory_1.PoiRendererFactory(this), new FontCatalogLoader_1.FontCatalogLoader(this.m_theme), this.m_theme, this.m_options);
    }
    resetTextRenderer() {
        const overlayText = this.m_textElementsRenderer.overlayText;
        this.m_textElementsRenderer = this.createTextRenderer();
        if (overlayText !== undefined) {
            this.m_textElementsRenderer.addOverlayText(overlayText);
        }
    }
    limitFov(fov, aspect) {
        fov = THREE.MathUtils.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
        let hFov = THREE.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.MathUtils.degToRad(fov), aspect));
        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {
            hFov = THREE.MathUtils.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);
            fov = THREE.MathUtils.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(THREE.MathUtils.degToRad(hFov), aspect));
        }
        return fov;
    }
    /**
     * Sets the field of view calculation, and applies it immediately to the camera.
     *
     * @param type - How to calculate the FOV
     */
    setFovOnCamera(fovCalculation, height) {
        let fov = 0;
        if (fovCalculation.type === "fixed") {
            this.calculateFocalLength(height);
            fov = fovCalculation.fov;
        }
        else {
            harp_utils_1.assert(this.m_focalLength !== 0);
            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);
        }
        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);
    }
    /**
     * Sets the focal length based on the supplied fov and the height of the canvas. This must be
     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is
     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas
     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is
     * fixed but the FOV changes.
     * @param height - Height of the canvas in css / client pixels.
     */
    calculateFocalLength(height) {
        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(THREE.MathUtils.degToRad(this.m_options.fovCalculation.fov), height);
    }
    /**
     * Get canvas client size in css/client pixels.
     *
     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by
     * calculating it from actual canvas size and current pixel ratio.
     */
    getCanvasClientSize() {
        const { clientWidth, clientHeight } = this.canvas;
        if (clientWidth === 0 ||
            clientHeight === 0 ||
            typeof clientWidth !== "number" ||
            typeof clientHeight !== "number") {
            const pixelRatio = this.m_renderer.getPixelRatio();
            return {
                width: Math.round(this.canvas.width / pixelRatio),
                height: Math.round(this.canvas.height / pixelRatio)
            };
        }
        else {
            return { width: clientWidth, height: clientHeight };
        }
    }
}
exports.MapView = MapView;
//# sourceMappingURL=MapView.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewAtmosphere.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewAtmosphere = exports.AtmosphereLightMode = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js");
/**
 * Atmosphere effect variants.
 */
var AtmosphereVariant;
(function (AtmosphereVariant) {
    AtmosphereVariant[AtmosphereVariant["Ground"] = 1] = "Ground";
    AtmosphereVariant[AtmosphereVariant["Sky"] = 2] = "Sky";
    AtmosphereVariant[AtmosphereVariant["SkyAndGround"] = 3] = "SkyAndGround";
})(AtmosphereVariant || (AtmosphereVariant = {}));
/**
 * Atmosphere shader variants.
 */
var AtmosphereShadingVariant;
(function (AtmosphereShadingVariant) {
    AtmosphereShadingVariant[AtmosphereShadingVariant["ScatteringShader"] = 0] = "ScatteringShader";
    AtmosphereShadingVariant[AtmosphereShadingVariant["SimpleColor"] = 1] = "SimpleColor";
    AtmosphereShadingVariant[AtmosphereShadingVariant["Wireframe"] = 2] = "Wireframe";
})(AtmosphereShadingVariant || (AtmosphereShadingVariant = {}));
/**
 * Lists light modes.
 */
var AtmosphereLightMode;
(function (AtmosphereLightMode) {
    AtmosphereLightMode[AtmosphereLightMode["LightOverhead"] = 0] = "LightOverhead";
    AtmosphereLightMode[AtmosphereLightMode["LightDynamic"] = 1] = "LightDynamic";
})(AtmosphereLightMode = exports.AtmosphereLightMode || (exports.AtmosphereLightMode = {}));
/**
 * Maximum altitude that atmosphere reaches as the percent of the Earth radius.
 */
const SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;
/**
 * Maximum altitude that ground atmosphere is visible as the percent of the Earth radius.
 */
const GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 0.0001;
/**
 * Utility cache for holding temporary values.
 */
const cache = {
    clipPlanes: { near: 0, far: 0 }
};
/**
 * Class that provides {@link MapView}'s atmospheric scattering effect.
 */
let MapViewAtmosphere = /** @class */ (() => {
    class MapViewAtmosphere {
        /**
         * Creates and adds `Atmosphere` effects to the scene.
         *
         * @note Currently works only with globe projection.
         *
         * @param m_mapAnchors - The {@link MapAnchors} instance where the effect will be added.
         * @param m_sceneCamera - The camera used to render entire scene.
         * @param m_projection - The geo-projection used to transform geo coordinates to
         *                       cartesian space.
         * @param m_updateCallback - The optional callback to that should be called whenever atmosphere
         * configuration changes, may be used to inform related components (`MapView`) to redraw.
         * @param m_atmosphereVariant - The optional atmosphere configuration variant enum
         * [[AtmosphereVariant]], which denotes where the atmosphere scattering effect should be
         * applied, it may be ground or sky atmosphere only or most realistic for both, which is
         * chosen by default.
         * @param m_materialVariant - The optional material variant to be used, mainly for
         * testing and tweaking purposes.
         */
        constructor(m_mapAnchors, m_sceneCamera, m_projection, m_updateCallback, m_atmosphereVariant = AtmosphereVariant.SkyAndGround, m_materialVariant = AtmosphereShadingVariant.ScatteringShader) {
            this.m_mapAnchors = m_mapAnchors;
            this.m_sceneCamera = m_sceneCamera;
            this.m_projection = m_projection;
            this.m_updateCallback = m_updateCallback;
            this.m_atmosphereVariant = m_atmosphereVariant;
            this.m_materialVariant = m_materialVariant;
            this.m_enabled = true;
            this.m_clipPlanesEvaluator = new ClipPlanesEvaluator_1.TiltViewClipPlanesEvaluator(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR, 0, 1.0, 0.05, 10000000.0);
            // TODO: Support for Theme definition should be added.
            //private m_cachedTheme: Theme = { styles: {} };
            this.m_lightDirection = new THREE.Vector3(0.0, 1.0, 0.0);
            // tslint:disable-next-line: no-bitwise
            if (this.m_atmosphereVariant & AtmosphereVariant.Sky) {
                this.createSkyGeometry();
            }
            // tslint:disable-next-line: no-bitwise
            if (this.m_atmosphereVariant & AtmosphereVariant.Ground) {
                this.createGroundGeometry();
            }
            this.addToMapAnchors(this.m_mapAnchors);
        }
        /**
         * Check if map anchors have already atmosphere effect added.
         *
         * @param mapAnchors - MapAnchors to check.
         */
        static isPresent(mapAnchors) {
            for (const mapAnchor of mapAnchors.children) {
                if (mapAnchor.name === MapViewAtmosphere.SkyAtmosphereUserName ||
                    mapAnchor.name === MapViewAtmosphere.GroundAtmosphereUserName) {
                    return true;
                }
            }
            return false;
        }
        get skyMesh() {
            return this.m_skyMesh;
        }
        get groundMesh() {
            return this.m_groundMesh;
        }
        /**
         * Allows to enable/disable the atmosphere effect, regardless of the theme settings.
         *
         * Use this method to change the setup in runtime without defining corresponding theme setup.
         *
         * @param enable - A boolean that specifies whether the atmosphere should be enabled or
         *                 disabled.
         */
        set enabled(enable) {
            // Check already disposed.
            if (this.disposed) {
                return;
            }
            if (this.m_enabled === enable) {
                return;
            }
            this.m_enabled = enable;
            const isAdded = MapViewAtmosphere.isPresent(this.m_mapAnchors);
            if (enable && !isAdded) {
                this.addToMapAnchors(this.m_mapAnchors);
            }
            else if (!enable && isAdded) {
                this.removeFromMapAnchors(this.m_mapAnchors);
            }
        }
        /**
         * Returns the current atmosphere status, enabled or disabled.
         */
        get enabled() {
            return this.m_enabled;
        }
        set lightMode(lightMode) {
            if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
                return;
            }
            const dynamicLight = lightMode === AtmosphereLightMode.LightDynamic;
            if (this.m_groundMaterial !== undefined) {
                const groundMat = this.m_groundMaterial;
                groundMat.setDynamicLighting(dynamicLight);
            }
            if (this.m_skyMaterial !== undefined) {
                const skyMat = this.m_skyMaterial;
                skyMat.setDynamicLighting(dynamicLight);
            }
        }
        /**
         * Disposes allocated resources.
         */
        dispose() {
            var _a, _b, _c, _d;
            // Unlink from scene and mapview anchors
            if (this.enabled) {
                this.enabled = false;
            }
            (_a = this.m_skyMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
            (_b = this.m_groundMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
            (_c = this.m_skyGeometry) === null || _c === void 0 ? void 0 : _c.dispose();
            (_d = this.m_groundGeometry) === null || _d === void 0 ? void 0 : _d.dispose();
            // After disposal we may no longer enable effect.
            this.m_skyGeometry = undefined;
            this.m_groundGeometry = undefined;
            this.m_skyMaterial = undefined;
            this.m_groundMaterial = undefined;
            this.m_skyMesh = undefined;
            this.m_groundMesh = undefined;
        }
        /**
         * Sets the atmosphere depending on the
         * {@link @here/harp-datasource-protocol#Theme} instance provided.
         *
         * This function is called when a theme is loaded. Atmosphere is added only if the theme
         * contains a atmosphere definition with a:
         * - `color` property, used to set the atmosphere color.
         *
         * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.
         */
        reset(theme) {
            //this.m_cachedTheme = theme;
        }
        get disposed() {
            return this.m_skyMesh === undefined && this.m_groundMesh === undefined;
        }
        /**
         * Handles atmosphere effect adding.
         */
        addToMapAnchors(mapAnchors) {
            harp_utils_1.assert(!MapViewAtmosphere.isPresent(mapAnchors), "Atmosphere already added");
            if (this.m_skyMesh !== undefined) {
                mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));
            }
            if (this.m_groundMesh !== undefined) {
                mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));
            }
            // Request an update once the anchor is added to {@link MapView}.
            if (this.m_updateCallback) {
                this.m_updateCallback();
            }
        }
        /**
         * Handles atmosphere effect removal.
         */
        removeFromMapAnchors(mapAnchors) {
            if (!MapViewAtmosphere.isPresent(mapAnchors)) {
                return;
            }
            let update = false;
            if (this.m_skyMesh !== undefined) {
                mapAnchors.remove(this.m_skyMesh);
                update = true;
            }
            if (this.m_groundMesh !== undefined) {
                mapAnchors.remove(this.m_groundMesh);
                update = true;
            }
            if (update && this.m_updateCallback) {
                this.m_updateCallback();
            }
        }
        createSkyGeometry() {
            let skyGeometry;
            switch (this.m_projection.type) {
                case harp_geoutils_1.ProjectionType.Spherical:
                    skyGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                    break;
                default: {
                    skyGeometry = new THREE.PlaneGeometry(200, 200);
                    break;
                }
            }
            skyGeometry.translate(0, 0, 0);
            this.m_skyGeometry = new THREE.BufferGeometry();
            this.m_skyGeometry.fromGeometry(skyGeometry);
            skyGeometry.dispose();
            if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {
                this.m_skyMaterial = new harp_materials_1.SkyAtmosphereMaterial();
            }
            else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {
                this.m_skyMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0xc4f8ed),
                    opacity: 0.4,
                    transparent: false,
                    depthTest: true,
                    depthWrite: false,
                    side: THREE.BackSide,
                    blending: THREE.NormalBlending,
                    fog: false
                });
            }
            else {
                this.m_skyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x7fffff,
                    depthTest: false,
                    depthWrite: false,
                    normalScale: new THREE.Vector2(-1, -1),
                    side: THREE.BackSide,
                    wireframe: true
                });
            }
            this.m_skyMesh = new THREE.Mesh(this.m_skyGeometry, this.m_skyMaterial);
            // Assign custom name so sky object may be easily recognized withing the scene.
            this.m_skyMesh.name = MapViewAtmosphere.SkyAtmosphereUserName;
            this.setupSkyForRendering();
        }
        createGroundGeometry() {
            let groundGeometry;
            switch (this.m_projection.type) {
                case harp_geoutils_1.ProjectionType.Spherical:
                    groundGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                    break;
                default: {
                    groundGeometry = new THREE.PlaneGeometry(200, 200);
                    break;
                }
            }
            groundGeometry.translate(0, 0, 0);
            this.m_groundGeometry = new THREE.BufferGeometry();
            this.m_groundGeometry.fromGeometry(groundGeometry);
            groundGeometry.dispose();
            if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {
                this.m_groundMaterial = new harp_materials_1.GroundAtmosphereMaterial();
            }
            else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {
                this.m_groundMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0x00c5ff),
                    opacity: 0.4,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    side: THREE.FrontSide,
                    blending: THREE.NormalBlending,
                    fog: false
                });
            }
            else {
                this.m_groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x11899a,
                    depthTest: true,
                    depthWrite: false,
                    side: THREE.FrontSide,
                    wireframe: true
                });
            }
            this.m_groundMesh = new THREE.Mesh(this.m_groundGeometry, this.m_groundMaterial);
            // Assign name so object may be recognized withing the scene.
            this.m_groundMesh.name = MapViewAtmosphere.GroundAtmosphereUserName;
            this.setupGroundForRendering();
        }
        setupSkyForRendering() {
            if (this.m_skyMesh === undefined) {
                return;
            }
            // Depending on material variant we need to update uniforms or only
            // update camera near/far planes cause camera need to see further then
            // actual earth geometry.
            let onBeforeCallback;
            if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
                // Setup only further clip planes before rendering.
                onBeforeCallback = (camera, _material) => {
                    this.overrideClipPlanes(camera);
                };
            }
            else {
                // Setup proper clip planes and update uniforms values.
                onBeforeCallback = (camera, material) => {
                    this.overrideClipPlanes(camera);
                    // Check material wasn't swapped.
                    harp_utils_1.assert(material instanceof harp_materials_1.SkyAtmosphereMaterial);
                    const mat = this.m_skyMaterial;
                    mat.updateUniforms(mat, this.m_skyMesh, camera, this.m_lightDirection);
                };
            }
            // Sky material should be already created with mesh.
            harp_utils_1.assert(this.m_skyMaterial !== undefined);
            this.m_skyMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
                onBeforeCallback(camera, material);
            };
            this.m_skyMesh.onAfterRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
                this.revertClipPlanes(camera);
            };
        }
        setupGroundForRendering() {
            if (this.m_groundMesh === undefined) {
                return;
            }
            if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
                return;
            }
            // Ground material should be already created.
            harp_utils_1.assert(this.m_groundMaterial !== undefined);
            // Ground mesh does not need custom clip planes and uses the same camera setup as
            // real (data source based) geometry.
            this.m_groundMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
                harp_utils_1.assert(material instanceof harp_materials_1.GroundAtmosphereMaterial);
                const mat = this.m_groundMaterial;
                mat.updateUniforms(mat, this.m_groundMesh, camera, this.m_lightDirection);
            };
        }
        overrideClipPlanes(rteCamera) {
            // Store current clip planes used by global camera before modifying them.
            const sceneCam = this.m_sceneCamera;
            cache.clipPlanes.near = sceneCam.near;
            cache.clipPlanes.far = sceneCam.far;
            // Calculate view ranges using world camera.
            // NOTE: ElevationProvider is not passed to evaluator, leaves min/max altitudes unchanged.
            const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(this.m_sceneCamera, this.m_projection);
            // Update relative to eye camera used internally in rendering.
            harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);
            const c = rteCamera;
            c.near = viewRanges.near;
            // Small margin ensures that we never cull small triangles just below or at
            // horizon - possible due to frustum culling in-precisions.
            c.far = viewRanges.far + harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * 0.1;
            c.updateProjectionMatrix();
        }
        revertClipPlanes(rteCamera) {
            harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);
            const c = rteCamera;
            // Restore scene camera clip planes.
            c.near = cache.clipPlanes.near;
            c.far = cache.clipPlanes.far;
            c.updateProjectionMatrix();
        }
    }
    /**
     * User data name attribute assigned to created mesh.
     */
    MapViewAtmosphere.SkyAtmosphereUserName = "SkyAtmosphere";
    /**
     * User data name attribute assigned to created mesh.
     */
    MapViewAtmosphere.GroundAtmosphereUserName = "GroundAtmosphere";
    return MapViewAtmosphere;
})();
exports.MapViewAtmosphere = MapViewAtmosphere;
function createMapAnchor(mesh, renderOrder) {
    const anchor = mesh;
    anchor.renderOrder = renderOrder;
    anchor.pickable = false;
    anchor.anchor = new THREE.Vector3(0, 0, 0);
    return anchor;
}
//# sourceMappingURL=MapViewAtmosphere.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewFog.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewFog.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewFog = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Manages the fog display in {@link MapView}.
 */
class MapViewFog {
    /**
     * Constructs a `MapViewFog` instance.
     *
     * @param m_scene - The scene used in {@link MapView} that contains the map objects.
     */
    constructor(m_scene) {
        this.m_scene = m_scene;
        this.m_enabled = true;
        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.
        this.m_fogIsDefined = false;
        this.m_cachedTheme = { styles: {} };
    }
    /**
     * Allows for disabling the fog, even if it is defined in the theme. Use this property for
     * custom views like the demo app's debug camera. However, if the theme does not define a
     * fog, enabling this property here has no effect.
     *
     * @param value - A boolean that specifies whether the fog should be enabled or disabled.
     */
    set enabled(enableFog) {
        this.m_enabled = enableFog;
        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
            this.add();
        }
        else if (!enableFog && this.m_scene.fog !== null) {
            this.remove();
        }
    }
    /**
     * Returns the current fog status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    /**
     * Sets the fog depending on the {@link @here/harp-datasource-protocol#Theme}
     * instance provided. This function is called when a
     * theme is loaded. Fog is added only if the theme contains a fog definition with a:
     * - `color` property, used to set the fog color.
     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far
     * clipping plane distance.
     *
     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.
     */
    reset(theme) {
        this.m_cachedTheme = theme;
        if (theme !== undefined &&
            theme.fog !== undefined &&
            theme.fog.color !== undefined &&
            theme.fog.startRatio !== undefined) {
            this.m_fogIsDefined = true;
            this.m_fog.color.set(theme.fog.color);
            if (this.m_enabled && this.m_scene.fog === null) {
                this.add();
            }
        }
        else {
            this.m_fogIsDefined = false;
            if (this.m_scene.fog !== null) {
                this.remove();
            }
        }
    }
    /**
     * Updates the fog at runtime, depending on the camera.
     *
     * @param camera - An instance of a `THREE.Camera` with a `far` property.
     */
    update(mapView, viewDistance) {
        if (this.m_scene.fog !== null &&
            this.m_cachedTheme !== undefined &&
            this.m_cachedTheme.fog &&
            this.m_cachedTheme.fog.startRatio !== undefined &&
            (mapView.camera.far !== undefined || viewDistance !== undefined)) {
            // If maximum visibility range is available use it instead of camera.far distance,
            // this makes fog independent from dynamic camera planes and keeps consistent
            // distance based "melting" (fog) effect during a tilt.
            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;
            // TODO: We may move below constants to theme Fog definition
            // Density of the fog when viewing straight along the horizon line.
            const horizontalDensity = 1.0;
            // Theoretical density of the fog when viewing straight from top to down.
            const verticalDensity = 0.0;
            // The fraction of the maximum viewing distance along the eye vector
            // to start applying the fog.
            const startRatio = this.m_cachedTheme.fog.startRatio;
            // The fraction of maximum viewing range at which fog fully covers geometry.
            const endRatio = 1.0;
            harp_utils_1.assert(startRatio <= endRatio);
            const t = Math.abs(Math.cos(mapView.tilt));
            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);
            this.m_fog.near = harp_utils_1.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);
            this.m_fog.far = harp_utils_1.MathUtils.lerp(viewRange * endRatio, viewRange, density);
            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);
            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);
        }
    }
    /**
     * Handles fog addition.
     */
    add() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = this.m_fog;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(true);
    }
    /**
     * Handles fog removal.
     */
    remove() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = null;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(false);
    }
    /**
     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified
     * explicitly.
     *
     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298
     */
    setFogInRawShaderMaterials(enableFog) {
        this.m_scene.traverse(object => {
            if (!(object instanceof THREE.Mesh)) {
                return;
            }
            if (!(object.material instanceof THREE.Material)) {
                return;
            }
            // HighPrecisionLineMaterial does not support fog
            if (object.material instanceof harp_materials_1.HighPrecisionLineMaterial) {
                return;
            }
            // We may skip redundant updates.
            if (object.material.fog === enableFog) {
                return;
            }
            object.material.fog = enableFog;
            // Fog properties can't be easily changed at runtime (once the material
            // is rendered at least once) and thus requires building of new shader
            // program - force material update.
            object.material.needsUpdate = true;
        });
    }
}
exports.MapViewFog = MapViewFog;
//# sourceMappingURL=MapViewFog.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewPoints.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Squares = exports.Circles = exports.MapViewPoints = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * `MapViewPoints` is a class to extend for the `"circles"` and `"squares"` [[Technique]]s to
 * implement raycasting of [[THREE.Points]] as expected in
 * {@link MapView}, that are in screen space.
 * It copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its
 * children classes, {@link Circles} and {@link Squares}, who hold the intersection testing in the
 * `testPoint` method. This class also has the ability to dismiss the testing via the
 * `enableRayTesting` flag.
 *
 * Its main motivation is to handle the point styles of XYZ projects.
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js
 */
class MapViewPoints extends THREE.Points {
    constructor() {
        super(...arguments);
        /**
         * This allows to discard the ray testing.
         */
        this.enableRayTesting = true;
    }
    /**
     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it
     * then calls the tailored `testPoint` method in the children classes to test intersections
     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.
     *
     * @param raycaster - The raycaster.
     * @param intersects - The array to fill with the results.
     */
    raycast(raycaster, intersects) {
        if (!this.enableRayTesting) {
            return;
        }
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const screenCoords = raycaster.ray.origin
            .clone()
            .add(raycaster.ray.direction)
            .project(raycaster.camera);
        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * raycaster.width), Math.ceil(((1 - screenCoords.y) / 2) * raycaster.height));
        if (geometry instanceof THREE.BufferGeometry) {
            const point = new THREE.Vector3();
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for (let i = 0, il = indices.length; i < il; i++) {
                    const a = indices[i];
                    point.fromArray(positions, a * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
            else {
                for (let i = 0, l = positions.length / 3; i < l; i++) {
                    point.fromArray(positions, i * 3);
                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                    if (pointInfo.pointIsOnScreen) {
                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);
                    }
                }
            }
        }
        else {
            const vertices = geometry.vertices;
            for (let index = 0; index < vertices.length; index++) {
                const point = vertices[index];
                const pointInfo = getPointInfo(point, matrixWorld, raycaster);
                if (pointInfo.pointIsOnScreen) {
                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);
                }
            }
        }
    }
}
exports.MapViewPoints = MapViewPoints;
function getPointInfo(point, matrixWorld, raycaster) {
    const worldPosition = point.clone();
    worldPosition.applyMatrix4(matrixWorld);
    const distance = worldPosition.distanceTo(raycaster.ray.origin);
    worldPosition.project(raycaster.camera);
    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
    const pointIsOnScreen = relativeScreenPosition.x < 1 &&
        relativeScreenPosition.x > -1 &&
        relativeScreenPosition.y < 1 &&
        relativeScreenPosition.y > -1;
    if (pointIsOnScreen) {
        worldPosition.x = ((worldPosition.x + 1) / 2) * raycaster.width;
        worldPosition.y = ((1 - worldPosition.y) / 2) * raycaster.height;
        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);
        return {
            absoluteScreenPosition,
            pointIsOnScreen,
            distance
        };
    }
    return {
        pointIsOnScreen
    };
}
/**
 * Point object that implements the raycasting of circles in screen space.
 */
class Circles extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radius = this.material.size / 2;
        if (dist <= radius) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Circles = Circles;
/**
 * Point object that implements the raycasting of squares in screen space.
 */
class Squares extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const halfSize = this.material.size / 2;
        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Squares = Squares;
//# sourceMappingURL=MapViewPoints.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PathBlockingElement.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PathBlockingElement.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathBlockingElement = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * This path in world coordinates is projected to screen space and blocks all other labels.
 *
 * It could be used for example:
 * - Border rejects labels.
 * - Route blocks street labels from being rendered underneath.
 *
 * Could potentially be expanded in future to have a priority, however for now, this isn't required.
 */
class PathBlockingElement {
    /**
     * Constructs a path from a list of points.
     * Pre allocates the [[screenSpaceLines]] used to render.
     * @param points - Points in world coordinates.
     */
    constructor(points) {
        this.points = points;
        this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);
        for (let i = 0; i < this.screenSpaceLines.length; i++) {
            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());
        }
    }
}
exports.PathBlockingElement = PathBlockingElement;
//# sourceMappingURL=PathBlockingElement.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickHandler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickHandler = exports.PickObjectType = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a {@link TextElement}
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a {@link TextElement}.
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
const tmpOBB = new harp_geoutils_1.OrientedBox3();
/**
 * Handles the picking of scene geometry and roads.
 * @internal
 */
class PickHandler {
    constructor(mapView, camera, enablePickTechnique = false) {
        this.mapView = mapView;
        this.camera = camera;
        this.enablePickTechnique = enablePickTechnique;
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to
     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the
     * shader cannot be tested for intersection.
     *
     * @param x - The X position in CSS/client coordinates, without the applied display ratio.
     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y) {
        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);
        const pickResults = [];
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = worldPos.x * clientWidth * 0.5;
            const screenY = worldPos.y * clientHeight * 0.5;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);
        }
        const intersects = [];
        const tileList = this.mapView.visibleTileSet.dataSourceTileList;
        tileList.forEach(dataSourceTileList => {
            dataSourceTileList.renderedTiles.forEach(tile => {
                tmpOBB.copy(tile.boundingBox);
                tmpOBB.position.sub(this.mapView.worldCenter);
                // This offset shifts the box by the given tile offset, see renderTileObjects in
                // MapView
                const worldOffsetX = tile.computeWorldOffsetX();
                tmpOBB.position.x += worldOffsetX;
                if (tmpOBB.intersectsRay(rayCaster.ray) !== undefined) {
                    rayCaster.intersectObjects(tile.objects, true, intersects);
                }
            });
        });
        for (const intersect of intersects) {
            const pickResult = {
                type: PickObjectType.Unspecified,
                point: intersect.point,
                distance: intersect.distance,
                intersection: intersect
            };
            if (intersect.object.userData === undefined ||
                intersect.object.userData.feature === undefined) {
                pickResults.push(pickResult);
                continue;
            }
            const featureData = intersect.object.userData.feature;
            if (this.enablePickTechnique) {
                pickResult.technique = intersect.object.userData.technique;
            }
            this.addObjInfo(featureData, intersect, pickResult);
            if (featureData.objInfos !== undefined) {
                const featureId = featureData.objInfos.length === 1
                    ? harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])
                    : undefined;
                pickResult.featureId = featureId;
            }
            let pickObjectType;
            switch (featureData.geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    pickObjectType = PickObjectType.Point;
                    break;
                case harp_datasource_protocol_1.GeometryType.Line:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    pickObjectType = PickObjectType.Line;
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    pickObjectType = PickObjectType.Area;
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    pickObjectType = PickObjectType.Object3D;
                    break;
                default:
                    pickObjectType = PickObjectType.Unspecified;
            }
            pickResult.type = pickObjectType;
            pickResults.push(pickResult);
        }
        pickResults.sort((a, b) => {
            return a.distance - b.distance;
        });
        return pickResults;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (featureData.objInfos === undefined) {
            return;
        }
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        if (featureData.starts === undefined ||
            featureData.starts.length === 0 ||
            (intersect.faceIndex === undefined && intersect.index === undefined)) {
            return;
        }
        if (featureData.starts.length === 1) {
            pickResult.userData = featureData.objInfos[0];
            return;
        }
        const intersectIndex = intersect.faceIndex !== undefined ? intersect.faceIndex * 3 : intersect.index;
        // TODO: Implement binary search.
        let objInfosIndex = 0;
        for (const featureStartIndex of featureData.starts) {
            if (featureStartIndex > intersectIndex) {
                break;
            }
            objInfosIndex++;
        }
        pickResult.userData = featureData.objInfos[objInfosIndex - 1];
    }
}
exports.PickHandler = PickHandler;
//# sourceMappingURL=PickHandler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickingRaycaster.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickingRaycaster.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingRaycaster = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Raycasting points is not supported as necessary in Three.js. This class extends a
 * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space
 * geometry.
 *
 * @internal
 */
class PickingRaycaster extends THREE.Raycaster {
    /**
     * Constructor.
     *
     * @param width - the canvas width.
     * @param height - the canvas height.
     */
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }
}
exports.PickingRaycaster = PickingRaycaster;
//# sourceMappingURL=PickingRaycaster.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolarTileDataSource = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ "./node_modules/@here/harp-datasource-protocol/index-decoder.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "./node_modules/@here/harp-mapview/lib/DataSource.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
const MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js");
/**
 * {@link DataSource} providing geometry for poles
 */
class PolarTileDataSource extends DataSource_1.DataSource {
    constructor({ name = "polar", styleSetName, minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset = -2, geometryLevelOffset = 1, debugTiles = false }) {
        super({
            name,
            styleSetName,
            minDataLevel,
            maxDataLevel,
            minDisplayLevel,
            maxDisplayLevel,
            storageLevelOffset
        });
        this.m_tilingScheme = harp_geoutils_1.polarTilingScheme;
        this.m_maxLatitude = THREE.MathUtils.radToDeg(harp_geoutils_1.MercatorConstants.MAXIMUM_LATITUDE);
        this.m_geometryLevelOffset = geometryLevelOffset;
        this.m_debugTiles = debugTiles;
        this.cacheable = false;
    }
    /** @override */
    dispose() {
        if (this.m_northPoleEntry) {
            this.m_northPoleEntry.material.dispose();
            delete this.m_northPoleEntry;
        }
        if (this.m_southPoleEntry) {
            this.m_southPoleEntry.material.dispose();
            delete this.m_southPoleEntry;
        }
        if (this.m_styleSetEvaluator) {
            delete this.m_styleSetEvaluator;
        }
    }
    createTechiqueEntry(kind) {
        if (!this.m_styleSetEvaluator) {
            return undefined;
        }
        const env = new index_decoder_1.MapEnv({
            $geometryType: "polygon",
            $layer: "earth",
            kind
        });
        const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);
        if (techniques.length === 0) {
            return undefined;
        }
        const technique = techniques[0];
        const material = DecodedTileHelpers_1.createMaterial({ technique, env: this.mapView.env });
        if (!material) {
            return undefined;
        }
        return { material, technique };
    }
    /** @override */
    setStyleSet(styleSet, definitions, languages) {
        this.dispose();
        if (styleSet !== undefined) {
            this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator(styleSet, definitions);
            this.m_northPoleEntry = this.createTechiqueEntry("north_pole");
            this.m_southPoleEntry = this.createTechiqueEntry("south_pole");
        }
        this.mapView.markTilesDirty(this);
    }
    /** @override */
    setTheme(theme, languages) {
        const styleSet = (this.styleSetName !== undefined && theme.styles && theme.styles[this.styleSetName]) ||
            [];
        this.setStyleSet(styleSet, theme.definitions, languages);
    }
    /** @override */
    canGetTile(zoomLevel, tileKey) {
        if (zoomLevel !== tileKey.level || tileKey.level < 1) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    shouldSubdivide(zoomLevel, tileKey) {
        if (zoomLevel <= tileKey.level) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        this.createTileGeometry(tile);
        return tile;
    }
    get geometryLevelOffset() {
        return this.m_geometryLevelOffset;
    }
    set geometryLevelOffset(geometryLevelOffset) {
        this.m_geometryLevelOffset = geometryLevelOffset;
    }
    intersectEdge(latitude, a, b) {
        const latA = a.latitude;
        const latB = b.latitude;
        let lonA = a.longitude;
        let lonB = b.longitude;
        if (Math.abs(latA) === 90) {
            lonA = lonB;
        }
        if (Math.abs(latB) === 90) {
            lonB = lonA;
        }
        const deltaLat = latB - latA;
        const deltaLon = lonB - lonA;
        const scale = (latitude - latA) / deltaLat;
        return new harp_geoutils_1.GeoCoordinates(latitude, lonA + deltaLon * scale, 0);
    }
    createTileGeometry(tile) {
        const { north, south } = tile.geoBox;
        const isNorthPole = north > 0 && south >= 0;
        const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;
        if (techniqueEntry === undefined) {
            tile.forceHasGeometry(true);
            return;
        }
        const srcProjection = this.m_tilingScheme.projection;
        const dstProjection = this.projection;
        const maxLat = this.m_maxLatitude;
        const poleLat = isNorthPole ? maxLat : -maxLat;
        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);
        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));
        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));
        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));
        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));
        let points;
        let needsGeometryCut = false;
        // special case where tile contains half of the hemisphere
        if (tile.tileKey.level === 1) {
            const isLeftHalf = box.min.x === 0;
            const poleX = isLeftHalf ? box.max.x : box.min.x;
            const poleY = (box.max.y + box.min.y) / 2;
            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));
            // coordinates are not used, needed for right position
            const pXX = isLeftHalf ? pBL : pBR;
            points = isNorthPole
                ? isLeftHalf
                    ? [pPole, pTR, pXX, pBR]
                    : [pPole, pBL, pXX, pTL]
                : isLeftHalf
                    ? [pPole, pBR, pXX, pTR]
                    : [pPole, pTL, pXX, pBL];
            needsGeometryCut = true;
        }
        else {
            // ccw for north, cw for south
            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];
            const lats = points.map(p => p.latitude);
            const lmax = Math.max(...lats);
            const lmin = Math.min(...lats);
            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;
            if (isAllPointsOut) {
                return;
            }
            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;
            needsGeometryCut = isSomePointsOut;
            if (needsGeometryCut) {
                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);
                if (nearest !== 0) {
                    for (let i = 0; i < nearest; i++) {
                        points.push(points.shift());
                    }
                }
            }
        }
        if (needsGeometryCut) {
            const centerX = (box.min.x + box.max.x) / 2;
            const centerY = (box.min.y + box.max.y) / 2;
            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));
            harp_geoutils_1.TransverseMercatorUtils.alignLongitude(points, center);
            // points aligned as follows:
            // a - nearest to the pole, always in
            // b - next to nearest
            // c - farthes from the pole, always out
            // d - prev from nearest
            const a = points[0];
            const b = points[1];
            const c = points[2];
            const d = points[3];
            const inPointB = Math.abs(b.latitude) >= maxLat;
            const inPointD = Math.abs(d.latitude) >= maxLat;
            const cutStart = inPointB
                ? this.intersectEdge(poleLat, b, c)
                : this.intersectEdge(poleLat, a, b);
            const cutEnd = inPointD
                ? this.intersectEdge(poleLat, d, c)
                : this.intersectEdge(poleLat, a, d);
            points.splice(inPointB ? 2 : 1, 4, cutStart);
            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;
            // tslint:disable-next-line:no-bitwise
            const subdivisions = 1 << Math.max(0, level);
            const step = 360 / subdivisions;
            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);
            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);
            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {
                points.push(new harp_geoutils_1.GeoCoordinates(poleLat, i * step - 180, 0));
            }
            points.push(cutEnd);
            if (inPointD) {
                points.push(d);
            }
        }
        const g = new THREE.Geometry();
        for (const point of points) {
            const projected = dstProjection.projectPoint(point, new THREE.Vector3());
            g.vertices.push(projected.sub(tile.center));
        }
        for (let i = 1; i < points.length - 1; i++) {
            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));
        }
        const geometry = new THREE.BufferGeometry();
        geometry.fromGeometry(g);
        g.dispose();
        const mesh = new THREE.Mesh(geometry, techniqueEntry.material);
        mesh.userData = {
            dataSource: this.name,
            tileKey: tile.tileKey
        };
        if (this.m_debugTiles) {
            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);
            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });
            tile.objects.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true })));
        }
        MapObjectAdapter_1.MapObjectAdapter.create(mesh, {
            technique: techniqueEntry.technique,
            kind: [isNorthPole ? harp_datasource_protocol_1.StandardGeometryKind.Water : harp_datasource_protocol_1.StandardGeometryKind.Background]
        });
        tile.objects.push(mesh);
    }
}
exports.PolarTileDataSource = PolarTileDataSource;
//# sourceMappingURL=PolarTileDataSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenCollisions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScreenCollisionsDebug = exports.ScreenCollisions = exports.isLineWithBound = exports.DetailedCollisionBox = exports.CollisionBox = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DebugContext_1 = __webpack_require__(/*! ./DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
// tslint:disable-next-line:no-var-requires
const RBush = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
const logger = harp_utils_1.LoggerManager.instance.create("ScreenCollissions");
class CollisionBox extends harp_utils_1.Math2D.Box {
    constructor(box) {
        super();
        if (box !== undefined) {
            this.copy(box);
        }
    }
    copy(box) {
        if (box instanceof harp_utils_1.Math2D.Box) {
            this.set(box.x, box.y, box.w, box.h);
        }
        else if (box instanceof THREE.Box2) {
            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);
        }
        else {
            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);
        }
        return this;
    }
    get minX() {
        return this.x;
    }
    set minX(minX) {
        this.x = minX;
    }
    get maxX() {
        return this.x + this.w;
    }
    set maxX(maxX) {
        this.w = maxX - this.x;
    }
    get minY() {
        return this.y;
    }
    set minY(minY) {
        this.y = minY;
    }
    get maxY() {
        return this.y + this.h;
    }
    set maxY(maxY) {
        this.h = maxY - this.y;
    }
}
exports.CollisionBox = CollisionBox;
/**
 * Collision box with additional boxes defining tighter bounds for the enclosed feature
 * (e.g.glyph bounds for text).
 */
class DetailedCollisionBox extends CollisionBox {
    constructor(box, detailBoxes) {
        super(box);
        this.detailBoxes = detailBoxes;
    }
}
exports.DetailedCollisionBox = DetailedCollisionBox;
function isLineWithBound(box) {
    return box.line !== undefined;
}
exports.isLineWithBound = isLineWithBound;
const tmpCollisionBox = new CollisionBox();
class ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object.
     */
    constructor() {
        /** The screen bounding box. */
        this.screenBounds = new harp_utils_1.Math2D.Box();
        /** Tree of allocated bounds. */
        this.rtree = new RBush();
        //
    }
    /**
     * Resets the list of allocated screen bounds.
     */
    reset() {
        this.rtree.clear();
    }
    /**
     * Updates the screen bounds that are used to check if bounding boxes are visible.
     *
     * @param width - The width of the container.
     * @param height - The height of the container.
     */
    update(width, height) {
        this.screenBounds.set(width / -2, height / -2, width, height);
        this.reset();
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds - The bounding box in NDC scaled coordinates (i.e. top left is -width/2,
     * -height/2)
     */
    allocate(bounds) {
        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;
        this.rtree.insert(bbox);
    }
    /**
     * Inserts the given bounds into the rtree.
     *
     * @param bounds - The bounding boxes (the bounding boxes must be in the space returned from the
     * ScreenProjector.project method).
     */
    allocateIBoxes(bounds) {
        this.rtree.load(bounds);
    }
    /**
     * Search for all bounds in the tree intersecting with the given box.
     * @param box - The box used for the search.
     * @returns An array of all IBoxes intersecting with the given box.
     */
    search(box) {
        return this.rtree.search(box);
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);
        const results = this.search(collisionBox);
        return this.intersectsDetails(collisionBox, results);
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isVisible(bounds) {
        return this.screenBounds.intersects(bounds);
    }
    /**
     * Checks if the given screen bounds is contained within the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isFullyVisible(bounds) {
        return this.screenBounds.containsBox(bounds);
    }
    /**
     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified
     * [[IBox]]es.
     *
     * @param testBox - The box to test for intersection.
     * @param boxes - The candidate boxes the test box may intersect with. It's assumed that the
     * global bounds of these boxes intersect with the given test box.
     * @returns `true` if any intersection found.
     */
    intersectsDetails(testBox, boxes) {
        for (const box of boxes) {
            if (box instanceof DetailedCollisionBox) {
                for (const detailBox of box.detailBoxes) {
                    if (detailBox.intersects(testBox)) {
                        return true;
                    }
                }
            }
            else if (isLineWithBound(box)) {
                const boundedLine = box;
                if (this.intersectsLine(testBox, boundedLine)) {
                    return true;
                }
            }
            else {
                return true;
            }
        }
        return false;
    }
    /**
     * Computes the intersection between the supplied CollisionBox and the LineWithBound.
     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be
     * in Screen Coordinate space
     */
    intersectsLine(bbox, boundedLine) {
        const line = boundedLine.line;
        // Note, these aren't normalized, but it doesn't matter, we are just interested
        // in the sign.
        const lineXDiffTransformed = line.end.x - line.start.x;
        // Sign of bottom left, bottom right, top left and top right corners.
        let signBL;
        let signBR;
        let signTL;
        let signTR;
        if (lineXDiffTransformed !== 0) {
            const lineYDiffTransformed = line.end.y - line.start.y;
            const normalX = lineYDiffTransformed;
            const normalY = -lineXDiffTransformed;
            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;
            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);
            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);
            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);
            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);
        }
        else {
            signBL = Math.sign(bbox.minX - line.start.x);
            signBR = Math.sign(bbox.maxX - line.start.x);
            signTL = Math.sign(bbox.minX - line.start.x);
            signTR = Math.sign(bbox.maxX - line.start.x);
        }
        return signBL !== signBR || signBL !== signTL || signBL !== signTR;
    }
}
exports.ScreenCollisions = ScreenCollisions;
/**
 * @hidden
 *
 * Shows requests for screen space during labelling in an HTML canvas, which should be sized like
 * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests
 * for screen space were done.
 *
 * Also logs statistics.
 */
class ScreenCollisionsDebug extends ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.
     */
    constructor(debugCanvas) {
        super();
        /** 2D rendering context. */
        this.m_renderContext = null;
        this.m_renderingEnabled = false;
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
        if (debugCanvas !== undefined && debugCanvas !== null) {
            this.m_renderContext = debugCanvas.getContext("2d");
        }
    }
    /**
     * Resets the list of allocated bounds and clears the debug canvas.
     * @override
     */
    reset() {
        super.reset();
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
    }
    /**
     * Updates the screen bounds used to check if bounding boxes are visible.
     *
     * @param width - The width of the container.
     * @param height - The height of the container.
     * @override
     */
    update(width, height) {
        if (this.m_renderingEnabled) {
            logger.log(
            // tslint:disable-next-line: max-line-length
            `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
        }
        super.update(width, height);
        if (this.m_renderContext !== null) {
            this.m_renderContext.canvas.width = width;
            this.m_renderContext.canvas.height = height;
        }
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_SCREEN_COLLISIONS", true)
        this.m_renderingEnabled = DebugContext_1.debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds - the bounding box in world coordinates.
     * @override
     */
    allocate(bounds) {
        super.allocate(bounds);
        this.m_numAllocations++;
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            this.m_renderContext.strokeStyle = "#6666ff";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y, bounds.w, -bounds.h);
        }
    }
    /** @override */
    allocateIBoxes(boundsArray) {
        for (const bounds of boundsArray) {
            this.m_numAllocations++;
            if (this.m_renderingEnabled && this.m_renderContext !== null) {
                this.m_renderContext.strokeStyle = "#aa2222";
                this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));
            }
        }
        super.allocateIBoxes(boundsArray);
    }
    /** @override */
    intersectsDetails(testBox, boxes) {
        const collisionFound = super.intersectsDetails(testBox, boxes);
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            const padding = collisionFound ? 2 : 1;
            this.m_renderContext.strokeStyle = collisionFound ? "#FF0000" : "#00ff00";
            this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - padding, this.screenBounds.y + this.screenBounds.h - testBox.y + padding, testBox.w + 2 * padding, -testBox.h - 2 * padding);
        }
        if (collisionFound) {
            this.m_numFailedTests++;
        }
        else {
            this.m_numSuccessfulTests++;
        }
        return collisionFound;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     * @override
     */
    isVisible(bounds) {
        const visible = super.isVisible(bounds);
        if (visible) {
            this.m_numSuccessfulVisibilityTests++;
        }
        else {
            this.m_numFailedVisibilityTests++;
        }
        return visible;
    }
}
exports.ScreenCollisionsDebug = ScreenCollisionsDebug;
//# sourceMappingURL=ScreenCollisions.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenProjector.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScreenProjector = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.
 * @param ndc - The position to check.
 */
function isOnScreen(ndc) {
    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
let ScreenProjector = /** @class */ (() => {
    class ScreenProjector {
        /**
         * Constructs a new `ScreenProjector`.
         *
         * @param m_camera - Camera to project against.
         */
        constructor(m_camera) {
            this.m_camera = m_camera;
            this.m_width = 0;
            this.m_height = 0;
        }
        /**
         * Height of the screen.
         */
        get width() {
            return this.m_width;
        }
        /**
         * Width of the screen.
         */
        get height() {
            return this.m_height;
        }
        /**
         * Apply current projectionViewMatrix of the camera to project the source vector into
         * screen coordinates.
         *
         * @param {(Vector3Like)} source The source vector to project.
         * @param {THREE.Vector2} target The target vector.
         * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
         * outside the near / far plane.
         */
        project(source, target = new THREE.Vector2()) {
            const p = this.projectVector(source, ScreenProjector.tempV3);
            if (p.z > -1 && p.z < 1) {
                return this.ndcToScreen(p, target);
            }
            return undefined;
        }
        /**
         * Apply current projectionViewMatrix of the camera to project the source vector into
         * screen coordinates.
         *
         * @param {(Vector3Like)} source The source vector to project.
         * @param {THREE.Vector2} target The target vector.
         * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
         * outside the screen.
         */
        projectOnScreen(source, target = new THREE.Vector2()) {
            const p = this.projectVector(source, ScreenProjector.tempV3);
            if (isOnScreen(p)) {
                return this.ndcToScreen(p, target);
            }
            return undefined;
        }
        /**
         * Apply current projectionViewMatrix of the camera to project the source vector into
         * screen coordinates. The z component between -1 and 1 is also returned.
         *
         * @param {(Vector3Like)} source The source vector to project.
         * @param {THREE.Vector3} target The target vector.
         * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if
         * outside the near / far plane.
         */
        project3(source, target = new THREE.Vector3()) {
            const p = this.projectVector(source, ScreenProjector.tempV3);
            if (p.z > -1 && p.z < 1) {
                target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);
                return target;
            }
            return undefined;
        }
        /**
         * Apply current projectionViewMatrix of the camera to project the source vector. Stores
         * result in NDC in the target vector.
         *
         * @param {(Vector3Like)} source The source vector to project.
         * @param {THREE.Vector3} target The target vector.
         * @returns {THREE.Vector3} The projected vector (the parameter 'target').
         */
        projectVector(source, target) {
            target.set(source.x, source.y, source.z).project(this.m_camera);
            return target;
        }
        /**
         * Fast test to check if projected point is on screen.
         *
         * @returns {boolean} `true` if point is on screen, `false` otherwise.
         */
        onScreen(source) {
            const p = this.projectVector(source, ScreenProjector.tempV3);
            return isOnScreen(p);
        }
        /**
         * Update the `ScreenProjector` with the latest values of the screen and the camera.
         *
         * @param {THREE.Camera} camera Camera to project against.
         * @param {number} width Width of screen/canvas.
         * @param {number} height Height of screen/canvas.
         */
        update(camera, width, height) {
            this.m_camera = camera;
            this.m_width = width;
            this.m_height = height;
        }
        ndcToScreen(ndc, screenCoords) {
            return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);
        }
    }
    ScreenProjector.tempV2 = new THREE.Vector2();
    ScreenProjector.tempV3 = new THREE.Vector3();
    return ScreenProjector;
})();
exports.ScreenProjector = ScreenProjector;
//# sourceMappingURL=ScreenProjector.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyBackground.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyBackground.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyBackground = void 0;
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js");
const SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js");
/**
 * Class that handles {@link MapView}'s sky background.
 */
class SkyBackground {
    /**
     * Constructs a new `SkyBackground`.
     *
     * @param m_sky - Sky configuration parameters.
     * @param m_projectionType - {@link MapView}'s projection type.
     * @param camera - {@link MapView}'s camera.
     */
    constructor(m_sky, m_projectionType, camera) {
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        switch (this.m_sky.type) {
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap": {
                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);
                break;
            }
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skyTexture.dispose();
    }
    /**
     * Sky texture.
     */
    get texture() {
        return this.m_skyTexture.texture;
    }
    /**
     * This method updates the skybox based on the camera position (needed for some types of sky).
     *
     * @param camera - The camera used in the map view.
     */
    updateCamera(camera) {
        if (this.m_sky.type === "gradient") {
            this.m_skyTexture.update(camera);
        }
    }
    /**
     * Updates the sky texture with new parameters.
     *
     * @param params - New sky configuration parameters.
     * @param projectionType - Which projection is used, this may also change (in which case the
     * textures should be recreated).
     */
    updateTexture(params, projectionType) {
        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
        switch (params.type) {
            case "gradient":
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);
                }
                break;
            case "cubemap": {
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);
                }
                break;
            }
        }
        this.m_projectionType = projectionType;
        this.m_sky = params;
    }
}
exports.SkyBackground = SkyBackground;
//# sourceMappingURL=SkyBackground.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyCubemapTexture = exports.SkyCubemapFaceId = exports.SKY_CUBEMAP_FACE_COUNT = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const logger = harp_utils_1.LoggerManager.instance.create("SkyCubemapTexture");
/**
 * Number of faces that form a [[SkyCubemapTexture]].
 */
exports.SKY_CUBEMAP_FACE_COUNT = 6;
/**
 * Maps the faceId to the expected position in the threejs faces array.
 */
var SkyCubemapFaceId;
(function (SkyCubemapFaceId) {
    SkyCubemapFaceId[SkyCubemapFaceId["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeZ"] = 5] = "negativeZ";
})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));
/**
 * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].
 */
class SkyCubemapTexture {
    /**
     * Constructs a new `SkyCubemapTexture`.
     *
     * @param sky - Initial [[CubemapSky]] configuration.
     */
    constructor(sky) {
        const faces = this.createCubemapFaceArray(sky);
        this.m_skybox =
            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skybox.dispose();
    }
    /**
     * `SkyCubemapTexture`'s texture resource.
     */
    get texture() {
        return this.m_skybox;
    }
    /**
     * Updates the `SkyCubemapTexture` with new parameters.
     *
     * @param params - New [[CubemapSky]] configuration.
     */
    updateTexture(sky) {
        const faces = this.createCubemapFaceArray(sky);
        if (faces === undefined) {
            return;
        }
        this.m_skybox = new three_1.CubeTextureLoader().load(faces);
    }
    createCubemapFaceArray(sky) {
        const faces = [
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined
        ];
        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {
            const face = sky[SkyCubemapFaceId[i]];
            if (face === undefined) {
                logger.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
                return;
            }
            faces[i] = face;
        }
        return faces;
    }
}
exports.SkyCubemapTexture = SkyCubemapTexture;
//# sourceMappingURL=SkyCubemapTexture.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyGradientTexture = exports.DEFAULT_MONOMIAL_POWER = exports.DEFAULT_TEXTURE_SIZE = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
exports.DEFAULT_TEXTURE_SIZE = 512;
exports.DEFAULT_MONOMIAL_POWER = 1;
// Vectors used for skybox bitmap computation.
const cameraDir = [
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0),
    new three_1.Vector3(0, -1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1)
];
const cameraRight = [
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0)
];
const cameraUp = [
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0)
];
/**
 * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].
 *
 * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,
 * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom
 *  hemisphere..
 */
class SkyGradientTexture {
    /**
     * Constructs a new `SkyGradientTexture`.
     *
     * @param sky - Initial [[GradientSky]] configuration.
     * @param m_projectionType - {@link MapView}'s projection type.
     * @param m_height - Optional height parameter.
     */
    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        const topColor = new three_1.Color(sky.topColor);
        const bottomColor = new three_1.Color(sky.bottomColor);
        const groundColor = new three_1.Color(sky.groundColor);
        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;
        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;
        this.m_faces = [];
        for (let i = 0; i < this.m_faceCount; ++i) {
            const data = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);
            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox = new three_1.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        }
        else {
            this.m_farClipPlaneDividedVertically = new three_1.Line3();
            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new three_1.Vector3();
            this.m_topMidFarPoint = new three_1.Vector3();
            this.m_horizonPosition = new three_1.Vector3();
            this.m_farClipPlaneCorners = [
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3()
            ];
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.m_faces[i].dispose();
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.dispose();
        }
    }
    /**
     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on
     * {@link MapView}'s projection).
     */
    get texture() {
        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;
    }
    /**
     * This method updates the position of the texture depending on the camera frustum.
     *
     * @param camera - The camera used in the map view.
     */
    update(camera) {
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {
            this.setHorizonPosition(camera);
            this.updateTexturePosition();
        }
    }
    /**
     * Updates the `SkyGradientTexture` with new parameters.
     *
     * @param params - New [[GradientSky]] configuration.
     */
    updateTexture(sky) {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);
            this.m_faces[i].needsUpdate = true;
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.needsUpdate = true;
        }
    }
    // When creating the texture, a Uint8Array is required, because the resulting texture passed
    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because
    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.
    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
        const color = new three_1.Color();
        const dir = new three_1.Vector3();
        const right = new three_1.Vector3();
        const up = new three_1.Vector3();
        const upDir = new three_1.Vector3(0, 0, 1);
        for (let i = 0; i < this.m_height; ++i) {
            for (let j = 0; j < this.m_width; ++j) {
                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
                    const offsetX = right
                        .copy(cameraRight[faceIdx])
                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);
                    const offsetY = up
                        .copy(cameraUp[faceIdx])
                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);
                    dir.copy(cameraDir[faceIdx])
                        .add(offsetX)
                        .add(offsetY)
                        .normalize();
                    const t = Math.max(upDir.dot(dir), 0);
                    color
                        .copy(groundColor)
                        .lerp(bottomColor, Math.min(t * 100, 1))
                        .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                        .multiplyScalar(255);
                }
                else {
                    const t = i / this.m_height;
                    if (i === 0) {
                        color.copy(groundColor).multiplyScalar(255);
                    }
                    else {
                        color
                            .copy(bottomColor)
                            .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                            .multiplyScalar(255);
                    }
                }
                data[i * this.m_width * 3 + j * 3] = color.r;
                data[i * this.m_width * 3 + j * 3 + 1] = color.g;
                data[i * this.m_width * 3 + j * 3 + 2] = color.b;
            }
        }
    }
    setHorizonPosition(camera) {
        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])
            .add(this.m_farClipPlaneCorners[1])
            .multiplyScalar(0.5);
        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])
            .add(this.m_farClipPlaneCorners[3])
            .multiplyScalar(0.5);
        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
        // When there is no intersection between the ground plane and the
        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous
        // intersection point stored in the m_horizonPosition will be considered the valid one.
        if (!hasIntersection) {
            this.m_horizonPosition.set(0.0, 0.0, 0.0);
        }
    }
    updateTexturePosition() {
        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
        const skyRatio = coveredBySky / frustumHeight;
        // If there is no intersection between the ground plane and the line that defines the far
        // clip plane divided vertically, it means that there is no sky visible and therefore the
        // ground color should be displayed. When there is no intersection, the length of the
        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with
        // all the three components to zero.
        // If there is an intersection, calculate the offset.
        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
        // If the bottom part of the far clipping plane is under the ground plane, scroll the
        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture
        // up.
        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
    }
}
exports.SkyGradientTexture = SkyGradientTexture;
//# sourceMappingURL=SkyGradientTexture.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Statistics.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Statistics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceStatistics = exports.FrameStatsArray = exports.FrameStats = exports.Statistics = exports.MultiStageTimer = exports.computeArrayAverage = exports.computeArrayStats = exports.SampledTimer = exports.SimpleTimer = exports.RingBuffer = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const logger = harp_utils_1.LoggerManager.instance.create("Statistics");
/**
 * A simple ring buffer to store the last `n` values of the timer. The buffer works on
 * a First-In-First-Out (FIFO) basis.
 */
class RingBuffer {
    /**
     * Sets up the ring buffer.
     *
     * @param capacity - The buffer's capacity.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    /**
     * Clears the contents, removes all elements.
     */
    clear() {
        this.head = this.tail = this.size = 0;
    }
    /**
     * Adds a single element to the ring buffer.
     *
     * @param data - Data element.
     */
    enqOne(data) {
        let next = this.head + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size < this.capacity) {
            this.size++;
        }
        this.buffer[this.head] = data;
        this.head = next;
        if (this.size === this.capacity) {
            this.tail = this.head;
        }
    }
    /**
     * Adds one or more elements.
     *
     * @param data - The elements to add.
     */
    enq(...data) {
        for (const v of data) {
            this.enqOne(v);
        }
    }
    /**
     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.
     * Before calling this method, make sure that `size > 0`.
     */
    deq() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        const data = this.buffer[this.tail];
        let next = this.tail + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size > 0) {
            this.size--;
        }
        this.tail = next;
        return data;
    }
    /**
     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get top() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        return this.buffer[this.tail];
    }
    /**
     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get bottom() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        let previous = this.head - 1;
        if (previous < 0) {
            previous = this.capacity - 1;
        }
        return this.buffer[previous];
    }
    /**
     * Creates an iterator for the buffer.
     */
    iterator() {
        return new RingBuffer.Iterator(this);
    }
    /**
     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.
     */
    asArray() {
        const array = new Array();
        for (let i = 0; i < this.size; i++) {
            array.push(this.buffer[(this.tail + i) % this.capacity]);
        }
        return array;
    }
}
exports.RingBuffer = RingBuffer;
(function (RingBuffer) {
    /**
     * A local class for RingBuffer<T>
     */
    class Iterator {
        /**
         * Creates an iterator for the ring buffer.
         *
         * @param m_buffer - `Ringbuffer` to iterate over.
         * @param m_index - Start index.
         */
        constructor(m_buffer, m_index = 0) {
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        /**
         * Gets the iterator's current value. This function does not fail even if an overrun occurs.
         * To detect an overrun, watch the result for [[next]].
         */
        get value() {
            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
        }
        /**
         * Advances the iterator to the next element.
         *
         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.
         */
        next() {
            this.m_index++;
            return this.m_index < this.m_buffer.size;
        }
    }
    RingBuffer.Iterator = Iterator;
})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));
/**
 * A simple timer that stores only the latest measurement.
 */
class SimpleTimer {
    constructor(statistics, name) {
        this.statistics = statistics;
        this.name = name;
        /** `true` if timer has been started. */
        this.running = false;
    }
    /**
     * Gets the latest measurement. This function may return `undefined` if no measurement
     * was done.
     */
    get value() {
        return this.m_currentValue;
    }
    /**
     * Sets the measurement value for the amount of time that has elapsed from start() to stop().
     * Use this function to override the timer's duration.
     *
     * @param val - The timer's duration.
     */
    setValue(val) {
        this.m_currentValue = val;
    }
    /**
     * Resets the value to be able to start again.
     */
    reset() {
        this.m_currentValue = undefined;
    }
    /**
     * Starts the timer. Returns the current time, based on `Performance.now()`.
     */
    start() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (this.running) {
            throw new Error("Timer '" + this.name + "' is already running");
        }
        this.running = true;
        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Stops the timer. Requires that the timer has started.
     */
    stop() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            // this.currentValue is a number now!
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            this.m_currentValue = t;
            this.setValue(t);
            this.running = false;
            return t;
        }
    }
    /**
     * Samples the timer. Requires that the timer has started.
     *
     * @returns the current timer value; `-1` if statistics are disabled.
     */
    now() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);
            return t;
        }
    }
}
exports.SimpleTimer = SimpleTimer;
/**
 * A timer that stores the last `n` samples in a ring buffer.
 */
class SampledTimer extends SimpleTimer {
    /**
     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!
     *
     * @param statistics - Statistics to use for management.
     * @param name - Name of the timer. Use colons to build a hierarchy.
     */
    constructor(statistics, name) {
        super(statistics, name);
        this.statistics = statistics;
        this.name = name;
        /**
         * The number of times the timer has reset.
         */
        this.numResets = 0;
        /**
         * Maximum samples until the statistics are reset and updated, which may destroy a median
         * computation.
         */
        this.maxNumSamples = 1000;
        /**
         * The array of sampled values, its length cannot exceed `maxNumSamples`.
         */
        this.samples = new RingBuffer(this.maxNumSamples);
    }
    /**
     * Resets the timer and clears all of its historical values.
     * @override
     */
    reset() {
        super.reset();
        this.getStats();
        this.samples.clear();
        this.numResets++;
    }
    /**
     * Add a single measurement to the sample.
     *
     * @param val - A measurement to add.
     * @override
     */
    setValue(val) {
        super.setValue(val);
        if (val !== undefined) {
            this.samples.enqOne(val);
        }
    }
    /**
     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,
     * as it requires a copy of the sampled values.
     */
    getStats() {
        return computeArrayStats(this.samples.asArray());
    }
}
exports.SampledTimer = SampledTimer;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the [[ArrayStats]] for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the
 *      entries.
 * @returns {(Stats | undefined)}
 */
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    samples.sort((a, b) => {
        return a - b;
    });
    const min = samples[0];
    const max = samples[samples.length - 1];
    let median;
    let median75;
    let median90;
    let median95;
    let median97;
    let median99;
    let median999;
    if (samples.length === 1) {
        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];
    }
    else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];
    }
    else {
        const mid = Math.floor(samples.length / 2);
        median =
            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        const mid75 = Math.round(samples.length * 0.75) - 1;
        median75 = samples[mid75];
        const mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        const mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        const mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        const mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        const mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return {
        min,
        max,
        avg,
        median,
        median75,
        median90,
        median95,
        median97,
        median99,
        median999,
        numSamples: samples.length
    };
}
exports.computeArrayStats = computeArrayStats;
/**
 * Only exported for testing
 * @ignore
 *
 * Compute the averages for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values.
 * @returns {(Stats | undefined)}
 */
function computeArrayAverage(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return avg;
}
exports.computeArrayAverage = computeArrayAverage;
/**
 * Measures a sequence of connected events, such as multiple processing stages in a function.
 * Each stage is identified with a timer name, that must be a valid timer in the statistics
 * object. Additionally, all timers within a `MultiStageTimer` must be unique.
 *
 * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,
 * one timer stops and the next timer starts.
 */
class MultiStageTimer {
    /**
     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.
     *
     * @param statistics - The statistics object that manages the timers.
     * @param name - Name of this `MultiStageTimer`.
     * @param stages - List of timer names.
     */
    constructor(statistics, name, stages) {
        this.statistics = statistics;
        this.name = name;
        this.stages = stages;
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(stage => {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    /**
     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its
     * last stage, the value is `undefined`.
     */
    get value() {
        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
    }
    /**
     * Resets the timers across all stages.
     */
    reset() {
        if (!this.statistics.enabled) {
            return;
        }
        this.stages.forEach(stage => {
            this.statistics.getTimer(stage).reset();
        });
    }
    /**
     * Starts the `MultiStageTimer` at its first stage.
     */
    start() {
        this.stage = this.stages[0];
        return this.statistics.getTimer(this.stages[0]).value || -1;
    }
    /**
     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be
     * `undefined` if not all stages started.
     */
    stop() {
        this.stage = undefined;
        return this.value !== undefined ? this.value : -1;
    }
    /**
     * Gets the current stage.
     */
    get stage() {
        return this.currentStage;
    }
    /**
     * Sets the current stage. If a new stage is provided, the current timer (if available) is
     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,
     * this is equivalent to calling `stop` on the `MultiStageTimer`.
     *
     * @param stage - The next stage to start.
     */
    set stage(stage) {
        if (this.currentStage === stage) {
            return;
        }
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).stop();
        }
        this.currentStage = stage;
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).start();
        }
    }
}
exports.MultiStageTimer = MultiStageTimer;
/**
 * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can
 * disable statistics to minimize their impact on performance.
 */
class Statistics {
    /**
     * Sets up a group of timers.
     *
     * @param name - The statistics name, for logging purposes.
     * @param enabled - If `false`, the timers do not measure the performance.
     */
    constructor(name, enabled = false) {
        this.name = name;
        this.enabled = enabled;
        this.timers = new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    /**
     * Adds a timer, based on the name specified.
     *
     * @param name - The timer's name; must be unique.
     */
    createTimer(name, keepSamples = true) {
        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);
        return this.addTimer(timer);
    }
    /**
     * Adds the timer specified.
     *
     * @param timer - The timer's name, which must be unique within this statistics object.
     */
    addTimer(timer) {
        if (this.timers.get(timer.name) !== undefined) {
            throw new Error("Duplicate timer name: '" + timer.name + "'");
        }
        this.timers.set(timer.name, timer);
        return timer;
    }
    /**
     * Gets a timer by name.
     *
     * @param name - The timer's name.
     */
    getTimer(name) {
        if (!this.enabled) {
            return this.nullTimer;
        }
        const t = this.timers.get(name);
        return t === undefined ? this.nullTimer : t;
    }
    /**
     * Checks if a timer with the specified name already exists.
     *
     * @param name - The timer's name.
     * @returns `true` if a timer with `name` already exists; `false` otherwise.
     */
    hasTimer(name) {
        const t = this.timers.get(name);
        return t !== undefined;
    }
    /**
     * Resets all timers.
     */
    reset() {
        this.timers.forEach((timer) => {
            timer.reset();
        });
    }
    /**
     * Prints all values to the console.
     *
     * @param header - Optional header line.
     * @param footer - Optional footer line.
     */
    log(header, footer) {
        if (header !== undefined || this.name !== undefined) {
            logger.log(header !== undefined ? header : this.name);
        }
        let maxNameLength = 0;
        this.timers.forEach((timer) => {
            maxNameLength = Math.max(maxNameLength, timer.name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.timers.forEach((timer) => {
            let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
            s += print(timer.value);
            // sampled timers also update their stats and log them
            if (timer instanceof SampledTimer) {
                const simpleStats = timer.getStats();
                if (simpleStats !== undefined) {
                    s +=
                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                            `N=${print(simpleStats.numSamples)} ]`;
                }
            }
            logger.log(s);
        });
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
}
exports.Statistics = Statistics;
/**
 * Class containing all counters, timers and events of the current frame.
 */
class FrameStats {
    constructor() {
        this.entries = new Map();
        this.messages = undefined;
    }
    /**
     * Retrieve the value of the performance number.
     *
     * @param name - Name of the performance number.
     * @returns The value of the performance number or `undefined` if it has not been declared by
     *      `setValue` before.
     */
    getValue(name) {
        return this.entries.get(name);
    }
    /**
     * Set the value of the performance number.
     *
     * @param name - Name of the performance number.
     * @param name - New value of the performance number.
     */
    setValue(name, value) {
        this.entries.set(name, value);
    }
    /**
     * Add a value to the current value of the performance number. If the performance is not known,
     * it will be initialized with `value`.
     *
     * @param name - Name of the performance number.
     * @param name - Value to be added to the performance number.
     */
    addValue(name, value) {
        const oldValue = this.entries.get(name);
        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));
    }
    /**
     * Add a text message to the frame, like "Font XYZ has been loaded"
     *
     * @param message - The message to add.
     */
    addMessage(message) {
        if (this.messages === undefined) {
            this.messages = [];
        }
        this.messages.push(message);
    }
    /**
     * Reset all known performance values to `0` and the messages to `undefined`.
     */
    reset() {
        this.entries.forEach((value, name) => {
            this.entries.set(name, 0);
        });
        this.messages = undefined;
    }
}
exports.FrameStats = FrameStats;
/**
 * @ignore
 * Only exported for testing.
 *
 * Instead of passing around an array of objects, we store the frame statistics as an object of
 * arrays. This allows convenient computations from {@link RingBuffer},
 */
class FrameStatsArray {
    constructor(capacity = 0) {
        this.capacity = capacity;
        this.frameEntries = new Map();
        this.messages = new RingBuffer(capacity);
    }
    get length() {
        return this.messages.size;
    }
    reset() {
        this.frameEntries.forEach((buffer, name) => {
            buffer.clear();
        });
        this.messages.clear();
    }
    addFrame(frameStats) {
        const currentSize = this.length;
        const frameEntries = this.frameEntries;
        frameStats.entries.forEach((value, name) => {
            let buffer = frameEntries.get(name);
            if (buffer === undefined) {
                // If there is a buffer that has not been known before, add it to the known buffers,
                // fill it up with with 0 to the size of all the other buffers to make them of equal
                // size to make PerfViz happy.
                buffer = new RingBuffer(this.capacity);
                for (let i = 0; i < currentSize; i++) {
                    buffer.enqOne(0);
                }
                this.frameEntries.set(name, buffer);
            }
            buffer.enqOne(value);
        });
        this.messages.enq(frameStats.messages);
    }
    /**
     * Prints all values to the console.
     */
    log() {
        let maxNameLength = 0;
        this.frameEntries.forEach((buffer, name) => {
            maxNameLength = Math.max(maxNameLength, name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.frameEntries.forEach((buffer, name) => {
            let s = name + ": " + " ".repeat(maxNameLength - name.length);
            const simpleStats = computeArrayStats(buffer.asArray());
            if (simpleStats !== undefined) {
                s +=
                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                        `N=${print(simpleStats.numSamples)} ]`;
            }
            logger.log(s);
        });
    }
}
exports.FrameStatsArray = FrameStatsArray;
/**
 * Performance measurement central. Maintains the current
 * {@link FrameStats}, which holds all individual
 * performance numbers.
 *
 * Implemented as an instance for easy access.
 */
let PerformanceStatistics = /** @class */ (() => {
    class PerformanceStatistics {
        /**
         * Creates an instance of PerformanceStatistics. Overrides the current `instance`.
         *
         * @param {boolean} [enabled=true] If `false` the performance values will not be stored.
         * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.
         * @memberof PerformanceStatistics
         */
        constructor(enabled = true, maxNumFrames = 1000) {
            this.enabled = enabled;
            this.maxNumFrames = maxNumFrames;
            /**
             * Current frame statistics. Contains all values for the current frame. Will be cleared when
             * [[PerformanceStatistics#storeFrameInfo]] is called.
             *
             * @type {FrameStats}
             * @memberof PerformanceStatistics
             */
            this.currentFrame = new FrameStats();
            /**
             * Additional results stored for the current application run, not per frame. Only the last value
             * is stored.
             *
             * @type {(Map<string, number>)}
             */
            this.appResults = new Map();
            /**
             * Additional configuration values stored for the current application run, not per frame. Only
             * the last value is stored.
             *
             * @type {(Map<string, string>)}
             * @memberof PerformanceStatistics
             */
            this.configs = new Map();
            PerformanceStatistics.m_instance = this;
            this.m_frameEvents = new FrameStatsArray(maxNumFrames);
        }
        /**
         * Returns `true` when the maximum number of storable frames is reached.
         *
         * @readonly
         * @type {boolean}
         * @memberof PerformanceStatistics
         */
        get isFull() {
            return this.m_frameEvents.length >= this.maxNumFrames;
        }
        /**
         * Global instance to the instance. The current instance can be overridden by creating a new
         * `PerformanceStatistics`.
         */
        static get instance() {
            if (PerformanceStatistics.m_instance === undefined) {
                PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);
            }
            return PerformanceStatistics.m_instance;
        }
        /**
         * @ignore
         * Only exported for testing.
         *
         * Return the array of frame events.
         */
        get frameEvents() {
            return this.m_frameEvents;
        }
        /**
         * Clears all settings, all stored frame events as well as the current frame values.
         *
         * @memberof PerformanceStatistics
         */
        clear() {
            this.clearFrames();
            this.configs.clear();
            this.appResults.clear();
        }
        /**
         * Clears only all stored frame events as well as the current frame values.
         *
         * @memberof PerformanceStatistics
         */
        clearFrames() {
            this.m_frameEvents.reset();
            this.currentFrame.reset();
        }
        /**
         * Add the render state information from [[THREE.WebGLInfo]] to the current frame.
         * @param {THREE.WebGLInfo} webGlInfo
         */
        addWebGLInfo(webGlInfo) {
            if (webGlInfo.render !== undefined) {
                this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
                this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
                this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
                this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
            }
            if (webGlInfo.memory !== undefined) {
                this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
                this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
            }
            if (webGlInfo.programs !== undefined) {
                this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
            }
        }
        /**
         * Add memory statistics to the current frame if available.
         * @note Currently only supported on Chrome
         */
        addMemoryInfo() {
            if (window !== undefined && window.performance !== undefined) {
                const memory = window.performance.memory;
                if (memory !== undefined) {
                    this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                    this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                    this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
                }
            }
        }
        /**
         * Stores the current frame events into the array of events and clears all values.
         *
         * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.
         * @memberof PerformanceStatistics
         */
        storeAndClearFrameInfo() {
            if (this.m_frameEvents.length >= this.maxNumFrames) {
                return false;
            }
            this.m_frameEvents.addFrame(this.currentFrame);
            this.currentFrame.reset();
            return true;
        }
        /**
         * Logs all values to the logger.
         *
         * @param header - Optional header line.
         * @param footer - Optional footer line.
         */
        log(header, footer) {
            logger.log(header !== undefined ? header : "PerformanceStatistics");
            const appResults = this.appResults;
            appResults.forEach((value, name) => {
                logger.log(name, value);
            });
            const configs = this.configs;
            configs.forEach((value, name) => {
                logger.log(name, value);
            });
            this.m_frameEvents.log();
            if (footer !== undefined) {
                logger.log(footer);
            }
        }
        /**
         * Convert to a plain object that can be serialized. Required to copy the test results over to
         * nightwatch.
         */
        getAsPlainObject(onlyLastFrame = false) {
            const appResults = {};
            const configs = {};
            const frames = {};
            const plainObject = {
                configs,
                appResults,
                frames
            };
            const appResultValues = this.appResults;
            appResultValues.forEach((value, name) => {
                appResults[name] = value;
            });
            const configValues = this.configs;
            configValues.forEach((value, name) => {
                configs[name] = value;
            });
            if (onlyLastFrame) {
                for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                    frames[name] = buffer.bottom;
                }
            }
            else {
                for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                    frames[name] = buffer.asArray();
                }
            }
            plainObject.messages = this.m_frameEvents.messages.asArray();
            return plainObject;
        }
        /**
         * Convert the last frame values to a plain object that can be serialized. Required to copy the
         * test results over to nightwatch.
         */
        getLastFrameStatistics() {
            return this.getAsPlainObject(true);
        }
        /**
         * Convert to a plain object that can be serialized. Required to copy the test results over to
         * nightwatch.
         */
        getAsSimpleFrameStatistics(onlyLastFrame = false) {
            const configs = new Map();
            const appResults = new Map();
            const frames = new Map();
            const simpleStatistics = {
                configs,
                appResults,
                frames,
                messages: this.m_frameEvents.messages.asArray()
            };
            const appResultValues = this.appResults;
            appResultValues.forEach((value, name) => {
                appResults.set(name, value);
            });
            const configValues = this.configs;
            configValues.forEach((value, name) => {
                configs.set(name, value);
            });
            if (onlyLastFrame) {
                for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                    frames.set(name, buffer.bottom);
                }
            }
            else {
                for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                    frames.set(name, buffer.asArray());
                }
            }
            return simpleStatistics;
        }
    }
    PerformanceStatistics.m_instance = undefined;
    return PerformanceStatistics;
})();
exports.PerformanceStatistics = PerformanceStatistics;
//# sourceMappingURL=Statistics.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/TextureLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/TextureLoader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureLoader = void 0;
/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * A texture loader that supports request headers(e.g. for Authorization)
 */
class TextureLoader {
    constructor() {
        this.m_textureLoader = new THREE.TextureLoader();
    }
    /**
     * Load an image from url and create a texture
     * @param url - URL to the image
     * @param requestHeaders - Optional request headers to load image(e.g. Authorization)
     * @param crossOrigin - Enable/disable CORS
     */
    async load(url, requestHeaders, crossOrigin = true) {
        // Use THREE.js texture loader directly if no request header is set
        if (requestHeaders === undefined) {
            return this.loadWithThreeLoader(url);
        }
        // Load image with fetch API if request header is set
        const response = await fetch(url, {
            headers: requestHeaders,
            mode: crossOrigin ? "cors" : "no-cors"
        });
        const blob = await response.blob();
        // Load image from blob using THREE.js loader
        const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));
        // Set correct image format from original URL or blob mime type
        // (object URL does not contain file format)
        const isJPEG = blob.type === "image/jpeg/" ||
            url.search(/\.jpe?g($|\?)/i) > 0 ||
            url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
        return texture;
    }
    loadWithThreeLoader(url) {
        return new Promise((resolve, reject) => {
            this.m_textureLoader.setCrossOrigin("");
            this.m_textureLoader.load(url, texture => resolve(texture), undefined, () => reject(new Error("failed to load texture")));
        });
    }
}
exports.TextureLoader = TextureLoader;
//# sourceMappingURL=TextureLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeHelpers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLight = exports.toTextureFilter = exports.toWrappingMode = exports.toTextureDataType = exports.toPixelFormat = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.
 */
function toPixelFormat(format) {
    switch (format) {
        case "Alpha":
            return THREE.AlphaFormat;
        case "RGB":
            return THREE.RGBFormat;
        case "RGBA":
            return THREE.RGBAFormat;
        case "Luminance":
            return THREE.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE.LuminanceAlphaFormat;
        case "RGBE":
            return THREE.RGBEFormat;
        case "Depth":
            return THREE.DepthFormat;
        case "DepthStencil":
            return THREE.DepthStencilFormat;
        case "Red":
            return THREE.RedFormat;
        default:
            throw new Error(`invalid pixel format: ${format}`);
    }
}
exports.toPixelFormat = toPixelFormat;
/**
 * Returns `three.js` texture data types based on a [[TextureDataType]] specified.
 */
function toTextureDataType(dataType) {
    switch (dataType) {
        case "UnsignedByte":
            return THREE.UnsignedByteType;
        case "Byte":
            return THREE.ByteType;
        case "Short":
            return THREE.ShortType;
        case "UnsignedShort":
            return THREE.UnsignedShortType;
        case "Int":
            return THREE.IntType;
        case "UnsignedInt":
            return THREE.UnsignedIntType;
        case "Float":
            return THREE.FloatType;
        case "HalfFloat":
            return THREE.HalfFloatType;
        default:
            throw new Error(`invalid texture data type: ${dataType}`);
    }
}
exports.toTextureDataType = toTextureDataType;
/**
 * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.
 */
function toWrappingMode(mode) {
    switch (mode) {
        case "clamp":
            return THREE.ClampToEdgeWrapping;
        case "repeat":
            return THREE.RepeatWrapping;
        case "mirror":
            return THREE.MirroredRepeatWrapping;
        default:
            throw new Error(`invalid wrapping mode: ${mode}`);
    }
}
exports.toWrappingMode = toWrappingMode;
/**
 * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.
 */
function toTextureFilter(filter) {
    switch (filter) {
        case "nearest":
            return THREE.NearestFilter;
        case "nearestMipMapNearest":
            return THREE.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE.NearestMipMapLinearFilter;
        case "linear":
            return THREE.LinearFilter;
        case "linearMipMapNearest":
            return THREE.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE.LinearMipMapLinearFilter;
        default:
            throw new Error(`invalid texture filter: ${filter}`);
    }
}
exports.toTextureFilter = toTextureFilter;
/**
 * Create a specific light for lighting the map.
 */
function createLight(lightDescription) {
    switch (lightDescription.type) {
        case "ambient": {
            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            return light;
        }
        case "directional": {
            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            if (lightDescription.castShadow !== undefined) {
                light.castShadow = lightDescription.castShadow;
            }
            if (light.castShadow) {
                light.shadow.bias = 0.00001;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
            }
            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
            light.position.normalize();
            return light;
        }
    }
}
exports.createLight = createLight;
//# sourceMappingURL=ThemeHelpers.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeLoader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeLoader = exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js");
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
/**
 * Loads and validates a theme from URL objects.
 */
class ThemeLoader {
    /**
     * Loads a {@link @here/harp-datasource-protocol#Theme} from a
     * remote resource, provided as a URL that points to a
     * JSON-encoded theme.
     *
     * By default, resolves following features of theme:
     *
     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])
     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section
     *     of theme (see [[resolveThemeReferences]])
     *
     * Relative URIs of reference resources are resolved to full URL using the document's base URL
     * (see [[resolveUrls]]).
     *
     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by
     * providing {@link @here/harp-utils#UriResolver} using {@link ThemeLoadOptions.uriResolver}
     * option.
     *
     * @param theme - {@link @here/harp-datasource-protocol#Theme} instance or theme URL
     *                to the theme.
     * @param options - Optional, a {@link ThemeLoadOptions} objects
     *                  containing any custom settings for
     *                  this load request.
     */
    static async load(theme, options) {
        options = options || {};
        if (typeof theme === "string") {
            const uriResolver = options.uriResolver;
            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;
            const response = await fetch(themeUrl, { signal: options.signal });
            if (!response.ok) {
                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);
            }
            theme = (await response.json());
            theme.url = harp_utils_1.resolveReferenceUri(harp_utils_1.getAppBaseUrl(), themeUrl);
            theme = this.resolveUrls(theme, options);
        }
        else if (theme.url === undefined) {
            // assume that theme url is same as baseUrl
            theme.url = harp_utils_1.getAppBaseUrl();
            theme = this.resolveUrls(theme, options);
        }
        else {
            theme = this.convertFlatTheme(theme);
        }
        if (theme === null || theme === undefined) {
            throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
        }
        ThemeLoader.checkTechniqueSupport(theme);
        const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, false);
        theme = await ThemeLoader.resolveBaseThemes(theme, options);
        if (resolveDefinitions) {
            const contextLoader = new harp_utils_1.ContextLogger(options.logger || console, `when processing Theme ${theme.url}:`);
            ThemeLoader.resolveThemeReferences(theme, contextLoader);
        }
        return theme;
    }
    /**
     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.
     *
     * @param theme -
     */
    static isThemeLoaded(theme) {
        return theme.extends === undefined;
    }
    /**
     * @deprecated Please use `ThemeLoader.load`
     *
     * Loads a {@link @here/harp-datasource-protocol#Theme} from a remote resource,
     * provided as a URL that points to a JSON-encoded
     * theme.
     *
     * @param themeUrl - The URL to the theme.
     *
     */
    static async loadAsync(themeUrl) {
        return ThemeLoader.load(themeUrl);
    }
    /**
     * Resolves all {@link @here/harp-datasource-protocol#Theme}'s relatives URLs
     * to full URL using the {@link @here/harp-datasource-protocol#Theme}'s URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * This method mutates original `theme` instance.
     *
     * @param theme - The {@link @here/harp-datasource-protocol#Theme} to resolve.
     */
    static resolveUrls(theme, options) {
        // Ensure that all resources referenced in theme by relative URIs are in fact relative to
        // theme.
        theme = ThemeLoader.convertFlatTheme(theme);
        if (theme.url === undefined) {
            return theme;
        }
        const childUrlResolver = harp_utils_1.composeUriResolvers(options === null || options === void 0 ? void 0 : options.uriResolver, new harp_utils_1.RelativeUriResolver(theme.url));
        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);
        if (theme.extends && resolveIncludes) {
            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(baseTheme => {
                if (typeof baseTheme === "string") {
                    return childUrlResolver.resolveUri(baseTheme);
                }
                else {
                    if (baseTheme.url !== undefined) {
                        return baseTheme;
                    }
                    else {
                        baseTheme.url = theme.url;
                        return this.resolveUrls(baseTheme, options);
                    }
                }
            });
        }
        if (!ThemeLoader.convertFlatTheme(theme)) {
            return theme;
        }
        const resolveResources = options === undefined || !(options.resolveResourceUris === false);
        if (resolveResources) {
            ThemeLoader.resolveResources(theme, childUrlResolver);
        }
        return theme;
    }
    static checkTechniqueSupport(theme) {
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                for (const style of theme.styles[styleSetName]) {
                    switch (style.technique) {
                        // TODO: Re-enable this once "dashed-line" is deprecated.
                        /* case "dashed-line":
                            console.warn(
                                `Using deprecated "dashed-line" technique.
                                Use "solid-line" technique instead`
                            ); */
                        default:
                            break;
                    }
                }
            }
        }
    }
    /**
     * Expand all `ref` expressions in {@link @here/harp-datasource-protocol#Theme}
     * basing on `definitions`.
     *
     * @remarks
     * This method mutates original `theme` instance.
     */
    static resolveThemeReferences(theme, contextLogger) {
        if (theme.definitions !== undefined) {
            contextLogger.pushAttr("definitions");
            /**
             * First, try to resolve all internal references in definitions, so if we may save few
             * CPU cycles if some definition is used many times in actual style sets.
             */
            for (const definitionName in theme.definitions) {
                if (!theme.definitions.hasOwnProperty(definitionName)) {
                    continue;
                }
                const def = theme.definitions[definitionName];
                if (Theme_1.isActualSelectorDefinition(def)) {
                    contextLogger.pushAttr(definitionName);
                    const resolvedDef = ThemeLoader.resolveStyle(def, theme.definitions, contextLogger);
                    contextLogger.pop();
                    if (resolvedDef === undefined) {
                        contextLogger.pushAttr(definitionName);
                        contextLogger.warn("skipping invalid style in definition");
                        contextLogger.pop();
                        delete theme.definitions[definitionName];
                    }
                    else {
                        theme.definitions[definitionName] = resolvedDef;
                    }
                }
            }
            contextLogger.pop();
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                contextLogger.pushAttr("styles");
                contextLogger.pushAttr(styleSetName);
                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(theme.styles[styleSetName], theme.definitions, contextLogger);
                contextLogger.pop();
                contextLogger.pop();
            }
        }
        return theme;
    }
    /**
     * Expand all `ref` in [[StyleSet]] basing on `definitions`.
     */
    static resolveStyleSet(styleSet, definitions, contextLogger) {
        const result = [];
        for (let index = 0; index < styleSet.length; ++index) {
            const currentStyle = styleSet[index];
            contextLogger.pushIndex(index);
            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
            if (resolvedStyle !== undefined) {
                result.push(resolvedStyle);
            }
            else {
                contextLogger.warn("invalid style, ignored");
            }
            contextLogger.pop();
        }
        return result;
    }
    /**
     * Expand all `ref` in [[Style]] instance basing on `definitions`.
     */
    static resolveStyle(style, definitions, contextLogger) {
        if (Theme_1.isJsonExprReference(style)) {
            // expand and instantiate references to style definitions.
            const def = definitions && definitions[style[1]];
            if (!def) {
                contextLogger.warn(`invalid reference '${style[1]}' - not found`);
                return undefined;
            }
            if (!Theme_1.isActualSelectorDefinition(def)) {
                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);
                return undefined;
            }
            // instantiate the style
            style = harp_utils_1.cloneDeep(def);
        }
        style = style;
        if (Array.isArray(style.when)) {
            contextLogger.pushAttr("when");
            const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);
            contextLogger.pop();
            if (resolvedWhen === undefined) {
                return undefined;
            }
            style.when = resolvedWhen;
        }
        if (style.attr !== undefined) {
            const attr = style.attr;
            contextLogger.pushAttr("attr");
            for (const prop in attr) {
                if (!attr.hasOwnProperty(prop)) {
                    continue;
                }
                const value = attr[prop];
                if (!Array.isArray(value)) {
                    continue; // nothing to do
                }
                contextLogger.pushAttr(prop);
                const resolvedValue = this.resolveExpressionReferences(value, definitions, contextLogger);
                contextLogger.pop();
                if (resolvedValue !== undefined) {
                    attr[prop] = resolvedValue;
                }
                else {
                    delete attr[prop];
                }
            }
            contextLogger.pop();
        }
        return style;
    }
    /**
     * Resolve `[ref, ...]` in expressions.
     *
     * Returns `undefined` some reference was invalid (missing or wrong type).
     */
    static resolveExpressionReferences(value, definitions, contextLogger) {
        let failed = false;
        function resolveInternal(node) {
            if (Theme_1.isJsonExprReference(node)) {
                const defName = node[1];
                const def = definitions && definitions[defName];
                if (def === undefined) {
                    contextLogger.warn(`invalid reference '${defName}' - not found`);
                    failed = true;
                    return undefined;
                }
                if (Theme_1.isLiteralDefinition(def) || harp_datasource_protocol_1.isJsonExpr(def)) {
                    return def;
                }
                if (Theme_1.isBoxedDefinition(def)) {
                    return def.value;
                }
                contextLogger.warn(`invalid reference '${defName}' - expected value definition`);
                failed = true;
                return undefined;
            }
            else if (Array.isArray(node)) {
                const result = [...node];
                for (let i = 1; i < result.length; ++i) {
                    result[i] = resolveInternal(result[i]);
                }
                return result;
            }
            else {
                return node;
            }
        }
        const r = resolveInternal(value);
        if (failed) {
            return undefined;
        }
        return r;
    }
    /**
     * Realize `extends` clause by merging `theme` with
     * its base {@link @here/harp-datasource-protocol#Theme}.
     *
     * @param theme - {@link @here/harp-datasource-protocol#Theme} object
     * @param options - Optional, a {@link ThemeLoadOptions} objects
     *                  containing any custom settings for
     *                  this load request.
     */
    static async resolveBaseThemes(theme, options) {
        options = options || {};
        if (theme.extends === undefined) {
            return theme;
        }
        const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
        if (maxInheritanceDepth <= 0) {
            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);
        }
        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;
        delete theme.extends;
        let baseThemesMerged = {};
        for (const baseTheme of baseThemes) {
            const actualBaseTheme = await ThemeLoader.load(baseTheme, Object.assign(Object.assign({}, options), { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));
            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);
        }
        return ThemeLoader.mergeThemes(theme, baseThemesMerged);
    }
    static mergeThemes(theme, baseTheme) {
        const definitions = Object.assign(Object.assign({}, baseTheme.definitions), theme.definitions);
        let styles;
        if (baseTheme.styles && theme.styles) {
            const currentStyleSets = Object.keys(baseTheme.styles);
            const incomingStyleSets = Object.keys(theme.styles);
            styles = {};
            currentStyleSets.forEach(styleSetName => {
                const index = incomingStyleSets.indexOf(styleSetName);
                if (index !== -1) {
                    // merge the current and incoming styleset
                    // and add the result to `styles`.
                    styles[styleSetName] = [
                        ...baseTheme.styles[styleSetName],
                        ...theme.styles[styleSetName]
                    ];
                    // remove the styleset from the incoming list
                    incomingStyleSets.splice(index, 1);
                }
                else {
                    // copy the existing style set to `styles`.
                    styles[styleSetName] = baseTheme.styles[styleSetName];
                }
            });
            // add the remaining stylesets to styles.
            incomingStyleSets.forEach(p => {
                styles[p] = theme.styles[p];
            });
        }
        else if (baseTheme.styles) {
            styles = Object.assign({}, baseTheme.styles);
        }
        else if (theme.styles) {
            styles = Object.assign({}, theme.styles);
        }
        return Object.assign(Object.assign(Object.assign({}, baseTheme), theme), { definitions, styles });
    }
    static convertFlatTheme(theme) {
        if (Array.isArray(theme.styles)) {
            // Convert the flat theme to a standard theme.
            const styles = {};
            theme.styles.forEach(style => {
                if (harp_datasource_protocol_1.isJsonExpr(style)) {
                    throw new Error("invalid usage of theme reference");
                }
                const styleSetName = style.styleSet;
                if (styleSetName === undefined) {
                    throw new Error("missing reference to style set");
                }
                if (!styles[styleSetName]) {
                    styles[styleSetName] = [];
                }
                styles[styleSetName].push(style);
            });
            theme.styles = styles;
        }
        return theme;
    }
    static resolveResources(theme, childUrlResolver) {
        if (theme.sky && theme.sky.type === "cubemap") {
            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {
                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];
                if (faceUrl !== undefined) {
                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);
                }
            }
        }
        if (theme.images) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                image.url = childUrlResolver.resolveUri(image.url);
                if (image.atlas !== undefined) {
                    image.atlas = childUrlResolver.resolveUri(image.atlas);
                }
            }
        }
        if (theme.fontCatalogs) {
            for (const font of theme.fontCatalogs) {
                font.url = childUrlResolver.resolveUri(font.url);
            }
        }
        if (theme.poiTables) {
            for (const poiTable of theme.poiTables) {
                poiTable.url = childUrlResolver.resolveUri(poiTable.url);
            }
        }
        if (theme.styles !== undefined) {
            for (const styleSetName in theme.styles) {
                if (!theme.styles.hasOwnProperty(styleSetName)) {
                    continue;
                }
                const styleSet = theme.styles[styleSetName];
                for (const style of styleSet) {
                    if (!style.attr) {
                        continue;
                    }
                    ["map", "normalMap", "displacementMap", "roughnessMap"].forEach(texturePropertyName => {
                        const textureProperty = style.attr[texturePropertyName];
                        if (textureProperty && typeof textureProperty === "string") {
                            style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);
                        }
                    });
                }
            }
        }
    }
}
exports.ThemeLoader = ThemeLoader;
//# sourceMappingURL=ThemeLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Tile.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Tile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tile = exports.TileLoaderState = exports.getFeatureDataSize = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const LodMesh_1 = __webpack_require__(/*! ./geometry/LodMesh */ "./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const TextElement_1 = __webpack_require__(/*! ./text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementGroup_1 = __webpack_require__(/*! ./text/TextElementGroup */ "./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js");
const TextElementGroupPriorityList_1 = __webpack_require__(/*! ./text/TextElementGroupPriorityList */ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js");
const TileTextStyleCache_1 = __webpack_require__(/*! ./text/TileTextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
const logger = harp_utils_1.LoggerManager.instance.create("Tile");
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Compute the memory footprint of `TileFeatureData`.
 */
function getFeatureDataSize(featureData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.starts !== undefined) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
exports.getFeatureDataSize = getFeatureDataSize;
/**
 * Missing Typedoc
 */
var TileLoaderState;
(function (TileLoaderState) {
    TileLoaderState[TileLoaderState["Initialized"] = 0] = "Initialized";
    TileLoaderState[TileLoaderState["Loading"] = 1] = "Loading";
    TileLoaderState[TileLoaderState["Loaded"] = 2] = "Loaded";
    TileLoaderState[TileLoaderState["Decoding"] = 3] = "Decoding";
    TileLoaderState[TileLoaderState["Ready"] = 4] = "Ready";
    TileLoaderState[TileLoaderState["Canceled"] = 5] = "Canceled";
    TileLoaderState[TileLoaderState["Failed"] = 6] = "Failed";
})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));
/**
 * The class that holds the tiled data for a {@link DataSource}.
 */
class Tile {
    /**
     * Creates a new {@link Tile}.
     *
     * @param dataSource - The {@link DataSource} that created this {@link Tile}.
     * @param tileKey - The unique identifier for this {@link Tile}.
     *                  Currently only up to level 24 is
     *                  supported, because of the use of the upper bits for the offset.
     * @param offset - The optional offset, this is an integer which represents what multiple of 360
     *                 degrees to shift, only useful for flat projections, hence optional.
     * @param localTangentSpace - Whether the tile geometry is in local tangent space or not.
     */
    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        /**
         * A list of the THREE.js objects stored in this `Tile`.
         */
        this.objects = [];
        /**
         * The optional list of HERE TileKeys of tiles with geometries that cross
         * the boundaries of this `Tile`.
         */
        this.dependencies = new Array();
        /**
         * Keeping some stats for the individual {@link Tile}s to analyze caching behavior.
         *
         * The frame the {@link Tile} was last requested. This is
         * required to know when the given {@link Tile}
         * can be removed from the cache.
         */
        this.frameNumLastRequested = -1;
        /**
         * The frame the `Tile` was first visible.
         */
        this.frameNumVisible = -1;
        /**
         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine
         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is
         * visible.
         */
        this.frameNumLastVisible = -1;
        /**
         * After removing from cache, this is the number of frames the `Tile` was visible.
         */
        this.numFramesVisible = 0;
        /**
         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the
         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of
         * computing visibility.
         */
        this.visibilityCounter = -1;
        /**
         * @hidden
         *
         * Used to tell if the Tile is used temporarily as a fallback tile.
         *
         * levelOffset is in in the range [-quadTreeSearchDistanceUp,
         * quadTreeSearchDistanceDown], where these values come from the
         * {@link VisibleTileSetOptions}
         */
        this.levelOffset = 0;
        /**
         * If the tile should not be rendered, this is used typically when the tile in question
         * is completely covered by another tile and therefore can be skipped without any visual
         * impact. Setting this value directly affects the [[willRender]] method, unless
         * overriden by deriving classes.
         */
        this.skipRendering = false;
        /**
         * The bounding box of this `Tile` in world coordinates.
         */
        this.m_boundingBox = new harp_geoutils_1.OrientedBox3();
        this.m_disposed = false;
        this.m_localTangentSpace = false;
        this.m_forceHasGeometry = undefined;
        // Used for {@link TextElement}s that are stored in the data, and that are placed explicitly,
        // fading in and out.
        this.m_textElementGroups = new TextElementGroupPriorityList_1.TextElementGroupPriorityList();
        // Blocks other labels from showing.
        this.m_pathBlockingElements = [];
        // Center of the tile's unelevated bounding box world coordinates.
        this.m_worldCenter = new THREE.Vector3();
        this.m_visibleArea = 0;
        // Tile elevation range in meters
        this.m_elevationRange = { minElevation: 0, maxElevation: 0 };
        // List of owned textures for disposal
        this.m_ownedTextures = new WeakSet();
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.updateBoundingBox();
        this.m_worldCenter.copy(this.boundingBox.position);
        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;
        this.m_textStyleCache = new TileTextStyleCache_1.TileTextStyleCache(this);
        this.m_offset = offset;
        this.m_uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);
    }
    /**
     * The visibility status of the {@link Tile}. It is actually
     * visible or planned to become visible.
     */
    get isVisible() {
        // Tiles are not evaluated as invisible until the second frame they aren't requested.
        // This happens in order to prevent that, during VisibleTileSet visibility evaluation,
        // visible tiles that haven't yet been evaluated for the current frame are preemptively
        // removed from [[DataSourceCache]].
        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
    }
    set isVisible(visible) {
        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
    }
    /**
     * The {@link @here/harp-geoutils#Projection} currently used by the {@link MapView}.
     */
    get projection() {
        return this.dataSource.projection;
    }
    /**
     * The {@link MapView} this `Tile` belongs to.
     */
    get mapView() {
        return this.dataSource.mapView;
    }
    /**
     * Whether the data of this tile is in local tangent space or not.
     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then
     * {@link MapView} will rotate the objects before rendering using the rotation matrix of the
     * oriented [[boundingBox]].
     */
    get localTangentSpace() {
        return this.m_localTangentSpace;
    }
    /*
     * The size of this Tile in system memory.
     */
    get memoryUsage() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo.heapSize;
    }
    /**
     * The center of this `Tile` in world coordinates.
     */
    get center() {
        return this.m_worldCenter;
    }
    /**
     * Gets the key to uniquely represent this tile (based on
     * the {@link tileKey} and {@link offset}), note
     * this key is only unique within the given {@link DataSource},
     * to get a key which is unique across
     * {@link DataSource}s see [[DataSourceCache.getKeyForTile]].
     */
    get uniqueKey() {
        return this.m_uniqueKey;
    }
    /**
     * The optional offset, this is an integer which represents what multiple of 360 degrees to
     * shift, only useful for flat projections, hence optional.
     */
    get offset() {
        return this.m_offset;
    }
    /**
     * The optional offset, this is an integer which represents what multiple of 360 degrees to
     * shift, only useful for flat projections, hence optional.
     * @param offset - Which multiple of 360 degrees to apply to the {@link Tile}.
     */
    set offset(offset) {
        if (this.m_offset !== offset) {
            this.m_uniqueKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);
        }
        this.m_offset = offset;
    }
    /**
     * Compute {@link TileResourceInfo} of this `Tile`. May be using a cached value. The method
     * `invalidateResourceInfo` can be called beforehand to force a recalculation.
     *
     * @returns `TileResourceInfo` for this `Tile`.
     */
    getResourceInfo() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo;
    }
    /**
     * Force invalidation of the cached {@link TileResourceInfo}. Useful after the `Tile` has been
     * modified.
     */
    invalidateResourceInfo() {
        this.m_resourceInfo = undefined;
    }
    /**
     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is
     * disposed.
     * @param texture - Texture to be owned by the `Tile`
     */
    addOwnedTexture(texture) {
        this.m_ownedTextures.add(texture);
    }
    /**
     * @internal
     * @deprecated User text elements are deprecated.
     *
     * Gets the list of developer-defined {@link TextElement} in this `Tile`. This list is always
     * rendered first.
     */
    get userTextElements() {
        let group = this.m_textElementGroups.groups.get(TextElement_1.TextElement.HIGHEST_PRIORITY);
        if (group === undefined) {
            group = new TextElementGroup_1.TextElementGroup(TextElement_1.TextElement.HIGHEST_PRIORITY);
            this.m_textElementGroups.groups.set(group.priority, group);
        }
        return group;
    }
    /**
     * Adds a developer-defined {@link TextElement} to this `Tile`.
     *
     * @remarks
     * The {@link TextElement} is always
     * visible, if it's in the map's currently visible area.
     *
     * @deprecated use [[addTextElement]].
     *
     * @param textElement - The Text element to add.
     */
    addUserTextElement(textElement) {
        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;
        this.addTextElement(textElement);
    }
    /**
     * Removes a developer-defined {@link TextElement} from this `Tile`.
     *
     * @deprecated use [[removeTextElement]].
     *
     * @param textElement - A developer-defined TextElement to remove.
     * @returns `true` if the element has been removed successfully; `false` otherwise.
     */
    removeUserTextElement(textElement) {
        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;
        return this.removeTextElement(textElement);
    }
    /**
     * Adds a {@link TextElement} to this `Tile`, which is added to the visible set of
     * {@link TextElement}s based on the capacity and visibility. The {@link TextElement}'s priority
     * controls if or when it becomes visible.
     *
     * To ensure that a TextElement is visible, use a high value for its priority, such as
     * `TextElement.HIGHEST_PRIORITY`. Since the number of visible TextElements is limited by the
     * screen space, not all TextElements are visible at all times.
     *
     * @param textElement - The TextElement to add.
     */
    addTextElement(textElement) {
        this.textElementGroups.add(textElement);
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Clone all groups so that they are handled as new element groups
            // by TextElementsRenderer and it doesn't try to reuse the same state stored
            // for the old groups.
            this.m_textElementGroups = this.textElementGroups.clone();
        }
        this.textElementsChanged = true;
    }
    /**
     * Adds a [[PathBlockingElement]] to this `Tile`. This path has the highest priority and blocks
     * all other labels. There maybe in future a use case to give it a priority, but as that isn't
     * yet required, it is left to be implemented later if required.
     * @param blockingElement - Element which should block all other labels.
     */
    addBlockingElement(blockingElement) {
        this.m_pathBlockingElements.push(blockingElement);
    }
    /**
     * Removes a {@link TextElement} from this `Tile`.
     *
     * @remarks
     * For the element to be removed successfully, the
     * priority of the {@link TextElement} has to be equal to its priority when it was added.
     *
     * @param textElement - The TextElement to remove.
     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.
     */
    removeTextElement(textElement) {
        const groups = this.textElementGroups;
        if (!groups.remove(textElement)) {
            return false;
        }
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Clone all groups so that they are handled as new element groups
            // by TextElementsRenderer and it doesn't try to reuse the same state stored
            // for the old groups.
            this.m_textElementGroups = groups.clone();
        }
        this.textElementsChanged = true;
        return true;
    }
    /**
     * @internal
     *
     * Gets the current [[GroupedPriorityList]] which
     * contains a list of all {@link TextElement}s to be
     * selected and placed for rendering.
     */
    get textElementGroups() {
        return this.m_textElementGroups;
    }
    /**
     * Gets the current modification state for the list
     * of {@link TextElement}s in the `Tile`. If the
     * value is `true` the TextElement is placed for
     * rendering during the next frame.
     */
    get textElementsChanged() {
        var _a;
        return (_a = this.m_textElementsChanged) !== null && _a !== void 0 ? _a : false;
    }
    set textElementsChanged(changed) {
        this.m_textElementsChanged = changed;
    }
    /**
     * Returns true if the `Tile` has any text elements to render.
     */
    hasTextElements() {
        return this.m_textElementGroups.count() > 0;
    }
    /**
     * Get the current blocking elements.
     */
    get blockingElements() {
        return this.m_pathBlockingElements;
    }
    /**
     * Called before {@link MapView} starts rendering this `Tile`.
     *
     * @param zoomLevel - The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered. Influenced directly by the
     * [[skipRendering]] property unless specifically overriden in deriving classes.
     */
    willRender(_zoomLevel) {
        return !this.skipRendering;
    }
    /**
     * Called after {@link MapView} has rendered this `Tile`.
     */
    didRender() {
        // to be overridden by subclasses
    }
    /**
     * Estimated visible area of tile used for sorting the priorities during loading.
     */
    get visibleArea() {
        return this.m_visibleArea;
    }
    set visibleArea(area) {
        this.m_visibleArea = area;
        if (this.tileLoader !== undefined) {
            this.tileLoader.updatePriority(area);
        }
    }
    /**
     * @internal
     * Gets the tile's ground elevation range in meters.
     */
    get elevationRange() {
        return this.m_elevationRange;
    }
    /**
     * @internal
     * Sets the tile's ground elevation range in meters.
     *
     * @param elevationRange - The elevation range.
     */
    set elevationRange(elevationRange) {
        var _a;
        if (elevationRange.minElevation === this.m_elevationRange.minElevation &&
            elevationRange.maxElevation === this.m_elevationRange.maxElevation &&
            elevationRange.calculationStatus === this.m_elevationRange.calculationStatus) {
            return;
        }
        this.m_elevationRange.minElevation = elevationRange.minElevation;
        this.m_elevationRange.maxElevation = elevationRange.maxElevation;
        this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;
        this.elevateGeoBox();
        // Only update bounding box if tile has already been decoded and a maximum geometry height
        // is provided by the data source.
        if (this.m_maxGeometryHeight !== undefined) {
            harp_utils_1.assert(((_a = this.decodedTile) === null || _a === void 0 ? void 0 : _a.boundingBox) === undefined);
            this.updateBoundingBox();
        }
    }
    /**
     * Gets the decoded tile; it is removed after geometry handling.
     */
    get decodedTile() {
        return this.m_decodedTile;
    }
    /**
     * Applies the decoded tile to the tile.
     * If the geometry is empty, then the tile's forceHasGeometry flag is set.
     * Map is updated.
     * @param decodedTile - The decoded tile to set.
     */
    set decodedTile(decodedTile) {
        var _a;
        this.m_decodedTile = decodedTile;
        this.invalidateResourceInfo();
        if (decodedTile === undefined) {
            return;
        }
        if (decodedTile.geometries.length === 0) {
            this.forceHasGeometry(true);
        }
        // If the decoder provides a more accurate bounding box than the one we computed from
        // the flat geo box we take it instead. Otherwise, if an elevation range was set, elevate
        // bounding box to match the elevated geometry.
        this.m_maxGeometryHeight = decodedTile.boundingBox
            ? undefined
            : (_a = decodedTile.maxGeometryHeight) !== null && _a !== void 0 ? _a : 0;
        this.elevateGeoBox();
        this.updateBoundingBox(decodedTile.boundingBox);
        const stats = Statistics_1.PerformanceStatistics.instance;
        if (stats.enabled && decodedTile.decodeTime !== undefined) {
            stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
            stats.currentFrame.addValue("decode.decodedTiles", 1);
        }
        if (decodedTile.copyrightHolderIds !== undefined) {
            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));
        }
        this.dataSource.requestUpdate();
    }
    /**
     * Remove the decodedTile when no longer needed.
     */
    removeDecodedTile() {
        this.m_decodedTile = undefined;
        this.invalidateResourceInfo();
    }
    /**
     * Called by the {@link @here/harp-mapview-decoder#TileLoader}
     *
     * @remarks
     * after the `Tile` has finished loading its map data. Can be used
     * to add content to the `Tile`.
     * The {@link @here/harp-datasource-protocol#DecodedTile} should still be available.
     */
    loadingFinished() {
        // To be used in subclasses.
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object - The object that references the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectGeometry(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a `Tile` object's material.
     *
     * @param object - The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectMaterial(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a Texture that is part of a `Tile` object's material.
     *
     * @param texture - The texture about to be disposed.
     * @returns `true` if the texture can be disposed.
     */
    shouldDisposeTexture(texture) {
        return this.m_ownedTextures.has(texture);
    }
    /**
     * Returns `true` if this `Tile` has been disposed.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * Gets the [[TileGeometryLoader]] that manages this tile.
     */
    get tileGeometryLoader() {
        return this.m_tileGeometryLoader;
    }
    /**
     * Sets the [[TileGeometryLoader]] to manage this tile.
     *
     * @param tileGeometryLoader - A [[TileGeometryLoader]] instance to manage the geometry creation
     *      for this tile.
     */
    set tileGeometryLoader(tileGeometryLoader) {
        this.m_tileGeometryLoader = tileGeometryLoader;
    }
    /**
     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.
     */
    get basicGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        return this.m_tileGeometryLoader === undefined
            ? this.hasGeometry
            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;
    }
    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, MapView checks if the [[objects]] list is not empty. However, you can override
     * this check by manually setting this property.
     */
    get hasGeometry() {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        }
        else {
            return this.m_forceHasGeometry;
        }
    }
    /**
     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.
     *
     * @param value - A new value for the [[hasGeometry]] flag.
     */
    forceHasGeometry(value) {
        this.m_forceHasGeometry = value;
    }
    /**
     * Reset the visibility counter. This will force the visibility check to be rerun on all objects
     * in this `Tile`.
     */
    resetVisibilityCounter() {
        this.visibilityCounter = -1;
    }
    /**
     * Gets the {@link ITileLoader} that manages this tile.
     */
    get tileLoader() {
        return this.m_tileLoader;
    }
    /**
     * Sets the {@link ITileLoader} to manage this tile.
     *
     * @param tileLoader - A {@link ITileLoader} instance to manage
     *                     the loading process for this tile.
     */
    set tileLoader(tileLoader) {
        this.m_tileLoader = tileLoader;
    }
    /**
     * Loads this `Tile` geometry.
     */
    load() {
        const tileLoader = this.tileLoader;
        if (tileLoader === undefined) {
            return;
        }
        tileLoader
            .loadAndDecode()
            .then(tileLoaderState => {
            harp_utils_1.assert(tileLoaderState === TileLoaderState.Ready);
            const decodedTile = tileLoader.decodedTile;
            this.decodedTile = decodedTile;
        })
            .catch(tileLoaderState => {
            if (tileLoaderState !== TileLoaderState.Canceled &&
                tileLoaderState !== TileLoaderState.Failed) {
                logger.error("Unknown error" + tileLoaderState);
            }
        });
    }
    /**
     * Text style cache for this tile.
     * @hidden
     */
    get textStyleCache() {
        return this.m_textStyleCache;
    }
    /**
     * Frees the rendering resources allocated by this `Tile`.
     *
     * The default implementation of this method frees the geometries and the materials for all the
     * reachable objects.
     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this
     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).
     */
    clear() {
        const disposeMaterial = (material) => {
            Object.getOwnPropertyNames(material).forEach((property) => {
                const materialProperty = material[property];
                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {
                    const texture = materialProperty;
                    if (this.shouldDisposeTexture(texture)) {
                        texture.dispose();
                    }
                }
            });
            material.dispose();
        };
        const disposeObject = (object) => {
            if (this.shouldDisposeObjectGeometry(object)) {
                if (object.geometry !== undefined) {
                    object.geometry.dispose();
                }
                if (object.geometries !== undefined) {
                    for (const geometry of object.geometries) {
                        geometry.dispose();
                    }
                }
            }
            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach((material) => {
                        if (material !== undefined) {
                            disposeMaterial(material);
                        }
                    });
                }
                else {
                    disposeMaterial(object.material);
                }
            }
        };
        this.objects.forEach((rootObject) => {
            rootObject.traverse((object) => {
                disposeObject(object);
            });
            disposeObject(rootObject);
        });
        this.objects.length = 0;
        if (this.preparedTextPaths) {
            this.preparedTextPaths = [];
        }
        this.m_textStyleCache.clear();
        this.clearTextElements();
        this.invalidateResourceInfo();
    }
    /**
     * Removes all {@link TextElement} from the tile.
     */
    clearTextElements() {
        if (!this.hasTextElements()) {
            return;
        }
        this.textElementsChanged = true;
        this.m_pathBlockingElements.splice(0);
        this.textElementGroups.clear();
    }
    /**
     * Adds a callback that will be called whenever the tile is disposed. Multiple callbacks may be
     * added.
     * @internal
     * @param callback - The callback to be called when the tile is disposed.
     */
    addDisposeCallback(callback) {
        this.m_disposeCallback = harp_utils_1.chainCallbacks(this.m_disposeCallback, callback);
    }
    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.cancel();
            this.m_tileLoader = undefined;
        }
        if (this.m_tileGeometryLoader !== undefined) {
            this.m_tileGeometryLoader.dispose();
            this.m_tileGeometryLoader = undefined;
        }
        this.clear();
        this.m_disposed = true;
        // Ensure that tile is removable from tile cache.
        this.frameNumLastRequested = 0;
        if (this.m_disposeCallback) {
            this.m_disposeCallback(this);
        }
    }
    /**
     * Computes the offset in the x world coordinates corresponding to this tile, based on
     * its [[offset]].
     * @returns The x offset.
     */
    computeWorldOffsetX() {
        return this.projection.worldExtent(0, 0).max.x * this.offset;
    }
    /**
     * Update tile for current map view zoom level
     * @param zoomLevel - Zoom level of the map view
     */
    update(zoomLevel) {
        for (const object of this.objects) {
            if (object instanceof LodMesh_1.LodMesh) {
                object.setLevelOfDetail(zoomLevel - this.tileKey.level);
            }
        }
    }
    /**
     * Gets the tile's bounding box.
     */
    get boundingBox() {
        return this.m_boundingBox;
    }
    /**
     * Updates the tile's world bounding box.
     * @param [newBoundingBox] The new bounding box to set. If undefined, the bounding box will be
     * computed by projecting the tile's geoBox.
     */
    updateBoundingBox(newBoundingBox) {
        if (newBoundingBox) {
            this.m_boundingBox.copy(newBoundingBox);
            this.m_worldCenter.copy(this.boundingBox.position);
        }
        else {
            this.projection.projectBox(this.geoBox, this.boundingBox);
        }
    }
    /**
     * Elevates the tile's geo box using the elevation range and maximum geometry height.
     */
    elevateGeoBox() {
        var _a;
        this.geoBox.southWest.altitude = this.m_elevationRange.minElevation;
        this.geoBox.northEast.altitude =
            this.m_elevationRange.maxElevation + ((_a = this.m_maxGeometryHeight) !== null && _a !== void 0 ? _a : 0);
    }
    computeResourceInfo() {
        let heapSize = 0;
        let num3dObjects = 0;
        let numTextElements = 0;
        const aggregatedObjSize = {
            heapSize: 0,
            gpuSize: 0
        };
        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.
        // They should be counted only once even if they are shared.
        const visitedObjects = new Map();
        for (const object of this.objects) {
            if (object.visible) {
                num3dObjects++;
            }
            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);
        }
        for (const group of this.textElementGroups.groups) {
            numTextElements += group[1].elements.length;
        }
        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes
        // was the minimum retained size of a TextElement that was not being rendered. If a
        // TextElement is actually rendered, the size may be _much_ bigger.
        heapSize += numTextElements * 312;
        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {
            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
        }
        this.m_resourceInfo = {
            heapSize: aggregatedObjSize.heapSize + heapSize,
            gpuSize: aggregatedObjSize.gpuSize,
            num3dObjects,
            numTextElements,
            numUserTextElements: 0
        };
    }
}
exports.Tile = Tile;
//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileOffsetUtils = exports.MapViewUtils = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const Tile_1 = __webpack_require__(/*! ./Tile */ "./node_modules/@here/harp-mapview/lib/Tile.js");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewUtils");
// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.
// There may be cases where it is possible to construct Object3Ds with considerable less memory
// consumption, but this value is used to simplify the estimation.
const MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;
const MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
/**
 * Zoom level to request terrain tiles for getting the height of the camera above terrain.
 */
const TERRAIN_ZOOM_LEVEL = 4;
// Caching those for performance reasons.
const groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);
const groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());
const groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
const rayCaster = new THREE.Raycaster();
const epsilon = 1e-5;
/**
 * Cached ThreeJS instances for realtime maths.
 */
const space = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const tangentSpace = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const cache = {
    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],
    transforms: [
        {
            xAxis: new THREE.Vector3(),
            yAxis: new THREE.Vector3(),
            zAxis: new THREE.Vector3(),
            position: new THREE.Vector3()
        }
    ]
};
/**
 * Rounds a given zoom level up to the nearest integer value if it's close enough.
 *
 * The zoom level set in {@link MapView} after a zoom level
 * target is given to {@link (MapView.lookAt:WITH_PARAMS)} or
 * {@link @here/harp-map-controls#MapControls} never matches
 * exactly the target due to the precision loss caused by the
 * conversion from zoom level to camera distance (done in
 * {@link (MapView.lookAt:WITH_PARAMS)} and {@link @here/harp-map-controls#MapControls})
 * and from distance back to zoom level (done at every frame on camera update).
 * As a result, given a fixed integer zoom level input, the final zoom level computed at every frame
 * may fall sometimes below the integer value and others above. This causes flickering since each
 * frame will use different tile levels and different style evaluations for object visibility.
 * See HARP-9673 and HARP-8523.
 * @param zoomLevel - Input zoom level
 * @return The ceiling zoom level if input zoom level is close enough, otherwise the unmodified
 * input zoom level.
 */
function snapToCeilingZoomLevel(zoomLevel) {
    const eps = 1e-6;
    const ceiling = Math.ceil(zoomLevel);
    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;
}
var MapViewUtils;
(function (MapViewUtils) {
    MapViewUtils.MAX_TILT_DEG = 89;
    MapViewUtils.MAX_TILT_RAD = MapViewUtils.MAX_TILT_DEG * THREE.MathUtils.DEG2RAD;
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView - Instance of MapView.
     * @param targetNDCx - Target x position in NDC space.
     * @param targetNDCy - Target y position in NDC space.
     * @param zoomLevel - The desired zoom level.
     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.
     */
    function zoomOnTargetPosition(mapView, targetNDCx, targetNDCy, zoomLevel, maxTiltAngle = MapViewUtils.MAX_TILT_RAD) {
        const { elevationProvider, camera } = mapView;
        // Use for now elevation at camera position. See getTargetAndDistance.
        const elevation = elevationProvider
            ? elevationProvider.getHeight(mapView.projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)
            : undefined;
        // Get current target position in world space before we zoom.
        const worldTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        const groundDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);
        const cameraHeight = groundDistance + (elevation !== null && elevation !== void 0 ? elevation : 0);
        // Set the cameras height according to the given zoom level.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            camera.position.setZ(cameraHeight);
        }
        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            camera.position.setLength(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + cameraHeight);
        }
        // In sphere, we may have to also orbit the camera around the position located at the
        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change
        // this tilt by changing the camera's height above.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // FIXME: We cannot use mapView.tilt here b/c it does not reflect the latest camera
            // changes.
            // tslint:disable-next-line: deprecation
            const tilt = extractCameraTilt(camera, mapView.projection);
            const deltaTilt = tilt - maxTiltAngle;
            if (deltaTilt > 0) {
                orbitFocusPoint(mapView, 0, deltaTilt, maxTiltAngle);
            }
        }
        // Get new target position after the zoom
        const newWorldTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        if (!worldTarget || !newWorldTarget) {
            return;
        }
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // Calculate the difference and pan the map to maintain the map relative to the target
            // position.
            worldTarget.sub(newWorldTarget);
            panCameraAboveFlatMap(mapView, worldTarget.x, worldTarget.y);
        }
        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            panCameraAroundGlobe(mapView, worldTarget, newWorldTarget);
        }
    }
    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;
    /**
     * Orbits the camera around the focus point of the camera.
     *
     * @param mapView - The {@link MapView} instance to manipulate.
     * @param deltaAzimuthDeg - Delta azimuth in degrees.
     * @param deltaTiltDeg - Delta tilt in degrees.
     * @param maxTiltAngleRad - The maximum tilt between the camera and its target in radian.
     */
    function orbitFocusPoint(mapView, deltaAzimuthDeg, deltaTiltDeg, maxTiltAngleRad = MapViewUtils.MAX_TILT_RAD) {
        const target = mapView.target;
        const sphericalCoordinates = extractSphericalCoordinatesFromLocation(mapView, mapView.camera, target);
        const tilt = Math.max(Math.min(THREE.MathUtils.radToDeg(maxTiltAngleRad), deltaTiltDeg + THREE.MathUtils.radToDeg(sphericalCoordinates.tilt)), 0);
        const heading = THREE.MathUtils.radToDeg(sphericalCoordinates.azimuth + Math.PI) + deltaAzimuthDeg;
        mapView.lookAt({
            target,
            distance: mapView.targetDistance,
            tilt,
            heading
        });
    }
    MapViewUtils.orbitFocusPoint = orbitFocusPoint;
    /**
     * Calculate target (focus) point geo-coordinates for given camera.
     * @see getTargetPositionFromCamera
     *
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level measured in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future. Use
     * MapView.worldTarget instead.
     */
    function getGeoTargetFromCamera(camera, projection, elevation) {
        // This function does almost the same as:
        // rayCastGeoCoordinates(mapView, 0, 0)
        // but in more gentle and performance wise manner
        // tslint:disable-next-line: deprecation
        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);
        if (targetWorldPos !== null) {
            return projection.unprojectPoint(targetWorldPos);
        }
        return null;
    }
    MapViewUtils.getGeoTargetFromCamera = getGeoTargetFromCamera;
    /**
     * Calculate target (focus) point world coordinates for given camera position and orientation.
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future.
     */
    function getWorldTargetFromCamera(camera, projection, elevation) {
        const cameraPos = cache.vector3[0].copy(camera.position);
        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);
        rayCaster.set(cameraPos, cameraLookAt);
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const targetWorldPos = new THREE.Vector3();
        const result = projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)
            : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.getWorldTargetFromCamera = getWorldTargetFromCamera;
    /**
     * Returns the height of the camera above the earths surface.
     *
     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine
     * how high the camera is above the surface.
     *
     * @param level - Which level to request the surface height from.
     * @return Height in world units.
     */
    function getHeightAboveTerrain(location, projection, elevationProvider, level) {
        if (elevationProvider !== undefined) {
            const geoLocation = projection.unprojectPoint(location);
            const heightAboveTerrain = elevationProvider.getHeight(geoLocation, level);
            if (heightAboveTerrain !== undefined) {
                const height = projection.unprojectAltitude(location) - heightAboveTerrain;
                return Math.max(height, 1);
            }
        }
        return Math.abs(projection.groundDistance(location));
    }
    /**
     * @internal
     * @deprecated This method will be moved to MapView.
     */
    function getTargetAndDistance(projection, camera, elevationProvider) {
        const cameraPitch = extractAttitude({ projection }, camera).pitch;
        //FIXME: For now we keep the old behaviour when terrain is enabled (i.e. use the camera
        //       height above terrain to deduce the target distance).
        //       This leads to zoomlevel changes while panning. We have to find a proper solution
        //       for terrain (e.g. raycast with the ground surfcae that is elevated by the average
        //       elevation in the scene)
        const elevation = elevationProvider
            ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)
            : undefined;
        // Even for a tilt of 90 raycastTargetFromCamera is returning some point almost at
        // infinity.
        const target = cameraPitch < MapViewUtils.MAX_TILT_RAD
            ? // tslint:disable-next-line: deprecation
                getWorldTargetFromCamera(camera, projection, elevation)
            : null;
        if (target !== null) {
            const distance = camera.position.distanceTo(target);
            return { target, distance };
        }
        else {
            // We either reached the [[PITCH_LIMIT]] or we did not hit the ground surface.
            // In this case we do the reverse, i.e. compute some fallback distance and
            // use it to compute the tagret point by using the camera direction.
            const cameraPosZ = getHeightAboveTerrain(camera.position, projection, elevationProvider, TERRAIN_ZOOM_LEVEL);
            //For flat projection we fallback to the target distance at 89 degree pitch.
            //For spherical projection we fallback to the tangent line distance
            const distance = projection.type === harp_geoutils_1.ProjectionType.Planar
                ? cameraPosZ / Math.cos(Math.min(cameraPitch, MapViewUtils.MAX_TILT_RAD))
                : Math.sqrt(Math.pow(cameraPosZ + EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2) -
                    Math.pow(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2));
            const cameraDir = camera.getWorldDirection(cache.vector3[0]);
            cameraDir.multiplyScalar(distance);
            const fallbackTarget = cache.vector3[1];
            fallbackTarget.copy(camera.position).add(cameraDir);
            return { target: fallbackTarget, distance };
        }
    }
    MapViewUtils.getTargetAndDistance = getTargetAndDistance;
    /**
     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,
     * given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates - Coordinates of the center of the view.
     * @param distance - Distance to the target in meters.
     * @param yawDeg - Camera yaw in degrees.
     * @param pitchDeg - Camera pitch in degrees.
     * @param projection - Active MapView, needed to get the camera fov and map projection.
     * @param result - Optional output vector.
     * @returns Camera position in world space.
     */
    function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE.Vector3()) {
        const pitchRad = THREE.MathUtils.degToRad(pitchDeg);
        const altitude = Math.cos(pitchRad) * distance;
        const yawRad = THREE.MathUtils.degToRad(yawDeg);
        projection.projectPoint(targetCoordinates, result);
        const groundDistance = distance * Math.sin(pitchRad);
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            result.x = result.x + Math.sin(yawRad) * groundDistance;
            result.y = result.y - Math.cos(yawRad) * groundDistance;
            result.z = result.z + altitude;
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // In globe yaw and pitch are understood to be in tangent space. The approach below is
            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and
            // set its new length (groundDistance). Finally the up vector's length is set to the
            // camera height and added to the transformed Y above.
            // Get the Z axis in tangent space: it is the normalized position vector of the target.
            tangentSpace.z.copy(result).normalize();
            // Get the Y axis (north axis in tangent space):
            tangentSpace.y
                .set(0, 0, 1)
                .projectOnPlane(tangentSpace.z)
                .normalize();
            // Rotate this north axis by the given yaw, giving the camera direction relative to
            // the target.
            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);
            tangentSpace.y.applyQuaternion(cache.quaternions[0]);
            // Push the camera to the specified distance.
            tangentSpace.y.setLength(groundDistance);
            // Now get the actual camera position vector: from the target position, add the
            // previous computation to get the projection of the camera on the ground, then add
            // the height of the camera in the tangent space.
            const height = distance * Math.cos(pitchRad);
            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));
            const a = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + altitude;
            const b = Math.sin(pitchRad) * distance;
            const cameraHeight = Math.sqrt(a * a + b * b);
            result.setLength(cameraHeight);
        }
        return result;
    }
    MapViewUtils.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;
    /**
     * @hidden
     * @internal
     *
     * Add offset to geo points for minimal view box in flat projection with tile wrapping.
     *
     * In flat projection, with wrap around enabled, we should detect clusters of points around that
     * wrap antimeridian.
     *
     * Here, we fit points into minimal geo box taking world wrapping into account.
     */
    function wrapGeoPointsToScreen(points, startPosition) {
        let startIndex = 0;
        if (startPosition === undefined) {
            startPosition = harp_geoutils_1.GeoCoordinates.fromObject(points[0]);
            startIndex = 1;
        }
        let north = startPosition.latitude;
        let south = startPosition.latitude;
        let lonCenter = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(startPosition.longitude);
        let lonSpan = 0;
        let east = startPosition.longitude;
        let west = startPosition.longitude;
        const result = [];
        result.push(new harp_geoutils_1.GeoCoordinates(north, lonCenter));
        for (let i = startIndex; i < points.length; i++) {
            const p = harp_geoutils_1.GeoCoordinates.fromObject(points[i]);
            if (p.latitude > north) {
                north = p.latitude;
            }
            else if (p.latitude < south) {
                south = p.latitude;
            }
            let longitude = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(p.longitude);
            const relToCenter = harp_geoutils_1.MathUtils.angleDistanceDeg(lonCenter, longitude);
            longitude = lonCenter - relToCenter;
            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {
                east = Math.max(east, lonCenter - relToCenter);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            }
            else if (relToCenter > 0 && relToCenter > lonSpan / 2) {
                west = Math.min(west, longitude);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            }
            result.push(new harp_geoutils_1.GeoCoordinates(p.latitude, longitude));
        }
        return result;
    }
    MapViewUtils.wrapGeoPointsToScreen = wrapGeoPointsToScreen;
    /**
     * @hidden
     * @internal
     *
     * Given `cameraPos`, force all points that lie on non-visible sphere half to be "near" max
     * possible viewable circle from given camera position.
     *
     * Assumes that shpere projection with world center is in `(0, 0, 0)`.
     */
    function wrapWorldPointsToView(points, cameraPos) {
        const cameraPosNormalized = cameraPos.clone().normalize();
        for (const point of points) {
            if (point.angleTo(cameraPos) > Math.PI / 2) {
                // Point is on other side of sphere, we "clamp it to" max possible viewable circle
                // from given camera position
                const pointLen = point.length();
                point.projectOnPlane(cameraPosNormalized).setLength(pointLen);
            }
        }
    }
    MapViewUtils.wrapWorldPointsToView = wrapWorldPointsToView;
    /**
     * @hidden
     * @internal
     *
     * Return [[GeoPoints]] bounding {@link @here/harp-geoutils#GeoBox}
     * applicable for [[getFitBoundsDistance]].
     *
     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`
     */
    function geoBoxToGeoPoints(box) {
        const center = box.center;
        return [
            new harp_geoutils_1.GeoCoordinates(box.north, box.west),
            new harp_geoutils_1.GeoCoordinates(box.north, box.east),
            new harp_geoutils_1.GeoCoordinates(center.latitude, box.west),
            new harp_geoutils_1.GeoCoordinates(center.latitude, box.east),
            new harp_geoutils_1.GeoCoordinates(box.south, box.west),
            new harp_geoutils_1.GeoCoordinates(box.south, box.east),
            new harp_geoutils_1.GeoCoordinates(box.north, center.longitude),
            new harp_geoutils_1.GeoCoordinates(box.south, center.longitude)
        ];
    }
    MapViewUtils.geoBoxToGeoPoints = geoBoxToGeoPoints;
    /**
     * @hidden
     * @internal
     *
     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.
     *
     * All dimensions belong to world space.
     *
     * @param points - points which shall are to be covered by view
     *
     * @param worldTarget - readonly, world target of {@link MapView}
     * @param camera - readonly, camera with proper `position` and rotation set
     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}
     */
    function getFitBoundsDistance(points, worldTarget, camera) {
        const cameraRotationMatrix = new THREE.Matrix4();
        cameraRotationMatrix.extractRotation(camera.matrixWorld);
        const screenUpVector = new THREE.Vector3(0, 1, 0).applyMatrix4(cameraRotationMatrix);
        const screenSideVector = new THREE.Vector3(1, 0, 0).applyMatrix4(cameraRotationMatrix);
        const screenVertMidPlane = new THREE.Plane().setFromCoplanarPoints(camera.position, worldTarget, worldTarget.clone().add(screenUpVector));
        const screenHorzMidPlane = new THREE.Plane().setFromCoplanarPoints(camera.position, worldTarget, worldTarget.clone().add(screenSideVector));
        const cameraPos = cache.vector3[0];
        cameraPos.copy(camera.position);
        const halfVertFov = THREE.MathUtils.degToRad(camera.fov / 2);
        const halfHorzFov = THREE.MathUtils.degToRad((camera.fov / 2) * camera.aspect);
        // tan(fov/2)
        const halfVertFovTan = 1 / Math.tan(halfVertFov);
        const halfHorzFovTan = 1 / Math.tan(halfHorzFov);
        const cameraToTarget = cache.vector3[1];
        cameraToTarget
            .copy(cameraPos)
            .sub(worldTarget)
            .negate();
        const cameraToTargetNormalized = new THREE.Vector3().copy(cameraToTarget).normalize();
        const offsetVector = new THREE.Vector3();
        const cameraToPointOnRefPlane = new THREE.Vector3();
        const pointOnRefPlane = new THREE.Vector3();
        function checkAngle(point, referencePlane, maxAngle, fovFactor) {
            referencePlane.projectPoint(point, pointOnRefPlane);
            cameraToPointOnRefPlane
                .copy(cameraPos)
                .sub(pointOnRefPlane)
                .negate();
            const viewAngle = cameraToTarget.angleTo(cameraToPointOnRefPlane);
            if (viewAngle <= maxAngle) {
                return;
            }
            const cameraToPointLen = cameraToPointOnRefPlane.length();
            const cameraToTargetLen = cameraToTarget.length();
            const newCameraDistance = cameraToPointLen * (Math.sin(viewAngle) * fovFactor - Math.cos(viewAngle)) +
                cameraToTargetLen;
            offsetVector
                .copy(cameraToTargetNormalized)
                .multiplyScalar(cameraToTargetLen - newCameraDistance);
            cameraPos.add(offsetVector);
            cameraToTarget.sub(offsetVector);
        }
        for (const point of points) {
            checkAngle(point, screenVertMidPlane, halfVertFov, halfVertFovTan);
            checkAngle(point, screenHorzMidPlane, halfHorzFov, halfHorzFovTan);
        }
        return cameraToTarget.length();
    }
    MapViewUtils.getFitBoundsDistance = getFitBoundsDistance;
    /**
     * @hidden
     * @internal
     *
     * Get {@link LookAtParams} that fit all `worldPoints`
     * giving that {@link MapView} will target at
     * `geoTarget`.
     *
     * @param geoTarget - desired target (see {@link MapView.target}) as geo point
     * @param worldTarget - same as `geoTarget` but in world space
     * @param worldPoints - points we want to see
     * @param params - other params derived from {@link MapView}.
     */
    function getFitBoundsLookAtParams(geoTarget, worldTarget, worldPoints, params) {
        const { tilt, heading, projection } = params;
        const startDistance = params.minDistance;
        const tmpCamera = params.camera.clone();
        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera.quaternion);
        getCameraPositionFromTargetCoordinates(geoTarget, startDistance, -heading, tilt, projection, tmpCamera.position);
        tmpCamera.updateMatrixWorld(true);
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            wrapWorldPointsToView(worldPoints, tmpCamera.position);
        }
        const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera);
        return {
            target: geoTarget,
            distance,
            heading,
            tilt
        };
    }
    MapViewUtils.getFitBoundsLookAtParams = getFitBoundsLookAtParams;
    /**
     * @deprecated use getCameraPositionFromTargetCoordinates instead
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache.vector3[1]));
    }
    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXinNDC - X coordinate in NDC space.
     * @param pointOnScreenYinNDC - Y coordinate in NDC space.
     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        const pointInNDCPosition = cache.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);
        const cameraPos = cache.vector3[1].copy(mapView.camera.position);
        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);
        // Prepare the unprojection matrix which projects from NDC space to camera space
        // and takes the current rotation of the camera into account.
        cache.matrix4[1].multiplyMatrices(cache.matrix4[0], cache.matrix4[1].getInverse(mapView.camera.projectionMatrix));
        // Unproject the point via the unprojection matrix.
        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);
        // Use the point in camera space as the vector towards this point.
        rayCaster.set(cameraPos, pointInCameraSpace.normalize());
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const worldPosition = new THREE.Vector3();
        const result = mapView.projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)
            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView - Instance of MapView.
     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan
     *                  the map to the left in default camera orientation.
     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the
     *                  map downwards in default camera orientation.
     */
    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
    }
    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;
    /**
     * The function doing a pan in the spherical space
     * when {@link MapView}'s active [[ProjectionType]]
     * is spherical. In other words, the function that rotates the camera around the globe.
     *
     * @param mapView - MapView instance.
     * @param fromWorld - Start vector representing the scene position of a geolocation.
     * @param toWorld - End vector representing the scene position of a geolocation.
     */
    function panCameraAroundGlobe(mapView, fromWorld, toWorld) {
        cache.quaternions[0]
            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())
            .inverse();
        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);
        mapView.camera.applyMatrix4(cache.matrix4[0]);
        mapView.camera.updateMatrixWorld();
    }
    MapViewUtils.panCameraAroundGlobe = panCameraAroundGlobe;
    /**
     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the
     * maximum possible tilt to the new target, and under the horizon in sphere projection.
     *
     * @param mapView - The {@link MapView} instance in use.
     * @param deltaYawDeg - Delta yaw in degrees.
     * @param deltaPitchDeg - Delta pitch in degrees.
     * @param maxTiltAngleRad - Max tilt angle in radians.
     */
    function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {
        // 1. Apply yaw: rotate around the vertical axis.
        mapView.camera.rotateOnWorldAxis(mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? cache.vector3[0].copy(mapView.camera.position).normalize()
            : cache.vector3[0].set(0, 0, 1), THREE.MathUtils.degToRad(-deltaYawDeg));
        mapView.camera.updateMatrixWorld();
        // 2. Apply pitch: rotate around the camera's local X axis.
        if (deltaPitchDeg === 0) {
            return;
        }
        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;
        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.
        let newPitch = THREE.MathUtils.clamp(pitch + THREE.MathUtils.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);
        // In sphere projection, the value of a maximum pitch is smaller than the value of the
        // maximum tilt, as the curvature of the surface adds up to it.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.
            const maxPitch = Math.asin((EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /
                mapView.camera.position.length());
            newPitch = Math.min(newPitch, maxPitch);
        }
        mapView.camera.rotateX(newPitch - pitch);
    }
    MapViewUtils.rotate = rotate;
    /**
     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations
     * hinge on the current `projection` and `target`, because yaw and pitch are defined in
     * tangent space of the target point.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param projection - Current projection.
     * @param target - The camera target.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE.Quaternion()) {
        const transform = cache.transforms[0];
        projection.localTangentSpace(target, transform);
        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        result.setFromRotationMatrix(cache.matrix4[0]);
        cache.quaternions[0].setFromAxisAngle(cache.vector3[1].set(0, 0, 1), THREE.MathUtils.degToRad(yawDeg));
        cache.quaternions[1].setFromAxisAngle(cache.vector3[1].set(1, 0, 0), THREE.MathUtils.degToRad(pitchDeg));
        result.multiply(cache.quaternions[0]);
        result.multiply(cache.quaternions[1]);
        return result;
    }
    MapViewUtils.getCameraRotationAtTarget = getCameraRotationAtTarget;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge
     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent
     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView - Instance of MapView.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function setRotation(mapView, yawDeg, pitchDeg) {
        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);
    }
    MapViewUtils.setRotation = setRotation;
    /**
     * Extracts current camera tilt angle in radians.
     *
     * @param camera - The [[Camera]] in use.
     * @param projection - The {@link @here/harp-geoutils#Projection} used to
     *                     convert between geo and world coordinates.
     *
     * @deprecated Use MapView.tilt
     */
    function extractCameraTilt(camera, projection) {
        // For planar projections the camera target point local tangent is the same
        // at every point on the ground (ignoring terrain fluctuations), so we may
        // simply use inverted ground normal for tilt calculation. This simplifies
        // the more generic calculus used for spherical projections.
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const lookAt = camera.getWorldDirection(cache.vector3[0]).normalize();
            const normal = projection
                .surfaceNormal(camera.position, cache.vector3[1])
                .negate();
            const cosTheta = lookAt.dot(normal);
            return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));
        }
        else {
            // Sanity check if new projection type is introduced.
            harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
            // tslint:disable-next-line: deprecation
            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);
            // If focus point is lost we then expose maximum allowable tilt value.
            if (targetGeoCoords !== null) {
                return MapViewUtils.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);
            }
            else {
                logger.warn("MapView camera is pointing in the void, using maxTilt: ", MapViewUtils.MAX_TILT_RAD);
                return MapViewUtils.MAX_TILT_RAD;
            }
        }
    }
    MapViewUtils.extractCameraTilt = extractCameraTilt;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),
     * starting north.
     * - Pitch :Rotation around the horizontal axis.
     * - Roll : Rotation around the view axis.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.
     */
    function extractAttitude(options, object) {
        // 1. Build the matrix of the tangent space of the object.
        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.
        options.projection.localTangentSpace(options.projection.unprojectPoint(cache.vector3[1]), {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);
        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.
        cache.matrix4[0].getInverse(cache.matrix4[1]).multiply(object.matrixWorld);
        space.x.setFromMatrixColumn(cache.matrix4[0], 0);
        space.y.setFromMatrixColumn(cache.matrix4[0], 1);
        space.z.setFromMatrixColumn(cache.matrix4[0], 2);
        // 3. Deduce orientation from the base axes.
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // Decompose rotation matrix into Z0 X Z1 Euler angles.
        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));
        if (d < 1.0 - epsilon) {
            if (d > -1.0 + epsilon) {
                yaw = Math.atan2(space.z.x, -space.z.y);
                pitch = Math.acos(space.z.z);
                roll = Math.atan2(space.x.z, space.y.z);
            }
            else {
                // Looking bottom-up with space.z.z == -1.0
                yaw = -Math.atan2(-space.y.x, space.x.x);
                pitch = 180;
                roll = 0;
            }
        }
        else {
            // Looking top-down with space.z.z == 1.0
            yaw = Math.atan2(-space.y.x, space.x.x);
            pitch = 0.0;
            roll = 0.0;
        }
        return {
            yaw,
            pitch,
            roll
        };
    }
    MapViewUtils.extractAttitude = extractAttitude;
    /**
     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical
     * coordinates of `object` in the tangent space of `location`.
     *
     * @param mapView - The {@link MapView} instance to consider.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     */
    function extractSphericalCoordinatesFromLocation(mapView, object, location) {
        mapView.projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        let tilt = 0;
        let azimuth = 0;
        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with
        // tangent Z.
        cache.vector3[1]
            .copy(object.position)
            .sub(cache.vector3[0])
            .normalize();
        if (cache.vector3[1].dot(tangentSpace.z) > 1 - epsilon) {
            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.
            azimuth = Math.PI - extractAttitude(mapView, object).yaw;
            // Wrap between -PI and PI.
            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));
            tilt = 0;
            return { tilt, azimuth };
        }
        tilt = cache.vector3[1].angleTo(tangentSpace.z);
        // Tilted view: the azimuth is the direction of the object from the origin.
        cache.vector3[1]
            .copy(object.position)
            .sub(cache.vector3[0])
            .projectOnPlane(tangentSpace.z)
            .normalize();
        azimuth = cache.vector3[1].angleTo(tangentSpace.y);
        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {
            azimuth = -azimuth;
        }
        return { tilt, azimuth };
    }
    MapViewUtils.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;
    /**
     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle
     * (in radians) of `object` in the tangent space of `location`.
     *
     * @param projection - The {@link @here/harp-geoutils#Projection} used when
     *                     converting from geo to world coordinates.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     */
    function extractTiltAngleFromLocation(projection, object, location) {
        projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.
        const dirVec = cache.vector3[1].copy(object.position).sub(cache.vector3[0]);
        const dirLen = dirVec.length();
        if (dirLen < epsilon) {
            logger.error("Can not calculate tilt for the zero length vector!");
            return 0;
        }
        dirVec.divideScalar(dirLen);
        const cosTheta = dirVec.dot(tangentSpace.z);
        if (cosTheta > 1 - epsilon) {
            // Top down view.
            return 0;
        }
        return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));
    }
    MapViewUtils.extractTiltAngleFromLocation = extractTiltAngleFromLocation;
    /**
     * Get perspective camera frustum planes distances.
     * @return all plane distances in helper object.
     */
    function getCameraFrustumPlanes(camera) {
        const near = camera.near;
        const far = camera.far;
        let top = (near * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov))) / camera.zoom;
        let height = 2 * top;
        let width = camera.aspect * height;
        let left = -0.5 * width;
        const view = camera.view;
        if (view !== null && view.enabled) {
            const fullWidth = view.fullWidth;
            const fullHeight = view.fullHeight;
            left += (view.offsetX * width) / fullWidth;
            top -= (view.offsetY * height) / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        // Correct by skew factor
        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;
        return {
            left,
            right: left + width,
            top,
            bottom: top - height,
            near,
            far
        };
    }
    MapViewUtils.getCameraFrustumPlanes = getCameraFrustumPlanes;
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXNDC -  Abscissa in NDC space.
     * @param pointOnScreenYNDC -  Ordinate in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    }
    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;
    /**
     * Calculates and returns the distance from the ground, which is needed to put the camera to
     * this height, to see the size of the area that would be covered by one tile for the given zoom
     * level.
     *
     * @param mapView - Instance of MapView.
     * @param options - Subset of necessary {@link MapView} properties.
     */
    function calculateDistanceToGroundFromZoomLevel(options, zoomLevel) {
        const cameraPitch = extractAttitude(options, options.camera).pitch;
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return ((options.focalLength * tileSize) / 256) * Math.cos(cameraPitch);
    }
    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    /**
     * Calculates and returns the distance to the target point.
     *
     * @param options - Necessary subset of MapView properties to compute the distance.
     * @param zoomLevel - The zoom level to get the equivalent height to.
     */
    function calculateDistanceFromZoomLevel(options, zoomLevel) {
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return (options.focalLength * tileSize) / 256;
    }
    MapViewUtils.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param distance - The distance in meters, which are scene units in {@link MapView}.
     */
    function calculateZoomLevelFromDistance(options, distance) {
        const tileSize = (256 * distance) / options.focalLength;
        const zoomLevel = THREE.MathUtils.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);
        return snapToCeilingZoomLevel(zoomLevel);
    }
    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    /**
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance, camera) {
        const perspCam = camera;
        const cameraRange = perspCam.far - perspCam.near;
        const viewSpaceDistance = clipDistance * perspCam.far;
        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    }
    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    /**
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance - Distance from the camera (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance, camera) {
        const perspCam = camera;
        return distance * perspCam.far;
    }
    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;
    /**
     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.
     *
     * @param hFov - Horizontal field of view in rad.
     * @param aspect - Aspect ratio.
     */
    function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    }
    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    /**
     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.
     *
     * @param hFov - Vertical field of view in rad.
     * @param aspect - Aspect ratio.
     */
    function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);
    }
    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    /**
     * Calculates the focal length based on the vertical FOV and height.
     *
     * @param vFov - Vertical field of view in rad.
     * @param height - Height of canvas in pixels.
     */
    function calculateFocalLengthByVerticalFov(vFov, height) {
        return height / 2 / Math.tan(vFov / 2);
    }
    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    /**
     * Calculates the vertical field of view based on the focal length and the height.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param height - Height of canvas in pixels.
     */
    function calculateFovByFocalLength(focalLength, height) {
        return THREE.MathUtils.radToDeg(2 * Math.atan(height / 2 / focalLength));
    }
    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance - Object distance in world space.
     * @param worldSize - Object size in world space.
     * @return object size in screen space.
     */
    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {
        return (focalLength * worldSize) / distance;
    }
    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance - Object distance in world space.
     * @param screenSize - Object size in screen space.
     * @return object size in world space.
     */
    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {
        return (distance * screenSize) / focalLength;
    }
    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object - The mesh object to evaluate
     * @param size - The {@link MemoryUsage} to update.
     * @param visitedObjects - Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateObject3dSize(object, parentSize, visitedObjects) {
        const size = parentSize !== undefined
            ? parentSize
            : {
                heapSize: 0,
                gpuSize: 0
            };
        if (visitedObjects === undefined) {
            visitedObjects = new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            for (const child of object.children) {
                estimateObject3dSize(child, size, visitedObjects);
            }
        }
        return size;
    }
    MapViewUtils.estimateObject3dSize = estimateObject3dSize;
    /**
     * Check if tiles or other content is currently being loaded.
     *
     * This method can be removed once HARP-7932 is implemented.
     *
     * @returns `true` if MapView has visible tiles or other content that is being loaded.
     */
    function mapViewIsLoading(mapView) {
        let numTilesLoading = 0;
        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {
            numTilesLoading += tileList.numTilesLoading;
            for (const tile of tileList.visibleTiles) {
                if (tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                    numTilesLoading++;
                }
                if (tile.tileGeometryLoader !== undefined && !tile.tileGeometryLoader.isFinished) {
                    numTilesLoading++;
                }
            }
        }
        let isLoading = numTilesLoading > 0;
        if (mapView.textElementsRenderer !== undefined) {
            isLoading = isLoading || mapView.textElementsRenderer.loading;
        }
        isLoading =
            isLoading ||
                !mapView.poiTableManager.finishedLoading ||
                !mapView.visibleTileSet.allVisibleTilesLoaded;
        return isLoading;
    }
    MapViewUtils.mapViewIsLoading = mapViewIsLoading;
    function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null || texture === undefined || texture.image === undefined) {
            return;
        }
        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        // May be HTMLImage or ImageData
        const image = texture.image;
        // Assuming RGBA
        const imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    }
    function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (material instanceof THREE.RawShaderMaterial ||
            material instanceof THREE.ShaderMaterial) {
            const rawMaterial = material;
            for (const name in rawMaterial.uniforms) {
                if (rawMaterial.uniforms[name] !== undefined) {
                    const uniform = rawMaterial.uniforms[name];
                    if (uniform instanceof THREE.Texture) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        }
        else if (material instanceof THREE.MeshBasicMaterial ||
            material instanceof harp_materials_1.MapMeshBasicMaterial) {
            const meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {
            const standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof THREE.LineBasicMaterial ||
            material instanceof THREE.LineDashedMaterial) {
            // Nothing to be done here
        }
        else {
            logger.warn("estimateMeshSize: unidentified material: ", material);
        }
    }
    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        // Attributes (apparently) do not have their uuid set up.
        if (attribute.uuid === undefined) {
            attribute.uuid = THREE.MathUtils.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        let attrBytes = 0;
        let bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (attribute instanceof THREE.InterleavedBufferAttribute ||
            attribute instanceof THREE.BufferAttribute) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    }
    function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        let bufferGeometry;
        if (geometry instanceof THREE.Geometry) {
            // Each vertex is represented as 3 floats vector (24 bytes).
            objectSize.heapSize += geometry.vertices.length * 24;
            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and
            // colors are not counted here.
            objectSize.heapSize += geometry.faces.length * (24 + 24);
            // Additionally, the internal _bufferGeometry is also counted:
            bufferGeometry = geometry._bufferGeometry;
        }
        else if (geometry instanceof THREE.BufferGeometry) {
            bufferGeometry = geometry;
        }
        if (bufferGeometry === undefined) {
            // Nothing more to calculate.
            return;
        }
        const attributes = bufferGeometry.attributes;
        if (attributes === undefined) {
            logger.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for (const property in attributes) {
            if (attributes[property] !== undefined) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (bufferGeometry.index !== null) {
            estimateAttributeSize(bufferGeometry.index, "index", objectSize, visitedObjects);
        }
    }
    function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || object instanceof THREE.Scene) {
            return;
        }
        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            // Estimated minimum impact on heap.
            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            const gpuSize = 0;
            // Cast to LodMesh class which contains the minimal required properties sub-set.
            const mesh = object;
            // Calculate material(s) impact.
            if (mesh.material !== undefined) {
                if (Array.isArray(mesh.material)) {
                    const materials = mesh.material;
                    for (const material of materials) {
                        estimateMaterialSize(material, objectSize, visitedObjects);
                    }
                }
                else {
                    const material = mesh.material;
                    estimateMaterialSize(material, objectSize, visitedObjects);
                }
            }
            // Calculate cost of geometry.
            if (mesh.geometries !== undefined) {
                for (const geometry of mesh.geometries) {
                    estimateGeometrySize(geometry, objectSize, visitedObjects);
                }
            }
            else if (mesh.geometry !== undefined) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            // Add info that is required for picking (parts of) objects and match them to
            // the featureID in the map data.
            const featureData = object.userData !== undefined
                ? object.userData.feature
                : undefined;
            if (featureData !== undefined) {
                heapSize += Tile_1.getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified object", object);
        }
    }
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages() {
        if (navigator.languages !== undefined && navigator.languages.length > 0) {
            const languageList = [];
            for (const lang of navigator.languages) {
                languageList.push(getIsoLanguageCode(lang));
            }
            return languageList;
        }
        if (navigator.language !== undefined) {
            return [getIsoLanguageCode(navigator.language)];
        }
        return undefined;
    }
    MapViewUtils.getBrowserLanguages = getBrowserLanguages;
    /**
     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)
     */
    function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    }
})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000
];
var TileOffsetUtils;
(function (TileOffsetUtils) {
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}
     *                  from which to compute the unique key.
     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset
     * @param bitshift - How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
        const shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    }
    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key - Key to extract offset and morton key.
     * @param bitshift - How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
        let offset = 0;
        let mortonCode = key;
        let i = 0;
        // Compute the offset
        for (; i < bitshift; i++) {
            // Note, we use 52, because 2^53-1 is the biggest value, the highest value
            // that can be set is the bit in the 52th position.
            const num = powerOfTwo[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += powerOfTwo[bitshift - 1 - i];
            }
        }
        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset
        offset -= powerOfTwo[bitshift - 1];
        return { offset, mortonCode };
    }
    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey - Key to decompose
     * @param bitshift - Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey, bitshift = 4) {
        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
        const parentTileKey = harp_geoutils_1.TileKey.fromMortonCode(harp_geoutils_1.TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    }
    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;
    /**
     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and
     * 2^(52-bitshift).
     *
     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really
     * matter, this is primarily used to find a unique id, if there is an offset 10, which is
     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.
     * What can be a problem though is that the cache gets filled up and isn't emptied.
     *
     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set
     * the high bits instead.
     *
     * @param offset - Offset to pack into the high bits.
     * @param offsetBits - How many bits to use to pack the offset.
     */
    function getShiftedOffset(offset, offsetBits = 4) {
        let result = 0;
        const totalOffsetsToStore = powerOfTwo[offsetBits];
        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,
        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -
        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be
        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).
        offset += totalOffsetsToStore / 2;
        while (offset < 0) {
            offset += totalOffsetsToStore;
        }
        while (offset >= totalOffsetsToStore) {
            offset -= totalOffsetsToStore;
        }
        // Offset is now a number between >= 0 and < totalOffsetsToStore
        for (let i = 0; i < offsetBits && offset > 0; i++) {
            // tslint:disable: no-bitwise
            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an
            // integer safely.
            if (offset & 0x1) {
                result += powerOfTwo[53 - offsetBits + i];
            }
            offset >>>= 1;
            // tslint:enable: no-bitwise
        }
        harp_utils_1.assert(offset === 0);
        return result;
    }
})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/VisibleTileSet.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VisibleTileSet = exports.ResourceComputationType = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "./node_modules/@here/harp-lrucache/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-mapview/lib/Utils.js");
/**
 * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If
 * it is in MB, an estimation is used.
 */
var ResourceComputationType;
(function (ResourceComputationType) {
    ResourceComputationType[ResourceComputationType["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType[ResourceComputationType["NumberOfTiles"] = 1] = "NumberOfTiles";
})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));
// Direction in quad tree to search: up -> shallower levels, down -> deeper levels.
var SearchDirection;
(function (SearchDirection) {
    SearchDirection[SearchDirection["NONE"] = 0] = "NONE";
    SearchDirection[SearchDirection["UP"] = 1] = "UP";
    SearchDirection[SearchDirection["DOWN"] = 2] = "DOWN";
    SearchDirection[SearchDirection["BOTH"] = 3] = "BOTH";
})(SearchDirection || (SearchDirection = {}));
const MB_FACTOR = 1.0 / (1024.0 * 1024.0);
/**
 * Wrapper for LRU cache that encapsulates tiles caching for any {@link DataSource} used.
 *
 * Provides LRU based caching mechanism where each tile is identified by its tile key
 * (morton code) and data source name.
 * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted
 * only when cache reaches full saturation and tile is no longer visible.
 * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and
 * data source name, thus it is required that each {@link DataSource} used should have unique
 * name, but implementation could be improved to omit this limitation.
 */
class DataSourceCache {
    constructor(cacheSize, rct = ResourceComputationType.EstimationInMb) {
        this.m_disposedTiles = [];
        this.m_resourceComputationType = rct;
        this.m_tileCache = new harp_lrucache_1.LRUCache(cacheSize, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
        this.m_tileCache.evictionCallback = (_, tile) => {
            if (tile.tileLoader !== undefined) {
                // Cancel downloads as early as possible.
                tile.tileLoader.cancel();
            }
            this.m_disposedTiles.push(tile);
        };
        this.m_tileCache.canEvict = (_, tile) => {
            // Tiles can be evicted that weren't requested in the last frame.
            return !tile.isVisible;
        };
    }
    /**
     * Creates unique tile key for caching based on morton code, tile offset and its data source.
     *
     * @param mortonCode - The tile morton code.
     * @param offset - The tile offset.
     * @param dataSource - The {@link DataSource} from which tile was loaded.
     */
    static getKey(mortonCode, offset, dataSource) {
        return `${dataSource.name}_${mortonCode}_${offset}`;
    }
    /**
     * Create unique tile identifier for caching, based on tile object passed in.
     *
     * @param tile - The tile for which key is generated.
     */
    static getKeyForTile(tile) {
        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);
    }
    /**
     * Get information how cached tiles affects cache space available.
     *
     * The way how cache evaluates the __resources size__ have a big influence on entire
     * caching mechanism, if [[resourceComputationType]] is set to:
     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size
     * differently depending on the memory consumed, on other side
     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,
     * so its real memory consumed does not matter affect caching behavior. Of course in
     * the second scenario cache may grow significantly in terms of memory usage and thus it
     * is out of control.
     *
     * @return [[ResourceComputationType]] enum that describes if resources are counted by
     * space occupied in memory or just by number of them.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Get the cache capacity measured as number if megabytes or number of entries.
     *
     * The total cached tiles size determines cache saturation, if it reaches the capacity value
     * then the resources becomes evicted (released) starting from the oldest (the latest used).
     *
     * @see size.
     * @see resourceComputationType.
     */
    get capacity() {
        return this.m_tileCache.capacity;
    }
    /**
     * Get total cache size described as number of megabytes consumed or number of tiles stored.
     *
     * @see capacity.
     * @see resourceComputationType.
     */
    get size() {
        return this.m_tileCache.size;
    }
    /**
     * Set cache capacity and the algorithm used for cache size calculation.
     *
     * @see capacity.
     * @see resourceComputationType.
     * @param size - The new capacity declared in megabytes or number of entires.
     * @param rct - The enum value that determines how size and capacity are evaluated.
     */
    setCapacity(size, rct) {
        this.m_resourceComputationType = rct;
        this.m_tileCache.setCapacityAndMeasure(size, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
    }
    /**
     * Get tile cached or __undefined__ if tile is not yet in cache.
     *
     * @param mortonCode - An unique tile morton code.
     * @param offset - Tile offset.
     * @param dataSource - A {@link DataSource} the tile comes from.
     */
    get(mortonCode, offset, dataSource) {
        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));
    }
    /**
     * Add new tile to the cache.
     *
     * @param mortonCode - En unique tile code (morton code).
     * @param offset - The tile offset.
     * @param dataSource - A {@link DataSource} the tile comes from.
     * @param tile - The tile reference.
     */
    set(mortonCode, offset, dataSource, tile) {
        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);
    }
    /**
     * Delete tile from cache.
     *
     * @note This method will not call eviction callback.
     * @param tile - The tile reference to be removed from cache.
     */
    delete(tile) {
        const tileKey = DataSourceCache.getKeyForTile(tile);
        this.deleteByKey(tileKey);
    }
    /**
     * Delete tile using its unique identifier.
     *
     * @note Tile identifier its constructed using information about tile code (morton code) and its
     * {@link DataSource}.
     * @note This is explicit removal thus eviction callback will not be processed.
     * @see DataSourceCache.getKey.
     * @param tileKey - The unique tile identifier.
     */
    deleteByKey(tileKey) {
        this.m_tileCache.delete(tileKey);
    }
    /**
     * Dispose all tiles releasing their internal data.
     */
    disposeTiles() {
        this.m_disposedTiles.forEach(tile => {
            tile.dispose();
        });
        this.m_disposedTiles.length = 0;
    }
    /**
     * Shrink cache to its allowed capacity.
     *
     * This method should be called each time after operations are performed on the cache entries,
     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory
     * consumed by its entries and check if cache is overgrown, is such case some tiles will be
     * evicted.
     */
    shrinkToCapacity() {
        this.m_tileCache.shrinkToCapacity();
    }
    /**
     * Evict all cached tiles implicitly even without checking if still in use.
     */
    evictAll() {
        this.m_tileCache.evictAll();
    }
    /**
     * Evict selected tiles implicitly.
     *
     * @param selector - The callback used to determine if tile should be evicted.
     */
    evictSelected(selector) {
        this.m_tileCache.evictSelected(selector);
    }
    /**
     * Call functor (callback) on each tile store in cache.
     *
     * Optionally you may specify from which {@link DataSource} tiles should be processed.
     * This limits the tiles visited to a sub-set originating from single {@link DataSource}.
     * @param callback - The function to be called for each visited tile.
     * @param inDataSource - The optional {@link DataSource} to which tiles should belong.
     */
    forEach(callback, inDataSource) {
        this.m_tileCache.forEach((entry, key) => {
            if (inDataSource === undefined || entry.dataSource === inDataSource) {
                callback(entry, key);
            }
        });
    }
}
/**
 * Manages visible {@link Tile}s for {@link MapView}.
 *
 * Responsible for election of rendered tiles:
 *  - quad-tree traversal
 *  - frustum culling
 *  - sorting tiles by relevance (visible area) to prioritize load
 *  - limiting number of visible tiles
 *  - caching tiles
 *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby
 *    zoom levels
 */
class VisibleTileSet {
    constructor(m_frustumIntersection, m_tileGeometryManager, options) {
        this.m_frustumIntersection = m_frustumIntersection;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.options = options;
        this.dataSourceTileList = [];
        this.allVisibleTilesLoaded = false;
        this.m_cameraOverride = new THREE.PerspectiveCamera();
        this.m_viewRange = { near: 0.1, far: Infinity, minimum: 0.1, maximum: Infinity };
        // Maps morton codes to a given Tile, used to find overlapping Tiles. We only need to have this
        // for a single TilingScheme, i.e. that of the BackgroundDataSource.
        this.m_coveringMap = new Map();
        this.m_resourceComputationType = ResourceComputationType.EstimationInMb;
        this.m_resourceComputationType =
            options.resourceComputationType === undefined
                ? ResourceComputationType.EstimationInMb
                : options.resourceComputationType;
        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);
    }
    /**
     * Returns cache size.
     */
    getDataSourceCacheSize() {
        return this.options.tileCacheSize;
    }
    /**
     * Sets cache size.
     *
     * @param size - cache size
     * @param computationType - Optional value specifying the way a {@link Tile}s cache usage is
     *      computed, either based on size in MB (mega bytes) or in number of tiles. Defaults to
     *      `ResourceComputationType.EstimationInMb`.
     */
    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {
        this.options.tileCacheSize = size;
        // This effectively invalidates DataSourceCache
        this.resourceComputationType = computationType;
    }
    /**
     * Retrieves maximum number of visible tiles.
     */
    getNumberOfVisibleTiles() {
        return this.options.maxVisibleDataSourceTiles;
    }
    /**
     * Sets maximum number of visible tiles.
     *
     * @param size - size of visible tiles array
     */
    setNumberOfVisibleTiles(size) {
        this.options.maxVisibleDataSourceTiles = size;
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Sets the way tile cache is managing its elements.
     *
     * Cache may be either keeping number of elements stored or the memory consumed by them.
     *
     * @param computationType - Type of algorith used in cache for checking full saturation,
     * may be counting number of elements or memory consumed by them.
     */
    set resourceComputationType(computationType) {
        this.m_resourceComputationType = computationType;
        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);
    }
    /**
     * Evaluate frustum near/far clip planes and visibility ranges.
     */
    updateClipPlanes(maxElevation, minElevation) {
        if (maxElevation !== undefined) {
            this.options.clipPlanesEvaluator.maxElevation = maxElevation;
        }
        if (minElevation !== undefined) {
            this.options.clipPlanesEvaluator.minElevation = minElevation;
        }
        const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;
        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(camera, projection, elevationProvider);
        return this.m_viewRange;
    }
    /**
     * Calculates a new set of visible tiles.
     * @param storageLevel - The camera storage level, see {@link MapView.storageLevel}.
     * @param zoomLevel - The camera zoom level.
     * @param dataSources - The data sources for which the visible tiles will be calculated.
     * @param elevationRangeSource - Source of elevation range data if any.
     * @returns view ranges and their status since last update (changed or not).
     */
    updateRenderList(storageLevel, zoomLevel, dataSources, elevationRangeSource) {
        let allVisibleTilesLoaded = true;
        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
        this.dataSourceTileList = [];
        this.m_coveringMap.clear();
        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {
            // Sort by distance to camera, now the tiles that are further away are at the end
            // of the list.
            //
            // Sort is unstable if distance is equal, which happens a lot when looking top-down.
            // Unstable sorting makes label placement unstable at tile borders, leading to
            // flickering.
            visibleTileKeys.sort((a, b) => {
                const distanceDiff = a.distance - b.distance;
                // Take care or numerical precision issues
                const minDiff = (a.distance + b.distance) * 0.000001;
                return Math.abs(distanceDiff) < minDiff
                    ? a.tileKey.mortonCode() - b.tileKey.mortonCode()
                    : distanceDiff;
            });
            const actuallyVisibleTiles = [];
            let allDataSourceTilesLoaded = true;
            let numTilesLoading = 0;
            // Create actual tiles only for the allowed number of visible tiles
            const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
            for (let i = 0; i < visibleTileKeys.length &&
                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
                const tileEntry = visibleTileKeys[i];
                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);
                if (tile === undefined) {
                    continue;
                }
                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
                if (!tile.allGeometryLoaded) {
                    numTilesLoading++;
                }
                else {
                    tile.numFramesVisible++;
                    // If this tile's data source is "covering" then other tiles beneath it have
                    // their rendering skipped, see [[Tile.willRender]].
                    this.skipOverlappedTiles(dataSource, tile);
                    if (tile.frameNumVisible < 0) {
                        // Store the fist frame the tile became visible.
                        tile.frameNumVisible = dataSource.mapView.frameNumber;
                    }
                }
                // Update the visible area of the tile. This is used for those tiles that are
                // currently loaded and are waiting to be decoded to sort the jobs by area.
                tile.visibleArea = tileEntry.area;
                tile.elevationRange = tileEntry;
                actuallyVisibleTiles.push(tile);
            }
            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);
            this.dataSourceTileList.push({
                dataSource,
                storageLevel,
                zoomLevel: dataZoomLevel,
                allVisibleTileLoaded: allDataSourceTilesLoaded,
                numTilesLoading,
                visibleTiles: actuallyVisibleTiles,
                renderedTiles: new Map()
            });
            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;
        }
        this.allVisibleTilesLoaded =
            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
        this.populateRenderedTiles();
        this.forEachCachedTile(tile => {
            // Remove all tiles that are still being loaded, but are no longer visible. They have to
            // be reloaded when they become visible again. Hopefully, they are still in the browser
            // cache by then.
            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {
                // The internal TileLoader is cancelled automatically when the Tile is disposed.
                this.disposeTile(tile);
            }
        });
        this.m_dataSourceCache.shrinkToCapacity();
        let minElevation;
        let maxElevation;
        this.dataSourceTileList.forEach(renderListEntry => {
            // Calculate min/max elevation from every data source tiles,
            // data sources without elevationRangeSource will contribute to
            // values with zero levels for both elevations.
            const tiles = renderListEntry.renderedTiles;
            tiles.forEach(tile => {
                tile.update(renderListEntry.zoomLevel);
                minElevation = harp_utils_1.MathUtils.min2(minElevation, tile.geoBox.minAltitude);
                maxElevation = harp_utils_1.MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);
            });
        });
        if (minElevation === undefined) {
            minElevation = 0;
        }
        if (maxElevation === undefined) {
            maxElevation = 0;
        }
        // If clip planes evaluator depends on the tiles elevation re-calculate
        // frustum planes and update the camera near/far plane distances.
        let viewRangesChanged = false;
        const oldViewRanges = this.m_viewRange;
        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);
        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;
        return {
            viewRanges: newViewRanges,
            viewRangesChanged
        };
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset, creating it if
     * necessary.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @return The tile if it was found or created, undefined otherwise.
     */
    getTile(dataSource, tileKey, offset = 0) {
        const cacheOnly = false;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the cache.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @return The tile if found in cache, undefined otherwise.
     */
    getCachedTile(dataSource, tileKey, offset = 0) {
        harp_utils_1.assert(dataSource.cacheable);
        const cacheOnly = true;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTile(dataSource, tileKey, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        return dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset));
    }
    /**
     * Gets the tile corresponding to the given data source and location from the rendered tiles.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param geoPoint - The geolocation included within the tile.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        const tilingScheme = dataSource.getTilingScheme();
        const visibleLevel = dataSourceVisibleTileList.zoomLevel;
        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);
        if (!visibleTileKey) {
            return undefined;
        }
        let tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));
        if (tile !== undefined) {
            return tile;
        }
        const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(dataSource, visibleLevel);
        let parentTileKey = visibleTileKey;
        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {
            parentTileKey = parentTileKey.parent();
            tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));
            if (tile !== undefined) {
                return tile;
            }
        }
        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);
        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {
            const childLevel = visibleLevel + levelOffset;
            const childTileKey = harp_geoutils_1.TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);
            if (childTileKey) {
                tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset));
                if (tile !== undefined) {
                    return tile;
                }
            }
        }
        return undefined;
    }
    /**
     * Removes all internal bookkeeping entries and cache related to specified datasource.
     *
     * Called by {@link MapView} when {@link DataSource} has been removed from {@link MapView}.
     */
    removeDataSource(dataSource) {
        this.clearTileCache(dataSource);
        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource !== dataSource);
    }
    /**
     * Clear the tile cache.
     *
     * Remove the {@link Tile} objects created by cacheable {@link DataSource}.
     * If a {@link DataSource} name is
     * provided, this method restricts the eviction
     * the {@link DataSource} with the given name.
     *
     * @param dataSourceName - The name of the {@link DataSource}.
     */
    clearTileCache(dataSource) {
        if (dataSource !== undefined) {
            this.m_dataSourceCache.evictSelected((tile, _) => {
                return tile.dataSource === dataSource;
            });
        }
        else {
            this.m_dataSourceCache.evictAll();
        }
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance
     *      are processed. If `undefined`, tiles from all {@link DataSource}s are processed.
     */
    markTilesDirty(dataSource) {
        if (dataSource === undefined) {
            this.dataSourceTileList.forEach(renderListEntry => {
                this.markDataSourceTilesDirty(renderListEntry);
            });
        }
        else {
            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);
            if (renderListEntry === undefined) {
                return;
            }
            this.markDataSourceTilesDirty(renderListEntry);
        }
    }
    /**
     * Dispose tiles that are marked for removal by {@link @here/harp-lrucache#LRUCache} algorithm.
     */
    disposePendingTiles() {
        this.m_dataSourceCache.disposeTiles();
    }
    /**
     * Process callback function [[fun]] with each visible tile in set.
     *
     * @param fun - The callback function to be called.
     */
    forEachVisibleTile(fun) {
        for (const listEntry of this.dataSourceTileList) {
            listEntry.renderedTiles.forEach(fun);
        }
    }
    /**
     * Process callback function [[fun]] with each tile in the cache.
     *
     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to
     * DataSource passed in.
     *
     * @param fun - The callback function to be called.
     * @param dataSource - The optional DataSource reference for tiles selection.
     */
    forEachCachedTile(fun, dataSource) {
        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);
    }
    /**
     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.
     */
    disposeTile(tile) {
        // TODO: Consider using evict here!
        this.m_dataSourceCache.delete(tile);
        tile.dispose();
    }
    /**
     * Skips rendering of tiles that are overlapped. The overlapping {@link Tile} comes from a
     * {@link DataSource} which is fully covering, i.e. there it is fully opaque.
     **/
    skipOverlappedTiles(dataSource, tile) {
        if (this.options.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // HARP-7899, currently the globe has no background planes in the tiles (it relies on
            // the BackgroundDataSource), because the LOD mismatches, hence disabling for globe.
            return;
        }
        if (dataSource.isFullyCovering()) {
            const key = tile.uniqueKey;
            const entry = this.m_coveringMap.get(key);
            if (entry === undefined) {
                // We need to reset the flag so that if the covering datasource is disabled, that
                // the tiles beneath then start to render.
                tile.skipRendering = false;
                this.m_coveringMap.set(key, tile);
            }
            else {
                // Skip the Tile if either the stored entry or the tile to consider is from the
                // [[BackgroundDataSource]]
                if (entry.dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {
                    entry.skipRendering = true;
                }
                else if (dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {
                    tile.skipRendering = true;
                }
            }
        }
    }
    // Returns the search direction and the number of levels up / down that can be searched.
    getSearchDirection(dataSource, visibleLevel) {
        const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minDataLevel));
        const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxDataLevel - visibleLevel));
        const searchDirection = searchLevelsDown > 0 && searchLevelsUp > 0
            ? SearchDirection.BOTH
            : searchLevelsDown > 0
                ? SearchDirection.DOWN
                : searchLevelsUp > 0
                    ? SearchDirection.UP
                    : SearchDirection.NONE;
        return { searchDirection, searchLevelsUp, searchLevelsDown };
    }
    /**
     * Populates the list of tiles to render, see "renderedTiles". Tiles that are loaded and which
     * are an exact match are added straight to the list, tiles that are still loading are replaced
     * with tiles in the cache that are either a parent or child of the requested tile. This helps
     * to prevent flickering when zooming in / out. The distance to search is based on the options
     * [[quadTreeSearchDistanceDown]] and [[quadTreeSearchDistanceUp]].
     *
     * Each {@link DataSource} can also switch this behaviour on / off using the
     * [[allowOverlappingTiles]] flag.
     *
     */
    populateRenderedTiles() {
        this.dataSourceTileList.forEach(renderListEntry => {
            const renderedTiles = renderListEntry.renderedTiles;
            // Tiles for which we need to fall(back/forward) to.
            const incompleteTiles = [];
            // Populate the list of tiles which can be shown ("renderedTiles"), and the list of
            // tiles that are incomplete, and for which we search for an alternative
            // ("incompleteTiles").
            renderListEntry.visibleTiles.forEach(tile => {
                tile.levelOffset = 0;
                if (tile.hasGeometry) {
                    renderedTiles.set(tile.uniqueKey, tile);
                }
                else {
                    // if dataSource supports cache and it was existing before this render
                    // then enable searching for loaded tiles in cache
                    incompleteTiles.push(tile.uniqueKey);
                }
            });
            const dataSource = renderListEntry.dataSource;
            if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {
                // Either all tiles are loaded or the datasource doesn't support using cached tiles
                // from other levels.
                return;
            }
            const dataZoomLevel = renderListEntry.zoomLevel;
            const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);
            // Minor optimization for the fallback search, only check parent tiles once, otherwise
            // the recursive algorithm checks all parent tiles multiple times, the key is the code
            // of the tile that is checked and the value is whether a parent was found or not.
            const checkedTiles = new Map();
            // Iterate over incomplete (not loaded tiles) and find their parents or children that
            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour
            // falling back to parent tiles rather than children.
            for (const tileKeyCode of incompleteTiles) {
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.UP) {
                    if (this.findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource)) {
                        // Continue to next entry so we don't search down.
                        continue;
                    }
                }
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.DOWN) {
                    this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);
                }
            }
        });
    }
    findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource) {
        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const tilingScheme = dataSource.getTilingScheme();
        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
            const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);
            const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);
            if (childTile !== undefined && childTile.hasGeometry) {
                // childTile has geometry, so can be reused as fallback
                renderedTiles.set(childTileCode, childTile);
                childTile.levelOffset = nextLevelDiff;
                continue;
            }
            // Recurse down until the max distance is reached.
            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);
            }
        }
    }
    /**
     * Returns true if a tile was found in the cache which is a parent
     * @param tileKeyCode - Morton code of the current tile that should be searched for.
     * @param dataZoomLevel - The current data zoom level of tiles that are to be displayed.
     * @param renderedTiles - The list of tiles that are shown to the user.
     * @param checkedTiles - Used to map a given code to a boolean which tells us if an ancestor is
     * displayed or not.
     * @param dataSource - The provider of tiles.
     * @returns Whether a parent tile exists.
     */
    findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource) {
        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);
        // Check if another sibling has already added the parent.
        if (renderedTiles.get(parentCode) !== undefined) {
            return true;
        }
        const exists = checkedTiles.get(parentCode);
        if (exists !== undefined) {
            return exists;
        }
        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);
        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);
        const parentTileKey = parentTile ? parentTile.tileKey : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);
        if (parentTile !== undefined && parentTile.hasGeometry) {
            checkedTiles.set(parentCode, true);
            // parentTile has geometry, so can be reused as fallback
            renderedTiles.set(parentCode, parentTile);
            // We want to have parent tiles as -ve, hence the minus.
            parentTile.levelOffset = -nextLevelDiff;
            return true;
        }
        else {
            checkedTiles.set(parentCode, false);
        }
        // Recurse up until the max distance is reached or we go to the parent of all parents.
        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {
            const foundUp = this.findUp(parentCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource);
            // If there was a tile upstream found, then add it to the list, so we can
            // early skip checkedTiles.
            checkedTiles.set(parentCode, foundUp);
            if (foundUp) {
                return true;
            }
        }
        return false;
    }
    getTileImpl(dataSource, tileKey, offset, cacheOnly) {
        function updateTile(tileToUpdate) {
            if (tileToUpdate === undefined) {
                return;
            }
            // Keep the tile from being removed from the cache.
            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;
        }
        if (!dataSource.cacheable && !cacheOnly) {
            const resultTile = dataSource.getTile(tileKey);
            updateTile(resultTile);
            return resultTile;
        }
        const tileCache = this.m_dataSourceCache;
        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);
        if (tile !== undefined && tile.offset === offset) {
            updateTile(tile);
            return tile;
        }
        if (cacheOnly) {
            return undefined;
        }
        tile = dataSource.getTile(tileKey);
        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry
        if (tile !== undefined) {
            tile.offset = offset;
            updateTile(tile);
            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);
            this.m_tileGeometryManager.initTile(tile);
        }
        return tile;
    }
    markDataSourceTilesDirty(renderListEntry) {
        const dataSourceCache = this.m_dataSourceCache;
        const retainedTiles = new Set();
        function markTileDirty(tile, tileGeometryManager) {
            const tileKey = DataSourceCache.getKeyForTile(tile);
            if (!retainedTiles.has(tileKey)) {
                retainedTiles.add(tileKey);
                if (tile.tileGeometryLoader !== undefined) {
                    tile.tileGeometryLoader.reset();
                }
                // Prevent label rendering issues when the style set is changing. Prevent Text
                // element rendering that depends on cleaned font catalog data.
                tile.clearTextElements();
                tile.load();
            }
        }
        renderListEntry.visibleTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        renderListEntry.renderedTiles.forEach(tile => {
            markTileDirty(tile, this.m_tileGeometryManager);
        });
        dataSourceCache.forEach((tile, key) => {
            if (!retainedTiles.has(key)) {
                dataSourceCache.deleteByKey(key);
                tile.dispose();
            }
        }, renderListEntry.dataSource);
    }
    // Computes the visible tile keys for each supplied data source.
    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
        const tileKeys = Array();
        let allBoundingBoxesFinal = true;
        if (dataSources.length === 0) {
            return { tileKeys, allBoundingBoxesFinal };
        }
        const dataSourceBuckets = new Map();
        dataSources.forEach(dataSource => {
            const tilingScheme = dataSource.getTilingScheme();
            const bucket = dataSourceBuckets.get(tilingScheme);
            if (bucket === undefined) {
                dataSourceBuckets.set(tilingScheme, [dataSource]);
            }
            else {
                bucket.push(dataSource);
            }
        });
        // If elevation is to be taken into account extend view frustum:
        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that
        // are far below ground plane and high enough to intersect the frustum.
        if (elevationRangeSource !== undefined) {
            this.m_cameraOverride.copy(this.m_frustumIntersection.camera);
            this.m_cameraOverride.near = Math.min(this.m_cameraOverride.near, this.m_viewRange.minimum);
            this.m_cameraOverride.far = Math.max(this.m_cameraOverride.far, this.m_viewRange.maximum);
            this.m_cameraOverride.updateProjectionMatrix();
            this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);
        }
        else {
            this.m_frustumIntersection.updateFrustum();
        }
        // For each bucket of data sources with same tiling scheme, calculate frustum intersection
        // once using the maximum display level.
        for (const [tilingScheme, bucket] of dataSourceBuckets) {
            const zoomLevels = bucket.map(dataSource => dataSource.getDataZoomLevel(zoomLevel));
            const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);
            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
            for (const dataSource of bucket) {
                // For each data source check what tiles from the intersection should be rendered
                // at this zoom level.
                const visibleTileKeys = [];
                const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
                for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel).values()) {
                    if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {
                        visibleTileKeys.push(tileKeyEntry);
                    }
                }
                tileKeys.push({ dataSource, visibleTileKeys });
            }
        }
        return { tileKeys, allBoundingBoxesFinal };
    }
}
exports.VisibleTileSet = VisibleTileSet;
function viewRangesEqual(a, b) {
    return (a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near);
}
//# sourceMappingURL=VisibleTileSet.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerBasedDecoder = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
/**
 * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Decoder based on [[ConcurrentWorkerSet]].
 *
 * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends decode requests,
 * - configuration.
 */
class WorkerBasedDecoder {
    /**
     * Creates a new `WorkerBasedDecoder`.
     *
     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.
     * @param decoderServiceType - Service type identifier.
     */
    constructor(workerSet, decoderServiceType) {
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tile decoder services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.decoderServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Get {@link Tile} from tile decoder service in worker.
     *
     * @remarks
     * Invokes {@link @here/harp-datasource-protocol#DecodeTileRequest} on
     * [[TileDecoderService]] running in worker pool.
     */
    decodeTile(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Get {@link @here/harp-datasource-protocol#TileInfo} from tile decoder service in worker.
     *
     * @remarks
     * Invokes {@link @here/harp-datasource-protocol#TileInfoRequest}
     * on [[TileDecoderService]] running in worker pool.
     */
    getTileInfo(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Configure tile decoder service in workers.
     *
     * @remarks
     * Broadcasts {@link @here/harp-datasource-protocol#ConfigurationMessage}
     * to all [[TileDecoderService]]s running in worker pool.
     *
     * @param styleSet -  new [[StyleSet]], undefined means no change
     * @param languages - new list of languages
     * @param options -   new options, undefined options are not changed
     */
    configure(styleSet, definitions, languages, options) {
        const message = {
            service: this.serviceId,
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration,
            styleSet,
            definitions,
            options,
            languages
        };
        this.workerSet.broadcastMessage(message);
    }
    /**
     * The number of workers started for this decoder. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.workerSet.workerCount;
    }
}
exports.WorkerBasedDecoder = WorkerBasedDecoder;
//# sourceMappingURL=WorkerBasedDecoder.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerBasedTiler = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
/**
 * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Tiler based on [[ConcurrentWorkerSet]].
 *
 * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends tile requests,
 * - configuration.
 */
class WorkerBasedTiler {
    /**
     * Creates a new `WorkerBasedTiler`.
     *
     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.
     * @param tilerServiceType - Service type identifier.
     */
    constructor(workerSet, tilerServiceType) {
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tiler services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TilerService]]s in all workers to serve tiling requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.tilerServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId - Index identifier.
     * @param input - Url to the index payload, or direct GeoJSON.
     */
    registerIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId - Index identifier.
     * @param input - Url to the index payload, or direct GeoJSON.
     */
    updateIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Retrieves a tile for a previously registered index.
     *
     * @param indexId - Index identifier.
     * @param tileKey - The {@link @here/harp-geoutils#TileKey} that identifies the tile.
     */
    getTile(indexId, tileKey) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,
            index: indexId,
            tileKey: tileKeyCode
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
}
exports.WorkerBasedTiler = WorkerBasedTiler;
//# sourceMappingURL=WorkerBasedTiler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LowResRenderPass = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
/**
 * The `LowResRenderPass` renders the scene at a lower resolution into an internal
 * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal
 * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.
 *
 * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be
 * visible.
 */
class LowResRenderPass extends Pass_1.Pass {
    /**
     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at
     * a quad.
     *
     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     */
    constructor(lowResPixelRatio) {
        super();
        this.lowResPixelRatio = lowResPixelRatio;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_savedWidth = 0;
        this.m_savedHeight = 0;
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
        this.m_pixelRatio = lowResPixelRatio;
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        this.m_quadMaterial.dispose();
        this.m_quad.geometry.dispose();
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     *
     * @default `undefined`
     */
    set pixelRatio(ratio) {
        this.m_pixelRatio = ratio;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
        }
    }
    get pixelRatio() {
        return this.m_pixelRatio;
    }
    /**
     * The render function of `LowResRenderPass`. It renders the whole scene into an internal
     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.
     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it
     * is the screen.
     *
     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene - The ThreeJS Scene instance to render the scene with.
     * @param camera - The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.
     * @override
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled || this.pixelRatio === undefined) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_savedWidth = readBuffer.width;
            this.m_savedHeight = readBuffer.height;
            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                depthBuffer: true,
                stencilBuffer: true
            });
            this.m_renderTarget.texture.name = "LowResRenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        this.m_quadUniforms.opacity.value = 1.0;
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.m_renderTarget);
        renderer.clear();
        // Render into the low resolution internal render target.
        renderer.render(scene, camera);
        // Render the low resolution target into the screen.
        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.clear();
        renderer.render(this.m_quadScene, this.m_localCamera);
        renderer.setRenderTarget(oldRenderTarget);
    }
    /**
     * Resize the internal render target to match the new size specified. The size of internal
     * buffer depends on the `pixelRatio`.
     *
     * @param width - New width to apply to the render target.
     * @param height - New height to apply to the render target.
     * @override
     */
    setSize(width, height) {
        this.m_savedWidth = width;
        this.m_savedHeight = height;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
        }
    }
}
exports.LowResRenderPass = LowResRenderPass;
//# sourceMappingURL=LowResRenderPass.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MSAARenderPass = exports.MSAASampling = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
/**
 * This enum represents the sampling level to apply to
 * a {@link MSAARenderPass} instance. At level 0,
 * only one sample is performed, which is like
 * disabling the MSAA pass.
 */
var MSAASampling;
(function (MSAASampling) {
    MSAASampling[MSAASampling["Level_0"] = 0] = "Level_0";
    MSAASampling[MSAASampling["Level_1"] = 1] = "Level_1";
    MSAASampling[MSAASampling["Level_2"] = 2] = "Level_2";
    MSAASampling[MSAASampling["Level_3"] = 3] = "Level_3";
    MSAASampling[MSAASampling["Level_4"] = 4] = "Level_4";
    MSAASampling[MSAASampling["Level_5"] = 5] = "Level_5";
})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));
/**
 * {@link MapView}'s MSAA implementation.
 *
 * @remarks
 * MSAA stands for Multi Sampling Anti-Aliasing, and its concept
 * is to provide a rendering engine with additional color values for each pixel, so they can include
 * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation
 * with four samples. Because of its native nature, it is more efficient and one may not want to use
 * MapView's MSAA implementation when these four samples are satisfying. However in some situations
 * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the
 * number of samples at runtime. On the other hand, when the interaction stops, the engine also
 * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then
 * turn very noticeable. In such static renders, the number of samples could be dramatically
 * increased on a last frame to render.
 */
let MSAARenderPass = /** @class */ (() => {
    class MSAARenderPass extends Pass_1.Pass {
        /**
         * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a
         * quad.
         *
         * @param m_scene - The scene to render.
         * @param m_camera - The camera to render the scene through.
         */
        constructor() {
            super();
            /**
             * The sampling level determines the number of samples that will be performed per frame.
             * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.
             * Therefore there can be between 1 and 32 samples.
             *
             * @default `SamplingLevel.Level_1`
             */
            this.samplingLevel = MSAASampling.Level_1;
            this.m_renderTarget = null;
            this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            this.m_quadScene = new THREE.Scene();
            this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
            this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);
            this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
            this.m_quad.frustumCulled = false;
            this.m_quadScene.add(this.m_quad);
        }
        /**
         * Releases all used resources.
         */
        dispose() {
            if (this.m_renderTarget !== null) {
                this.m_renderTarget.dispose();
                this.m_renderTarget = null;
            }
        }
        /**
         * The render function of `MSAARenderPass`.
         *
         * @remarks
         * At each call of this method, and for each sample the {@link MapView}
         * camera provided in the `render method is offset within the dimension of a
         * pixel on screen. It then renders the whole scene with this offset to a local
         * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera
         * created in the constructor shoots the quad and renders to the write buffer or to the frame
         * buffer. The quad material's opacity is modified so the renders can accumulate in the
         * targetted buffer.
         *
         * The number of samples can be modified at runtime through the enum [[SamplingLevel]].
         *
         * If there is no further pass, the {@link Pass.renderToScreen} flag can be set to `true` to
         * output directly to the framebuffer.
         *
         * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.
         * @param scene - The ThreeJS Scene instance to render the scene with.
         * @param camera - The ThreeJS Camera instance to render the scene with.
         * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.
         * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.
         * @override
         */
        render(renderer, scene, camera, writeBuffer, readBuffer) {
            if (!this.enabled) {
                return;
            }
            // Initiates the local render target with the read buffer's dimensions, if not available.
            if (this.m_renderTarget === null) {
                this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                });
                this.m_renderTarget.texture.name = "MSAARenderPass.sample";
            }
            this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
            const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];
            const rendererClearColor = renderer.getClearColor();
            const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
            // The method `camera.setViewOffset` will be called in the next loop. In order to maintain
            // its usability externally (like for the triple view in mosaic demo) we must cache the
            // previous values stored in `camera.view` and re-assign them at the end of the pass.
            // 1. Create a default cache object, with default dimensions the size of our read buffer.
            const oldView = {
                enabled: camera.view !== null && camera.view.enabled,
                fullWidth: readBuffer.width,
                fullHeight: readBuffer.height,
                x: 0,
                y: 0,
                width: readBuffer.width,
                height: readBuffer.height
            };
            // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called
            // externally: copy the existing `camera.view` values in the cache. Override the cache
            // object with the values provided externally.
            if (oldView.enabled && camera.view !== null) {
                oldView.fullWidth = camera.view.fullWidth;
                oldView.fullHeight = camera.view.fullHeight;
                oldView.x = camera.view.offsetX;
                oldView.y = camera.view.offsetY;
                oldView.width = camera.view.width;
                oldView.height = camera.view.height;
            }
            const oldRenderTarget = renderer.getRenderTarget();
            for (let i = 0; i < offsets.length; i++) {
                // 4. Then for each sample, call `setViewOffset` with our object. This also updates the
                // `camera.view` object in Three.js.
                const offset = offsets[i];
                camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
                // 5. Divide the opacity of the quad by the number of samples to accumulate on the
                // target buffer, and reduce the impact of the offset on color to reduce banding. Then
                // render.
                const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
                const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;
                this.m_quadUniforms.opacity.value = sampleWeight;
                renderer.setRenderTarget(this.m_renderTarget);
                renderer.clear();
                renderer.render(scene, camera);
                // 6. Render the quad on top of the previous renders.
                // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
                renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                if (i === 0) {
                    renderer.setClearColor(0x000000);
                    renderer.clear();
                }
                renderer.render(this.m_quadScene, this.m_localCamera);
                if (i === 0 && rendererClearColor !== undefined) {
                    renderer.setClearColor(oldClearColor);
                }
            }
            renderer.setRenderTarget(oldRenderTarget);
            // 7. Restore `camera.view` as set externally (or not).
            if (camera.view !== null) {
                camera.view.enabled = oldView.enabled;
                camera.view.offsetX = oldView.x;
                camera.view.offsetY = oldView.y;
            }
        }
        /**
         * Resize the internal render target to match the new size specified.
         *
         * @param width - New width to apply to the render target.
         * @param height - New height to apply to the render target.
         * @override
         */
        setSize(width, height) {
            if (this.m_renderTarget) {
                this.m_renderTarget.setSize(width, height);
            }
        }
    }
    // tslint:disable:max-line-length
    /**
     * The list of offsets to apply to the camera, per sampling level, adapted from :
     *
     * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
     */
    // tslint:enable:max-line-length
    // tslint:disable-next-line:member-ordering
    MSAARenderPass.OffsetVectors = [
        [[0, 0]],
        [
            [4, 4],
            [-4, -4]
        ],
        [
            [-2, -6],
            [6, -2],
            [-6, 2],
            [2, 6]
        ],
        [
            [1, -3],
            [-1, 3],
            [5, 1],
            [-3, -5],
            [-5, 5],
            [-7, -1],
            [3, 7],
            [7, -7]
        ],
        [
            [1, 1],
            [-1, -3],
            [-3, 2],
            [4, -1],
            [-5, -2],
            [2, 5],
            [5, 3],
            [3, -5],
            [-2, 6],
            [0, -7],
            [-4, -6],
            [-6, 4],
            [-8, 0],
            [7, -4],
            [6, 7],
            [-7, -8]
        ],
        [
            [-4, -7],
            [-7, -5],
            [-3, -5],
            [-5, -4],
            [-1, -4],
            [-2, -2],
            [-6, -1],
            [-4, 0],
            [-7, 1],
            [-1, 2],
            [-6, 3],
            [-3, 3],
            [-7, 6],
            [-3, 6],
            [-5, 7],
            [-1, 7],
            [5, -7],
            [1, -6],
            [6, -5],
            [4, -4],
            [2, -3],
            [7, -2],
            [1, -1],
            [4, -1],
            [2, 1],
            [6, 2],
            [0, 4],
            [4, 4],
            [2, 5],
            [7, 5],
            [5, 6],
            [3, 7]
        ]
    ];
    return MSAARenderPass;
})();
exports.MSAARenderPass = MSAARenderPass;
//# sourceMappingURL=MSAARenderPass.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MapRenderingManager = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js");
const MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js");
const Outline_1 = __webpack_require__(/*! ./Outline */ "./node_modules/@here/harp-mapview/lib/composing/Outline.js");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
const UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js");
const DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;
const DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;
/**
 * The implementation of {@link IMapRenderingManager} to
 * instantiate in {@link MapView} and manage the map
 * rendering.
 */
class MapRenderingManager {
    /**
     * The constructor of `MapRenderingManager`.
     *
     * @param width - Width of the frame buffer.
     * @param height - Height of the frame buffer.
     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     * @param antialiasSetting - The object defining the demeanor of MSAA.
     */
    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {
        this.bloom = {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        };
        this.outline = {
            enabled: false,
            thickness: 0.005,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        };
        this.vignette = {
            enabled: false,
            offset: 1.0,
            darkness: 1.0
        };
        this.sepia = {
            enabled: false,
            amount: 0.5
        };
        this.m_width = 1;
        this.m_height = 1;
        this.m_renderPass = new Pass_1.RenderPass();
        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);
        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);
        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);
        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);
        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();
        this.m_msaaPass.enabled =
            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel =
            antialiasSettings.dynamicMsaaSamplingLevel === undefined
                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel =
            antialiasSettings.staticMsaaSamplingLevel === undefined
                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;
    }
    updateOutline(options) {
        this.outline.color = options.color;
        this.outline.thickness = options.thickness;
        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
        this.outline.needsUpdate = true;
    }
    /**
     * The method to call to render the map with the `MapRenderingManager` instance. It contains the
     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering
     * conditions as disabling AA when a high DPI device is in use.
     *
     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.
     * @param scene - The ThreeJS Scene instance containing the map objects to render.
     * @param camera - The ThreeJS Camera instance to render the scene through.
     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of
     * antialiasing.
     */
    render(renderer, scene, camera, isStaticFrame) {
        const target = null;
        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {
            // Not designed to be combined with our own MSAA
            this.m_lowResPass.renderToScreen = true;
            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
            return;
        }
        const usePostEffects = this.bloom.enabled ||
            this.outline.enabled ||
            this.vignette.enabled ||
            this.sepia.enabled;
        let activeTarget = null;
        // 1. If the bloom is enabled, clear the depth.
        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
            renderer.setRenderTarget(this.m_target1);
            renderer.clearDepth();
        }
        // 2. Render the map.
        if (this.m_msaaPass.enabled) {
            // Use a higher MSAA sampling level for static rendering.
            this.m_msaaPass.samplingLevel = isStaticFrame
                ? this.m_staticMsaaSamplingLevel
                : this.m_dynamicMsaaSamplingLevel;
            // MSAA is the only effect for the moment.
            this.m_msaaPass.renderToScreen = !usePostEffects;
            // Render to the specified target with the MSAA pass.
            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
        }
        else {
            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                activeTarget = this.m_target1;
                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
            }
            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {
                renderer.render(scene, camera);
            }
        }
        // 3. Apply effects
        if (this.outline.enabled) {
            if (this.m_outlineEffect === undefined) {
                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);
            }
            if (this.outline.needsUpdate) {
                this.m_outlineEffect.color = this.outline.color;
                this.m_outlineEffect.thickness = this.outline.thickness;
                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                this.outline.needsUpdate = false;
            }
            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
            if (nextEffectEnabled) {
                activeTarget = this.m_target1;
            }
            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
            this.m_outlineEffect.render(scene, camera);
        }
        if (this.bloom.enabled) {
            if (this.m_bloomPass === undefined) {
                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
            }
            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
            this.m_bloomPass.renderToScreen = !nextEffectEnabled;
            this.m_bloomPass.radius = this.bloom.radius;
            this.m_bloomPass.strength = this.bloom.strength;
            this.m_bloomPass.threshold = this.bloom.threshold;
            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
        }
        else if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.dispose();
            this.m_bloomPass = undefined;
        }
        if (this.vignette.enabled) {
            const oldTarget = activeTarget;
            const nextEffectEnabled = this.sepia.enabled;
            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
            this.m_vignettePass.renderToScreen = !nextEffectEnabled;
            if (nextEffectEnabled) {
                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
            }
            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
        }
        if (this.sepia.enabled) {
            this.m_sepiaPass.renderToScreen = true;
            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
        }
    }
    /**
     * The resize function to call on resize events to resize the render targets. It shall include
     * the resize methods of all the sub-passes used in `MapRenderingManager`.
     *
     * @param width - New width to use.
     * @param height - New height to use.
     */
    setSize(width, height) {
        this.m_readBuffer.setSize(width, height);
        this.m_msaaPass.setSize(width, height);
        if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.setSize(width, height);
        }
        this.m_lowResPass.setSize(width, height);
        this.m_target1.setSize(width, height);
        this.m_target2.setSize(width, height);
        this.m_width = width;
        this.m_height = height;
    }
    /**
     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values
     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of
     * `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     */
    get lowResPixelRatio() {
        return this.m_lowResPass.pixelRatio;
    }
    set lowResPixelRatio(pixelRatio) {
        this.m_lowResPass.pixelRatio = pixelRatio;
        this.m_lowResPass.enabled = pixelRatio !== undefined;
    }
    /**
     * Set the level of sampling while the user interacts.
     *
     * @param samplingLevel - The sampling level.
     */
    set dynamicMsaaSamplingLevel(samplingLevel) {
        this.m_dynamicMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined during continuous rendering.
     */
    get dynamicMsaaSamplingLevel() {
        return this.m_dynamicMsaaSamplingLevel;
    }
    /**
     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided
     * in the {@link MapRenderingManager.render} method to render the scene.
     *
     * @param value - If `true`, MSAA is enabled, disabled otherwise.
     */
    set msaaEnabled(value) {
        this.m_msaaPass.enabled = value;
    }
    /**
     * Return whether the MSAA is enabled.
     */
    get msaaEnabled() {
        return this.m_msaaPass.enabled;
    }
    /**
     * Set the sampling level for rendering static frames.
     *
     * @param samplingLevel - The sampling level.
     */
    set staticMsaaSamplingLevel(samplingLevel) {
        this.m_staticMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined for rendering static frames.
     */
    get staticMsaaSamplingLevel() {
        return this.m_staticMsaaSamplingLevel;
    }
}
exports.MapRenderingManager = MapRenderingManager;
//# sourceMappingURL=MapRenderingManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Outline.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Outline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutlineEffect = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const vertexShaderChunk = `
#ifdef USE_EXTRUSION
  #ifndef HAS_EXTRUSION_PARS_VERTEX
    #include <extrusion_pars_vertex>
  #endif
#endif

#ifdef USE_FADING
  #include <fading_pars_vertex>
#endif

uniform float outlineThickness;

vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {
    float thickness = outlineThickness;
    const float ratio = 1.0;
    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
    vec4 norm = normalize( pos - pos2 );
    return pos + norm * thickness * pos.w * ratio;
}`;
const vertexShaderChunk2 = `
#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )
    #ifndef USE_ENVMAP
        vec3 objectNormal = normalize( normal );
    #endif
#endif

#ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif

#ifdef DECLARE_TRANSFORMED
    vec3 transformed = vec3( position );
#endif

#ifdef USE_EXTRUSION
 #ifndef HAS_EXTRUSION_VERTEX
  #include <extrusion_vertex>
 #endif
#endif

#ifdef USE_FADING
  #include <fading_vertex>
#endif

#ifdef USE_EXTRUSION
  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),
      objectNormal, vec4( transformed, 1.0 ) );
#else
  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );
#endif

#include <fog_vertex>`;
const fragmentShader = `
#include <common>
#include <fog_pars_fragment>

#ifdef USE_EXTRUSION
  #include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
  #include <fading_pars_fragment>
#endif

uniform vec3 outlineColor;
uniform float outlineAlpha;

void main() {

    gl_FragColor = vec4( outlineColor, outlineAlpha );

    #include <fog_fragment>

    #ifdef USE_EXTRUSION
      #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
      #include <fading_fragment>
    #endif
}`;
/**
 * Effect to render bold lines around extruded polygons.
 *
 * Implemented by rendering the mesh geometries with an outline material before rendering them
 * again with their original.
 */
class OutlineEffect {
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.enabled = true;
        this.m_defaultThickness = 0.02;
        this.m_defaultColor = new THREE.Color(0, 0, 0);
        this.m_defaultAlpha = 1;
        this.m_defaultKeepAlive = false;
        this.m_ghostExtrudedPolygons = false;
        this.m_cache = {};
        this.m_removeThresholdCount = 60;
        this.m_originalMaterials = {};
        this.m_originalOnBeforeRenders = {};
        this.m_shaderIDs = {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        };
        this.m_uniformsChunk = {
            outlineThickness: { value: this.m_defaultThickness },
            outlineColor: { value: this.m_defaultColor },
            outlineAlpha: { value: this.m_defaultAlpha }
        };
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    set thickness(thickness) {
        this.m_defaultThickness = thickness;
        this.m_uniformsChunk.outlineThickness.value = thickness;
        this.m_cache = {};
    }
    set color(color) {
        this.m_defaultColor.set(color);
        this.m_cache = {};
    }
    set ghostExtrudedPolygons(ghost) {
        this.m_ghostExtrudedPolygons = ghost;
    }
    clear(color, depth, stencil) {
        this.m_renderer.clear(color, depth, stencil);
    }
    getPixelRatio() {
        return this.m_renderer.getPixelRatio();
    }
    setPixelRatio(value) {
        this.m_renderer.setPixelRatio(value);
    }
    getSize(target) {
        return this.m_renderer.getSize(target);
    }
    setSize(width, height, updateStyle) {
        this.m_renderer.setSize(width, height, updateStyle);
    }
    setViewport(x, y, width, height) {
        this.m_renderer.setViewport(x, y, width, height);
    }
    setScissor(x, y, width, height) {
        this.m_renderer.setScissor(x, y, width, height);
    }
    setScissorTest(boolean) {
        this.m_renderer.setScissorTest(boolean);
    }
    setRenderTarget(renderTarget) {
        this.m_renderer.setRenderTarget(renderTarget);
    }
    render(scene, camera) {
        // Re-rendering the scene with the outline effect enables to hide the
        // extruded polygons and show only the outlines (it is a hack and should be
        // implemented another way!).
        if (this.m_ghostExtrudedPolygons) {
            if (!this.enabled) {
                this.m_renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = this.m_renderer.autoClear;
            this.m_renderer.autoClear = this.autoClear;
            this.m_renderer.render(scene, camera);
            this.m_renderer.autoClear = currentAutoClear;
        }
        this.renderOutline(scene, camera);
    }
    renderOutline(scene, camera) {
        const currentAutoClear = this.m_renderer.autoClear;
        const currentSceneAutoUpdate = scene.autoUpdate;
        const currentSceneBackground = scene.background;
        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        this.m_renderer.autoClear = false;
        this.m_renderer.shadowMap.enabled = false;
        scene.traverse(this.setOutlineMaterial.bind(this));
        this.m_renderer.render(scene, camera);
        scene.traverse(this.restoreOriginalMaterial.bind(this));
        this.cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        this.m_renderer.autoClear = currentAutoClear;
        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
    createInvisibleMaterial() {
        return new THREE.ShaderMaterial({ name: "invisible", visible: false });
    }
    createMaterial(originalMaterial) {
        // EdgeMaterial or depth prepass material should not be used for outlines.
        if (originalMaterial instanceof harp_materials_1.EdgeMaterial ||
            originalMaterial.isDepthPrepassMaterial === true) {
            return this.createInvisibleMaterial();
        }
        const shaderID = this.m_shaderIDs[originalMaterial.type];
        let originalVertexShader;
        let originalUniforms = originalMaterial.shaderUniforms !== undefined
            ? originalMaterial.shaderUniforms
            : originalMaterial.uniforms;
        if (shaderID !== undefined) {
            const shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        }
        else if (originalMaterial.isRawShaderMaterial === true) {
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) ||
                !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                return this.createInvisibleMaterial();
            }
        }
        else if (originalMaterial.isShaderMaterial === true) {
            originalVertexShader = originalMaterial.vertexShader;
        }
        else {
            return this.createInvisibleMaterial();
        }
        const isExtrusionMaterial = originalMaterial.shaderUniforms !== undefined &&
            originalMaterial.shaderUniforms.extrusionRatio !== undefined;
        const isFadingMaterial = harp_materials_1.FadingFeature.isDefined(originalMaterial);
        const uniforms = Object.assign(Object.assign({}, originalUniforms), this.m_uniformsChunk);
        const vertexShader = originalVertexShader
            // put vertexShaderChunk right before "void main() {...}"
            .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")
            // put vertexShaderChunk2 the end of "void main() {...}"
            // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
            .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")
            // remove any light related lines
            // Note: here is very sensitive to originalVertexShader
            // TODO: consider safer way
            .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        const defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) &&
            !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
            defines.DECLARE_TRANSFORMED = true;
        }
        if (isExtrusionMaterial) {
            // If the original material is setup for animated extrusion (like buildings), add the
            // uniform describing the extrusion to the outline material.
            uniforms.extrusionRatio = { value: harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN };
            defines.USE_EXTRUSION = 1;
        }
        if (isFadingMaterial) {
            uniforms.fadeNear = {
                value: originalUniforms.fadeNear !== undefined
                    ? originalUniforms.fadeNear.value
                    : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR
            };
            uniforms.fadeFar = {
                value: originalUniforms.fadeFar !== undefined
                    ? originalUniforms.fadeFar.value
                    : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR
            };
            defines.USE_FADING = 1;
        }
        const outlineMaterial = new THREE.ShaderMaterial({
            defines,
            uniforms,
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
            //wireframe: true,
            skinning: false,
            morphTargets: false,
            morphNormals: false,
            fog: false,
            blending: THREE.CustomBlending,
            blendSrc: THREE.SrcAlphaFactor,
            blendDst: THREE.OneMinusSrcAlphaFactor,
            blendSrcAlpha: THREE.OneFactor,
            blendDstAlpha: THREE.OneMinusSrcAlphaFactor,
            transparent: true,
            polygonOffset: true,
            // Extreme values used here to reduce artifacts, especially at tile borders.
            polygonOffsetFactor: 10.0,
            polygonOffsetUnits: 30.0
        });
        return outlineMaterial;
    }
    getOutlineMaterialFromCache(originalMaterial) {
        let data = this.m_cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: this.createMaterial(originalMaterial),
                used: true,
                keepAlive: this.m_defaultKeepAlive,
                count: 0
            };
            this.m_cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    getOutlineMaterial(originalMaterial) {
        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
        this.updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    setOutlineMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.getOutlineMaterial(object.material[i]);
            }
        }
        else {
            object.material = this.getOutlineMaterial(object.material);
        }
        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
    }
    restoreOriginalMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.m_originalMaterials[object.material[i].uuid];
            }
        }
        else {
            object.material = this.m_originalMaterials[object.material.uuid];
        }
        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const originalMaterial = this.m_originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) {
            return;
        }
        this.updateUniforms(material, originalMaterial);
    }
    updateUniforms(material, originalMaterial) {
        const outlineParameters = originalMaterial.userData.outlineParameters;
        const outlineUniforms = material.uniforms;
        outlineUniforms.outlineAlpha.value = originalMaterial.opacity;
        const originalUniforms = originalMaterial.shaderUniforms !== undefined
            ? originalMaterial.shaderUniforms
            : originalMaterial.uniforms;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) {
                outlineUniforms.outlineThickness.value = outlineParameters.thickness;
            }
            if (outlineParameters.color !== undefined) {
                outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);
            }
            if (outlineParameters.alpha !== undefined) {
                outlineUniforms.outlineAlpha.value = outlineParameters.alpha;
            }
        }
        // If the original material is setup for animated extrusion (like buildings), update the
        // uniforms in the outline material.
        if (originalUniforms !== undefined && originalUniforms.extrusionRatio !== undefined) {
            const value = originalMaterial.shaderUniforms.extrusionRatio.value;
            material.extrusionRatio = value;
            material.uniforms.extrusionRatio.value =
                value !== undefined ? value : harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
        }
        // Copy available fading params to the outline material.
        if (material.defines.USE_FADING !== undefined &&
            originalUniforms.fadeNear !== undefined &&
            originalUniforms.fadeFar !== undefined &&
            originalUniforms.fadeFar.value >= 0.0) {
            outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;
            outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;
        }
    }
    updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") {
            return;
        }
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            material.visible =
                originalMaterial.visible === false
                    ? false
                    : outlineParameters.visible !== undefined
                        ? outlineParameters.visible
                        : true;
            if (outlineParameters.keepAlive !== undefined) {
                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            }
        }
        else {
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
            material.visible = false;
        }
    }
    cleanupCache() {
        let keys;
        // clear originialMaterials
        keys = Object.keys(this.m_originalMaterials);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalMaterials[keys[i]] = undefined;
        }
        // clear originalOnBeforeRenders
        keys = Object.keys(this.m_originalOnBeforeRenders);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalOnBeforeRenders[keys[i]] = undefined;
        }
        // remove unused outlineMaterial from cache
        keys = Object.keys(this.m_cache);
        for (const key of keys) {
            if (this.m_cache[key].used === false) {
                this.m_cache[key].count++;
                if (this.m_cache[key].keepAlive === false &&
                    this.m_cache[key].count > this.m_removeThresholdCount) {
                    delete this.m_cache[key];
                }
            }
            else {
                this.m_cache[key].used = false;
                this.m_cache[key].count = 0;
            }
        }
    }
}
exports.OutlineEffect = OutlineEffect;
//# sourceMappingURL=Outline.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Pass.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Pass.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaderPass = exports.RenderPass = exports.Pass = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * The base class to extend for further passes in {@link MapView},
 * like the {@link MSAARenderPass},
 *
 * @remarks
 * `Pass` provides the core logic for both :
 * - render passes (proper scene renders),
 * - and shader passes (quad renders, i.e. effects added on top of the render output as a
 * postprocess).
 *
 * Even some shader passes still actually fall within the render pass category as they need to
 * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the
 * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.
 * These only are proper shader passes.
 */
class Pass {
    constructor() {
        this.enabled = false;
        this.renderToScreen = false;
        // tslint:enable:no-unused-variable
    }
    // tslint:disable-next-line:no-unused-variable
    setSize(width, height) {
        // Implemented in sub-classes.
    }
    // tslint:disable:no-unused-variable
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        // Implemented in sub-classes.
    }
}
exports.Pass = Pass;
/**
 * The pass that does a default normal scene rendering for further post-effects.
 */
class RenderPass extends Pass {
    constructor() {
        super();
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.render(scene, camera);
    }
}
exports.RenderPass = RenderPass;
/**
 * The base class to extend for post-effects on the final render (like Vignette, Sepia, color
 * correction...)
 */
class ShaderPass extends Pass {
    constructor(shader, textureID = "tDiffuse") {
        super();
        this.textureID = textureID;
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        }
        else {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new FullScreenQuad(this.material);
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        this.fsQuad.render(renderer);
    }
}
exports.ShaderPass = ShaderPass;
class FullScreenQuad {
    constructor(material) {
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const geometry = new THREE.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE.Mesh(geometry, material);
    }
    get material() {
        return this.m_mesh.material;
    }
    set material(value) {
        this.m_mesh.material = value;
    }
    render(renderer) {
        renderer.render(this.m_mesh, this.m_camera);
    }
}
//# sourceMappingURL=Pass.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BloomPass = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
const BlurDirectionX = new THREE.Vector2(1.0, 0.0);
const BlurDirectionY = new THREE.Vector2(0.0, 1.0);
/**
 * The TS version of ThreeJS's UnrealBloomPass.
 */
class BloomPass extends Pass_1.Pass {
    constructor(resolution, strength, radius, threshold) {
        super();
        this.resolution = new THREE.Vector2(256, 256);
        this.m_renderTargetsHorizontal = [];
        this.m_renderTargetsVertical = [];
        this.m_nMips = 5;
        this.m_separableBlurMaterials = [];
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_scene = new THREE.Scene();
        this.m_basic = new THREE.MeshBasicMaterial();
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        this.m_bloomTintColors = [
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1)
        ];
        this.strength = strength;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution;
        this.m_quad.frustumCulled = false;
        this.m_scene.add(this.m_quad);
        const pars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        };
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
        this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.m_renderTargetBright.texture.generateMipmaps = false;
        for (let i = 0; i < this.m_nMips; i++) {
            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);
        // tslint:disable:no-string-literal
        this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        this.m_highPassUniforms["smoothWidth"].value = 0.01;
        this.m_materialHighPassFilter = new THREE.ShaderMaterial({
            uniforms: this.m_highPassUniforms,
            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,
            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
        this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
        this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
        this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
        this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
        this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.m_compositeMaterial.needsUpdate = true;
        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);
        this.m_copyUniforms["opacity"].value = 1.0;
        // tslint:enable:no-string-literal
        this.m_materialCopy = new THREE.ShaderMaterial({
            uniforms: this.m_copyUniforms,
            vertexShader: harp_materials_1.CopyShader.vertexShader,
            fragmentShader: harp_materials_1.CopyShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
    }
    dispose() {
        for (const rt of this.m_renderTargetsHorizontal) {
            rt.dispose();
        }
        for (const rt of this.m_renderTargetsVertical) {
            rt.dispose();
        }
        this.m_renderTargetBright.dispose();
    }
    /** @override */
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.m_renderTargetBright.setSize(resx, resy);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_renderTargetsHorizontal[i].setSize(resx, resy);
            this.m_renderTargetsVertical[i].setSize(resx, resy);
            // tslint:disable-next-line:no-string-literal
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        // tslint:disable:no-string-literal
        // Render input to screen
        if (this.renderToScreen) {
            this.m_quad.material = this.m_basic;
            this.m_basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
        }
        // 1. Extract bright areas
        this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.m_quad.material = this.m_materialHighPassFilter;
        renderer.setRenderTarget(this.m_renderTargetBright);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this.m_renderTargetBright;
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_quad.material = this.m_separableBlurMaterials[i];
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value =
                inputRenderTarget.texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            inputRenderTarget = this.m_renderTargetsVertical[i];
        }
        // Composite all the mips
        this.m_quad.material = this.m_compositeMaterial;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // Blend it additively over the input texture
        this.m_quad.material = this.m_materialCopy;
        this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            renderer.render(this.m_scene, this.m_camera);
        }
        else {
            renderer.setRenderTarget(readBuffer);
            renderer.render(this.m_scene, this.m_camera);
        }
        // tslint:enable:no-string-literal
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new THREE.Vector2(0.5, 0.5) },
                direction: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {\n\
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
        });
    }
    getCompositeMaterial(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: { value: null },
                blurTexture2: { value: null },
                blurTexture3: { value: null },
                blurTexture4: { value: null },
                blurTexture5: { value: null },
                dirtTexture: { value: null },
                bloomStrength: { value: 1.0 },
                bloomFactors: { value: null },
                bloomTintColors: { value: null },
                bloomRadius: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
        });
    }
}
exports.BloomPass = BloomPass;
//# sourceMappingURL=UnrealBloomPass.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js");
Object.defineProperty(exports, "MapRenderingManager", { enumerable: true, get: function () { return MapRenderingManager_1.MapRenderingManager; } });
var Pass_1 = __webpack_require__(/*! ./Pass */ "./node_modules/@here/harp-mapview/lib/composing/Pass.js");
Object.defineProperty(exports, "Pass", { enumerable: true, get: function () { return Pass_1.Pass; } });
var MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js");
Object.defineProperty(exports, "MSAARenderPass", { enumerable: true, get: function () { return MSAARenderPass_1.MSAARenderPass; } });
Object.defineProperty(exports, "MSAASampling", { enumerable: true, get: function () { return MSAARenderPass_1.MSAASampling; } });
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopyrightCoverageProvider = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
// tslint:disable-next-line:no-var-requires
const RBush = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/**
 * Base class to provide copyrights based on copyright coverage information, defined by geographical
 * bounding boxes and relevant zoom level ranges.
 */
class CopyrightCoverageProvider {
    constructor() {
        /** Logger instance. */
        this.logger = harp_utils_1.LoggerManager.instance.create("CopyrightCoverageProvider");
    }
    /** @inheritdoc */
    getTree() {
        if (this.m_cachedTreePromise !== undefined) {
            return this.m_cachedTreePromise;
        }
        this.m_cachedTreePromise = this.getCopyrightCoverageData()
            .then(coverageInfo => this.initRBush(coverageInfo))
            .catch(error => {
            this.logger.error(error);
            return new RBush();
        });
        return this.m_cachedTreePromise;
    }
    /** @inheritdoc */
    async getCopyrights(geoBox, level) {
        const tree = await this.getTree();
        const result = [];
        const matchingEntries = tree.search({
            minX: geoBox.west,
            minY: geoBox.south,
            maxX: geoBox.east,
            maxY: geoBox.north
        });
        for (const entry of matchingEntries) {
            const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);
            const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);
            if (level >= minLevel && level <= maxLevel) {
                if (result.find(item => item.id === entry.label) === undefined) {
                    result.push({ id: entry.label });
                }
            }
        }
        return result;
    }
    /**
     * Initializes RBush.
     *
     * @param entries - Entries for tree.
     * @returns RBush instance.
     */
    initRBush(entries) {
        const tree = new RBush();
        if (!entries) {
            this.logger.warn("No copyright coverage data provided");
            return tree;
        }
        for (const entry of entries) {
            const { minLevel, maxLevel, label, alt } = entry;
            if (!entry.boxes) {
                tree.insert({
                    minX: -180,
                    minY: -90,
                    maxX: 180,
                    maxY: 180,
                    minLevel,
                    maxLevel,
                    label,
                    alt
                });
            }
            else {
                for (const box of entry.boxes) {
                    const [minY, minX, maxY, maxX] = box;
                    tree.insert({
                        minX,
                        minY,
                        maxX,
                        maxY,
                        minLevel,
                        maxLevel,
                        label,
                        alt
                    });
                }
            }
        }
        return tree;
    }
}
exports.CopyrightCoverageProvider = CopyrightCoverageProvider;
//# sourceMappingURL=CopyrightCoverageProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopyrightElementHandler = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const MapView_1 = __webpack_require__(/*! ../MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js");
/**
 * Helper class that maintains up-to-date {@link MapView} copyright information in DOM element.
 *
 * @example
 *
 *     // HTML snippet
 *     <div id="copyrightNotice" style="position:absolute; right:0; bottom:0; z-index:100"></div>
 *
 *     // JavaScript
 *     const mapView = new MapView({ ... });
 *     CopyrightElementHandler.install("copyrightNotice", mapView);
 */
class CopyrightElementHandler {
    /**
     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info
     * of the given `mapView`.
     *
     * Note: Generally, the static [[install]] method can be used to create and attach a new
     * `CopyrightElementHandler` to a {@link MapView}
     *
     * @param element - HTML DOM element or a HTML DOM element id
     * @param mapView - optional, [[attach]] to this {@link MapView} instance
     */
    constructor(element, mapView) {
        this.m_defaults = new Map();
        this.m_mapViews = [];
        /**
         * Update copyright info text in controlled HTML element.
         */
        this.update = () => {
            const mergedCopyrightInfo = this.m_mapViews
                .map(mapView => mapView.copyrightInfo)
                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, this.staticInfo || []);
            // Conditionally hiding of element with copyright information.
            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.
            if (mergedCopyrightInfo.length === 0) {
                this.m_element.style.display = "none";
                return;
            }
            else {
                this.m_element.style.display = "block";
            }
            if (this.m_defaults.size !== 0) {
                for (const sourceInfo of mergedCopyrightInfo) {
                    const defaults = this.m_defaults.get(sourceInfo.id);
                    if (defaults !== undefined) {
                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);
                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);
                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);
                    }
                }
            }
            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);
        };
        if (typeof element === "string") {
            const htmlElement = document.getElementById(element);
            if (!htmlElement) {
                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);
            }
            this.m_element = htmlElement;
        }
        else {
            this.m_element = element;
        }
        if (mapView !== undefined) {
            this.attach(mapView);
        }
    }
    /**
     * Install {@link CopyrightElementHandler} on DOM element and - optionally -
     * attach to a {@link MapView} instance.
     *
     * @param element - HTML DOM element or a HTML DOM element id
     * @param mapView -, optional, [[attach]] to this {@link MapView}
     */
    static install(element, mapView) {
        return new CopyrightElementHandler(element, mapView);
    }
    /**
     * Destroys this object by removing all event listeners from the attached {@link MapView}s.
     */
    destroy() {
        for (const mapView of this.m_mapViews) {
            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        }
    }
    /**
     * Attaches this {@link CopyrightInfo} updates from {@link MapView} instance.
     */
    attach(mapView) {
        this.m_mapViews.push(mapView);
        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.update();
        return this;
    }
    /**
     * Stop following {@link CopyrightInfo} updates from {@link MapView} instance.
     */
    detach(mapView) {
        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);
        this.update();
        return this;
    }
    /**
     * Set {@link CopyrightInfo} defaults to be used in case
     * {@link DataSource} does not provide deatailed
     * copyright information.
     *
     * @remarks
     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright
     * information retrieved from {@link MapView}.
     */
    setDefaults(defaults) {
        this.m_defaults.clear();
        if (defaults !== undefined) {
            for (const item of defaults) {
                this.m_defaults.set(item.id, item);
            }
        }
        return this;
    }
    /**
     * Sets the [[staticInfo]] property.
     *
     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and
     * copyright information obtained from attached {@link MapView}s.
     *
     * This information is used when {@link DataSource}
     * instances of given {@link MapView} do not provide
     * copyright information.
     */
    setStaticCopyightInfo(staticInfo) {
        this.staticInfo = staticInfo;
        return this;
    }
}
exports.CopyrightElementHandler = CopyrightElementHandler;
//# sourceMappingURL=CopyrightElementHandler.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopyrightInfo = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
var CopyrightInfo;
(function (CopyrightInfo) {
    /**
     * Merge {@link CopyrightInfo} arrays, removing duplicates.
     *
     * `id` and `label` are considered keys in deduplication algorithm.
     *
     * @param sources - non-duplicate elements from this array are added to `target`
     * @returns merge of all copyright infos in `sources`
     */
    function mergeArrays(a, b) {
        const result = [];
        for (const source of [a, b]) {
            if (source === undefined) {
                continue;
            }
            for (const sourceInfo of source) {
                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||
                    (findItem.label !== undefined && findItem.label === sourceInfo.label));
                if (existingInfo === undefined) {
                    result.push(Object.assign({}, sourceInfo));
                }
                else {
                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);
                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);
                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);
                }
            }
        }
        return result;
    }
    CopyrightInfo.mergeArrays = mergeArrays;
    /**
     * Format copyright information to a HTML string that can be displayed in the UI.
     *
     * * Empty list returns empty string.
     * * Entries with empty (but defined) labels are skipped.
     *
     * @param copyrightInfo - Array of copyrights to format.
     */
    function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        const filtered = copyrightInfo.filter(entry => entry.label !== "");
        if (filtered.length === 0) {
            return "";
        }
        return (" " +
            filtered
                .map(entry => {
                var _a;
                const label = (_a = entry.label) !== null && _a !== void 0 ? _a : entry.id;
                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;
                const link = entry.link;
                return link
                    ? `<a href="${link}" target="_blank" rel="noreferrer noopener">${text}</a>`
                    : `${text}`;
            })
                .join(", "));
    }
    CopyrightInfo.formatAsHtml = formatAsHtml;
})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));
//# sourceMappingURL=CopyrightInfo.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightProvider.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=CopyrightProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UrlCopyrightProvider = void 0;
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "./node_modules/@here/harp-transfer-manager/index.js");
const CopyrightCoverageProvider_1 = __webpack_require__(/*! ./CopyrightCoverageProvider */ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js");
/**
 * Copyright provider which retrieves copyright coverage information from provided URL.
 */
class UrlCopyrightProvider extends CopyrightCoverageProvider_1.CopyrightCoverageProvider {
    /**
     * Default constructor.
     *
     * @param m_fetchURL - URL to fetch copyrights data from.
     * @param m_baseScheme - Scheme to get copyrights from.
     * @param m_requestHeaders - Optional request headers for requests(e.g. Authorization)
     */
    constructor(m_fetchURL, m_baseScheme, m_requestHeaders, m_transferManager = harp_transfer_manager_1.TransferManager.instance()) {
        super();
        this.m_fetchURL = m_fetchURL;
        this.m_baseScheme = m_baseScheme;
        this.m_requestHeaders = m_requestHeaders;
        this.m_transferManager = m_transferManager;
    }
    /**
     * Sets request headers.
     * @param headers -
     */
    setRequestHeaders(headers) {
        this.m_requestHeaders = headers;
    }
    /**
     * @inheritdoc
     * @override
     */
    getCopyrightCoverageData() {
        if (this.m_cachedCopyrightResponse !== undefined) {
            return this.m_cachedCopyrightResponse;
        }
        this.m_cachedCopyrightResponse = this.m_transferManager
            .downloadJson(this.m_fetchURL, {
            headers: this.m_requestHeaders
        })
            .then(json => json[this.m_baseScheme])
            .catch(error => {
            this.logger.error(error);
            return [];
        });
        return this.m_cachedCopyrightResponse;
    }
}
exports.UrlCopyrightProvider = UrlCopyrightProvider;
//# sourceMappingURL=UrlCopyrightProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplacedBufferAttribute = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const VertexCache_1 = __webpack_require__(/*! ./VertexCache */ "./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js");
/**
 * @internal
 * BufferAttribute decorator that displaces on the fly the coordinates in a given attribute using a
 * specified displacement map.
 */
let DisplacedBufferAttribute = /** @class */ (() => {
    class DisplacedBufferAttribute extends THREE.BufferAttribute {
        /**
         * Creates an instance of displaced buffer attribute.
         * @param originalAttribute - The buffer attribute to be displaced
         *                            (e.g. the position attribute).
         * @param m_normals - The normals along which the coordinates will be displaced.
         * @param m_uvs - The uv coordinates to be used to sample the displacement map.
         * @param displacementMap - A texture with the displacement values in 32bit floats.
         */
        constructor(originalAttribute, m_normals, m_uvs, displacementMap) {
            super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);
            this.originalAttribute = originalAttribute;
            this.m_normals = m_normals;
            this.m_uvs = m_uvs;
            this.m_textureWidth = 0;
            this.m_textureHeight = 0;
            this.m_cache = new VertexCache_1.VertexCache(DisplacedBufferAttribute.MAX_CACHE_SIZE);
            this.m_lastPos = new THREE.Vector3();
            this.m_tmpNormal = new THREE.Vector3();
            this.resetTexture(displacementMap);
        }
        /**
         * Resets the displaced buffer attribute to use new buffer attributes or displacement map.
         * @param originalAttribute - The buffer attribute to be displaced
         *                            (e.g. the position attribute).
         * @param normals - The normals along which the coordinates will be displaced.
         * @param uvs -  The uv coordinates to be used to sample the displacement map.
         * @param displacementMap - A texture with the displacement values in 32bit floats.
         */
        reset(originalAttribute, normals, uvs, displacementMap) {
            this.array = originalAttribute.array;
            this.itemSize = originalAttribute.itemSize;
            this.count = this.array.length / this.itemSize;
            this.normalized = originalAttribute.normalized;
            this.originalAttribute = originalAttribute;
            this.m_normals = normals;
            this.m_uvs = uvs;
            this.m_cache.clear();
            this.m_lastBufferIndex = undefined;
            this.resetTexture(displacementMap);
        }
        // HARP-9585: These getters are overrides of the base class ones, however tslint doesn't
        // recognize them as such.
        getX(index) {
            return this.getDisplacedCoordinate(index).x;
        }
        getY(index) {
            return this.getDisplacedCoordinate(index).y;
        }
        getZ(index) {
            return this.getDisplacedCoordinate(index).z;
        }
        resetTexture(displacementMap) {
            this.m_texture = new Float32Array(displacementMap.image.data.buffer);
            this.m_textureWidth = displacementMap.image.width;
            this.m_textureHeight = displacementMap.image.height;
        }
        getDisplacedCoordinate(bufferIndex) {
            if (bufferIndex === this.m_lastBufferIndex) {
                return this.m_lastPos;
            }
            this.m_lastBufferIndex = bufferIndex;
            if (this.m_cache.get(bufferIndex, this.m_lastPos)) {
                return this.m_lastPos;
            }
            this.displacePosition(bufferIndex);
            this.m_cache.set(bufferIndex, this.m_lastPos);
            return this.m_lastPos;
        }
        displacePosition(bufferIndex) {
            this.m_lastPos.fromBufferAttribute(this.originalAttribute, bufferIndex);
            const normals = this.m_normals;
            this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);
            const uvs = this.m_uvs;
            const u = THREE.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);
            const v = THREE.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);
            const displacement = harp_utils_1.sampleBilinear(this.m_texture, this.m_textureWidth, this.m_textureHeight, u, v);
            this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));
        }
    }
    DisplacedBufferAttribute.MAX_CACHE_SIZE = 6;
    return DisplacedBufferAttribute;
})();
exports.DisplacedBufferAttribute = DisplacedBufferAttribute;
//# sourceMappingURL=DisplacedBufferAttribute.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplacedBufferGeometry = exports.displaceBox = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js");
const tmpV1 = new THREE.Vector3();
const tmpV2 = new THREE.Vector3();
const tmpBox = new THREE.Box3();
/**
 * @internal
 * Displace a box in a given direction by a specified range. The original box min and max vertices
 * are translated as a result by displacementRange.min and displacementRange.max respectively.
 * @param box - The original box to displace.
 * @param displacementRange - The minimum and maximum displacement values.
 * @param displacementDir - Direction in which the displacement will be applied.
 * @return The displaced box.
 */
function displaceBox(box, displacementRange, displacementDir) {
    tmpBox.copy(box);
    const tmpNormalMin = tmpV1.copy(displacementDir);
    const tmpNormalMax = tmpV2.copy(tmpNormalMin);
    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max)));
    return box;
}
exports.displaceBox = displaceBox;
/**
 * @internal
 * BufferGeometry decorator that displaces on the fly the position attribute using a specified
 * displacement map.
 */
class DisplacedBufferGeometry extends THREE.BufferGeometry {
    /**
     * Creates an instance of displaced buffer geometry.
     * @param originalGeometry - The goeometry to be displaced.
     * @param displacementMap - A texture with the displacement values.
     * @param displacementRange - The displacement value range found in the displacement map.
     * @param displacedPositions - Buffer attribute that will be used for displaced positions if
     * provided, otherwise a new buffer attribute will be created.
     */
    constructor(originalGeometry, displacementMap, displacementRange, displacedPositions) {
        super();
        this.originalGeometry = originalGeometry;
        this.displacementRange = displacementRange;
        this.m_originalBoundingBox = new THREE.Box3();
        if (!displacedPositions) {
            this.m_displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(originalGeometry.attributes.position, originalGeometry.attributes.normal, originalGeometry.attributes.uv, displacementMap);
        }
        else {
            this.m_displacedPositions = displacedPositions;
        }
        this.resetAttributes();
    }
    /**
     * Resets the displaced buffer geometry to use new geometry or displacement map.
     * @param geometry - The goeometry to be displaced.
     * @param displacementMap - A texture with the displacement values.
     * @param displacementRange - The displacement value range found in the displacement map.
     */
    reset(geometry, displacementMap, displacementRange) {
        this.originalGeometry = geometry;
        const positions = geometry.attributes.position;
        const normals = geometry.attributes.normal;
        const uvs = geometry.attributes.uv;
        this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);
        const displacementRangeChanged = this.displacementRange.min !== displacementRange.min ||
            this.displacementRange.max !== displacementRange.max;
        this.displacementRange = displacementRange;
        this.resetAttributes();
        this.resetBoundingVolumes(displacementRangeChanged);
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    // tslint:disable-next-line: explicit-override
    computeBoundingBox() {
        // Calculate a coarse approximation of the displaced geometry bbox by displacing the
        // original bbox and enlarging it to cover the whole displacement range.
        // This approximation is used to avoid having to displace the whole geometry, which will
        // be done only if the bbox test passes.
        if (this.originalGeometry.boundingBox === null) {
            this.originalGeometry.computeBoundingBox();
        }
        const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox);
        if (this.boundingBox === null) {
            this.boundingBox = origBBox.clone();
        }
        else {
            this.boundingBox.copy(origBBox);
        }
        displaceBox(this.boundingBox, this.displacementRange, tmpV1.fromBufferAttribute(this.attributes.normal, 0));
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    // tslint:disable-next-line: explicit-override
    computeBoundingSphere() {
        // Use as coarse approximation the sphere bounding the bbox.
        if (this.boundingBox === null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
        }
        this.boundingBox.getBoundingSphere(this.boundingSphere);
    }
    needsBoundingBoxUpdate(displacementRangeChanged) {
        return (displacementRangeChanged ||
            (this.boundingBox !== null &&
                (!this.originalGeometry.boundingBox ||
                    !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox))));
    }
    resetBoundingVolumes(displacementRangeChanged) {
        if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {
            this.computeBoundingBox();
            if (this.boundingSphere) {
                this.computeBoundingSphere();
            }
        }
    }
    resetAttributes() {
        this.index = this.originalGeometry.index;
        this.groups = this.originalGeometry.groups;
        this.drawRange = this.originalGeometry.drawRange;
        this.attributes = Object.assign({}, this.originalGeometry.attributes);
        this.attributes.position = this.m_displacedPositions;
    }
}
exports.DisplacedBufferGeometry = DisplacedBufferGeometry;
//# sourceMappingURL=DisplacedBufferGeometry.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/DisplacedMesh.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplacedMesh = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.js");
const DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js");
function isDisplacementMaterial(material) {
    const isDisplacementFeature = harp_materials_1.hasDisplacementFeature(material);
    harp_utils_1.assert(isDisplacementFeature, "Material does not support displacement maps.");
    return isDisplacementFeature;
}
function isDataTextureMap(map) {
    if (!map) {
        return false;
    }
    const isDataTexture = map instanceof THREE.DataTexture;
    harp_utils_1.assert(isDataTexture, "Material does not support displacement maps.");
    return isDataTexture;
}
/**
 * Mesh with geometry modified by a displacement map. Overrides raycasting behaviour to apply
 * displacement map before intersection test.
 * @internal
 */
class DisplacedMesh extends THREE.Mesh {
    /**
     * Creates an instance of displaced mesh.
     * @param geometry - Original geometry to displace.
     * @param material - Material(s) to be used by the mesh. All must have the same
     *                   displacement map.
     * @param m_getDisplacementRange - Displacement values range getter.
     * @param [m_raycastStrategy] Function that will be used to find ray intersections. If not
     * provided, THREE.Mesh's raycast will be used.
     */
    constructor(geometry, material, m_getDisplacementRange, m_raycastStrategy) {
        super(geometry, material);
        this.m_getDisplacementRange = m_getDisplacementRange;
        this.m_raycastStrategy = m_raycastStrategy;
    }
    static getDisplacedPositionAttribute(geometry, displacementMap) {
        // Reuse same buffer attribute for all meshes since it's only needed during the
        // intersection test.
        if (!DisplacedMesh.displacedPositions) {
            DisplacedMesh.displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
        }
        else {
            DisplacedMesh.displacedPositions.reset(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
        }
        return DisplacedMesh.displacedPositions;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    // tslint:disable-next-line: explicit-override
    raycast(raycaster, intersects) {
        // All materials in the object are expected to have the same displacement map.
        const firstMaterial = this.firstMaterial;
        // Use default raycasting implementation if there's no displacement material or if there's
        // no displacement map or its type is not supported.
        if (!isDisplacementMaterial(firstMaterial) ||
            !isDataTextureMap(firstMaterial.displacementMap)) {
            super.raycast(raycaster, intersects);
            return;
        }
        const displacementMap = firstMaterial.displacementMap;
        const displacementRange = Object.assign({}, this.m_getDisplacementRange());
        harp_utils_1.assert(this.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type.");
        const geometry = this.geometry;
        if (this.displacedGeometry) {
            this.displacedGeometry.reset(geometry, displacementMap, displacementRange);
        }
        else {
            this.displacedGeometry = new DisplacedBufferGeometry_1.DisplacedBufferGeometry(geometry, displacementMap, displacementRange, DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap));
        }
        // Replace the original geometry by the displaced one only during the intersection test.
        this.geometry = this.displacedGeometry;
        if (this.m_raycastStrategy) {
            this.m_raycastStrategy(this, raycaster, intersects);
        }
        else {
            super.raycast(raycaster, intersects);
        }
        super.geometry = this.displacedGeometry.originalGeometry;
    }
    get firstMaterial() {
        return Array.isArray(this.material) ? this.material[0] : this.material;
    }
}
exports.DisplacedMesh = DisplacedMesh;
//# sourceMappingURL=DisplacedMesh.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LodMesh = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * A mesh that can store multiple versions of a geometry with differents level of detail.
 * The rendered level of detail can be adapted during runtime.
 * @internal
 * @hidden
 */
class LodMesh extends THREE.Mesh {
    /**
     * Creates a [[LodMesh]] with given geometries and materials
     * @param geometries - A list of geometries with different levels of detail
     * @param material - Material for the mesh
     */
    constructor(geometries, material) {
        super(undefined, material);
        this.geometries = geometries;
    }
    /**
     * Update geometries of mesh
     */
    set geometries(geometries) {
        // dispose previous geometries
        if (this.m_geometries !== geometries) {
            this.disposeGeometries();
        }
        this.m_geometries = geometries;
        if (this.geometries && this.m_geometries.length > 0) {
            this.geometry = this.m_geometries[0];
        }
    }
    /**
     * Get geometries of mesh
     */
    get geometries() {
        return this.m_geometries;
    }
    /**
     * Change the rendered level of detail of the mesh
     * @param level - The level of detail (index of the geometry in the list).
     */
    setLevelOfDetail(level) {
        if (!this.m_geometries || this.m_geometries.length === 0) {
            return;
        }
        level = THREE.MathUtils.clamp(level, 0, this.m_geometries.length - 1);
        this.geometry = this.m_geometries[level];
    }
    /**
     * Dispose all geometries of mesh
     */
    disposeGeometries() {
        if (this.m_geometries) {
            for (const geometry of this.m_geometries) {
                geometry.dispose();
            }
        }
        this.geometry.dispose();
    }
}
exports.LodMesh = LodMesh;
//# sourceMappingURL=LodMesh.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/SolidLineMesh.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidLineMesh = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.js");
const tmpSphere = new THREE.Sphere();
const tmpInverseMatrix = new THREE.Matrix4();
const tmpRay = new THREE.Ray();
const tmpLine1 = new THREE.Line3();
const tmpBox = new THREE.Box3();
const tmpOBB = new harp_geoutils_1.OrientedBox3();
const tmpPlane = new THREE.Plane();
const tmpV1 = new THREE.Vector3();
const tmpV2 = new THREE.Vector3();
const tmpV3 = new THREE.Vector3();
const tmpV4 = new THREE.Vector3();
// Strides to access the index buffer. See [[createLineGeometry]].
// Stride between the start vertex indices of consecutive segments, each one made of 2 triangles.
const SEGMENT_STRIDE = 6;
// Stride between the start and end vertex indices of a segment. Vertices are duplicated so that
// each copy is extruded in opposite directions in the vertex shader.
const VERTEX_STRIDE = 2;
function isSolidLineMaterial(material) {
    return Array.isArray(material)
        ? material.every(mat => mat instanceof harp_materials_1.SolidLineMaterial)
        : material instanceof harp_materials_1.SolidLineMaterial;
}
/**
 * Computes the bounding sphere of the part of a given geometry corresponding to a feature.
 * @param geometry - The geometry containing the feature.
 * @param featureBeginIndex - The index where the feature starts in the geometry's
 *                            indices attribute.
 * @param featureEndIndex - The index where the feature end in the geometry's indices attribute.
 * @returns The feature bounding sphere.
 */
function computeFeatureBoundingSphere(geometry, featureBeginIndex, featureEndIndex) {
    let displacementRange;
    if (geometry instanceof DisplacedBufferGeometry_1.DisplacedBufferGeometry) {
        displacementRange = geometry.displacementRange;
        geometry = geometry.originalGeometry;
    }
    const attributes = geometry.attributes;
    const pos = attributes.position;
    const indices = geometry.index.array;
    const sphere = new THREE.Sphere();
    const bbox = tmpBox.makeEmpty();
    const vertex = tmpV1;
    // First compute the bounding box for all line segments.
    for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));
    }
    if (displacementRange) {
        // If geometry is displaced, expand the bounding box to cover the whole displacement range,
        // and return the sphere bounding the box. This is a coarse estimation, but avoids having
        // to displace all vertices.
        // All normals in the geometry are assumed to be the same or close enough so that any of
        // them can be used as displacement direction. For sphere projection, the surface normals
        // within a tile are approximately the same from level 4 onwards. Here are some examples of
        // the minimum dot product between normals in a tile (normals at tile's opposite corners):
        // TILE: (6,9,4): 0.9806892129880023
        // TILE: (12,17,5): 0.9946739445457075
        // TILE: (25,34,6): 0.9986326302953471
        // TILE: (50,68,7): 0.9996583822992287
        // TILE: (1620,2199,12): 0.9999996706085572
        const normal = tmpV2;
        normal.fromBufferAttribute(geometry.attributes.normal, 0);
        return DisplacedBufferGeometry_1.displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);
    }
    return bbox.getBoundingSphere(sphere);
}
/**
 * Finds the intersection of a ray with a extruded line.
 * @param ray - Intersection ray in object's local space.
 * @param line - The centerline.
 * @param vExtrusion - Line extrusion vector.
 * @param normal - Extrusion plane normal.
 * @param hWidth - Extrusion half width.
 * @returns Distance of the extruded line intersection to the ray origin.
 */
function intersectExtrudedLine(ray, line, vExtrusion, normal, hWidth) {
    var _a;
    const obb = tmpOBB;
    line.getCenter(obb.position);
    line.delta(obb.xAxis).normalize();
    obb.yAxis.copy(vExtrusion);
    obb.zAxis.copy(normal);
    obb.extents.set(line.distance() / 2, hWidth, hWidth);
    if (obb.contains(ray.origin)) {
        return 0;
    }
    return (_a = obb.intersectsRay(ray)) !== null && _a !== void 0 ? _a : Infinity;
}
/**
 * Finds the intersection of a ray with the closest end cap of a extruded line.
 * @param ray - Intersection ray in object's local space.
 * @param line - The centerline.
 * @param hWidth - Extrusion half width.
 * @returns Distance of the end cap intersection to the ray origin.
 */
function intersectClosestEndCap(ray, line, hWidth) {
    const sphere = new THREE.Sphere(line.start, hWidth);
    const startCapT = sphere.containsPoint(ray.origin)
        ? 0
        : ray.intersectSphere(sphere, tmpV4)
            ? tmpV4.sub(ray.origin).length()
            : Infinity;
    sphere.center.copy(line.end);
    const endCapT = sphere.containsPoint(ray.origin)
        ? 0
        : ray.intersectSphere(sphere, tmpV4)
            ? tmpV4.sub(ray.origin).length()
            : Infinity;
    return Math.min(startCapT, endCapT);
}
/**
 * Intersects line
 * @param ray - Intersection ray in object's local space.
 * @param line - The line to intersect.
 * @param vExtrusion - Line extrusion vector.
 * @param hWidth - The line's extrusion half width.
 * @param hWidthSq - The line's extrusion half width squared.
 * @param plane - The extrusion plane.
 * @param interPlane - The intersection of the ray with the extrusion plane.
 * @param outInterLine - The ray intersetion with the extruded line.
 * @returns true if ray intersects the extruded line, false otherwise.
 */
function intersectLine(ray, line, vExtrusion, hWidth, hWidthSq, plane, interPlane, outInterLine) {
    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {
        // Corner case: ray is coplanar to extruded line, find distance to extruded line sides
        // and end caps.
        const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);
        const endCapT = intersectClosestEndCap(ray, line, hWidth);
        const minT = Math.min(extrLineT, endCapT);
        if (minT === Infinity) {
            return false;
        }
        ray.at(minT, outInterLine);
        return true;
    }
    // The plain intersection is also a line intersection only if it's closer to the line
    // than the extrusion half width.
    const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));
    if (distSq > hWidthSq) {
        return false;
    }
    outInterLine.copy(interPlane);
    return true;
}
/**
 * Finds the intersections of a ray with a partition of a solid line mesh representing a feature.
 * @param mesh - The mesh whose intersections will be found.
 * @param raycaster - Contains the intersection ray.
 * @param localRay - Same ray as raycaster.ray but in object's local space.
 * @param halfWidth - The line's extrusion half width.
 * @param lHalfWidth - The line's extrusion half width in mesh local space.
 * @param lHalfWidthSq - The line's extrusion half width squared in mesh local space.
 * @param beginIdx - The index where the feature starts in the mesh geometry's indices attribute.
 * @param endIdx - The index where the feature end in the mesh geometry's indices attribute.
 * @param bSphere - The feature bounding sphere.
 * @param intersections - Array where all intersections found between ray and feature will
 *                        be pushed.
 */
function intersectFeature(mesh, raycaster, localRay, halfWidth, lHalfWidth, lHalfWidthSq, beginIdx, endIdx, bSphere, intersections) {
    const vExt = tmpV1;
    const plane = tmpPlane;
    const interPlane = tmpV2;
    const line = tmpLine1;
    const geometry = mesh.geometry;
    const attributes = geometry.attributes;
    const position = attributes.position;
    const bitangent = attributes.bitangent;
    const indices = geometry.index.array;
    tmpSphere.copy(bSphere);
    tmpSphere.applyMatrix4(mesh.matrixWorld);
    tmpSphere.radius += halfWidth;
    if (!raycaster.ray.intersectsSphere(tmpSphere)) {
        return;
    }
    for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {
        const a = indices[i];
        const b = indices[i + VERTEX_STRIDE];
        // Find the plane containing the line segment, using the segment start, end and extrusion
        // vector.
        line.start.fromBufferAttribute(position, a);
        line.end.fromBufferAttribute(position, b);
        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();
        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);
        if (plane.normal.manhattanLength() === 0) {
            // Invalid plane, coplanar points are actually collinear because:
            // a) The line segment has length 0.
            // b) The extrusion vector has length 0.
            // c) The extrusion and segment directions are the same.
            // In any case it's a degenerate segment, skip it.
            continue;
        }
        // The ray intersection if any, will be on the extrusion plane.
        if (!localRay.intersectPlane(plane, interPlane)) {
            continue;
        }
        const interLine = tmpV3;
        if (!intersectLine(localRay, line, vExt, lHalfWidth, lHalfWidthSq, plane, interPlane, interLine)) {
            continue;
        }
        // Move back to world space for distance calculation
        const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interLineWorld);
        if (distance < raycaster.near || distance > raycaster.far) {
            continue;
        }
        intersections.push({
            distance,
            point: interLineWorld.clone(),
            index: i,
            object: mesh
        });
    }
}
const singleFeatureStart = [0];
const MAX_SCALE_RATIO_DIFF = 1e-2;
/**
 * Finds the intersections of a ray with a group within a solid line mesh.
 * @param mesh - The mesh whose intersections will be found.
 * @param material - The material used by the group inside the mesh.
 * @param raycaster -  Contains the intersection ray.
 * @param localRay - Same ray as raycaster.ray but in object's local space.
 * @param firstFeatureIdx - Index of the first feature in the group.
 * @param groupEndIdx - Index of the last vertex in the group.
 * @param intersections -  Array where all intersections found between ray and group will be pushed.
 * @returns The next feature index after the group.
 */
function intersectGroup(mesh, material, raycaster, localRay, firstFeatureIdx, groupEndIdx, intersections) {
    var _a;
    const bVolumes = mesh.userData.feature.boundingVolumes;
    harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type.");
    const geometry = mesh.geometry;
    harp_utils_1.assert(isSolidLineMaterial(material), "Unsupported material type");
    const solidLineMaterial = material;
    const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;
    // Assumption: scaling is uniform or close enough to use a local width independent of direction.
    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);
    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    harp_utils_1.assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);
    const localHalfWidthSq = localHalfWidth * localHalfWidth;
    const featureStarts = (_a = mesh.userData.feature.starts) !== null && _a !== void 0 ? _a : singleFeatureStart;
    let featureIdx = firstFeatureIdx;
    let beginIdx = featureStarts[featureIdx];
    const lastFeatureIdx = featureStarts.length - 1;
    while (beginIdx < groupEndIdx) {
        const bVolumeIdx = featureIdx;
        const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;
        if (bVolumeIdx >= bVolumes.length) {
            // Geometry might be extruded on any direction. To avoid extruding all vertices, the
            // centerline geometry is used to compute a bounding sphere whose radius is later
            // expanded by the extrusion half width to ensure it contains the extruded geometry.
            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));
        }
        intersectFeature(mesh, raycaster, localRay, halfWidth, localHalfWidth, localHalfWidthSq, beginIdx, endIdx, bVolumes[bVolumeIdx], intersections);
        beginIdx = endIdx;
    }
    return featureIdx;
}
/**
 * Mesh formed by extruding a polyline in the shaders. Overrides raycasting behaviour to account for
 * extrusion, see [[SolidLineMaterial]].
 * @internal
 */
class SolidLineMesh extends THREE.Mesh {
    /**
     * Finds the intersections of a ray with a mesh, assuming the mesh is a polyline extruded in
     * the shaders (see [[SolidLineMaterial]]).
     * @param mesh - The mesh whose intersections will be found.
     * @param raycaster - Contains the intersection ray.
     * @param intersections - Array where all intersections found between ray and mesh will
     *                        be pushed.
     */
    static raycast(mesh, raycaster, intersections) {
        harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type");
        const geometry = mesh.geometry;
        harp_utils_1.assert(geometry.index !== null, "Geometry does not have indices");
        const matrixWorld = mesh.matrixWorld;
        tmpInverseMatrix.getInverse(matrixWorld);
        const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
        // Test intersection of ray with each of the features within the mesh.
        if (!mesh.userData.feature) {
            mesh.userData.feature = {};
        }
        if (!mesh.userData.feature.boundingVolumes) {
            mesh.userData.feature.boundingVolumes = [];
        }
        const indices = geometry.index.array;
        if (Array.isArray(mesh.material)) {
            let nextFeatureIdx = 0;
            for (const group of geometry.groups) {
                const material = mesh.material[group.materialIndex];
                const groupEndIdx = group.start + group.count;
                nextFeatureIdx = intersectGroup(mesh, material, raycaster, localRay, nextFeatureIdx, groupEndIdx, intersections);
            }
        }
        else {
            intersectGroup(mesh, mesh.material, raycaster, localRay, 0, indices.length, intersections);
        }
    }
    /**
     * Creates an instance of SolidLineMesh.
     * @param geometry - Mesh geometry.
     * @param material - Material(s) to be used by the mesh. They must be instances of
     * [[SolidLineMaterial]].
     */
    constructor(geometry, material) {
        super(geometry, material);
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    // tslint:disable-next-line: explicit-override
    raycast(raycaster, intersects) {
        SolidLineMesh.raycast(this, raycaster, intersects);
    }
}
exports.SolidLineMesh = SolidLineMesh;
//# sourceMappingURL=SolidLineMesh.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDataAccessor = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileDataAccessor");
/**
 * An accessor for all geometries in a tile.
 *
 * @remarks
 * This class uses a client-provided {@link ITileDataVisitor}
 * to visit all objects, based on filtering options specified
 * by both, the `TileDataAccessor` and
 * the visitor itself.
 */
class TileDataAccessor {
    /**
     * Constructs a `TileDataAccessor` instance.
     *
     * @param tile - The tile to access.
     * @param visitor - The visitor.
     * @param options - Options for the tile.
     */
    constructor(tile, visitor, options) {
        this.tile = tile;
        this.visitor = visitor;
        this.m_wantsPoints = true;
        this.m_wantsLines = true;
        this.m_wantsAreas = true;
        this.m_wantsObject3D = true;
        const wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    /**
     * Calls the visitor on all objects in the tile.
     */
    visitAll() {
        const objects = this.tile.objects;
        for (const object of objects) {
            this.visitObject(object);
        }
    }
    /**
     * Visits a single object. This function should normally be called during visiting.
     *
     * @param object - The object to visit.
     */
    visitObject(object) {
        const featureData = object.userData !== undefined
            ? object.userData.feature
            : undefined;
        // early opt out if there is no feature data, or if the feature data has only a single id
        // and the visitor wants to ignore that featureId
        if (featureData === undefined ||
            (featureData.objInfos !== undefined &&
                featureData.objInfos.length === 1 &&
                !this.visitor.wantsFeature(harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])))) {
            return;
        }
        const geometryType = featureData.geometryType;
        if (geometryType === undefined) {
            logger.warn("#visitObject: visiting object failed, no geometryType", object);
            return;
        }
        harp_utils_1.assert(featureData.objInfos !== undefined, "featureData.ids missing");
        harp_utils_1.assert(featureData.starts !== undefined, "featureData.starts missing");
        harp_utils_1.assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {
            harp_utils_1.assert(featureData.objInfos.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
        }
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                if (!this.m_wantsPoints) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                if (!this.m_wantsLines) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                if (!this.m_wantsAreas) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                if (!this.m_wantsObject3D) {
                    return;
                }
                break;
            default:
                logger.warn("#visitObject: invalid geometryType");
        }
        if (object.type !== "Mesh") {
            logger.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
            return;
        }
        const mesh = object;
        this.visitMesh(mesh, featureData);
    }
    /**
     * Gets the `BufferGeometry` from the specified object. This function requires the
     * attribute `position` in `BufferGeometry` to be set.
     *
     * @param object - The object from which to get the geometry.
     * @returns the geometry of the object, or `undefined`.
     */
    getBufferGeometry(object) {
        const geometry = object.geometry;
        if (geometry.type !== "BufferGeometry") {
            logger.warn("#visitObject: object does not have BufferGeometry");
            return undefined;
        }
        const bufferGeometry = geometry;
        // we know its a BufferAttribute because it is a BufferGeometry
        const position = bufferGeometry.getAttribute("position");
        if (!position) {
            logger.warn("#visitLines: BufferGeometry has no position attribute");
            return undefined;
        }
        return bufferGeometry;
    }
    /**
     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType - The type of geometry.
     * @param object - The object for which to access the attributes and geometry.
     * @param bufferGeometry - The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
            default:
                logger.warn("#getGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Obtains an accessor for the indexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType - The type of geometry.
     * @param object - The object for which to access the attributes and geometry.
     * @param bufferGeometry - The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            default:
                logger.warn("#getIndexedGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Visit the object.
     *
     * @param meshObject - Object of type `Mesh`.
     * @param featureData - Dataset stored along with the object.
     */
    visitMesh(meshObject, featureData) {
        const { objInfos, starts } = featureData;
        const geometryType = featureData.geometryType;
        // make linter happy: we already know that these both are valid
        if (objInfos === undefined || starts === undefined || geometryType === undefined) {
            return;
        }
        let geometryAccessor;
        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {
            const featureId = harp_datasource_protocol_1.getFeatureId(objInfos[featureIndex]);
            if (!this.visitor.wantsFeature(featureId)) {
                continue;
            }
            const featureStart = starts[featureIndex];
            let featureEnd = -1;
            // lazy creation of accessor, in case featureId was not wanted...
            if (geometryAccessor === undefined) {
                const bufferGeometry = this.getBufferGeometry(meshObject);
                if (bufferGeometry === undefined) {
                    continue;
                }
                if (bufferGeometry.index !== null) {
                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                else {
                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                if (geometryAccessor === undefined) {
                    logger.warn("#visitObject: no accessor geometryType", geometryType);
                    continue;
                }
            }
            featureEnd =
                featureIndex < starts.length - 1
                    ? starts[featureIndex + 1]
                    : geometryAccessor.getCount();
            // setup/update the accessor for the new range of the object
            geometryAccessor.setRange(featureStart, featureEnd);
            switch (geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    this.visitor.visitPoint(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));
                    this.visitor.visitLine(featureId, geometryAccessor);
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    this.visitor.visitArea(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));
                    this.visitor.visitObject3D(featureId, geometryAccessor);
                    break;
                default:
                    logger.warn("#visitObject: invalid geometryType");
            }
        }
    }
}
exports.TileDataAccessor = TileDataAccessor;
//# sourceMappingURL=TileDataAccessor.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexedBufferedGeometryLineAccessor = exports.IndexedBufferedGeometryAccessor = exports.BufferedGeometryObject3dAccessor = exports.BufferedGeometryLineAccessor = exports.BufferedGeometryAccessor = exports.BufferedGeometryAccessorBase = exports.isObject3dAccessor = exports.isLineAccessor = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ "./node_modules/@here/harp-lines/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometry");
/**
 * Helper function to check if an accessor is of type `ILineAccessor`.
 *
 * @param arg - `true` if `arg` is `ILineAccessor`.
 */
function isLineAccessor(arg) {
    /**
     * Get vertices from the object.
     *
     * @param mode - Specifies which part of the vertices should be returned.
     */
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
exports.isLineAccessor = isLineAccessor;
/**
 * Helper function to check if an accessor is of type `IObject3dAccessor`.
 *
 * @param arg - `true` if `arg` is `IObject3dAccessor`.
 */
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
exports.isObject3dAccessor = isObject3dAccessor;
/**
 * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.
 */
class BufferedGeometryAccessorBase {
    constructor(object, geometryType, bufferGeometry) {
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.start = -1;
        this.end = -1;
        this.startCapSize = 0;
        this.endCapSize = 0;
        harp_utils_1.assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong " + "type");
        }
        harp_utils_1.assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        // we know its a BufferAttribute because it is a BufferGeometry
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position " +
                "attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: " +
                "unsupported ArrayBuffer");
        }
    }
    /**
     * Get the number of accessible geometries in this buffer.
     *
     * @returns Number of primitives in this geometry.
     */
    getCount() {
        return this.position.count;
    }
    /**
     * Get `renderOrder` of object.
     *
     * @returns `renderOrder` of the object.
     */
    get renderOrder() {
        return this.object.renderOrder;
    }
    setRange(start, end, startCapSize = 0, endCapSize = 0) {
        harp_utils_1.assert(start >= 0);
        harp_utils_1.assert(end >= 0);
        harp_utils_1.assert(start <= end);
        this.start = start;
        this.end = end;
        this.startCapSize = startCapSize;
        this.endCapSize = endCapSize;
    }
    /**
     * Get one or more colors from materials.
     */
    get color() {
        /**
         * TODO: Get color(s) from vertex colors
         */
        const getColor = (material) => {
            const meshMaterial = material;
            if (meshMaterial.type === "MeshBasicMaterial" ||
                meshMaterial.type === "MeshStandardMaterial") {
                return meshMaterial.color;
            }
            else if (meshMaterial.type === "RawShaderMaterial") {
                const rawShaderMaterial = material;
                if (rawShaderMaterial.name === "SolidLineMaterial") {
                    return rawShaderMaterial.uniforms.diffuse.value;
                }
                logger.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
            }
            else {
                logger.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
            }
            return undefined;
        };
        if (Array.isArray(this.object.material)) {
            const results = new Array();
            const materials = this.object.material;
            for (const material of materials) {
                results.push(getColor(material));
            }
            return results;
        }
        else {
            return getColor(this.object.material);
        }
    }
}
exports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;
/**
 * Abstract base class of an accessor for nonindexed geometry.
 */
class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Create an object of type `BufferedGeometryAccessor`
     *
     * @param object - mesh object
     * @param geometryType - type of geometry to be used
     * @param bufferGeometry - which buffer geometry to use
     * @param stride - geometry stride length
     */
    constructor(object, geometryType, bufferGeometry, stride) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.stride = stride;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const positionsArray = this.position.array;
        const start = this.start * this.itemSize;
        const end = this.end * this.itemSize;
        for (let i = start; i < end; i++) {
            positionsArray[i] = 0;
        }
        this.position.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const start = this.start;
        const end = this.end;
        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
    }
    checkSetUp() {
        return (this.position !== undefined &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.position.count &&
            this.start <= this.end);
    }
}
exports.BufferedGeometryAccessor = BufferedGeometryAccessor;
/**
 * Accessor for nonindexed line geometry.
 */
class BufferedGeometryLineAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    get width() {
        //TODO: There is no implementation of such a line, yet...
        harp_utils_1.assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
        return undefined;
    }
}
exports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;
/**
 * Accessor for nonindexed unspecified (`Object3D`) geometry.
 */
class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 1);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isObject3dAccessor() {
        return true;
    }
    /** @override */
    getVertices() {
        return super.getVertices();
    }
}
exports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;
/**
 * Abstract base class of indexed geometry.
 */
class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Creates an abstract class `IndexedBufferedGeometryAccessor`.
     *
     * @param object - mesh to be used
     * @param geometryType - type of geometry
     * @param bufferGeometry - geometry used
     * @param start -
     * @param end -
     */
    constructor(object, geometryType, bufferGeometry, 
    // tslint:disable-next-line:no-unused-variable
    start, 
    // tslint:disable-next-line:no-unused-variable
    end) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.indices =
            this.bufferGeometry.index !== null
                ? this.bufferGeometry.index.array
                : undefined;
        if (!this.indices) {
            logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no " + "index");
            harp_utils_1.assert(!!this.indices);
        }
        else {
            if (!(this.indices instanceof Uint32Array)) {
                logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index " +
                    "has wrong type");
                harp_utils_1.assert(this.indices instanceof Uint32Array);
            }
        }
    }
    /**
     * Returns number of primitives, which is not known in this base class, so we return the number
     * of indices.
     *
     * @returns The number of indices in the geometry.
     * @override
     */
    getCount() {
        return this.indices.length;
    }
    checkSetUp() {
        return (!!this.indices &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.indices.length &&
            this.start <= this.end);
    }
}
exports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;
/**
 * Accessor for lines in an indexed geometry.
 */
class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    /**
     * Reconstructs line width from triangulated geometry.
     *
     * @returns Line width.
     */
    get width() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {
            const start = this.start + this.startCapSize;
            const positionArray = this.position.array;
            return harp_lines_1.reconstructLineWidth(positionArray, start);
        }
        return undefined;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const start = this.start;
        const end = this.end;
        for (let i = start; i < end; i++) {
            this.indices[i] = 0;
        }
        if (this.bufferGeometry.index !== null) {
            this.bufferGeometry.index.needsUpdate = true;
        }
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const itemSize = this.itemSize;
        const start = this.start;
        const end = this.end;
        const result = new Float32Array((end - start) * itemSize);
        const positionArray = this.position.array;
        if (itemSize === 2) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
            }
        }
        if (itemSize === 3) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
                result[j + 2] = positionArray[index * itemSize + 2];
            }
        }
        else {
            for (let i = start, j = 0; i < end; i++, j++) {
                const index = this.indices[i];
                for (let k = 0; k < itemSize; k++) {
                    result[j * itemSize + k] = positionArray[index * itemSize + k];
                }
            }
        }
        return result;
    }
}
exports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;
//# sourceMappingURL=TileGeometry.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TileGeometryCreator = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
// tslint:disable:max-line-length
const EdgeLengthGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.js");
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
const DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js");
const MapMaterialAdapter_1 = __webpack_require__(/*! ../MapMaterialAdapter */ "./node_modules/@here/harp-mapview/lib/MapMaterialAdapter.js");
const MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js");
const MapView_1 = __webpack_require__(/*! ../MapView */ "./node_modules/@here/harp-mapview/lib/MapView.js");
const PathBlockingElement_1 = __webpack_require__(/*! ../PathBlockingElement */ "./node_modules/@here/harp-mapview/lib/PathBlockingElement.js");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const LodMesh_1 = __webpack_require__(/*! ./LodMesh */ "./node_modules/@here/harp-mapview/lib/geometry/LodMesh.js");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometryCreator");
const tmpVector3 = new THREE.Vector3();
const tmpVector2 = new THREE.Vector2();
class AttachmentCache {
    constructor() {
        this.bufferAttributes = new Map();
        this.interleavedAttributes = new Map();
    }
}
class MemoCallExpr extends harp_datasource_protocol_1.CallExpr {
    constructor(expr) {
        super("memo", [expr]);
        this.m_cachedProperties = [];
        this.m_deps = Array.from(expr.dependencies().properties);
        this.descriptor = this;
    }
    call(context) {
        let changed = false;
        this.m_deps.forEach((d, i) => {
            const newValue = context.env.lookup(d);
            if (!changed && newValue !== this.m_cachedProperties[i]) {
                changed = true;
            }
            if (changed) {
                this.m_cachedProperties[i] = newValue;
            }
        });
        if (changed || this.m_cachedValue === undefined) {
            this.m_cachedValue = context.evaluate(this.args[0]);
        }
        return this.m_cachedValue;
    }
}
class AttachmentInfo {
    constructor(geometry, info, cache) {
        this.geometry = geometry;
        this.info = info;
        this.cache = cache;
    }
    getBufferAttribute(description) {
        if (this.cache.bufferAttributes.has(description)) {
            return this.cache.bufferAttributes.get(description);
        }
        const attribute = DecodedTileHelpers_1.getBufferAttribute(description);
        this.cache.bufferAttributes.set(description, attribute);
        return attribute;
    }
    getInterleavedBufferAttributes(description) {
        const interleavedAttributes = this.cache.interleavedAttributes.get(description);
        if (interleavedAttributes) {
            return interleavedAttributes;
        }
        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(description.type);
        const buffer = new ArrayCtor(description.buffer);
        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);
        const attrs = description.attributes.map(interleavedAttr => {
            const attribute = new THREE.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
            const name = interleavedAttr.name;
            return { name, attribute };
        });
        this.cache.interleavedAttributes.set(description, attrs);
        return attrs;
    }
}
function addToExtrudedMaterials(material, extrudedMaterials) {
    if (Array.isArray(material)) {
        const materials = material;
        extrudedMaterials.push(...materials);
    }
    else {
        extrudedMaterials.push(material);
    }
}
/**
 * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.
 */
class TileGeometryCreator {
    /**
     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.
     */
    constructor() {
        //
    }
    /**
     * The `instance` of the `TileGeometryCreator`.
     *
     * @returns TileGeometryCreator
     */
    static get instance() {
        return this.m_instance || (this.m_instance = new TileGeometryCreator());
    }
    /**
     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a
     * technique is identified as disabled, its property `enabled` is set to `false`.
     *
     * @param decodedTile - The decodedTile containing the actual tile map data.
     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be
     *      created.
     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be
     *      created.
     */
    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
        for (const technique of decodedTile.techniques) {
            // tslint:disable-next-line: deprecation
            const kind = technique.kind;
            // No info about kind, no way to filter it.
            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {
                technique._kindState = true;
                continue;
            }
            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or
            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.
            technique._kindState =
                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||
                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));
        }
        for (const srcGeometry of decodedTile.geometries) {
            for (const group of srcGeometry.groups) {
                group.createdOffsets = [];
            }
        }
    }
    /**
     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before
     * calling this method.
     *
     * @see [[TileGeometryCreator#initDecodedTile]]
     *
     * @param tile - The {@link Tile} to process.
     * @param decodedTile - The decodedTile containing the actual tile map data.
     */
    createAllGeometries(tile, decodedTile) {
        const filter = (technique) => {
            return technique._kindState !== false;
        };
        this.createObjects(tile, decodedTile, filter);
        this.preparePois(tile, decodedTile);
        // TextElements do not get their geometry created by Tile, but are managed on a
        // higher level.
        const textFilter = (technique) => {
            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                !harp_datasource_protocol_1.isTextTechnique(technique)) {
                return false;
            }
            return filter(technique);
        };
        this.createTextElements(tile, decodedTile, textFilter);
        this.createLabelRejectionElements(tile, decodedTile);
        // HARP-7899, disable ground plane for globe
        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // The ground plane is required for when we change the zoom back and we fall back to the
            // parent, in that case we reduce the renderOrder of the parent tile and this ground
            // place ensures that parent doesn't come through. This value must be above the
            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper
            // covering of the parent tile by the children, hence dividing by 2. To put a bit more
            // concretely, we assume all objects are rendered with a renderOrder between 0 and
            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and
            // the fallback tiles have their renderOrder set between -20000 and -10000
            TileGeometryCreator.instance.addGroundPlane(tile, -MapView_1.FALLBACK_RENDER_ORDER_OFFSET / 2);
        }
    }
    createLabelRejectionElements(tile, decodedTile) {
        if (decodedTile.pathGeometries === undefined) {
            return;
        }
        for (const path of decodedTile.pathGeometries) {
            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));
        }
    }
    /**
     * Processes the given tile and assign default values for geometry kinds,
     * render orders and label priorities.
     *
     * @param {Tile} tile
     * @param {(GeometryKindSet | undefined)} enabledKinds
     * @param {(GeometryKindSet | undefined)} disabledKinds
     */
    processTechniques(tile, enabledKinds, disabledKinds) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        this.processPriorities(tile);
        // Speedup and simplify following code: Test all techniques if they intersect with
        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be
        // ignored hereafter.
        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
        // compile the dynamic expressions.
        const exprPool = tile.dataSource.exprPool;
        decodedTile.techniques.forEach((technique) => {
            for (const propertyName in technique) {
                if (!technique.hasOwnProperty(propertyName)) {
                    continue;
                }
                const value = technique[propertyName];
                if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== "kind") {
                    // "kind" is reserved.
                    try {
                        let expr = harp_datasource_protocol_1.Expr.fromJSON(value);
                        if (expr.dependencies().volatile !== true) {
                            expr = new MemoCallExpr(harp_datasource_protocol_1.Expr.fromJSON(value));
                        }
                        technique[propertyName] = expr.intern(exprPool);
                    }
                    catch (error) {
                        logger.error("Failed to compile expression:", error);
                    }
                }
            }
        });
    }
    /**
     * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].
     *
     * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the
     * object, such that the tile it belongs to can be identified during picking.
     *
     * @param tile - The {@link Tile} to add the object to.
     * @param object - The object to add to the root of the tile.
     * @param geometryKind - The kind of object. Can be used for filtering.
     * @param custom - additional parameters for [[MapObjectAdapter]]
     */
    registerTileObject(tile, object, geometryKind, mapAdapterParams) {
        const kind = geometryKind instanceof Set
            ? Array.from(geometryKind.values())
            : Array.isArray(geometryKind)
                ? geometryKind
                : [geometryKind];
        MapObjectAdapter_1.MapObjectAdapter.create(object, Object.assign({ kind }, mapAdapterParams));
        // TODO legacy fields, encoded directly in `userData to be removed
        if (object.userData === undefined) {
            object.userData = {};
        }
        const userData = object.userData;
        userData.tileKey = tile.tileKey;
        userData.dataSource = tile.dataSource.name;
        userData.kind = kind;
        // Force a visibility check of all objects.
        tile.resetVisibilityCounter();
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile - The {@link Tile} to process paths on.
     * @param textPathGeometries - The original path geometries that may have defects.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
        const processedPaths = new Array();
        const newPaths = textPathGeometries.slice();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            const technique = decodedTile.techniques[textPath.technique];
            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||
                (textFilter !== undefined && !textFilter(technique))) {
                continue;
            }
            processedPaths.push(textPath);
        }
        return processedPaths;
    }
    /**
     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The
     * priorities of the {@link TextElement}s are updated to simplify label placement.
     *
     * @param tile - The {@link Tile} to create the testElements on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    createTextElements(tile, decodedTile, textFilter) {
        const mapView = tile.mapView;
        const textStyleCache = tile.textStyleCache;
        const worldOffsetX = tile.computeWorldOffsetX();
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        if (decodedTile.textPathGeometries !== undefined) {
            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
                }
                // Make sorting stable.
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                const userData = textPath.objInfos;
                const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, textStyleCache.getRenderStyle(technique), textStyleCache.getLayoutStyle(technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);
                textElement.pathLengthSqr = textPath.pathLengthSqr;
                textElement.minZoomLevel =
                    technique.minZoomLevel !== undefined
                        ? technique.minZoomLevel
                        : mapView.minZoomLevel;
                textElement.maxZoomLevel =
                    technique.maxZoomLevel !== undefined
                        ? technique.maxZoomLevel
                        : mapView.maxZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;
                // tslint:disable-next-line: deprecation
                textElement.kind = technique.kind;
                // Get the userData for text element picking.
                textElement.userData = textPath.objInfos;
                textElement.textFadeTime = technique.textFadeTime;
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i) + worldOffsetX;
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;
                    const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textStyleCache.getRenderStyle(technique), textStyleCache.getLayoutStyle(technique), priority, technique.xOffset || 0.0, technique.yOffset || 0.0, featureId, technique.style, undefined, undefined, tile.offset);
                    textElement.minZoomLevel =
                        technique.minZoomLevel !== undefined
                            ? technique.minZoomLevel
                            : mapView.minZoomLevel;
                    textElement.maxZoomLevel =
                        technique.maxZoomLevel !== undefined
                            ? technique.maxZoomLevel
                            : mapView.maxZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    // tslint:disable-next-line: deprecation
                    textElement.kind = technique.kind;
                    textElement.fadeNear = fadeNear;
                    textElement.fadeFar = fadeFar;
                    textElement.textFadeTime = technique.textFadeTime;
                    // Get the userData for text element picking.
                    textElement.userData = userData;
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile - The {@link Tile} to create the geometry on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param techniqueFilter -: Optional filter. Should return true for any technique that is
     *      applicable.
     */
    createObjects(tile, decodedTile, techniqueFilter) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const materials = [];
        const extrudedMaterials = [];
        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
        const dataSource = tile.dataSource;
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const objects = tile.objects;
        const viewRanges = mapView.viewRanges;
        const elevationEnabled = mapView.elevationProvider !== undefined;
        for (const attachment of this.getAttachments(decodedTile)) {
            const srcGeometry = attachment.geometry;
            const groups = attachment.info.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (group.createdOffsets === undefined) {
                    group.createdOffsets = [];
                }
                if (group.createdOffsets.indexOf(tile.offset) !== -1 ||
                    technique._kindState === false ||
                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {
                    continue;
                }
                let count = group.count;
                group.createdOffsets.push(tile.offset);
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                    // Mark this group as created, so it does not get processed again.
                    groups[groupIndex].createdOffsets.push(tile.offset);
                }
                if (!DecodedTileHelpers_1.usesObject3D(technique)) {
                    continue;
                }
                const extrusionAnimationEnabled = (_a = animatedExtrusionHandler === null || animatedExtrusionHandler === void 0 ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) !== null && _a !== void 0 ? _a : false;
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    const onMaterialUpdated = (texture) => {
                        dataSource.requestUpdate();
                        if (texture !== undefined) {
                            tile.addOwnedTexture(texture);
                        }
                    };
                    material = DecodedTileHelpers_1.createMaterial({
                        technique,
                        env: mapView.env,
                        fog: mapView.scene.fog !== null,
                        shadowsEnabled: mapView.shadowsEnabled
                    }, onMaterialUpdated);
                    if (material === undefined) {
                        continue;
                    }
                    if (extrusionAnimationEnabled && harp_materials_1.hasExtrusionFeature(material)) {
                        addToExtrudedMaterials(material, extrudedMaterials);
                    }
                    materials[techniqueIndex] = material;
                }
                // tslint:disable-next-line: deprecation
                const techniqueKind = technique.kind;
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                }
                const bufferGeometry = new THREE.BufferGeometry();
                (_b = srcGeometry.vertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(vertexAttribute => {
                    const buffer = attachment.getBufferAttribute(vertexAttribute);
                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);
                });
                (_c = srcGeometry.interleavedVertexAttributes) === null || _c === void 0 ? void 0 : _c.forEach(attr => {
                    attachment
                        .getInterleavedBufferAttributes(attr)
                        .forEach(({ name, attribute }) => bufferGeometry.setAttribute(name, attribute));
                });
                const index = (_d = attachment.info.index) !== null && _d !== void 0 ? _d : srcGeometry.index;
                if (index) {
                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));
                }
                // Geometry with edges are typically buildings. If they are buildings, the outline
                // effect may be applied to it, which needs the normals.
                const isBuilding = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    attachment.info.edgeIndex !== undefined;
                if (!bufferGeometry.getAttribute("normal") &&
                    (isBuilding || harp_datasource_protocol_1.needsVertexNormals(technique))) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    // TODO: Unify access to shader defines via SolidLineMaterial setters
                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));
                    const lineMaterial = material;
                    if (technique.clipping !== false &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        tile.boundingBox.getSize(tmpVector3);
                        tmpVector2.set(tmpVector3.x, tmpVector3.y);
                        lineMaterial.clipTileSize = tmpVector2;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        harp_materials_1.setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
                    }
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                // When the source geometry is split in groups, we
                // should create objects with an array of materials.
                const hasFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                    srcGeometry.featureStarts &&
                    srcGeometry.featureStarts.length > 0;
                const object = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, hasFeatureGroups ? [material] : material, tile, elevationEnabled);
                object.renderOrder = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, mapView.env);
                if (attachment.info.uuid !== undefined) {
                    object.uuid = attachment.info.uuid;
                    object.userData.geometryId = attachment.info.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    // tslint:disable-next-line:max-line-length
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(mapView.env, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                this.addUserData(tile, srcGeometry, technique, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                    object.castShadow = mapView.shadowsEnabled;
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                else if (harp_datasource_protocol_1.isStandardTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) ||
                    harp_datasource_protocol_1.isStandardTechnique(technique) ||
                    harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    DepthPrePass_1.isRenderDepthPrePassEnabled(technique, discreteZoomEnv);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    // Set geometry kind for depth pass mesh so that it gets the displacement map
                    // for elevation overlay.
                    this.registerTileObject(tile, depthPassMesh, techniqueKind, {
                        technique
                    });
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                this.registerTileObject(tile, object, techniqueKind, {
                    technique
                });
                objects.push(object);
                // Add the extruded building edges as a separate geometry.
                if (isBuilding) {
                    const buildingTechnique = technique;
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.setAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
                    }
                    const normalAttribute = bufferGeometry.getAttribute("normal");
                    if (normalAttribute !== undefined) {
                        edgeGeometry.setAttribute("normal", normalAttribute);
                    }
                    const uvAttribute = bufferGeometry.getAttribute("uv");
                    if (uvAttribute !== undefined) {
                        edgeGeometry.setAttribute("uv", uvAttribute);
                    }
                    edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar,
                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);
                    }
                    this.registerTileObject(tile, edgeObj, techniqueKind, {
                        technique
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(edgeMaterial, {
                        color: buildingTechnique.lineColor,
                        opacity: buildingTechnique.opacity
                    });
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    object.customDepthMaterial = new harp_materials_1.MapMeshDepthMaterial({
                        depthPacking: THREE.RGBADepthPacking
                    });
                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);
                }
                // Add the fill area edges as a separate geometry.
                if (harp_datasource_protocol_1.isFillTechnique(technique) && attachment.info.edgeIndex) {
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    this.registerTileObject(tile, outlineObj, techniqueKind, {
                        technique
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: fillTechnique.lineColor,
                        opacity: fillTechnique.opacity
                    });
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    DecodedTileHelpers_1.applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, (_e = outlineTechnique.secondaryColor) !== null && _e !== void 0 ? _e : 0x000000, discreteZoomEnv);
                    if (outlineTechnique.secondaryCaps !== undefined) {
                        outlineMaterial.caps = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);
                    }
                    const outlineObj = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, outlineMaterial, tile, elevationEnabled);
                    outlineObj.renderOrder =
                        ((_f = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env)) !== null && _f !== void 0 ? _f : 0) - 0.0000001;
                    this.addUserData(tile, srcGeometry, technique, outlineObj);
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                    const secondaryWidth = DecodedTileHelpers_1.buildMetricValueEvaluator(outlineTechnique.secondaryWidth, 
                    // tslint:disable-next-line: deprecation
                    outlineTechnique.metricUnit);
                    this.registerTileObject(tile, outlineObj, techniqueKind, { technique });
                    const mainMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.get(material);
                    const outlineMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: outlineTechnique.secondaryColor,
                        opacity: outlineTechnique.opacity,
                        caps: outlineTechnique.secondaryCaps,
                        // Still handled above
                        lineWidth: (frameMapView) => {
                            if (!mainMaterialAdapter) {
                                return;
                            }
                            mainMaterialAdapter.ensureUpdated(frameMapView);
                            const mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;
                            const secondaryLineWidth = harp_datasource_protocol_1.getPropertyValue(secondaryWidth, mapView.env);
                            const opacity = outlineMaterialAdapter.currentStyledProperties
                                .opacity;
                            if (typeof mainLineWidth === "number" &&
                                typeof secondaryLineWidth === "number") {
                                if (secondaryLineWidth <= mainLineWidth &&
                                    (opacity === null || opacity === undefined || opacity === 1)) {
                                    // We could mark object as invisible somehow, not sure how
                                    // objectAdapter.markInvisible();
                                    return 0;
                                }
                                else {
                                    return secondaryLineWidth;
                                }
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                    objects.push(outlineObj);
                }
            }
        }
        if (extrudedMaterials.length > 0) {
            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);
        }
    }
    /**
     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Create a ground plane mesh for a tile
     * @param tile - Tile
     * @param material - Material
     * @param createTexCoords - Enable creation of texture coordinates
     */
    createGroundPlane(tile, material, createTexCoords, shadowsEnabled) {
        const { dataSource, projection, mapView } = tile;
        const sourceProjection = dataSource.getTilingScheme().projection;
        const shouldSubdivide = projection.type === harp_geoutils_1.ProjectionType.Spherical;
        const tmpV = new THREE.Vector3();
        function moveTileCenter(geom) {
            const attr = geom.getAttribute("position");
            const posArray = attr.array;
            for (let i = 0; i < posArray.length; i += 3) {
                tmpV.set(posArray[i], posArray[i + 1], posArray[i + 2]);
                projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posArray[i] = tmpV.x;
                posArray[i + 1] = tmpV.y;
                posArray[i + 2] = tmpV.z;
            }
            attr.needsUpdate = true;
        }
        // Create plane
        const { east, west, north, south } = tile.geoBox;
        const geometry = new THREE.BufferGeometry();
        const sw = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), new THREE.Vector3());
        const se = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), new THREE.Vector3());
        const nw = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), new THREE.Vector3());
        const ne = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), new THREE.Vector3());
        const posAttr = new THREE.BufferAttribute(new Float32Array([...sw.toArray(), ...se.toArray(), ...nw.toArray(), ...ne.toArray()]), 3);
        geometry.setAttribute("position", posAttr);
        if (shadowsEnabled === true) {
            sourceProjection.surfaceNormal(sw, tmpV);
            // Webmercator needs to have it negated to work correctly.
            tmpV.negate();
            const normAttr = new THREE.BufferAttribute(new Float32Array([
                ...tmpV.toArray(),
                ...tmpV.toArray(),
                ...tmpV.toArray(),
                ...tmpV.toArray()
            ]), 3);
            geometry.setAttribute("normal", normAttr);
        }
        geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
        if (createTexCoords) {
            const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
            geometry.setAttribute("uv", uvAttr);
        }
        if (shouldSubdivide) {
            const geometries = [];
            const sphericalModifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.MathUtils.degToRad(10), sourceProjection);
            const enableMixedLod = mapView.enableMixedLod || mapView.enableMixedLod === undefined;
            if (enableMixedLod) {
                // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level
                for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {
                    const subdivision = Math.pow(2, zoomLevelOffset);
                    const zoomLevelGeometry = geometry.clone();
                    if (subdivision > 1) {
                        const edgeModifier = new EdgeLengthGeometrySubdivisionModifier_1.EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, EdgeLengthGeometrySubdivisionModifier_1.SubdivisionMode.All, sourceProjection);
                        edgeModifier.modify(zoomLevelGeometry);
                    }
                    sphericalModifier.modify(zoomLevelGeometry);
                    moveTileCenter(zoomLevelGeometry);
                    geometries.push(zoomLevelGeometry);
                }
                return new LodMesh_1.LodMesh(geometries, material);
            }
            else {
                // Use static mesh if mixed LOD is disabled
                sphericalModifier.modify(geometry);
                moveTileCenter(geometry);
                return new THREE.Mesh(geometry, material);
            }
        }
        else {
            // Use static mesh for planar projection
            moveTileCenter(geometry);
            return new THREE.Mesh(geometry, material);
        }
    }
    /**
     * Creates and add a background plane for the tile.
     * @param tile - Tile
     * @param renderOrder - Render order of the tile
     */
    addGroundPlane(tile, renderOrder) {
        const shadowsEnabled = tile.mapView.shadowsEnabled;
        const material = this.createGroundPlaneMaterial(new THREE.Color(tile.mapView.clearColor), tile.mapView.shadowsEnabled, tile.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const mesh = this.createGroundPlane(tile, material, false, shadowsEnabled);
        mesh.receiveShadow = shadowsEnabled;
        mesh.renderOrder = renderOrder;
        this.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background);
        tile.objects.push(mesh);
    }
    createGroundPlaneMaterial(color, shadowsEnabled, depthWrite) {
        if (shadowsEnabled) {
            return new harp_materials_1.MapMeshStandardMaterial({
                color,
                visible: true,
                depthWrite,
                removeDiffuseLight: true
            });
        }
        else {
            return new harp_materials_1.MapMeshBasicMaterial({
                color,
                visible: true,
                depthWrite
            });
        }
    }
    /**
     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.
     *
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     */
    *getAttachments(decodedTile) {
        const cache = new AttachmentCache();
        for (const geometry of decodedTile.geometries) {
            // the main attachment
            const mainAttachment = {
                index: geometry.index,
                edgeIndex: geometry.edgeIndex,
                uuid: geometry.uuid,
                groups: geometry.groups
            };
            yield new AttachmentInfo(geometry, mainAttachment, cache);
            if (geometry.attachments) {
                // the additional attachments
                for (const info of geometry.attachments) {
                    yield new AttachmentInfo(geometry, info, cache);
                }
            }
        }
    }
    /**
     * Process the given {@link Tile} and assign default values to render orders
     * and label priorities.
     *
     * @param tile - The {@link Tile} to process.
     */
    processPriorities(tile) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        const theme = tile.mapView;
        if (!theme) {
            return;
        }
        const { priorities, labelPriorities } = tile.mapView.theme;
        decodedTile.techniques.forEach(technique => {
            if (harp_datasource_protocol_1.isTextTechnique(technique) ||
                harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique)) {
                // for screen-space techniques the `category` is used to assign
                // priorities.
                if (labelPriorities && typeof technique._category === "string") {
                    // override the `priority` when the technique uses `category`.
                    const priority = labelPriorities.indexOf(technique._category);
                    if (priority !== -1) {
                        technique.priority = labelPriorities.length - priority;
                    }
                }
            }
            else if (priorities && technique._styleSet !== undefined) {
                // Compute the render order based on the style category and styleSet.
                const computeRenderOrder = (category) => {
                    const priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(entry => entry.group === technique._styleSet && entry.category === category);
                    return priority !== undefined && priority !== -1
                        ? (priority + 1) * 10
                        : undefined;
                };
                if (typeof technique._category === "string") {
                    // override the renderOrder when the technique is using categories.
                    const renderOrder = computeRenderOrder(technique._category);
                    if (renderOrder !== undefined) {
                        technique.renderOrder = renderOrder;
                    }
                }
                if (typeof technique._secondaryCategory === "string") {
                    // override the secondaryRenderOrder when the technique is using categories.
                    const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);
                    if (secondaryRenderOrder !== undefined) {
                        technique.secondaryRenderOrder = secondaryRenderOrder;
                    }
                }
            }
        });
    }
    setupTerrainMaterial(technique, material, terrainColor) {
        if (technique.displacementMap === undefined) {
            // Render terrain using the given color.
            const stdMaterial = material;
            stdMaterial.color.set(terrainColor);
            return;
        }
        // Render terrain using height-based colors.
        material.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
            // We remove the displacement map from manipulating the vertices, it is
            // however still required for the pixel shader, so it can't be directly
            // removed.
            shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
        };
        material.displacementMap.needsUpdate = true;
    }
    addUserData(tile, srcGeometry, technique, object) {
        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
            harp_utils_1.assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
            harp_utils_1.assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
            const displacementMap = srcGeometry.objInfos[0];
            const tileDisplacementMap = {
                tileKey: tile.tileKey,
                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),
                displacementMap,
                geoBox: tile.geoBox
            };
            object.userData = tileDisplacementMap;
        }
        else {
            // Set the feature data for picking with `MapView.intersectMapObjects()` except for
            // solid-line which uses tile-based picking.
            const featureData = {
                geometryType: srcGeometry.type,
                starts: srcGeometry.featureStarts,
                objInfos: srcGeometry.objInfos
            };
            object.userData.feature = featureData;
            object.userData.technique = technique;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(env, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(env, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, env);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, env)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, env)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
exports.TileGeometryCreator = TileGeometryCreator;
//# sourceMappingURL=TileGeometryCreator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TileGeometryLoader = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "./node_modules/@here/harp-mapview/lib/Statistics.js");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js");
/**
 * Loads the geometry for its {@link Tile}. Loads all geometry in a single step.
 */
class TileGeometryLoader {
    constructor(m_tile) {
        this.m_tile = m_tile;
        this.m_isFinished = false;
    }
    /**
     * Make sure that all technique have their geometryKind set, either from the theme or their
     * default value.
     *
     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.
     *
     * @param {DecodedTile} decodedTile
     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.
     */
    static prepareAvailableGeometryKinds(decodedTile) {
        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();
        for (const technique of decodedTile.techniques) {
            const geometryKind = TileGeometryLoader.compileGeometryKind(technique);
            if (geometryKind instanceof Set) {
                for (const kind of geometryKind) {
                    foundSet.add(kind);
                }
            }
            else {
                foundSet.add(geometryKind);
            }
        }
        return foundSet;
    }
    /**
     * Make sure that the technique has its geometryKind set, either from the theme or their default
     * value.
     *
     * @param {Technique} technique
     */
    static compileGeometryKind(technique) {
        // tslint:disable-next-line: deprecation
        let geometryKind = technique.kind;
        // Set default kind based on technique.
        if (geometryKind === undefined) {
            if (harp_datasource_protocol_1.isFillTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;
            }
            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||
                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||
                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||
                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;
            }
            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||
                harp_datasource_protocol_1.isTextTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;
            }
            else {
                geometryKind = harp_datasource_protocol_1.GeometryKind.All;
            }
            // tslint:disable-next-line: deprecation
            technique.kind = geometryKind;
        }
        else if (Array.isArray(geometryKind)) {
            // tslint:disable-next-line: deprecation
            geometryKind = technique.kind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);
        }
        return geometryKind;
    }
    /**
     * The {@link Tile} this `TileGeometryLoader` is managing.
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.
     */
    get isFinished() {
        return this.m_isFinished;
    }
    /**
     * `True` if geometry of a `Tile` has been loaded but is not fully processed.
     */
    get geometryCreationPending() {
        // Geometry loading not yet finished and timeout already set, but not yet processing
        // (m_timeout !== undefined), or timeout callback already in progress
        // (m_timeout === undefined), but decoded tile still not reset.
        return !this.isFinished && this.m_decodedTile !== undefined;
    }
    /**
     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.
     */
    get basicGeometryLoaded() {
        return this.m_tile.hasGeometry;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        return this.m_isFinished;
    }
    /**
     * Set the {@link @here/harp-datasource-protocol#DecodedTile} of the tile.
     *
     * @remarks
     * Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        if (this.m_decodedTile !== undefined) {
            this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    /**
     * The kinds of geometry stored in this {@link Tile}.
     */
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    /**
     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.
     */
    update(enabledKinds, disabledKinds) {
        var _a;
        const tile = this.tile;
        // Cheap sanity check, do it first so no longer processing is needed.
        if (this.isFinished) {
            return;
        }
        // Check if tile should be already discarded (invisible, disposed).
        // If the tile is not ready for display, or if it has become invisible while being loaded,
        // for example by moving the camera, the tile is not finished and its geometry is not
        // created. This is an optimization for fast camera movements and zooms.
        if (this.discardNeedlessTile(tile)) {
            return;
        }
        // Finish loading if tile has no data.
        if (((_a = tile.tileLoader) === null || _a === void 0 ? void 0 : _a.isFinished) && tile.decodedTile === undefined) {
            this.finish();
            return;
        }
        // Geometry kinds have changed when loading, if so reset entire loading because
        // this geometry loader generates all geometry at once.
        if (this.geometryCreationPending &&
            !this.compareGeometryKinds(enabledKinds, disabledKinds)) {
            this.reset();
        }
        // First time this tile is handled, or reset has been requested.
        // Note: Finished condition already checked above.
        if (!this.geometryCreationPending && tile.decodedTile !== undefined) {
            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
            this.setGeometryKinds(enabledKinds, disabledKinds);
            this.setDecodedTile(tile.decodedTile);
            this.prepareForRender(enabledKinds, disabledKinds);
        }
    }
    /**
     * Dispose of any resources.
     */
    dispose() {
        this.m_decodedTile = undefined;
        // TODO: Release other resource: availableGeometryKind, enabled/disabled sets, timeout?
    }
    /**
     * Reset the loader to its initial state and cancels any asynchronous work.
     */
    reset() {
        var _a, _b, _c;
        (_a = this.m_availableGeometryKinds) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.m_enabledKinds) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this.m_disabledKinds) === null || _c === void 0 ? void 0 : _c.clear();
        this.m_decodedTile = undefined;
        this.m_isFinished = false;
        if (this.m_timeout !== undefined) {
            clearTimeout(this.m_timeout);
            this.m_timeout = undefined;
        }
    }
    finish() {
        this.m_tile.loadingFinished();
        this.m_tile.removeDecodedTile();
        this.m_decodedTile = undefined;
        this.m_isFinished = true;
        if (this.m_timeout !== undefined) {
            clearTimeout(this.m_timeout);
            this.m_timeout = undefined;
        }
    }
    /**
     * Called by {@link VisibleTileSet} to mark that {@link Tile} is
     * visible and it should prepare geometry.
     */
    prepareForRender(enabledKinds, disabledKinds) {
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        // Just a sanity check that satisfies compiler check below.
        if (decodedTile === undefined) {
            this.finish();
            return;
        }
        this.m_timeout = setTimeout(() => {
            // Reset timeout so it is untouched during processing.
            this.m_timeout = undefined;
            if (this.discardNeedlessTile(tile)) {
                return;
            }
            const stats = Statistics_1.PerformanceStatistics.instance;
            let now = 0;
            if (stats.enabled) {
                now = harp_utils_1.PerformanceTimer.now();
            }
            const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
            tile.clear();
            // Set up techniques which should be processed.
            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
            geometryCreator.createAllGeometries(tile, decodedTile);
            if (stats.enabled) {
                const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;
                const currentFrame = stats.currentFrame;
                // Account for the geometry creation in the current frame.
                currentFrame.addValue("render.fullFrameTime", geometryCreationTime);
                currentFrame.addValue("render.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined
                    ? decodedTile.textPathGeometries.length
                    : 0);
                currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);
                currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
            }
            this.finish();
            tile.dataSource.requestUpdate();
        }, 0);
    }
    discardNeedlessTile(tile) {
        // If the tile has become invisible while being loaded, for example by moving the
        // camera, the tile is not finished and its geometry is not created. This is an
        // optimization for fast camera movements and zooms.
        if (!tile.isVisible) {
            // Dispose the tile from the visible set, so it can be reloaded properly next time
            // it is needed.
            tile.mapView.visibleTileSet.disposeTile(tile);
            const stats = Statistics_1.PerformanceStatistics.instance;
            if (stats.enabled) {
                stats.currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`);
            }
            this.finish();
            return true;
        }
        // Tile already disposed (this may potentially happen in timeout callback).
        else if (tile.disposed) {
            const stats = Statistics_1.PerformanceStatistics.instance;
            if (stats.enabled) {
                stats.currentFrame.addMessage(
                // tslint:disable-next-line: max-line-length
                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - disposed`);
            }
            this.finish();
            return true;
        }
        return false;
    }
    /**
     * Stores geometry kinds used to load decoded tile geometry.
     *
     * This values are stored to detect geometry kind changes during loading.
     *
     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds - Set of geometry kinds that won't be rendered.
     */
    setGeometryKinds(enabledKinds, disabledKinds) {
        var _a, _b;
        if (enabledKinds !== undefined) {
            this.m_enabledKinds = Object.assign((_a = this.m_enabledKinds) !== null && _a !== void 0 ? _a : new harp_datasource_protocol_1.GeometryKindSet(), enabledKinds);
        }
        if (disabledKinds !== undefined) {
            this.m_disabledKinds = Object.assign((_b = this.m_disabledKinds) !== null && _b !== void 0 ? _b : new harp_datasource_protocol_1.GeometryKindSet(), disabledKinds);
        }
    }
    /**
     * Compare enabled and disabled geometry kinds with currently set.
     *
     * Method compares input sets with recently used geometry kinds in performance wise
     * manner, taking special care of undefined and zero size sets.
     *
     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds - Set of geometry kinds that won't be rendered.
     * @return `true` only if sets are logically equal, meaning that undefined and empty sets
     * may result in same geometry (techniques kind) beeing rendered.
     */
    compareGeometryKinds(enabledKinds, disabledKinds) {
        const enabledSame = this.m_enabledKinds === enabledKinds;
        const disabledSame = this.m_disabledKinds === disabledKinds;
        // Same references, no need to compare.
        if (enabledSame && disabledSame) {
            return true;
        }
        const enabledEmpty = (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&
            (enabledKinds === undefined || enabledKinds.size === 0);
        const disabledEmpty = (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&
            (disabledKinds === undefined || disabledKinds.size === 0);
        // We deal only with empty, the same or undefined sets - fast return, no need to compare.
        if ((enabledEmpty && disabledEmpty) ||
            (enabledSame && disabledEmpty) ||
            (disabledSame && enabledEmpty)) {
            return true;
        }
        // It is enough that one the the sets are different, try to spot difference otherwise
        // return true. Compare only non-empty sets.
        if (!enabledEmpty) {
            // If one set undefined then other must be non-empty, for sure different.
            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!enabledKinds.has(this.m_enabledKinds)) {
                return false;
            }
        }
        if (!disabledEmpty) {
            // One set defined and non-empty other undefined, for sure different.
            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!disabledKinds.has(this.m_disabledKinds)) {
                return false;
            }
        }
        // No difference found.
        return true;
    }
}
exports.TileGeometryLoader = TileGeometryLoader;
//# sourceMappingURL=TileGeometryLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileGeometryManager = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ "./node_modules/@here/harp-mapview/lib/MapObjectAdapter.js");
const TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js");
/**
 * Manages the content (the geometries) of a tile.
 */
class TileGeometryManager {
    /**
     * Creates an instance of `TileGeometryManager` with a reference to the {@link MapView}.
     */
    constructor(mapView) {
        this.mapView = mapView;
        /**
         * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they
         * are ignored.
         */
        this.enableFilterByKind = true;
        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();
        /**
         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the
         * visibility of the kinds is applied to their geometries.
         */
        this.m_visibilityCounter = 1;
    }
    /**
     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.
     */
    get enabledGeometryKinds() {
        return this.enabledKinds;
    }
    set enabledGeometryKinds(kinds) {
        this.enabledKinds = kinds;
    }
    /**
     * The set of geometry kinds that is disabled. Their geometry will not be created after
     * decoding.
     */
    get disabledGeometryKinds() {
        return this.disabledKinds;
    }
    set disabledGeometryKinds(kinds) {
        this.disabledKinds = kinds;
    }
    /**
     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden
     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.
     */
    get hiddenGeometryKinds() {
        return this.hiddenKinds;
    }
    set hiddenGeometryKinds(kinds) {
        this.hiddenKinds = kinds;
        this.incrementVisibilityCounter();
    }
    get visibilityCounter() {
        return this.m_visibilityCounter;
    }
    /**
     * Initialize the {@link Tile} with the TileGeometryManager.
     */
    initTile(tile) {
        if (tile.dataSource.useGeometryLoader) {
            tile.tileGeometryLoader = new TileGeometryLoader_1.TileGeometryLoader(tile);
        }
    }
    /**
     * Process the {@link Tile}s for rendering. May alter the content of the tile per frame.
     */
    updateTiles(tiles) {
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                geometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);
                if (this.m_tileUpdateCallback) {
                    this.m_tileUpdateCallback(tile);
                }
            }
        }
        // If the visibility status of the kinds changed since the last update, the new visibility
        // status is applied (again).
        if (this.updateTileObjectVisibility(tiles)) {
            this.mapView.update();
        }
    }
    /**
     * Clear the enabled, disabled and hidden sets.
     */
    clear() {
        this.enabledKinds.clear();
        this.disabledKinds.clear();
        this.hiddenKinds.clear();
    }
    /**
     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the enabled set.
     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in
     *      `false` to remove from that set.
     */
    enableKind(kind, addOrRemoveToEnabledSet = true) {
        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
    }
    /**
     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the disabled set.
     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in
     *      `false` to remove from that set.
     */
    disableKind(kind, addOrRemoveToDisabledSet = true) {
        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
    }
    /**
     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the hidden set.
     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show
     *      it again.
     */
    hideKind(kind, addOrRemoveToHiddenSet = true) {
        let visibilityHasChanged = false;
        if (Array.isArray(kind) || kind instanceof Set) {
            for (const oneKind of kind) {
                const visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
                visibilityHasChanged = visibilityHasChanged || visibilityChange;
            }
        }
        else {
            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
        }
        // Will be evaluated in the next update()
        if (visibilityHasChanged) {
            this.incrementVisibilityCounter();
        }
    }
    /**
     * Return all [[GeometryKind]]s that are contained in the tiles.
     *
     * @param {IterableIterator<Tile>} tiles The
     * @returns {GeometryKindSet}
     */
    getAvailableKinds(tiles) {
        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();
        for (const tile of tiles) {
            const geometryLoader = tile.tileGeometryLoader;
            if (geometryLoader !== undefined) {
                const tileKinds = geometryLoader.availableGeometryKinds;
                if (tileKinds !== undefined) {
                    for (const kind of tileKinds) {
                        visibleKinds.add(kind);
                    }
                }
            }
        }
        return visibleKinds;
    }
    /**
     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified
     * tiles.
     *
     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.
     */
    updateTileObjectVisibility(tiles) {
        let needUpdate = false;
        for (const tile of tiles) {
            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
                continue;
            }
            tile.visibilityCounter = this.visibilityCounter;
            for (const object of tile.objects) {
                const objectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
                const geometryKind = objectAdapter === null || objectAdapter === void 0 ? void 0 : objectAdapter.kind;
                if (geometryKind !== undefined) {
                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));
                    needUpdate = needUpdate || object.visible !== nowVisible;
                    object.visible = nowVisible;
                }
            }
        }
        return needUpdate;
    }
    /**
     * Sets a callback that will be called for every updated tile on [[updateTiles]].
     *
     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been
     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will
     * be cleared.
     */
    setTileUpdateCallback(callback) {
        this.m_tileUpdateCallback = callback;
    }
    incrementVisibilityCounter() {
        return ++this.m_visibilityCounter;
    }
    /**
     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    enableDisableKinds(set, kind, addToSet) {
        if (Array.isArray(kind)) {
            for (const oneKind of kind) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind instanceof Set) {
            const kindSet = kind;
            for (const oneKind of kindSet) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind !== undefined) {
            this.addRemove(set, kind, addToSet);
        }
    }
    /**
     * Add or remove a single kind from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    addRemove(kindsSet, kind, addToSet) {
        if (addToSet) {
            if (!kindsSet.has(kind)) {
                kindsSet.add(kind);
                return true;
            }
        }
        else {
            if (kindsSet.has(kind)) {
                kindsSet.delete(kind);
                return true;
            }
        }
        return false;
    }
}
exports.TileGeometryManager = TileGeometryManager;
//# sourceMappingURL=TileGeometryManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/VertexCache.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VertexCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
// Offsets for the fields stored in cache for each vertex.
var Field;
(function (Field) {
    Field[Field["VertexId"] = 0] = "VertexId";
    Field[Field["OlderIdx"] = 1] = "OlderIdx";
    Field[Field["NewerIdx"] = 2] = "NewerIdx";
    Field[Field["X"] = 3] = "X";
    Field[Field["Y"] = 4] = "Y";
    Field[Field["Z"] = 5] = "Z";
    Field[Field["Count"] = 6] = "Count";
})(Field || (Field = {}));
const Invalid = -1;
/**
 * Compact vertex LRU Cache for on the fly temporary mesh transformations.
 * @internal
 */
class VertexCache {
    /**
     * Creates a new cache with the specified maximum size.
     * @param maxVertexCount - The maximum number of vertices the cache will store.
     */
    constructor(maxVertexCount) {
        this.maxVertexCount = maxVertexCount;
        this.m_cache = []; // Stores all fields for every cached vertex (see Field).
        this.m_vertexCount = 0;
        this.m_oldestIdx = 0;
        this.m_newestIdx = 0;
        this.m_cache.length = this.maxVertexCount * Field.Count;
        this.clear();
    }
    /**
     * Clears the vertex cache.
     */
    clear() {
        this.m_cache.fill(Invalid);
        this.m_vertexCount = 0;
    }
    /**
     * Gets a vertex from cache.
     * @param vertexId - The id of the vertex to get.
     * @param vertex - The vertex coordinates will be set here if found.
     * @returns whether the vertex was found on cache.
     */
    get(vertexId, vertex) {
        const vertexIdx = this.find(vertexId);
        if (vertexIdx === undefined) {
            return false;
        }
        this.promoteEntry(vertexIdx);
        this.getVertex(vertexIdx, vertex);
        return true;
    }
    /**
     * Sets a vertex in cache. It's assumed there's no vertex with the same id already in cache.
     * @param vertexId - The vertex id.
     * @param vertex - The vertex coordinates.
     */
    set(vertexId, vertex) {
        let vertexIdx = Invalid;
        if (this.m_vertexCount < this.maxVertexCount) {
            vertexIdx = this.m_vertexCount * Field.Count;
            this.m_vertexCount++;
        }
        else {
            vertexIdx = this.m_oldestIdx;
        }
        if (this.m_vertexCount === 1) {
            this.m_oldestIdx = this.m_newestIdx = vertexIdx;
        }
        else {
            this.promoteEntry(vertexIdx);
        }
        this.setVertex(vertexIdx, vertexId, vertex);
    }
    find(vertexId) {
        const size = this.m_cache.length;
        for (let i = 0; i < size; i += Field.Count) {
            if (this.m_cache[i] === vertexId) {
                return i;
            }
        }
        return undefined;
    }
    promoteEntry(vertexIdx) {
        if (vertexIdx === this.m_newestIdx) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        const newerIdx = this.getNewerIdx(vertexIdx);
        const olderIdx = this.getOlderIdx(vertexIdx);
        if (newerIdx !== Invalid) {
            harp_utils_1.assert(this.getOlderIdx(newerIdx) === vertexIdx);
            this.setOlderIdx(newerIdx, olderIdx);
        }
        if (olderIdx !== Invalid) {
            harp_utils_1.assert(this.getNewerIdx(olderIdx) === vertexIdx);
            this.setNewerIdx(olderIdx, newerIdx);
        }
        if (vertexIdx === this.m_oldestIdx) {
            this.m_oldestIdx = newerIdx;
        }
        // re-link ourselves
        this.setNewerIdx(vertexIdx, Invalid);
        this.setOlderIdx(vertexIdx, this.m_newestIdx);
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newestIdx !== Invalid);
        harp_utils_1.assert(this.getNewerIdx(this.m_newestIdx) === Invalid);
        this.setNewerIdx(this.m_newestIdx, vertexIdx);
        this.m_newestIdx = vertexIdx;
    }
    getOlderIdx(vertexIdx) {
        return this.m_cache[vertexIdx + Field.OlderIdx];
    }
    setOlderIdx(vertexIdx, olderIdx) {
        this.m_cache[vertexIdx + Field.OlderIdx] = olderIdx;
    }
    getNewerIdx(vertexIdx) {
        return this.m_cache[vertexIdx + Field.NewerIdx];
    }
    setNewerIdx(vertexIdx, newerIdx) {
        this.m_cache[vertexIdx + Field.NewerIdx] = newerIdx;
    }
    getVertex(vertexIdx, vertex) {
        vertex.x = this.m_cache[vertexIdx + Field.X];
        vertex.y = this.m_cache[vertexIdx + Field.Y];
        vertex.z = this.m_cache[vertexIdx + Field.Z];
    }
    setVertex(vertexIdx, vertexId, vertex) {
        this.m_cache[vertexIdx] = vertexId;
        this.m_cache[vertexIdx + Field.X] = vertex.x;
        this.m_cache[vertexIdx + Field.Y] = vertex.y;
        this.m_cache[vertexIdx + Field.Z] = vertex.z;
    }
}
exports.VertexCache = VertexCache;
//# sourceMappingURL=VertexCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.overlayOnElevation = exports.overlayTextElement = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * Overlays the specified object's geometry on the elevation represented by the given displacement
 * map .
 *
 * @param object - The object to be overlaid.
 * @param displacementMap - Texture representing the elevation data used to overlay the object.
 */
function overlayObject(object, displacementMap) {
    if (!("material" in object)) {
        return;
    }
    const material = object.material;
    if (Array.isArray(material)) {
        material.forEach(mat => {
            if (harp_materials_1.hasDisplacementFeature(mat)) {
                mat.displacementMap = displacementMap;
            }
        });
    }
    else if (material && harp_materials_1.hasDisplacementFeature(material)) {
        material.displacementMap = displacementMap;
    }
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param worldCoords - World coordinates to overlay.
 * @param elevationProvider - Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {
    // TODO: Move calculation of text element geoCoordinates to decoder.
    const geoCoords = projection.unprojectPoint(worldCoords);
    if (displacementMap.geoBox.contains(geoCoords)) {
        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);
    }
    else {
        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);
        if (geoCoords.altitude === undefined) {
            return false;
        }
    }
    projection.projectPoint(geoCoords, worldCoords);
    return true;
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param path - World coordinates to overlay.
 * @param elevationProvider - Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPath(path, elevationProvider, displacementMap, projection) {
    for (const position of path) {
        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {
            return false;
        }
    }
    return true;
}
/**
 * Overlays a text element on top of elevation data if available.
 *
 * @param textElement - The text element whose geometry will be overlaid.
 * @param elevationProvider -  Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 */
function overlayTextElement(textElement, elevationProvider, displacementMap, projection) {
    harp_utils_1.assert(!textElement.elevated);
    if (!displacementMap) {
        return;
    }
    textElement.elevated = textElement.path
        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)
        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);
}
exports.overlayTextElement = overlayTextElement;
/**
 * Overlays the geometry in the given tile on top of elevation data if available. The tile's
 * elevation may be updated with a more precise range.
 *
 * @param tile - The tile whose geometry will be overlaid.
 */
function overlayOnElevation(tile) {
    const elevationProvider = tile.mapView.elevationProvider;
    if (elevationProvider === undefined || tile.objects.length === 0) {
        return;
    }
    const firstObject = tile.objects[0];
    if (!firstObject.userData ||
        !firstObject.userData.kind ||
        !firstObject.userData.kind.find((kind) => {
            return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;
        })) {
        return;
    }
    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);
    if (displacementMap === undefined) {
        return;
    }
    // TODO: HARP-8808 Apply displacement maps once per material.
    for (const object of tile.objects) {
        overlayObject(object, displacementMap.texture);
    }
}
exports.overlayOnElevation = overlayOnElevation;
//# sourceMappingURL=overlayOnElevation.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/Image.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/Image.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageItem = void 0;
var ImageItem;
(function (ImageItem) {
    /**
     * Missing Typedoc
     */
    function isLoading(imageItem) {
        return imageItem.loadingPromise !== undefined;
    }
    ImageItem.isLoading = isLoading;
})(ImageItem = exports.ImageItem || (exports.ImageItem = {}));
//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/ImageCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const MipMapGenerator_1 = __webpack_require__(/*! ./MipMapGenerator */ "./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js");
const logger = harp_utils_1.LoggerManager.instance.create("ImageCache");
const mipMapGenerator = new MipMapGenerator_1.MipMapGenerator();
/**
 * Combines an {@link ImageItem} with a list of [[MapViews]] that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem - The {@link ImageItem} referenced by
     *                    the associated {@link MapView}s instances.
     * @param mapView - An optional first {@link MapView} referencing the {@link ImageItem}.
     */
    constructor(imageItem, mapView) {
        this.imageItem = imageItem;
        /**
         * The list of {@link MapView}s referencing the {@link ImageItem}.
         */
        this.mapViews = [];
        if (mapView !== undefined) {
            this.mapViews.push(mapView);
        }
    }
}
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This
 * allows to have an image loaded only once for multiple views. THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object. Not normally implemented for singletons, but good for
     * debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView - Specifiy which {@link MapView} requests the image.
     * @param url - URL of image.
     * @param imageData - Optional [ImageData]] containing the image content.
     */
    registerImage(mapView, url, imageData) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        const mapViews = [];
        if (mapView !== undefined) {
            mapViews.push(mapView);
        }
        imageCacheItem = {
            imageItem: {
                url,
                imageData,
                loaded: false
            },
            mapViews
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView - {@link MapView} requesting the image.
     * @param url - URL of image.
     * @param startLoading - Optional flag. If `true` the image will be loaded in the background.
     */
    addImage(mapView, url, startLoading = true) {
        const imageItem = this.registerImage(mapView, url, undefined);
        if (imageItem !== undefined && startLoading === true) {
            return this.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find {@link ImageItem} for the specified URL.
     *
     * @param url - URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const imageItem = this.m_images.get(url);
        if (imageItem !== undefined) {
            return imageItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all {@link ImageItem}s belonging to a {@link MapView}. May remove cached items if no
     * {@link MapView} are registered anymore.
     *
     * @param mapView - MapView to remove all {@link ImageItem}s from.
     */
    clear(mapView) {
        const itemsToRemove = [];
        this.m_images.forEach(imageItem => {
            const mapViewIndex = imageItem.mapViews.indexOf(mapView);
            if (mapViewIndex >= 0) {
                imageItem.mapViews.splice(mapViewIndex, 1);
            }
            if (imageItem.mapViews.length === 0) {
                itemsToRemove.push(imageItem.imageItem.url);
            }
        });
        for (const keyToDelete of itemsToRemove) {
            this.m_images.delete(keyToDelete);
        }
    }
    /**
     * Clear all {@link ImageItem}s from all {@link MapView}s.
     */
    clearAll() {
        this.m_images = new Map();
    }
    /**
     * Returns the number of all cached {@link ImageItem}s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Load an {@link ImageItem}. If the loading process is already running, it returns the current
     * promise.
     *
     * @param imageItem - `ImageItem` containing the URL to load image from.
     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem) {
        if (imageItem.imageData !== undefined) {
            return imageItem;
        }
        if (imageItem.loadingPromise !== undefined) {
            return imageItem.loadingPromise;
        }
        const imageLoader = new THREE.ImageLoader();
        imageItem.loadingPromise = new Promise(resolve => {
            logger.debug(`Loading image: ${imageItem.url}`);
            imageLoader.load(imageItem.url, image => {
                logger.debug(`... finished loading image: ${imageItem.url}`);
                this.renderImage(imageItem, image)
                    .then(() => {
                    imageItem.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(imageItem);
                    imageItem.loadingPromise = undefined;
                    resolve(imageItem);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }, 
            // Loading events no longer supported
            undefined, errorEvent => {
                logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                imageItem.loadingPromise = undefined;
                resolve(undefined);
            });
        });
        return imageItem.loadingPromise;
    }
    /**
     * Find the cached {@link ImageItem} by URL.
     *
     * @param url - URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * [[HTMLCanvasElement]].
     *
     * @param imageItem - {@link ImageItem} to assign image data to.
     * @param image - [[HTMLImageElement]] to
     */
    renderImage(imageItem, image) {
        return new Promise((resolve, reject) => {
            // use createImageBitmap if it is available. It should be available in webworkers as
            // well
            if (typeof createImageBitmap === "function") {
                const options = {
                    premultiplyAlpha: "default"
                };
                logger.debug(`Creating bitmap image: ${imageItem.url}`);
                createImageBitmap(image, 0, 0, image.width, image.height, options)
                    .then(imageBitmap => {
                    logger.debug(`... finished creating bitmap image: ${imageItem.url}`);
                    imageItem.loadingPromise = undefined;
                    imageItem.imageData = imageBitmap;
                    imageItem.loaded = true;
                    resolve(imageBitmap);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    resolve(undefined);
                });
            }
            else {
                try {
                    if (typeof document === "undefined") {
                        logger.error("Error: document is not available, cannot generate image");
                        reject(new Error("ImageCache#renderImage: document is not available, cannot " +
                            "render image to create texture"));
                    }
                    // TODO: Extract the rendering to the canvas part and make it configurable for
                    // the client, so it does not rely on the `document`.
                    // use the image, e.g. draw part of it on a canvas
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const context = canvas.getContext("2d");
                    if (context !== null) {
                        logger.debug(
                        // tslint:disable-next-line: max-line-length
                        `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, image.width, image.height);
                        imageItem.imageData = imageData;
                        imageItem.loaded = true;
                        resolve(imageData);
                    }
                    else {
                        logger.error(`renderImage: no context found`);
                        reject(new Error(`ImageCache#renderImage: no context found`));
                    }
                }
                catch (ex) {
                    logger.error(`renderImage failed: ${ex}`);
                    imageItem.imageData = undefined;
                    imageItem.loaded = true;
                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));
                }
            }
        });
    }
}
exports.ImageCache = ImageCache;
//# sourceMappingURL=ImageCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewImageCache = void 0;
const ImageCache_1 = __webpack_require__(/*! ./ImageCache */ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js");
/**
 * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.
 *
 * @remarks
 * An image may have multiple names in
 * a theme, the `MapViewImageCache` will take care of that.
 * Registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    /**
     * The constructor for `MapViewImageCache`.
     *
     * @param mapView - a {@link MapView} instance.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Register an existing image by name.
     *
     * @param name - Name of the image from {@link @here/harp-datasource-protocol#Theme}.
     * @param url - URL of image.
     * @param image - Optional [[ImageData]] of image.
     */
    registerImage(name, url, image) {
        if (name !== undefined) {
            if (this.hasName(name)) {
                throw new Error("duplicate name in cache");
            }
            const oldNames = this.m_url2Name.get(url);
            if (oldNames !== undefined) {
                if (oldNames.indexOf(name) < 0) {
                    oldNames.push(name);
                }
            }
            else {
                this.m_url2Name.set(url, [name]);
            }
            this.m_name2Url.set(name, url);
        }
        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);
        if (imageItem === undefined) {
            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image);
        }
        return imageItem;
    }
    /**
     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]
     * will be stored in the {@link ImageItem}.
     *
     * @param name - Name of image from {@link @here/harp-datasource-protocol#Theme}.
     * @param url - URL of image.
     * @param startLoading - Optional. Pass `true` to start loading the image in the background.
     */
    addImage(name, url, startLoading = true) {
        const imageItem = this.registerImage(name, url, undefined);
        if (startLoading === true) {
            return ImageCache_1.ImageCache.instance.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Find {@link ImageItem} by its name.
     *
     * @param name - Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Find {@link ImageItem} by URL.
     *
     * @param url - Url of image.
     */
    findImageByUrl(url) {
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Load an {@link ImageItem}. Returns a promise or a loaded {@link ImageItem}.
     *
     * @param imageItem - ImageItem to load.
     */
    loadImage(imageItem) {
        return ImageCache_1.ImageCache.instance.loadImage(imageItem);
    }
    /**
     * Remove all {@link ImageItem}s from the cache.
     *
     * @remarks
     * Also removes all {@link ImageItem}s that belong to this
     * {@link MapView} from the global {@link ImageCache}.
     */
    clear() {
        ImageCache_1.ImageCache.instance.clear(this.mapView);
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Returns number of image names stored in the cache.
     */
    get numberOfNames() {
        return this.m_name2Url.size;
    }
    /**
     * Returns number of image URLs in the cache.
     */
    get numberOfUrls() {
        return this.m_url2Name.size;
    }
    /**
     * Return `true` if an image with the given name is known.
     *
     * @param name - Name of the image.
     */
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
    /**
     * Return `true` if an image with the given URL is known.
     * @param url - URL of image.
     */
    hasUrl(url) {
        return this.m_url2Name.get(url) !== undefined;
    }
    /**
     * Return the names under which an image with the given URL is saved.
     */
    findNames(url) {
        return this.m_url2Name.get(url);
    }
}
exports.MapViewImageCache = MapViewImageCache;
//# sourceMappingURL=MapViewImageCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MipMapGenerator = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const isNode = typeof window === "undefined";
/**
 * Mip map generator resizes textures to next bigger power-of-two size by adding padding
 * and creates mip map levels.
 * @internal
 */
class MipMapGenerator {
    constructor() {
        if (!isNode) {
            this.m_paddingCanvas = document.createElement("canvas");
            this.m_paddingContext = this.m_paddingCanvas.getContext("2d");
            this.m_resizeCanvas = document.createElement("canvas");
            this.m_resizeContext = this.m_resizeCanvas.getContext("2d");
        }
    }
    /**
     * Gets size of an image padded to the next bigger power-of-two size
     * @param width - Width of image
     * @param height - Height of image
     */
    static getPaddedSize(width, height) {
        return {
            width: THREE.MathUtils.ceilPowerOfTwo(width),
            height: THREE.MathUtils.ceilPowerOfTwo(height)
        };
    }
    /**
     * Generate downsampled mip map levels from an image.
     * If the input image is not power-of-two the image is padded to the
     * next bigger power-of-two size.
     * @param image - Input image
     * @returns A list of images with mip maps of the input image
     */
    generateTextureAtlasMipMap(image) {
        if (isNode) {
            throw new Error("MipMapGenerator only works in browser.");
        }
        if (image.imageData === undefined) {
            throw new Error("Can not generate mip maps. Image data not loaded!");
        }
        const imageData = image.imageData;
        const mipMaps = [];
        // Add initial texture with padding as level 0
        const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(imageData.width, imageData.height);
        this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);
        mipMaps.push(this.m_paddingContext.getImageData(0, 0, paddedWidth, paddedHeight));
        let width = paddedWidth * 0.5;
        let height = paddedHeight * 0.5;
        while (width >= 1 && height >= 1) {
            const mipMapLevel = mipMaps.length;
            const previousImage = mipMaps[mipMapLevel - 1];
            // Resize previous mip map level
            mipMaps.push(this.resizeImage(previousImage, width, height));
            width *= 0.5;
            height *= 0.5;
        }
        return mipMaps;
    }
    /**
     * Copy image to a canvas and add padding if necessary.
     * @param image - Input image.
     * @param width - Width of output image
     * @param height - Width of output image
     * @returns Canvas with image and padding.
     */
    copyImageWithPadding(image, width, height) {
        this.m_paddingCanvas.width = width;
        this.m_paddingCanvas.height = height;
        this.m_paddingContext.clearRect(0, 0, width, height);
        if (image instanceof ImageBitmap) {
            this.m_paddingContext.drawImage(image, 0, 0);
        }
        else {
            this.m_paddingContext.putImageData(image, 0, 0);
        }
        // Add horizontal padding
        if (image.width !== width) {
            this.m_paddingContext.drawImage(this.m_paddingCanvas, image.width - 1, 0, 1, image.height, image.width, 0, width - image.width, image.height);
        }
        // Add vertical padding
        if (image.height !== height) {
            this.m_paddingContext.drawImage(this.m_paddingCanvas, 0, image.height - 1, width, 1, 0, image.height, width, height - image.height);
        }
        return this.m_paddingCanvas;
    }
    /**
     * Resize an image.
     *
     * Quality of resized image is best when
     * image.width and image.height are even numbers and the image
     * is resized by factor 0.5 or 2.
     * @param image - Input image
     * @param width - Width of output image
     * @param height - Height of output image
     * @return Resized image
     */
    resizeImage(image, width, height) {
        //  Copy image data to canvas because ImageData can't be resized directly
        const paddedImage = this.copyImageWithPadding(image, image.width, image.height);
        // Resize image to resize canvas
        this.m_resizeCanvas.width = width;
        this.m_resizeCanvas.height = height;
        this.m_resizeContext.clearRect(0, 0, width, height);
        this.m_resizeContext.drawImage(paddedImage, 0, 0, width, height);
        return this.m_resizeContext.getImageData(0, 0, width, height);
    }
}
exports.MipMapGenerator = MipMapGenerator;
//# sourceMappingURL=MipMapGenerator.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BoxBuffer = exports.BoxBufferMesh = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js");
/**
 * Initial number of boxes in BoxBuffer.
 */
const START_BOX_BUFFER_SIZE = 0;
/**
 * Maximum number of boxes in BoxBuffer.
 */
const MAX_BOX_BUFFER_SIZE = 32 * 1024;
/**
 * Number of vertices per box/glyph element: 4 corners.
 */
const NUM_VERTICES_PER_ELEMENT = 4;
/**
 * Number of indices added per box/glyph: 2 triangles, 6 indices.
 */
const NUM_INDICES_PER_ELEMENT = 6;
/**
 * Number of values per position.
 */
const NUM_POSITION_VALUES_PER_VERTEX = 3;
/**
 * Number of values per color.
 */
const NUM_COLOR_VALUES_PER_VERTEX = 4;
/**
 * Number of values per UV.
 */
const NUM_UV_VALUES_PER_VERTEX = 4;
/**
 * Number of values per index.
 */
const NUM_INDEX_VALUES_PER_VERTEX = 1;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and
 * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.
 */
class BoxBufferMesh extends THREE.Mesh {
    constructor(geometry, material) {
        super(geometry, material);
        this.type = "BoxBufferMesh";
    }
    /**
     * A mesh that has no positions and indices set is defined to be empty.
     *
     * @returns `True` if no indices have been added to the mesh.
     */
    get isEmpty() {
        if (this.geometry === undefined) {
            return true;
        }
        else {
            const bufferGeometry = this.geometry;
            return bufferGeometry.index === null || bufferGeometry.index.count === 0;
        }
    }
}
exports.BoxBufferMesh = BoxBufferMesh;
/**
 * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-
 * aligned boxes, like POIs.
 */
class BoxBuffer {
    /**
     * Creates a new `BoxBuffer`.
     *
     * @param material - Material to be used for [[Mesh]] of this `BoxBuffer`.
     * @param renderOrder - Optional renderOrder of this buffer.
     * @param startElementCount - Initial number of elements this `BoxBuffer` can hold.
     * @param maxElementCount - Maximum number of elements this `BoxBuffer` can hold.
     */
    constructor(material, renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, maxElementCount = MAX_BOX_BUFFER_SIZE) {
        this.material = material;
        this.renderOrder = renderOrder;
        this.startElementCount = startElementCount;
        this.maxElementCount = maxElementCount;
        this.m_size = 0;
        this.resizeBuffer(startElementCount);
        this.pickInfos = new Array();
    }
    /**
     * Duplicate this `BoxBuffer` with same material and renderOrder.
     *
     * @returns A clone of this `BoxBuffer`.
     */
    clone() {
        return new BoxBuffer(this.material, this.renderOrder);
    }
    /**
     * Dispose of the geometry.
     */
    dispose() {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
            this.geometry = undefined;
        }
        this.internalMesh = undefined;
    }
    /**
     * Return the current number of elements the buffer can hold.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Clear's the `BoxBuffer` attribute buffers.
     */
    reset() {
        if (this.positionAttribute !== undefined) {
            this.positionAttribute.count = 0;
            this.colorAttribute.count = 0;
            this.uvAttribute.count = 0;
            this.indexAttribute.count = 0;
            this.pickInfos.length = 0;
        }
    }
    /**
     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer
     * can only add the glyph by increasing the buffer size, the resize() method is called, which
     * will then create a new geometry for the mesh.
     *
     * @param glyphCount - Number of glyphs to be added to the buffer.
     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.
     */
    canAddElements(glyphCount = 1) {
        const indexAttribute = this.indexAttribute;
        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=
            indexAttribute.array.length) {
            // Too many elements for the current buffer, check if we can resize the buffer.
            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {
                return false;
            }
            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);
            this.resize(newSize);
        }
        return true;
    }
    /**
     * Returns this `BoxBuffer`'s attribute [[State]].
     */
    saveState() {
        const state = {
            positionAttributeCount: this.positionAttribute.count,
            colorAttributeCount: this.colorAttribute.count,
            uvAttributeCount: this.uvAttribute.count,
            indexAttributeCount: this.indexAttribute.count,
            pickInfoCount: this.pickInfos.length
        };
        return state;
    }
    /**
     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.
     *
     * @param state - [[State]] struct describing a previous attribute state.
     */
    restoreState(state) {
        this.positionAttribute.count = state.positionAttributeCount;
        this.colorAttribute.count = state.colorAttributeCount;
        this.uvAttribute.count = state.uvAttributeCount;
        this.indexAttribute.count = state.indexAttributeCount;
        this.pickInfos.length = state.pickInfoCount;
    }
    /**
     * Adds a new box to this `BoxBuffer`.
     *
     * @param screenBox - [[Math2D.Box]] holding screen coordinates for this box.
     * @param uvBox - [[Math2D.UvBox]] holding uv coordinates for this box.
     * @param color - Box's color.
     * @param opacity - Box's opacity.
     * @param distance - Box's distance to camera.
     * @param pickInfo - Box's picking information.
     */
    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
        if (!this.canAddElements()) {
            return false;
        }
        const { s0, t0, s1, t1 } = uvBox;
        const { x, y, w, h } = screenBox;
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(opacity * 255);
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        const baseVertex = positionAttribute.count;
        const baseIndex = indexAttribute.count;
        positionAttribute.setXYZ(baseVertex, x, y, distance);
        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
        colorAttribute.setXYZW(baseVertex, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
        uvAttribute.setXY(baseVertex, s0, t0);
        uvAttribute.setXY(baseVertex + 1, s1, t0);
        uvAttribute.setXY(baseVertex + 2, s0, t1);
        uvAttribute.setXY(baseVertex + 3, s1, t1);
        indexAttribute.setX(baseIndex, baseVertex);
        indexAttribute.setX(baseIndex + 1, baseVertex + 1);
        indexAttribute.setX(baseIndex + 2, baseVertex + 2);
        indexAttribute.setX(baseIndex + 3, baseVertex + 2);
        indexAttribute.setX(baseIndex + 4, baseVertex + 1);
        indexAttribute.setX(baseIndex + 5, baseVertex + 3);
        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
        indexAttribute.count += NUM_INDICES_PER_ELEMENT;
        this.pickInfos.push(pickInfo);
        return true;
    }
    /**
     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute
     * data.
     */
    updateBufferGeometry() {
        const positionAttribute = this.positionAttribute;
        const colorAttribute = this.colorAttribute;
        const uvAttribute = this.uvAttribute;
        const indexAttribute = this.indexAttribute;
        if (positionAttribute.count > 0) {
            positionAttribute.needsUpdate = true;
            positionAttribute.updateRange.offset = 0;
            positionAttribute.updateRange.count =
                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (colorAttribute.count > 0) {
            colorAttribute.needsUpdate = true;
            colorAttribute.updateRange.offset = 0;
            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (uvAttribute.count > 0) {
            uvAttribute.needsUpdate = true;
            uvAttribute.updateRange.offset = 0;
            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (indexAttribute.count > 0) {
            indexAttribute.needsUpdate = true;
            indexAttribute.updateRange.offset = 0;
            indexAttribute.updateRange.count = indexAttribute.count;
        }
        if (this.geometry !== undefined) {
            this.geometry.clearGroups();
            this.geometry.addGroup(0, this.indexAttribute.count);
        }
    }
    /**
     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce
     * footprint.
     */
    cleanUp() {
        // If there is nothing in this buffer, resize it, it may never be used again.
        if (this.indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
            this.clearAttributes();
        }
    }
    /**
     * Determine if the mesh is empty.
     */
    get isEmpty() {
        return this.internalMesh.isEmpty;
    }
    /**
     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are
     * resized. The mesh, once created, will not change, so it can always be added to the scene.
     */
    get mesh() {
        if (this.internalMesh === undefined) {
            this.resize();
        }
        return this.internalMesh;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     * @param imageData - Image data to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, imageData) {
        const n = this.pickInfos.length;
        const pickInfos = this.pickInfos;
        const positions = this.positionAttribute;
        const screenX = screenPosition.x;
        const screenY = screenPosition.y;
        const canvas = document.createElement("canvas");
        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
            const minX = positions.getX(positionIndex);
            if (screenX < minX) {
                continue;
            }
            const maxX = positions.getX(positionIndex + 1);
            if (screenX > maxX) {
                continue;
            }
            const minY = positions.getY(positionIndex);
            if (screenY < minY) {
                continue;
            }
            const maxY = positions.getY(positionIndex + 2);
            if (screenY > maxY) {
                continue;
            }
            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);
            if (imageData !== undefined &&
                pickInfos[pickInfoIndex].poiInfo !== undefined &&
                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&
                this.isPixelTransparent(imageData, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, canvas)) {
                continue;
            }
            if (pickInfos[pickInfoIndex] !== undefined) {
                pickCallback(pickInfos[pickInfoIndex]);
            }
        }
    }
    /**
     * Creates a new {@link @here/harp-datasource-protocol#Geometry} object
     * from all the attribute data stored in this `BoxBuffer`.
     *
     * @remarks
     * The [[Mesh]] object may be created if it is not initialized already.
     *
     * @param newSize - Optional number of elements to resize the buffer to.
     * @param forceResize - Optional flag to force a resize even if new size is smaller than before.
     */
    resize(newSize, forceResize) {
        if (this.geometry !== undefined) {
            this.geometry.dispose();
        }
        this.geometry = new THREE.BufferGeometry();
        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {
            this.resizeBuffer(newSize);
        }
        this.geometry.setAttribute("position", this.positionAttribute);
        this.geometry.setAttribute("color", this.colorAttribute);
        this.geometry.setAttribute("uv", this.uvAttribute);
        this.geometry.setIndex(this.indexAttribute);
        this.geometry.addGroup(0, this.indexAttribute.count);
        if (this.internalMesh === undefined) {
            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);
            this.internalMesh.renderOrder = this.renderOrder;
        }
        else {
            this.internalMesh.geometry = this.geometry;
        }
        return this.internalMesh;
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.
     *
     * @param info - The info object to increment with the values from this `BoxBuffer`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +
            this.uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    /**
     * Check if a pixel is transparent or not.
     *
     * @param imageData - Data containing the pixels.
     * @param xScreenPos - X position of the pixel.
     * @param yScreenPos - Y position of the pixel.
     * @param box - Bounding box of the image in screen coordinates.
     * @param uvBox - Uv box referred to the given bounding box.
     * @param canvas - Canvas element that will be used to draw the image, in case the imageData is
     *      an `ImageBitmap`
     */
    isPixelTransparent(imageData, xScreenPos, yScreenPos, box, uvBox, canvas) {
        let pixelIsTransparent = false;
        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
        const imageWidth = imageData.width;
        const x = imageWidth * u;
        const imageHeight = imageData.height;
        const y = imageHeight * v;
        const pixel = PixelPicker_1.getPixelFromImage(x, y, imageData, canvas);
        if (pixel !== undefined && pixel[3] === 0) {
            pixelIsTransparent = true;
        }
        return pixelIsTransparent;
    }
    /**
     * Remove current attributes and arrays. Minimizes memory footprint.
     */
    clearAttributes() {
        this.positionAttribute = undefined;
        this.colorAttribute = undefined;
        this.uvAttribute = undefined;
        this.indexAttribute = undefined;
        this.resize(START_BOX_BUFFER_SIZE, true);
    }
    /**
     * Resize the attribute buffers. New value must be larger than the previous one.
     *
     * @param newSize - New number of elements in the buffer. Number has to be larger than the
     *      previous size.
     */
    resizeBuffer(newSize) {
        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {
            const positionAttributeCount = this.positionAttribute.count;
            newPositionArray.set(this.positionAttribute.array);
            this.positionAttribute.array = newPositionArray;
            this.positionAttribute.count = positionAttributeCount;
        }
        else {
            this.positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
            this.positionAttribute.count = 0;
            this.positionAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
        if (this.colorAttribute !== undefined) {
            const colorAttributeCount = this.colorAttribute.count;
            newColorArray.set(this.colorAttribute.array);
            this.colorAttribute.array = newColorArray;
            this.colorAttribute.count = colorAttributeCount;
        }
        else {
            this.colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
            this.colorAttribute.count = 0;
            this.colorAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
        if (this.uvAttribute !== undefined) {
            const uvAttributeCount = this.uvAttribute.count;
            newUvArray.set(this.uvAttribute.array);
            this.uvAttribute.array = newUvArray;
            this.uvAttribute.count = uvAttributeCount;
        }
        else {
            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
            this.uvAttribute.count = 0;
            this.uvAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
        const newIndexArray = numIndexValues > 65535
            ? new Uint32Array(numIndexValues)
            : new Uint16Array(numIndexValues);
        if (this.indexAttribute !== undefined) {
            const indexAttributeCount = this.indexAttribute.count;
            newIndexArray.set(this.indexAttribute.array);
            this.indexAttribute.array = newIndexArray;
            this.indexAttribute.count = indexAttributeCount;
        }
        else {
            this.indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
            this.indexAttribute.count = 0;
            this.indexAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        this.m_size = newSize;
    }
}
exports.BoxBuffer = BoxBuffer;
//# sourceMappingURL=BoxBuffer.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPixelFromImageData = exports.getPixelFromImageBitmap = exports.screenToUvCoordinates = exports.getPixelFromImage = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * It returns an array containing the channel colors for the pixel at the given coordinates.
 *
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param imageData - Data containing the pixels.
 * @param canvas - Canvas element that will be used to draw the image, in case the imageData is an
 * ImageBitmap
 */
function getPixelFromImage(xPos, yPos, imageData, canvas) {
    let pickedColor;
    const isImageBitmap = (imgData) => {
        return imgData.close !== undefined;
    };
    if (isImageBitmap(imageData)) {
        if (canvas === undefined) {
            canvas = document.createElement("canvas");
        }
        pickedColor = getPixelFromImageBitmap(imageData, xPos, yPos, canvas);
    }
    else {
        const pixelsData = imageData;
        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);
        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);
    }
    return pickedColor;
}
exports.getPixelFromImage = getPixelFromImage;
/**
 * Given the x and y position in screen coordinates inside the target box, it map them to the UV
 * coordinates.
 * @param screenX - X value in screen coordinates.
 * @param screenY - Y value in screen coordinates.
 * @param box - Bounding box in screen coordinates.
 * @param uvBox - Uv box referred to the given bounding box.
 */
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    const minX = box.x;
    const maxX = box.x + box.w;
    const minY = box.y;
    const maxY = box.y + box.h;
    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return { u, v };
}
exports.screenToUvCoordinates = screenToUvCoordinates;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image - Bitmap image in which the pixels are stored.
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param canvas - HTML Canvas element on which the image is drawn.
 */
function getPixelFromImageBitmap(image, xPos, yPos, canvas) {
    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {
        return undefined;
    }
    let pixelData;
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
exports.getPixelFromImageBitmap = getPixelFromImageBitmap;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image - Image data in which the pixels are stored.
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param stride - The stride value of the image data.
 */
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    const getPixel = (imageData, index, strd) => {
        const i = index * strd;
        const d = imageData.data;
        const pixel = new Uint8ClampedArray(strd);
        for (let s = 0; s < strd; s++) {
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return undefined;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
exports.getPixelFromImageData = getPixelFromImageData;
//# sourceMappingURL=PixelPicker.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/Poi.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/Poi.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageOrigin = void 0;
/**
 * This enum defines the possible origin points for an image.
 */
var ImageOrigin;
(function (ImageOrigin) {
    ImageOrigin[ImageOrigin["TopLeft"] = 0] = "TopLeft";
    ImageOrigin[ImageOrigin["BottomLeft"] = 1] = "BottomLeft";
})(ImageOrigin = exports.ImageOrigin || (exports.ImageOrigin = {}));
// export enum TextAlign {
//     Center,
//     Left,
//     Right,
//     // ??? expands lines to have same length.
//     Justify
// }
// export interface LayoutOptions {
//     paddingH?: number;
//     paddingV: number;
//     transFormCenterX?: number;
//     transFormCenterY?: number;
//     rotation?: number;
//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */
//     rotationEnlargesBox: boolean;
// }
// export interface TextOptions {
//     bgColor?: THREE.Color;
//     wrapWords?: boolean;
//     maxNumLines?: number;
//     maxWidth?: number;
//     /** Replace with ellipsis if wider than maxWidth. */
//     addEllipsis?: boolean;
//     /** Handle right-to-left texts */
//     isRightToLeft?: boolean;
//     textAlignH?: AlignH; // = AlignH.Center;
//     textAlignV?: AlignV; // = AlignV.Center;
// }
// export class IconLabel {
//     constructor(text: string, options: LayoutOptions | TextOptions) {}
//     /**
//      * Setup a box with size and padding.
//      *
//      * @param box - Target box to set up.
//      */
//     getBox(box: THREE.Box2) {}
//     /**
//      * Compute width and height from text and font.
//      */
//     computeBox() {}
//     /**
//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.
//      */
//     prepareRendering() {}
// }
// export enum AlignH {
//     Center,
//     Left,
//     Right
// }
// export enum AlignV {
//     Center,
//     Top,
//     Bottom
// }
// export enum AnchorTarget {
//     /** Anchor point relative to Icon */
//     Icon,
//     /** Anchor point is transform center of icon */
//     IconCenter,
//     /** Anchor point relative to Icon including padding */
//     IconBox,
//     /** Anchor point relative to Label */
//     Label,
//     /** Anchor point relative to combination of Icon and Label */
//     Box
// }
// export class AnchorPosition {
//     targetH: AnchorTarget = AnchorTarget.Icon;
//     targetV: AnchorTarget = AnchorTarget.Icon;
//     alignH: AlignH = AlignH.Center;
//     alignV: AlignV = AlignV.Center;
// }
// export enum IconPinMode {
//     /** Pinned down, anchor point is the same at all angles. */
//     PinDown,
//     /**
//      * Icon stands up. "StreetLevel"-style. The anchor point moves to the bottom of the icon when
//      * the view direction gets parallel to the ground.
//      */
//     StandUp
// }
// export interface IconScaleOptions {
//     depthScale?: boolean;
//     minimumScale?: number;
// }
// export interface IconOptions {
//     useScreenSpace?: boolean; // = true
//     priority?: number;
//     scaleOptions?: IconScaleOptions;
//     /** Optional offset in screen space */
//     screenOffsetX?: number;
//     screenOffsetY?: number;
//     /** Optional 3D height above terrain. */
//     heightAboveGround?: number;
// }
// export class SimplePoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image ?: IconTexture,
//         options ?: IconOptions
//     ) { }
// }
// export class PoiIcon {
//     constructor(
//         readonly pos: THREE.Vector3,
//         readonly image?: IconTexture,
//         readonly label?: IconLabel,
//         options?: IconOptions
//     ) {}
// }
// export interface PoiOptions {
//     featureId?: number;
//     minZoomLevel?: number;
// }
// export class SimplePoi {
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
// }
// export class Poi {
//     /** store multiple icons, one for every LOD */
//     private m_icons: PoiIcon[] = [];
//     private m_lod = 0;
//     private m_featureId?: number;
//     private m_minZoomLevel: number = 0;
//     constructor(icon: PoiIcon, options?: PoiOptions) {
//         this.m_icons.push(icon);
//         if (options !== undefined) {
//             this.m_featureId = options.featureId;
//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;
//         }
//     }
//     icon(): PoiIcon | undefined {
//         return this.m_icons[this.m_lod];
//     }
//     /**
//      * Select the level of detail that should be used.
//      *
//      * @param levelOfDetail - Level of detail to render.
//      */
//     selectIcon(levelOfDetail: number) {}
// }
//# sourceMappingURL=Poi.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoiManager = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const TextElement_1 = __webpack_require__(/*! ../text/TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiManager");
/**
 * POI manager class, responsible for loading the
 * {@link @here/harp-datasource-protocol#PoiGeometry} objects
 * from the {@link @here/harp-datasource-protocol#DecodedTile},
 * and preparing them for rendering.
 *
 * @remarks
 * Also loads and manages the texture atlases for the icons.
 */
let PoiManager = /** @class */ (() => {
    class PoiManager {
        /**
         * The constructor of the `PoiManager`.
         *
         * @param mapView - The {@link MapView} instance that should display the POIs.
         */
        constructor(mapView) {
            this.mapView = mapView;
            this.m_imageTextures = new Map();
            this.m_poiShieldGroups = new Map();
        }
        /**
         * Warn about a missing POI table name, but only once.
         * @param poiTableName - POI mapping table name.
         * @param poiTable - POI table instance.
         */
        static notifyMissingPoiTable(poiTableName, poiTable) {
            if (poiTableName === undefined) {
                poiTableName = "undefined";
            }
            if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {
                PoiManager.m_missingPoiTableName.set(poiTableName, true);
                if (poiTable !== undefined && !poiTable.loadedOk) {
                    logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
                }
                else {
                    logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
                }
            }
        }
        /**
         * Warn about a missing POI name, but only once.
         * @param poiName - name of POI.
         * @param poiTableName - POI mapping table name.
         */
        static notifyMissingPoi(poiName, poiTableName) {
            if (poiName === undefined) {
                poiName = "undefined";
            }
            const key = `${poiTableName}[${poiName}]`;
            if (PoiManager.m_missingPoiName.get(key) === undefined) {
                PoiManager.m_missingPoiName.set(key, true);
                logger.warn(`updatePoiFromPoiTable: ` +
                    `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
            }
        }
        /**
         * Add all POIs from a decoded tile and store them as {@link TextElement}s in the {@link Tile}.
         *
         * Also handles LineMarkers, which is a recurring marker along a line (road).
         *
         * @param tile - Tile to add POIs to.
         * @param decodedTile - DecodedTile containing the raw
         *                      {@link @here/harp-datasource-protocol#PoiGeometry}
         *                      objects describing the POIs.
         */
        addPois(tile, decodedTile) {
            const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);
            const worldOffsetX = tile.computeWorldOffsetX();
            for (const poiGeometry of poiGeometries) {
                harp_utils_1.assert(poiGeometry.technique !== undefined);
                const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);
                const technique = decodedTile.techniques[techniqueIndex];
                if (technique._kindState === false ||
                    (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {
                    continue;
                }
                // The POI may be in the data, and there may be a Technique, but the technique may
                // specify to not show it.
                if (technique.showOnMap === false) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
                if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {
                    this.addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX);
                }
                else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                    this.addPoi(tile, poiGeometry, technique, positions, worldOffsetX);
                }
            }
        }
        /**
         * Load the texture atlas that defines the segments of the texture that should be used for
         * specific icons.
         *
         * @remarks
         * Creates an {@link @here/harp-datasource-protocol#ImageTexture}
         * for every element in the atlas, such that it can
         * be addressed in the theme file.
         *
         * @param imageName - Name of the image from the theme (NOT the url!).
         * @param atlas - URL of the JSON file defining the texture atlas.
         */
        addTextureAtlas(imageName, atlas) {
            fetch(atlas)
                .then(response => {
                if (!response.ok) {
                    throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
                }
                return response.json();
            })
                .then((jsonAtlas) => {
                if (jsonAtlas === undefined) {
                    logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
                    return;
                }
                try {
                    logger.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
                    for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
                        const imageTextureDef = jsonAtlas[textureName];
                        const imageTexture = {
                            name: textureName,
                            image: imageName,
                            xOffset: imageTextureDef.x,
                            yOffset: imageTextureDef.y,
                            width: imageTextureDef.width,
                            height: imageTextureDef.height
                        };
                        this.addImageTexture(imageTexture);
                    }
                }
                catch (ex) {
                    logger.error(`addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`);
                }
                this.mapView.update();
            })
                .catch((reason) => {
                logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);
            });
        }
        /**
         * Add an {@link @here/harp-datasource-protocol#ImageTexture} such that it
         * is available as a named entity for techniques in theme files.
         *
         * @param imageTexture - {@link @here/harp-datasource-protocol#ImageTexture}
         *                       that should be available for POIs.
         */
        addImageTexture(imageTexture) {
            if (imageTexture.name === undefined) {
                logger.error("addImageTexture: Name required", imageTexture);
                return;
            }
            if (this.m_imageTextures.get(imageTexture.name) !== undefined) {
                logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);
            }
            this.m_imageTextures.set(imageTexture.name, imageTexture);
        }
        /**
         * Return the {@link @here/harp-datasource-protocol#ImageTexture}
         * registered under the specified name.
         *
         * @param name - Name of the {@link @here/harp-datasource-protocol#ImageTexture}.
         */
        getImageTexture(name) {
            return this.m_imageTextures.get(name);
        }
        /**
         * Update the {@link TextElement} with the information taken from the {@link PoiTable} which is
         * referenced in the {@link PoiInfo} of the pointLabel.
         *
         * If the requested {@link PoiTable} is not available yet, the function returns `false`.
         * If the {@link PoiTable} is not defined, or if the references POI has no entry in
         * the {@link PoiTable}, no action is taken, and the function returns `false`.
         *
         * If the {@link PoiTable} has been processed, it returns `true`, indicating that this function
         * doesn't have to be called again.
         *
         * @param pointLabel - The {@link TextElement} to update.
         *
         * @returns `true` if the {@link PoiTable} has been processed, and the
         *          function does not have to be called again.
         */
        updatePoiFromPoiTable(pointLabel) {
            const poiInfo = pointLabel.poiInfo;
            // PoiTable requires poiName to be defined otherwise mapping via PoiTable is
            // not possible, such as table key is not defined.
            if (poiInfo === undefined ||
                poiInfo.poiTableName === undefined ||
                poiInfo.poiName === undefined) {
                return true;
            }
            // Try to acquire PoiTable
            const poiTableName = poiInfo.poiTableName;
            const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
            // Check if PoiTable is found, but its still loading.
            if (poiTable !== undefined && poiTable.isLoading) {
                // The PoiTable is still loading, we have to try again.
                return false;
            }
            // Remove poiTableName to mark this POI as processed.
            poiInfo.poiTableName = undefined;
            // PoiTable not found or can not be loaded.
            if (poiTable === undefined || !poiTable.loadedOk) {
                PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
                return true;
            }
            // Try to acquire PoiTableEntry.
            const poiName = poiInfo.poiName;
            const poiTableEntry = poiTable.getEntry(poiName);
            if (poiTableEntry === undefined) {
                PoiManager.notifyMissingPoi(poiName, poiTableName);
                return true;
            }
            if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {
                poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
            }
            pointLabel.visible =
                poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;
            pointLabel.priority =
                poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;
            poiInfo.iconMinZoomLevel =
                poiTableEntry.iconMinLevel !== undefined
                    ? poiTableEntry.iconMinLevel
                    : poiInfo.iconMinZoomLevel;
            poiInfo.iconMaxZoomLevel =
                poiTableEntry.iconMaxLevel !== undefined
                    ? poiTableEntry.iconMaxLevel
                    : poiInfo.iconMaxZoomLevel;
            poiInfo.textMinZoomLevel =
                poiTableEntry.textMinLevel !== undefined
                    ? poiTableEntry.textMinLevel
                    : poiInfo.textMinZoomLevel;
            poiInfo.textMaxZoomLevel =
                poiTableEntry.textMaxLevel !== undefined
                    ? poiTableEntry.textMaxLevel
                    : poiInfo.textMaxZoomLevel;
            pointLabel.updateMinMaxZoomLevelsFromPoiInfo();
            return true;
        }
        /**
         * Clear internal state. Applicable when switching themes.
         */
        clear() {
            this.m_imageTextures.clear();
            this.m_poiShieldGroups.clear();
        }
        /**
         * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers
         * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken
         * care of later that not too many of them are rendered (obey `minDistance` attribute).
         */
        addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX) {
            const env = this.mapView.env;
            let imageTextureName = technique.imageTexture !== undefined
                ? harp_datasource_protocol_1.composeTechniqueTextureName(harp_datasource_protocol_1.getPropertyValue(technique.imageTexture, env), technique)
                : undefined;
            let text = "";
            let userData;
            let featureId;
            if (poiGeometry.stringCatalog !== undefined) {
                harp_utils_1.assert(poiGeometry.texts.length > 0);
                text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || "";
                if (poiGeometry.objInfos !== undefined) {
                    userData = poiGeometry.objInfos[0];
                    featureId = harp_datasource_protocol_1.getFeatureId(userData);
                }
                if (poiGeometry.imageTextures !== undefined) {
                    harp_utils_1.assert(poiGeometry.imageTextures.length > 0);
                    imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];
                }
            }
            // let the combined image texture name (name of image in atlas, not the URL) and
            // text of the shield be the group key, at worst scenario it may be:
            // "undefined-"
            const groupKey = String(imageTextureName) + "-" + text;
            let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
            if (shieldGroupIndex === undefined) {
                shieldGroupIndex = this.m_poiShieldGroups.size;
                this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
            }
            // Debugging help to identify the group of a shield :
            // text = groupKey + ": " + text;
            const positionArray = [];
            for (let i = 0; i < positions.count; i += 3) {
                const x = positions.getX(i) + worldOffsetX;
                const y = positions.getY(i);
                const z = positions.getZ(i);
                positionArray.push(new THREE.Vector3(x, y, z));
            }
            const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, undefined, // TBD for road shields
            undefined, shieldGroupIndex, featureId, positionArray, undefined, undefined, undefined, userData);
            // If the poi icon is rendered, the label that shows text should also be rendered.
            // The distance rule of the icon should apply, not the one for text (only) labels.
            textElement.ignoreDistance = false;
            tile.addTextElement(textElement);
        }
        /**
         * Create and add POI {@link TextElement}s to tile with a series of positions.
         */
        addPoi(tile, poiGeometry, technique, positions, worldOffsetX) {
            if (poiGeometry.stringCatalog === undefined) {
                return;
            }
            const env = tile.mapView.env;
            const techniqueTextureName = technique.imageTexture !== undefined
                ? harp_datasource_protocol_1.composeTechniqueTextureName(harp_datasource_protocol_1.getPropertyValue(technique.imageTexture, env), technique)
                : undefined;
            const poiTechnique = technique;
            const poiTableName = poiTechnique.poiTable;
            let poiName = poiTechnique.poiName;
            for (let i = 0; i < positions.count; ++i) {
                const x = positions.getX(i) + worldOffsetX;
                const y = positions.getY(i);
                const z = positions.getZ(i);
                harp_utils_1.assert(poiGeometry.texts.length > i);
                let imageTextureName = techniqueTextureName;
                const text = poiGeometry.stringCatalog[poiGeometry.texts[i]] || "";
                const userData = poiGeometry.objInfos !== undefined ? poiGeometry.objInfos[i] : undefined;
                const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                const offsetDirection = poiGeometry.offsetDirections === undefined ? 0 : poiGeometry.offsetDirections[i];
                if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {
                    harp_utils_1.assert(poiGeometry.imageTextures.length > i);
                    imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];
                }
                if (poiTableName !== undefined) {
                    // The POI name to be used is taken from the data, since it will
                    // specify the name of the texture to use.
                    // The POI name in the technique may override the POI name from the
                    // data.
                    poiName =
                        poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;
                    imageTextureName = undefined;
                }
                const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, 0, featureId, x, y, z, offsetDirection, userData);
                tile.addTextElement(textElement);
            }
        }
        /**
         * Create the {@link TextElement} for a POI.
         *
         * @remarks
         * Even if the POI has no text, it is required that there
         * is a {@link TextElement}, since POIs are hooked onto {@link TextElement}s
         * for sorting.(Sorted by priority attribute).
         */
        checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, shieldGroupIndex, featureId, x, y, z, offsetDirection, userData) {
            const priority = technique.priority !== undefined ? technique.priority : 0;
            const positions = Array.isArray(x) ? x : new THREE.Vector3(x, y, z);
            // The current zoomlevel of mapview. Since this method is called for all tiles in the
            // VisibleTileSet we can be sure that the current zoomlevel matches the zoomlevel where
            // the tile should be shown.
            const env = this.mapView.env;
            const fadeNear = technique.fadeNear !== undefined
                ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
                : technique.fadeNear;
            const fadeFar = technique.fadeFar !== undefined
                ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
                : technique.fadeFar;
            const xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, env);
            const yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, env);
            const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), positions, tile.textStyleCache.getRenderStyle(technique), tile.textStyleCache.getLayoutStyle(technique), harp_datasource_protocol_1.getPropertyValue(priority, env), xOffset !== undefined ? xOffset : 0.0, yOffset !== undefined ? yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset, offsetDirection);
            textElement.mayOverlap = technique.textMayOverlap === true;
            textElement.reserveSpace = technique.textReserveSpace !== false;
            textElement.alwaysOnTop = technique.alwaysOnTop === true;
            textElement.userData = userData;
            // imageTextureName may be undefined if a poiTable is used.
            if (imageTextureName === undefined && poiTableName !== undefined) {
                imageTextureName = "";
            }
            else if (imageTextureName !== undefined && poiTableName !== undefined) {
                logger.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
            }
            if (imageTextureName !== undefined) {
                const textIsOptional = technique.textIsOptional === true;
                const iconIsOptional = technique.iconIsOptional !== false;
                const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
                const iconMayOverlap = technique.iconMayOverlap === undefined
                    ? textElement.textMayOverlap
                    : technique.iconMayOverlap === true;
                const iconReserveSpace = technique.iconReserveSpace === undefined
                    ? textElement.textReservesSpace
                    : technique.iconReserveSpace !== false;
                const iconColorRaw = technique.iconColor
                    ? harp_datasource_protocol_1.getPropertyValue(technique.iconColor, env)
                    : null;
                const iconColor = iconColorRaw !== null ? ColorCache_1.ColorCache.instance.getColor(iconColorRaw) : undefined;
                textElement.poiInfo = {
                    technique,
                    imageTextureName,
                    poiTableName,
                    poiName,
                    shieldGroupIndex,
                    textElement,
                    textIsOptional,
                    iconIsOptional,
                    renderTextDuringMovements,
                    mayOverlap: iconMayOverlap,
                    reserveSpace: iconReserveSpace,
                    featureId,
                    iconBrightness: technique.iconBrightness,
                    iconColor,
                    iconMinZoomLevel: technique.iconMinZoomLevel,
                    iconMaxZoomLevel: technique.iconMaxZoomLevel,
                    textMinZoomLevel: technique.textMinZoomLevel,
                    textMaxZoomLevel: technique.textMaxZoomLevel
                };
                textElement.updateMinMaxZoomLevelsFromPoiInfo();
            }
            else {
                // Select the smaller/larger one of the two min/max values, because the TextElement
                // is a container for both.
                if (textElement.minZoomLevel === undefined) {
                    textElement.minZoomLevel = technique.textMinZoomLevel;
                }
                if (textElement.maxZoomLevel === undefined) {
                    textElement.maxZoomLevel = technique.textMaxZoomLevel;
                }
            }
            textElement.distanceScale =
                technique.distanceScale !== undefined
                    ? technique.distanceScale
                    : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
            // tslint:disable-next-line: deprecation
            textElement.kind = technique.kind;
            return textElement;
        }
    }
    // Keep track of the missing POI table names, but only warn once.
    PoiManager.m_missingPoiTableName = new Map();
    PoiManager.m_missingPoiName = new Map();
    return PoiManager;
})();
exports.PoiManager = PoiManager;
//# sourceMappingURL=PoiManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoiRenderer = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "./node_modules/@here/harp-materials/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const MipMapGenerator_1 = __webpack_require__(/*! ../image/MipMapGenerator */ "./node_modules/@here/harp-mapview/lib/image/MipMapGenerator.js");
const BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
const INVALID_RENDER_BATCH = -1;
const tempPos = new THREE.Vector3(0);
/**
 * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was
 * specified.
 */
const neutralColor = new THREE.Color(1, 1, 1);
/**
 * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.
 */
const tmpIconColor = new THREE.Color();
/**
 * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the
 * same icon image ({@link @here/harp-datasource-protocol#ImageTexture}).
 *
 * @remarks
 * If the image is the same, all the objects in this batch can
 * share the same material, which makes them renderable in the same draw call, whatever the number
 * of actual objects (WebGL limits apply!).
 *
 * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon
 * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.
 */
let PoiRenderBufferBatch = /** @class */ (() => {
    class PoiRenderBufferBatch {
        /**
         * Create the `PoiRenderBufferBatch`.
         *
         * @param mapView - The {@link MapView} instance.
         * @param scene - The three.js scene to add the POIs to.
         * @param imageItem - The icon that will have his material shared.
         * @param renderOrder - RenderOrder of the batch geometry's [[Mesh]].
         */
        constructor(mapView, scene, imageItem, renderOrder) {
            this.mapView = mapView;
            this.scene = scene;
            this.imageItem = imageItem;
            this.renderOrder = renderOrder;
        }
        /**
         * Initialize with the {@link @here/harp-datasource-protocol#ImageTexture}.
         *
         * @remarks
         * Loads the image and sets up the icon size, the texture
         * coordinates and material of the batch. Since image loading is done asynchronously, this
         * batch cannot be rendered right away. MapView#update is being triggered if it loaded
         * successfully.
         */
        init() {
            if (this.boxBuffer === undefined) {
                this.setup();
            }
        }
        /**
         * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.
         */
        reset() {
            if (this.boxBuffer === undefined) {
                this.init();
            }
            this.boxBuffer.reset();
        }
        /**
         * Update the geometry with all the added boxes during the frame.
         */
        update() {
            if (this.boxBuffer === undefined) {
                this.init();
            }
            this.boxBuffer.updateBufferGeometry();
        }
        /**
         * Update the info with the memory footprint caused by objects owned by the
         * `PoiRenderBufferBatch`.
         *
         * @param info - The info object to increment with the values from this `PoiRenderBufferBatch`.
         */
        updateMemoryUsage(info) {
            if (this.boxBuffer !== undefined) {
                this.boxBuffer.updateMemoryUsage(info);
            }
        }
        /**
         * Setup texture and material for the batch.
         */
        setup() {
            // Texture images should be generated with premultiplied alpha
            const premultipliedAlpha = true;
            const texture = new THREE.Texture(this.imageItem.imageData, THREE.UVMapping, undefined, undefined, PoiRenderBufferBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter, PoiRenderBufferBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter, THREE.RGBAFormat);
            if (PoiRenderBufferBatch.trilinear && this.imageItem.mipMaps) {
                // Generate mipmaps for distance scaling of icon
                texture.mipmaps = this.imageItem.mipMaps;
                texture.image = texture.mipmaps[0];
            }
            texture.flipY = false;
            texture.premultiplyAlpha = premultipliedAlpha;
            texture.needsUpdate = true;
            this.m_material = new harp_materials_1.IconMaterial({
                map: texture
            });
            this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);
            const mesh = this.boxBuffer.mesh;
            mesh.frustumCulled = false;
            this.scene.add(mesh);
            this.mapView.update();
        }
    }
    // Enable trilinear filtering to reduce flickering due to distance scaling
    PoiRenderBufferBatch.trilinear = true;
    return PoiRenderBufferBatch;
})();
/**
 * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiRenderBuffer {
    /**
     * Create the `PoiRenderBuffer`.
     *
     * @param mapView - The {@link MapView} to be rendered to.
     * @param textCanvas - The [[TextCanvas]] to which scenes this `PoiRenderBuffer`
     *                     adds geometry to.
     * The actual scene a {@link TextElement} is added to is specified by the renderOrder of the
     * {@link TextElement}.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        this.batches = [];
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.
     *
     * @param poiInfo - Describes the POI icon.
     */
    registerPoi(poiInfo) {
        const { imageItem, imageTexture, imageTextureName } = poiInfo;
        if (imageItem === undefined ||
            imageTextureName === undefined ||
            imageTexture === undefined) {
            // No image -> invisible -> ignore
            return INVALID_RENDER_BATCH;
        }
        const renderOrder = poiInfo.renderOrder;
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it.
        const batchKey = imageTexture.image;
        let batchSet = this.m_batchMap.get(batchKey);
        let mappedIndex;
        let bufferBatch;
        if (batchSet === undefined) {
            batchSet = new Map();
            this.m_batchMap.set(batchKey, batchSet);
        }
        mappedIndex = batchSet.get(renderOrder);
        if (mappedIndex !== undefined) {
            return mappedIndex;
        }
        mappedIndex = this.batches.length;
        let layer = this.textCanvas.getLayer(renderOrder);
        if (layer === undefined) {
            this.textCanvas.addText("", tempPos, { layer: renderOrder });
            layer = this.textCanvas.getLayer(renderOrder);
        }
        bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);
        bufferBatch.init();
        batchSet.set(renderOrder, mappedIndex);
        this.batches.push(bufferBatch);
        return mappedIndex;
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenBox - Box to render icon into in 2D coordinates.
     * @param viewDistance - Box's distance to camera.
     * @param opacity - Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, viewDistance, opacity) {
        const poiRegistered = poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;
        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch : this.registerPoi(poiInfo);
        if (batchIndex === INVALID_RENDER_BATCH) {
            return INVALID_RENDER_BATCH;
        }
        harp_utils_1.assert(batchIndex >= 0);
        harp_utils_1.assert(batchIndex < this.batches.length);
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        if (this.batches[batchIndex].boxBuffer === undefined) {
            this.batches[batchIndex].init();
        }
        let color;
        if (poiInfo.iconBrightness !== undefined) {
            color = tmpIconColor.setScalar(poiInfo.iconBrightness);
            if (poiInfo.iconColor !== undefined) {
                color = tmpIconColor.multiply(poiInfo.iconColor);
            }
        }
        else if (poiInfo.iconColor !== undefined) {
            color = poiInfo.iconColor;
        }
        else {
            color = neutralColor;
        }
        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);
        return batchIndex;
    }
    /**
     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid
     * if the imageTexture could not be found
     *
     * @param index - Index into batch array.
     */
    getBatch(index) {
        if (index >= 0) {
            harp_utils_1.assert(index < this.batches.length);
            return this.batches[index];
        }
        // may be invalid if the imageTexture could not be found
        return undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.batches) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.batches) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link PoiInfo}s are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.batches) {
            if (batch.boxBuffer === undefined) {
                batch.init();
            }
            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.
     *
     * @param info - The info object to increment with the values from this `PoiRenderBuffer`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.batches) {
            if (batch.imageItem.imageData !== undefined) {
                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;
                info.heapSize += imageBytes;
                info.gpuSize += imageBytes;
            }
            if (batch.boxBuffer !== undefined) {
                batch.boxBuffer.updateMemoryUsage(info);
            }
        }
    }
}
/**
 * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being
 * rendered.
 */
let PoiRenderer = /** @class */ (() => {
    class PoiRenderer {
        /**
         * Create the `PoiRenderer` for the specified {@link MapView}.
         *
         * @param mapView - The MapView to be rendered to.
         * @param textCanvas - The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to
         * the different layers of this [[TextCanvas]] based on renderOrder.
         */
        constructor(mapView, textCanvas) {
            this.mapView = mapView;
            this.textCanvas = textCanvas;
            // temporary variable to save allocations
            this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
            this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);
        }
        /**
         * Compute screen box for icon. It is required that `prepareRender` has been successfully called
         * before `computeScreenBox` may be called.
         *
         * @param poiInfo - PoiInfo containing information for rendering the POI icon.
         * @param screenPosition - Position on screen (2D).
         * @param scale - Scale to apply to icon.
         * @param env - Current zoom level.
         * @param screenBox - Box that will be used to store the result.
         * @returns The computed screen box for the icon.
         */
        static computeIconScreenBox(poiInfo, screenPosition, scale, env, 
        /* out */ screenBox = new harp_utils_1.Math2D.Box()) {
            harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
            harp_utils_1.assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);
            const width = poiInfo.computedWidth * scale;
            const height = poiInfo.computedHeight * scale;
            const technique = poiInfo.technique;
            const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
            const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
            const centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0) * scale;
            const centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0) * scale;
            screenBox.x = centerX - width / 2;
            screenBox.y = centerY - height / 2;
            screenBox.w = width;
            screenBox.h = height;
            return screenBox;
        }
        /**
         * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a
         * `poiRenderBatch` is assigned, the POI is ready to be rendered.
         *
         * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.
         * @param env - TODO! The current zoomLevel level of {@link MapView}
         *
         * @returns `True` if the space is not already allocated by another object (text label or POI)
         */
        prepareRender(pointLabel, env) {
            const poiInfo = pointLabel.poiInfo;
            if (poiInfo === undefined) {
                return false;
            }
            if (poiInfo.poiRenderBatch === undefined) {
                this.preparePoi(pointLabel, env);
            }
            return poiInfo.poiRenderBatch !== undefined;
        }
        /**
         * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the
         * beginning of a frame before the POIs are placed.
         */
        reset() {
            this.m_renderBuffer.reset();
        }
        /**
         * Render the icon.
         *
         * @param poiInfo - PoiInfo containing information for rendering the POI icon.
         * @param screenPosition - Position on screen (2D):
         * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.
         * @param viewDistance - Box's distance to camera.
         * @param scale - Scaling factor to apply to text and icon.
         * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.
         * @param opacity - Opacity of icon to allow fade in/out.
         */
        renderPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
            harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
            PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
            if (allocateScreenSpace) {
                screenCollisions.allocate(this.m_tempScreenBox);
            }
            this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
        }
        /**
         * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.
         */
        update() {
            this.m_renderBuffer.update();
        }
        /**
         * Fill the picking results for the pixel with the given screen coordinate. If multiple
         * {@link PoiInfo}s are found, the order of the results is unspecified.
         *
         * @param screenPosition - Screen coordinate of picking position.
         * @param pickCallback - Callback to be called for every picked element.
         */
        pickTextElements(screenPosition, pickCallback) {
            this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);
        }
        /**
         * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
         *
         * @param info - The info object to increment with the values from this `PoiRenderer`.
         */
        getMemoryUsage(info) {
            this.m_renderBuffer.updateMemoryUsage(info);
        }
        /**
         * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading
         * of the actual image.
         */
        preparePoi(pointLabel, env) {
            const poiInfo = pointLabel.poiInfo;
            if (poiInfo === undefined || !pointLabel.visible) {
                return;
            }
            if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {
                // Already set up, nothing to be done here.
                return;
            }
            if (poiInfo.poiTableName !== undefined) {
                if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {
                    if (!pointLabel.visible) {
                        // PoiTable set this POI to not visible.
                        return;
                    }
                }
                else {
                    // PoiTable has not been loaded, but is required to determine visibility.
                    return;
                }
            }
            const imageTextureName = poiInfo.imageTextureName;
            const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);
            if (imageTexture === undefined) {
                // Warn about a missing texture, but only once.
                if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {
                    PoiRenderer.m_missingTextureName.set(imageTextureName, true);
                    logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);
                }
                poiInfo.isValid = false;
                return;
            }
            const imageDefinition = imageTexture.image;
            let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);
            if (imageItem === undefined) {
                logger.error(`init: No imageItem found with name '${imageDefinition}'`);
                poiInfo.isValid = false;
                return;
            }
            if (!imageItem.loaded) {
                if (imageItem.loadingPromise !== undefined) {
                    // already being loaded, will be rendered once available
                    return;
                }
                const imageUrl = imageItem.url;
                const loading = this.mapView.imageCache.loadImage(imageItem);
                if (loading instanceof Promise) {
                    loading
                        .then(loadedImageItem => {
                        if (loadedImageItem === undefined) {
                            logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);
                            return;
                        }
                        this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, env);
                    })
                        .catch(error => {
                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);
                        poiInfo.isValid = false;
                    });
                    return;
                }
                else {
                    imageItem = loading;
                }
            }
            this.setupPoiInfo(poiInfo, imageTexture, imageItem, env);
        }
        /**
         * Setup texture and material for the batch.
         *
         * @param poiInfo - {@link PoiInfo} to initialize.
         * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},
         *                       defines used area in atlas.
         * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.
         * @param env - The current zoom level of {@link MapView}
         */
        setupPoiInfo(poiInfo, imageTexture, imageItem, env) {
            harp_utils_1.assert(poiInfo.uvBox === undefined);
            if (imageItem === undefined || imageItem.imageData === undefined) {
                logger.error("setupPoiInfo: No imageItem/imageData found");
                // invalid render batch number
                poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;
                poiInfo.isValid = false;
                return;
            }
            const technique = poiInfo.technique;
            const imageWidth = imageItem.imageData.width;
            const imageHeight = imageItem.imageData.height;
            const paddedSize = MipMapGenerator_1.MipMapGenerator.getPaddedSize(imageWidth, imageHeight);
            const trilinearFiltering = PoiRenderBufferBatch.trilinear && imageItem.mipMaps;
            const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;
            const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;
            const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
            const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
            let minS = 0;
            let maxS = 1;
            let minT = 0;
            let maxT = 1;
            let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
            let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
            const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
            const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
            const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;
            const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;
            minS = xOffset / paddedImageWidth;
            maxS = (xOffset + width) / paddedImageWidth;
            const flipY = false;
            if (flipY) {
                minT = (imageHeight - yOffset) / paddedImageHeight;
                maxT = (imageHeight - yOffset - height) / paddedImageHeight;
            }
            else {
                minT = yOffset / paddedImageHeight;
                maxT = (yOffset + height) / paddedImageHeight;
            }
            // minS += 0.5 / imageWidth;
            // maxS += 0.5 / imageWidth;
            // minT += 0.5 / imageHeight;
            // maxT += 0.5 / imageHeight;
            // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
            const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, env);
            if (screenWidth !== undefined) {
                iconScaleV = iconScaleH = screenWidth / iconWidth;
            }
            const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, env);
            if (screenHeight !== undefined) {
                iconScaleV = screenHeight / iconHeight;
                if (screenWidth !== undefined) {
                    iconScaleH = iconScaleV;
                }
            }
            // compute stored values in imageTexture
            poiInfo.computedWidth = iconWidth * iconScaleH;
            poiInfo.computedHeight = iconHeight * iconScaleV;
            poiInfo.uvBox = {
                s0: minS,
                t0: maxT,
                s1: maxS,
                t1: minT
            };
            poiInfo.imageItem = imageItem;
            poiInfo.imageTexture = imageTexture;
            poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);
            poiInfo.isValid = true;
            harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        }
    }
    // keep track of the missing textures, but only warn once
    PoiRenderer.m_missingTextureName = new Map();
    return PoiRenderer;
})();
exports.PoiRenderer = PoiRenderer;
//# sourceMappingURL=PoiRenderer.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoiRendererFactory = void 0;
const PoiRenderer_1 = __webpack_require__(/*! ./PoiRenderer */ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js");
class PoiRendererFactory {
    /**
     * Creates an instance of poi renderer factory.
     * @param m_mapView -
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
    }
    /**
     * Creates poi renderer
     * @param textCanvas -
     * @returns
     */
    createPoiRenderer(textCanvas) {
        return new PoiRenderer_1.PoiRenderer(this.m_mapView, textCanvas);
    }
}
exports.PoiRendererFactory = PoiRendererFactory;
//# sourceMappingURL=PoiRendererFactory.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PoiTableManager = exports.PoiTable = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const logger = harp_utils_1.LoggerManager.instance.create("PoiTable");
/**
 * Class to store and maintain individual POI information for the {@link PoiTable}.
 */
class PoiTableEntry {
    /**
     * Verify that the JSON description of the POI table entry is valid.
     *
     * @param jsonEntry - JSON description of the POI table entry.
     *
     * @returns `true` if the `jsonEntry` is valid.
     */
    static verifyJSON(jsonEntry) {
        let isOK = typeof jsonEntry.name === "string" &&
            jsonEntry.name.length > 0 &&
            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&
            (jsonEntry.stackMode === undefined ||
                jsonEntry.stackMode === "yes" ||
                jsonEntry.stackMode === "no" ||
                jsonEntry.stackMode === "parent") &&
            (jsonEntry.visible === undefined || typeof jsonEntry.visible === "boolean") &&
            (jsonEntry.priority === undefined || typeof jsonEntry.priority === "number") &&
            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === "number") &&
            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === "number") &&
            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === "number") &&
            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === "number");
        if (isOK && jsonEntry.altNames !== undefined) {
            const altNames = jsonEntry.altNames;
            for (const str in altNames) {
                if (typeof str !== "string") {
                    isOK = false;
                    break;
                }
            }
        }
        return isOK;
    }
    /**
     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has
     * been verified with [[PoiTableEntry#verifyJSON]].
     *
     * @param jsonEntry - JSON description of the POI table entry. Expected to have been verified
     *                    with [[PoiTableEntry#verifyJSON]].
     */
    setup(jsonEntry) {
        this.name = jsonEntry.name;
        this.altNames = jsonEntry.altNames;
        this.iconName = jsonEntry.iconName;
        this.visible = jsonEntry.visible;
        this.priority = jsonEntry.priority;
        this.iconMinLevel = jsonEntry.iconMinLevel;
        this.iconMaxLevel = jsonEntry.iconMaxLevel;
        this.textMinLevel = jsonEntry.textMinLevel;
        this.textMaxLevel = jsonEntry.textMaxLevel;
        switch (jsonEntry.stackMode) {
            case "yes":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;
                break;
            case "no":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;
                break;
            case "parent":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;
                break;
            default:
        }
    }
}
/**
 * The `PoiTable` stores individual information for each POI type. If a {@link TextElement} has a
 * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the
 * TextElement and its icon are read from the PoiTable.
 *
 * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the
 * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key
 * to look up the POIs in the {@link PoiTable}.
 *
 * On the side of the {@link PoiTable}, the key to look up the PoiTableEntry is either the property
 * "name" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names
 * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to
 * `true`, the `altNames` will be used.
 */
class PoiTable {
    /**
     * Creates an instance of PoiTable.
     *
     * @param {string} name Name of the `PoiTable`. Must be unique.
     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`
     *          to find a [[PoiTableEntry]] in the table.
     */
    constructor(name, useAltNamesForKey) {
        this.name = name;
        this.useAltNamesForKey = useAltNamesForKey;
        /**
         * Stores the list of [[PoiTableEntry]]s.
         */
        this.poiList = new Array();
        /**
         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for
         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of
         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.
         * Value assigned to key it is the index to [[poiList]] array which contain actual
         * [[PoiTabelEntry]] objects.
         */
        this.poiDict = new Map();
        this.m_isLoading = false;
        this.m_loadedOk = undefined;
    }
    /**
     * Returns `true` if the table is currently being loaded, `false` otherwise.
     *
     * @readonly
     */
    get isLoading() {
        return this.m_isLoading;
    }
    /**
     * Returns `true` if the table has been loaded correctly, `false` otherwise.
     *
     * @readonly
     */
    get loadedOk() {
        return this.m_loadedOk === true;
    }
    /**
     * Gets [[PoiTableEntry]] for poi name specified.
     *
     * @param poiName - poi name or one of its alternative names if [[useAltNamesForKey]] is
     * set to `true`.
     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.
     */
    getEntry(poiName) {
        const entryIdx = this.poiDict.get(poiName);
        if (entryIdx !== undefined) {
            if (entryIdx < this.poiList.length) {
                return this.poiList[entryIdx];
            }
            else {
                throw new Error("Poi table entry index out of stored list!");
            }
        }
        return undefined;
    }
    /**
     * Start to load the PoiTable from the specified URL. Can only be called once per table.
     *
     * @param {string} poiTableUrl URL that points to the JSON file.
     *
     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and
     *          the `PoiTable` has been set up.
     */
    async load(poiTableUrl) {
        if (this.m_loadedOk !== undefined) {
            // Only load once.
            return true;
        }
        this.m_loadedOk = false;
        const response = await fetch(poiTableUrl);
        if (!response.ok) {
            throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);
        }
        const jsonPoiTable = (await response.json());
        if (jsonPoiTable === undefined) {
            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);
            return true;
        }
        this.startLoading();
        try {
            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {
                for (const tableEntry of jsonPoiTable.poiList) {
                    if (PoiTableEntry.verifyJSON(tableEntry)) {
                        const newPoiEntry = new PoiTableEntry();
                        newPoiEntry.setup(tableEntry);
                        const entryIdx = this.poiList.push(newPoiEntry) - 1;
                        if (!this.useAltNamesForKey) {
                            // Use actual name of entry as the key
                            if (newPoiEntry.name === undefined) {
                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `. No name set in entry: ${tableEntry}.`);
                            }
                            else {
                                this.poiDict.set(newPoiEntry.name, entryIdx);
                            }
                        }
                        else {
                            if (newPoiEntry.altNames !== undefined &&
                                newPoiEntry.altNames.length > 0) {
                                // Use the list of alternative names as keys.
                                for (const altName of newPoiEntry.altNames) {
                                    this.poiDict.set(altName, entryIdx);
                                }
                            }
                            else {
                                logger.debug(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
                            }
                        }
                    }
                    else {
                        logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
                    }
                }
            }
            this.m_loadedOk = true;
            this.finishedLoading();
        }
        catch (ex) {
            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);
            this.m_loadedOk = false;
            this.finishedLoading();
            return false;
        }
        return true;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishedLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTable = PoiTable;
/**
 * The `PoiTableManager` manages the list of [[PoiTables]] that
 * can be defined in the {@link @here/harp-datasource-protocol#Theme} sfile.
 */
class PoiTableManager {
    /**
     * Creates an instance of PoiTableManager.
     * @param {MapView} mapView Owning {@link MapView}.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_isLoading = false;
        this.m_poiTables = new Map();
    }
    /**
     * Load the {@link PoiTable}s that are stored in the {@link MapView}s
     * {@link @here/harp-datasource-protocol#Theme}.
     *
     * @remarks
     * Note that duplicate names of {@link PoiTable}s in the
     * {@link @here/harp-datasource-protocol#Theme} will lead to inaccessible {@link PoiTable}s.
     *
     * @param theme - {@link @here/harp-datasource-protocol#Theme}
     *                containing all {@link PoiTable}s to load.
     *
     * @returns Resolved once all the {@link PoiTable}s in
     *          the {@link @here/harp-datasource-protocol#Theme} have been loaded.
     */
    async loadPoiTables(theme) {
        const finished = new Promise(resolve => {
            this.clear();
            // Add the POI tables defined in the theme.
            if (theme.poiTables !== undefined) {
                this.startLoading();
                // Gather promises to signal the success of having loaded them all
                const loadPromises = new Array();
                theme.poiTables.forEach((poiTableRef) => {
                    if (poiTableRef !== undefined &&
                        poiTableRef.name !== undefined &&
                        typeof poiTableRef.name === "string") {
                        const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === "string") {
                            this.addTable(poiTable);
                            loadPromises.push(poiTable.load(poiTableRef.url));
                        }
                        else {
                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);
                        }
                    }
                    else {
                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);
                    }
                });
                if (loadPromises.length > 0) {
                    Promise.all(loadPromises).finally(() => {
                        this.finishLoading();
                        resolve();
                    });
                }
                else {
                    this.finishLoading();
                    resolve();
                }
            }
            else {
                this.finishLoading();
                resolve();
            }
        });
        return finished;
    }
    /**
     * Clear the list of {@link PoiTable}s.
     */
    clear() {
        this.m_poiTables = new Map();
    }
    /**
     * Return the map of {@link PoiTable}s.
     */
    get poiTables() {
        return this.m_poiTables;
    }
    /**
     * Manually add a {@link PoiTable}. Normally, the [[PoiTables]]s
     * are specified in the {@link @here/harp-datasource-protocol#Theme}.
     *
     * @remarks
     * Ensure that the name is unique.
     */
    addTable(poiTable) {
        this.m_poiTables.set(poiTable.name, poiTable);
    }
    /**
     * Retrieve a {@link PoiTable} by name.
     *
     * @param {(string | undefined)} poiTableName Name of the {@link PoiTable}.
     *
     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`
     *          otherwise.
     */
    getPoiTable(poiTableName) {
        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);
    }
    /**
     * Return `true` if the {@link PoiTable}s have finished loading.
     *
     * @readonly
     */
    get finishedLoading() {
        return !this.m_isLoading;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTableManager = PoiTableManager;
//# sourceMappingURL=PoiTableManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FontCatalogLoader = exports.DEFAULT_FONT_CATALOG_NAME = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
exports.DEFAULT_FONT_CATALOG_NAME = "default";
const logger = harp_utils_1.LoggerManager.instance.create("FontCatalogLoader");
class FontCatalogLoader {
    constructor(m_theme) {
        this.m_theme = m_theme;
        this.m_catalogsLoading = 0;
    }
    /**
     * Initializes font catalog loader.
     * @param defaultFontCatalogUrl - Url of the font catalog that will be used by default if the
     * theme doesn't define any font catalog.
     * @returns Name of the default font catalog.
     */
    initialize(defaultFontCatalogUrl) {
        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {
            this.m_theme.fontCatalogs = [
                {
                    name: exports.DEFAULT_FONT_CATALOG_NAME,
                    url: defaultFontCatalogUrl
                }
            ];
            return exports.DEFAULT_FONT_CATALOG_NAME;
        }
        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;
        return defaultFontCatalogName;
    }
    async loadCatalogs(catalogCallback) {
        harp_utils_1.assert(this.m_theme.fontCatalogs !== undefined);
        harp_utils_1.assert(this.m_theme.fontCatalogs.length > 0);
        const promises = [];
        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {
            this.m_catalogsLoading += 1;
            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
                .then(catalogCallback.bind(undefined, fontCatalogConfig.name))
                .catch((error) => {
                logger.error("Failed to load FontCatalog: ", error);
            })
                .finally(() => {
                this.m_catalogsLoading -= 1;
            });
            promises.push(fontCatalogPromise);
        });
        return Promise.all(promises);
    }
    get loading() {
        return this.m_catalogsLoading > 0;
    }
}
exports.FontCatalogLoader = FontCatalogLoader;
//# sourceMappingURL=FontCatalogLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/LayoutState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/LayoutState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayoutState = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
/**
 * Layout state of the text part of the `TextElement`.
 *
 * Used mainly for multi-anchor placement algorithm.
 * @hidden
 */
class LayoutState {
    constructor(placement) {
        this.m_hAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
        this.m_vAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
        this.textPlacement = placement;
    }
    /**
     * Set layout based on theme style defined and optional text placement.
     *
     * @param placement - The optional new anchor placement.
     */
    set textPlacement(placement) {
        this.m_hAlign = harp_text_canvas_1.hAlignFromPlacement(placement.h);
        this.m_vAlign = harp_text_canvas_1.vAlignFromPlacement(placement.v);
    }
    /**
     * Acquire current placement setup.
     *
     * Function returns alternative or base placement depending on layout state.
     *
     * @returns The current anchor placement.
     */
    get textPlacement() {
        return {
            h: harp_text_canvas_1.hPlacementFromAlignment(this.m_hAlign),
            v: harp_text_canvas_1.vPlacementFromAlignment(this.m_vAlign)
        };
    }
    /**
     * Reset existing `LayoutState` to contain values from style/theme layout.
     */
    reset(layoutStyle) {
        this.m_hAlign = layoutStyle.horizontalAlignment;
        this.m_vAlign = layoutStyle.verticalAlignment;
    }
    get horizontalAlignment() {
        return this.m_hAlign;
    }
    get verticalAlignment() {
        return this.m_vAlign;
    }
}
exports.LayoutState = LayoutState;
//# sourceMappingURL=LayoutState.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/MapViewState.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/MapViewState.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewState = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * View state obtained from a MapView instance.
 */
class MapViewState {
    constructor(m_mapView, m_renderedTilesChangeCheck) {
        this.m_mapView = m_mapView;
        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;
        this.m_lookAtVector = new THREE.Vector3();
    }
    get worldCenter() {
        return this.m_mapView.worldCenter;
    }
    get cameraIsMoving() {
        return this.m_mapView.cameraIsMoving;
    }
    get maxVisibilityDist() {
        return this.m_mapView.viewRanges.maximum;
    }
    get zoomLevel() {
        return this.m_mapView.zoomLevel;
    }
    get env() {
        return this.m_mapView.env;
    }
    get frameNumber() {
        return this.m_mapView.frameNumber;
    }
    get lookAtVector() {
        return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);
    }
    get lookAtDistance() {
        return this.m_mapView.targetDistance;
    }
    get isDynamic() {
        return this.m_mapView.isDynamicFrame;
    }
    get hiddenGeometryKinds() {
        return this.m_mapView.tileGeometryManager === undefined
            ? undefined
            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;
    }
    get renderedTilesChanged() {
        return this.m_renderedTilesChangeCheck();
    }
    get projection() {
        return this.m_mapView.projection;
    }
    get elevationProvider() {
        return this.m_mapView.elevationProvider;
    }
}
exports.MapViewState = MapViewState;
//# sourceMappingURL=MapViewState.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/Placement.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/Placement.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorldPosition = exports.isPathLabelTooSmall = exports.placePathLabel = exports.placePointLabel = exports.placeIcon = exports.PlacementResult = exports.newPointLabelTextMarginPercent = exports.persistentPointLabelTextMargin = exports.checkReadyForPlacement = exports.PrePlacementResult = exports.getMaxViewDistance = exports.pointToPlaneDistance = exports.computeViewDistance = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js");
const ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js");
/**
 * Minimum number of pixels per character. Used during estimation if there is enough screen space
 * available to render a text.
 */
const MIN_AVERAGE_CHAR_WIDTH = 5;
/**
 * Functions related to text element placement.
 */
const tmpPosition = new THREE.Vector3(0, 0, 0);
const tmpCameraDir = new THREE.Vector3(0, 0, 0);
const tmpPointDir = new THREE.Vector3(0, 0, 0);
const COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)
/**
 * Checks whether the distance of the text element to the camera plane meets threshold criterias.
 *
 * @param textElement - The textElement of which the view distance will be checked, with coordinates
 * in world space.
 * @param eyePos - The eye (or camera) position that will be used as reference to calculate
 * the distance.
 * @param eyeLookAt - The eye looking direction - normalized.
 * @param maxViewDistance - The maximum distance value.
 * @returns The text element view distance if it's lower than the maximum value, otherwise
 * `undefined`.
 */
function checkViewDistance(textElement, eyePos, eyeLookAt, projectionType, maxViewDistance) {
    const textDistance = computeViewDistance(textElement, eyePos, eyeLookAt);
    if (projectionType !== harp_geoutils_1.ProjectionType.Spherical) {
        return textDistance <= maxViewDistance ? textDistance : undefined;
    }
    // For sphere projection: Filter labels that are close to the horizon
    tmpPosition.copy(textElement.position).normalize();
    tmpCameraDir.copy(eyePos).normalize();
    const cosAlpha = tmpPosition.dot(tmpCameraDir);
    const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance
        ? textDistance
        : undefined;
    return viewDistance;
}
/**
 * Computes distance of the specified text element to camera plane given with position and normal.
 *
 * The distance is measured as projection of the vector between `eyePosition` and text
 * eonto the `eyeLookAt` vector, so it actually computes the distance to plane that
 * contains `eyePosition` and is described with `eyeLookAt` as normal.
 *
 * @note Used for measuring the distances to camera, results in the metric that describes
 * distance to camera near plane (assuming near = 0). Such metric is better as input for labels
 * scaling or fading factors then simple euclidean distance because it does not fluctuate during
 * simple camera panning.
 *
 * @param textElement - The textElement of which the view distance will be checked. It must have
 *                      coordinates in world space.
 * @param eyePosition - The world eye coordinates used a reference position to calculate
 *                      the distance.
 * @param eyeLookAt - The eye looking direction or simply said projection plane normal.
 * @returns The text element view distance.
 */
function computeViewDistance(textElement, eyePosition, eyeLookAt) {
    let viewDistance;
    // Compute the distances as the distance along plane normal.
    const path = textElement.path;
    if (path && path.length > 1) {
        const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);
        const viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);
        viewDistance = Math.min(viewDistance0, viewDistance1);
    }
    else {
        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);
    }
    return viewDistance;
}
exports.computeViewDistance = computeViewDistance;
/**
 * Computes distance between the given point and a plane.
 *
 * May be used to measure distance of point labels to the camera projection (near) plane.
 *
 * @param pointPos - The position to measure distance to.
 * @param planePos - The position of any point on the plane.
 * @param planeNorm - The plane normal vector (have to be normalized already).
 */
function pointToPlaneDistance(pointPos, planePos, planeNorm) {
    const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);
    return labelCamVec.dot(planeNorm);
}
exports.pointToPlaneDistance = pointToPlaneDistance;
/**
 * Computes the maximum view distance for text elements as a ratio of the given view's maximum far
 * plane distance.
 * @param viewState - The view for which the maximum view distance will be calculated.
 * @param farDistanceLimitRatio - The ratio to apply to the maximum far plane distance.
 * @returns Maximum view distance.
 */
function getMaxViewDistance(viewState, farDistanceLimitRatio) {
    return viewState.maxVisibilityDist * farDistanceLimitRatio;
}
exports.getMaxViewDistance = getMaxViewDistance;
/**
 * State of fading.
 */
var PrePlacementResult;
(function (PrePlacementResult) {
    PrePlacementResult[PrePlacementResult["Ok"] = 0] = "Ok";
    PrePlacementResult[PrePlacementResult["NotReady"] = 1] = "NotReady";
    PrePlacementResult[PrePlacementResult["Invisible"] = 2] = "Invisible";
    PrePlacementResult[PrePlacementResult["TooFar"] = 3] = "TooFar";
    PrePlacementResult[PrePlacementResult["Duplicate"] = 4] = "Duplicate";
    PrePlacementResult[PrePlacementResult["Count"] = 5] = "Count";
})(PrePlacementResult = exports.PrePlacementResult || (exports.PrePlacementResult = {}));
const tmpPlacementPosition = new THREE.Vector3();
const tmpPlacementBounds = new THREE.Box2();
/**
 * Applies early rejection tests for a given text element meant to avoid trying to place labels
 * that are not visible, not ready, duplicates etc...
 * @param textElement - The Text element to check.
 * @param viewState - The view for which the text element will be placed.
 * @param viewCamera - The view's camera.
 * @param m_poiManager - To prepare pois for rendering.
 * @param maxViewDistance - If specified, text elements farther than this max distance will be
 *                          rejected.
 * @returns An object with the result code and the text element view distance
 * ( or `undefined` of the checks failed) as second.
 */
function checkReadyForPlacement(textElement, viewState, viewCamera, poiManager, maxViewDistance) {
    let viewDistance;
    if (!textElement.visible) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    // If a PoiTable is specified in the technique, the table is required to be
    // loaded before the POI can be rendered.
    if (!poiManager.updatePoiFromPoiTable(textElement)) {
        // PoiTable has not been loaded, but is required to determine
        // visibility.
        return { result: PrePlacementResult.NotReady, viewDistance };
    }
    // Text element visibility and zoom level ranges must be checked after calling
    // updatePoiFromPoiTable, since that function may change those values.
    if (!textElement.visible ||
        !harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    viewDistance =
        maxViewDistance === undefined
            ? computeViewDistance(textElement, viewState.worldCenter, viewState.lookAtVector)
            : checkViewDistance(textElement, viewState.worldCenter, viewState.lookAtVector, viewState.projection.type, maxViewDistance);
    if (viewDistance === undefined) {
        return { result: PrePlacementResult.TooFar, viewDistance };
    }
    return { result: PrePlacementResult.Ok, viewDistance };
}
exports.checkReadyForPlacement = checkReadyForPlacement;
/**
 * Computes the offset for a point text accordingly to text alignment (and icon, if any).
 * @param textElement - The text element of which the offset will computed. It must be a point
 * label with [[layoutStyle]] and [[bounds]] already computed.
 * @param placement - The relative anchor placement (may be different then original alignment).
 * @param scale - The scaling factor (due to distance, etc.).
 * @param env - The {@link @here/harp-datasource-protocol#Env} used
 *                  to evaluate technique attributes.
 * @param offset - The offset result.
 */
function computePointTextOffset(textElement, placement, scale, env, offset = new THREE.Vector2()) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PoiLabel);
    harp_utils_1.assert(textElement.layoutStyle !== undefined);
    harp_utils_1.assert(textElement.bounds !== undefined);
    offset.x = textElement.xOffset;
    offset.y = textElement.yOffset;
    switch (placement.h) {
        case harp_text_canvas_1.HorizontalPlacement.Left:
            // Already accounts for any margin that is already applied to the text element bounds.
            offset.x -= textElement.bounds.max.x;
            break;
        case harp_text_canvas_1.HorizontalPlacement.Right:
            // Account for any margin applied as above.
            offset.x -= textElement.bounds.min.x;
            break;
    }
    switch (placement.v) {
        case harp_text_canvas_1.VerticalPlacement.Top:
            offset.y -= textElement.bounds.min.y;
            break;
        case harp_text_canvas_1.VerticalPlacement.Center:
            offset.y -= 0.5 * (textElement.bounds.max.y + textElement.bounds.min.y);
            break;
        case harp_text_canvas_1.VerticalPlacement.Bottom:
            // Accounts for vertical margin that may be applied to the text bounds.
            offset.y -= textElement.bounds.max.y;
            break;
    }
    if (textElement.poiInfo !== undefined && TextElement_1.poiIsRenderable(textElement.poiInfo)) {
        harp_utils_1.assert(textElement.poiInfo.computedWidth !== undefined);
        harp_utils_1.assert(textElement.poiInfo.computedHeight !== undefined);
        // Apply offset moving text out of the icon
        offset.x += textElement.poiInfo.computedWidth * (0.5 + placement.h);
        offset.y += textElement.poiInfo.computedHeight * (0.5 + placement.v);
        // Reverse, mirror or project offsets on different axis depending on the placement
        // required only for alternative placements.
        const hAlign = harp_text_canvas_1.hPlacementFromAlignment(textElement.layoutStyle.horizontalAlignment);
        const vAlign = harp_text_canvas_1.vPlacementFromAlignment(textElement.layoutStyle.verticalAlignment);
        if (hAlign !== placement.h || vAlign !== placement.v) {
            // Read icon offset used.
            const technique = textElement.poiInfo.technique;
            let iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
            let iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
            iconXOffset = typeof iconXOffset === "number" ? iconXOffset : 0;
            iconYOffset = typeof iconYOffset === "number" ? iconYOffset : 0;
            // Now mirror the text offset relative to icon so manhattan distance is preserved, when
            // alternative position is taken, this ensures that text-icon relative position is
            // the same as in base alignment.
            const hAlignDiff = hAlign - placement.h;
            const vAlignDiff = vAlign - placement.v;
            const relOffsetX = iconXOffset - textElement.xOffset;
            const relOffsetY = iconYOffset - textElement.yOffset;
            const centerBased = hAlign === harp_text_canvas_1.HorizontalPlacement.Center || vAlign === harp_text_canvas_1.VerticalPlacement.Center;
            if (centerBased) {
                // Center based alternative placements.
                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;
                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);
                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;
                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);
            }
            else {
                // Corner alternative placements
                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;
                offset.y -=
                    2 *
                        Math.sign(vAlignDiff) *
                        Math.min(Math.abs(vAlignDiff), 0.5) *
                        Math.abs(relOffsetX);
                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;
                offset.x -=
                    2 *
                        Math.sign(hAlignDiff) *
                        Math.min(Math.abs(hAlignDiff), 0.5) *
                        Math.abs(relOffsetY);
            }
        }
    }
    offset.multiplyScalar(scale);
    return offset;
}
const tmpBox = new THREE.Box2();
const tmpBoxes = [];
const tmpMeasurementParams = {};
const tmpCollisionBoxes = [];
const tmpCollisionBox = new ScreenCollisions_1.CollisionBox();
const tmpScreenPosition = new THREE.Vector2();
const tmpTextOffset = new THREE.Vector2();
const tmp2DBox = new harp_utils_1.Math2D.Box();
const tmpCenter = new THREE.Vector2();
const tmpSize = new THREE.Vector2();
/**
 * The margin applied to the text bounds of every point label.
 */
exports.persistentPointLabelTextMargin = new THREE.Vector2(2, 2);
/**
 * Additional bounds scaling (described as percentage of full size) applied to the new labels.
 *
 * This additional scaling (margin) allows to account for slight camera position and
 * orientation changes, so new labels are placed only if there is enough space around them.
 * Such margin limits collisions with neighboring labels while doing small camera movements and
 * thus reduces labels flickering.
 */
exports.newPointLabelTextMarginPercent = 0.1;
var PlacementResult;
(function (PlacementResult) {
    PlacementResult[PlacementResult["Ok"] = 0] = "Ok";
    PlacementResult[PlacementResult["Rejected"] = 1] = "Rejected";
    PlacementResult[PlacementResult["Invisible"] = 2] = "Invisible";
})(PlacementResult = exports.PlacementResult || (exports.PlacementResult = {}));
/**
 * Places an icon on screen.
 * @param iconRenderState - The icon state.
 * @param poiInfo - Icon information necessary to compute its dimensions.
 * @param screenPosition - Screen position of the icon.
 * @param scaleFactor - Scaling factor to apply to the icon dimensions.
 * @param screenCollisions - Used to check the icon visibility and collisions.
 * @param env - Current map env.
 * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 */
function placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {
    PoiRenderer_1.PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);
    if (!iconSpaceAvailable) {
        return iconRenderState.isVisible() ? PlacementResult.Rejected : PlacementResult.Invisible;
    }
    return PlacementResult.Ok;
}
exports.placeIcon = placeIcon;
/**
 * Place a point label text using single or multiple alternative placement anchors.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env} used
 *              to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).
 * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`
 * for newly placed (upcoming) label or `PlacementResult.Rejected` if the label was persistent.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @param multiAnchor - The parameter decides if multi-anchor placement algorithm should be
 * used, be default [[false]] meaning try to place label using current alignment settings only.
 * @returns `PlacementResult.Ok` if point __label can be placed__ at the base or any optional
 * anchor point. `PlacementResult.Rejected` if there's a collision for all placements or it's
 * __persistent label with icon rejected and text visible__. Finally `PlacementResult.Invisible`
 * if it's text is not visible at any placement position or it's __new label with text or icon__
 * __rejected__.
 */
function placePointLabel(labelState, screenPosition, scale, textCanvas, env, screenCollisions, isRejected, outScreenPosition, multiAnchor = false) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    const layoutStyle = labelState.element.layoutStyle;
    // For the new labels with rejected icons we don't need to go further.
    // Make them invisible.
    const newLabel = !labelState.visible;
    if (isRejected && newLabel) {
        return PlacementResult.Invisible;
    }
    // Check if alternative placements have been provided.
    multiAnchor =
        multiAnchor && layoutStyle.placements !== undefined && layoutStyle.placements.length > 1;
    // For single placement labels or labels with icon rejected, do only current anchor testing.
    if (!multiAnchor || isRejected) {
        return placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, isRejected, outScreenPosition);
    }
    // Otherwise test also alternative text placements.
    else {
        return placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
    }
}
exports.placePointLabel = placePointLabel;
/**
 * Try to place a point label text using multiple optional placements.
 *
 * @note Function should be called only for labels with icons not rejected and for text alignments
 * different then [[HorizontalAlignment.Center]] and [[VerticalAlignment.Center]].
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if label can be placed at the base or optional anchor point,
 * `PlacementResult.Rejected` if there's a collision for all placements, `PlacementResult.Invisible`
 * if it's not visible at any placement position.
 *
 * @internal
 * @hidden
 */
function placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    const label = labelState.element;
    // Store label state - persistent or new label.
    const persistent = labelState.visible;
    // Start with last alignment settings if layout state was stored or
    // simply begin from layout defined in theme.
    const lastPlacement = labelState.textPlacement;
    const placements = label.layoutStyle.placements;
    const placementsNum = placements.length;
    // Find current anchor placement on the optional placements list.
    // Index of exact match.
    const matchIdx = placements.findIndex(p => p.h === lastPlacement.h && p.v === lastPlacement.v);
    harp_utils_1.assert(matchIdx >= 0);
    // Will be true if all text placements are invisible.
    let allInvisible = true;
    // Iterate all placements starting from current one.
    for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {
        const anchorPlacement = placements[i % placementsNum];
        // Bounds may be already calculated for persistent label, force re-calculation only
        // for alternative (new) placements.
        const isLastPlacement = i === matchIdx && persistent;
        // Compute label bounds, visibility or collision according to new layout settings.
        const placementResult = placePointLabelAtAnchor(labelState, screenPosition, anchorPlacement, scale, textCanvas, env, screenCollisions, false, !isLastPlacement, outScreenPosition);
        // Store last successful (previous) placement coordinates in temp variables.
        if (isLastPlacement) {
            harp_utils_1.assert(label.bounds !== undefined);
            tmpPlacementPosition.copy(outScreenPosition);
            tmpPlacementBounds.copy(label.bounds);
        }
        // Check the text allocation
        if (placementResult === PlacementResult.Invisible) {
            // Persistent label out of screen or the new label that is colliding - next iteration.
            continue;
        }
        else {
            // This placement is visible, but surely colliding.
            allInvisible = false;
        }
        // If text rejected (label collides), proceed to test further placements.
        if (placementResult === PlacementResult.Rejected) {
            continue;
        }
        // Proper placement found.
        return PlacementResult.Ok;
    }
    // Revert recent screen position and bounds.
    outScreenPosition.copy(tmpPlacementPosition);
    label.bounds.copy(tmpPlacementBounds);
    // Revert back text canvas layout of the last placement.
    // In case of label rejected this allows to fade out text in the last position.
    applyTextPlacement(textCanvas, lastPlacement);
    return allInvisible
        ? // All text's placements out of the screen.
            PlacementResult.Invisible
        : persistent
            ? // All placements are either colliding or out of screen for persistent label.
                PlacementResult.Rejected
            : // No placement found for the new label.
                PlacementResult.Invisible;
}
/**
 * Places a point label on a specified text canvas using the alignment (anchor) currently set.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).
 * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`
 * or `PlacementResult.Rejected`.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 *
 * @internal
 * @hidden
 */
function placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, isRejected, outScreenPosition) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    // Use recently rendered (state stored) layout if available, otherwise theme based style.
    const lastPlacement = labelState.textPlacement;
    const result = placePointLabelAtAnchor(labelState, screenPosition, lastPlacement, scale, textCanvas, env, screenCollisions, isRejected, !labelState.visible, outScreenPosition);
    return result;
}
/**
 * Auxiliary function that tries to place a point label on a text canvas using specified alignment.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates
 * @param placement - Text placement relative to the label position.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).
 * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`
 * or `PlacementResult.Rejected`.
 * @param forceInvalidation - Set to true if text layout or other params has changed such as text
 * re-measurement is required and text buffer need to be invalidated.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 *
 * @internal
 * @hidden
 */
function placePointLabelAtAnchor(labelState, screenPosition, placement, scale, textCanvas, env, screenCollisions, isRejected, forceInvalidation, outScreenPosition) {
    const label = labelState.element;
    harp_utils_1.assert(label.glyphs !== undefined);
    harp_utils_1.assert(label.layoutStyle !== undefined);
    const measureText = label.bounds === undefined || forceInvalidation;
    if (label.bounds === undefined) {
        label.bounds = new THREE.Box2();
    }
    // Override label text layout (on TextCanvas) for measurements and text buffer creation.
    applyTextPlacement(textCanvas, placement);
    if (measureText) {
        // Setup measurements parameters for textCanvas.measureText().
        tmpMeasurementParams.outputCharacterBounds = undefined;
        tmpMeasurementParams.path = undefined;
        tmpMeasurementParams.pathOverflow = false;
        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;
        // Compute label bounds according to layout settings.
        textCanvas.measureText(label.glyphs, label.bounds, tmpMeasurementParams);
        // Apply additional persistent margin, keep in mind that text bounds just calculated
        // are not (0, 0, w, h) based, so their coords usually are also non-zero.
        // TODO: Make the margin configurable
        label.bounds.expandByVector(exports.persistentPointLabelTextMargin);
    }
    // Compute text offset from the anchor point
    const textOffset = computePointTextOffset(label, placement, scale, env, tmpTextOffset);
    textOffset.add(screenPosition);
    tmpBox.copy(label.bounds);
    tmpBox.translate(textOffset);
    tmpBox.getCenter(tmpCenter);
    tmpBox.getSize(tmpSize);
    tmpSize.multiplyScalar(scale);
    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    // Update output screen position.
    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);
    // Check the text visibility if invisible finish immediately
    // regardless of the persistence state - no fading required.
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    const persistent = labelState.visible;
    // Check if icon's label was already rejected.
    if (isRejected) {
        // Allows to fade out persistent label and simply ignore new one.
        // NOTE:
        // It might be changed if we would like to render text without icon (at border, etc.).
        return persistent ? PlacementResult.Rejected : PlacementResult.Invisible;
    }
    if (measureText) {
        // Up-scaled label bounds are used only for new labels and after visibility check, this is
        // intentional to avoid processing labels out of the screen due to increased bounds, such
        // labels would be again invisible in the next frame.
        tmpBox.getSize(tmpSize);
        tmpSize.multiplyScalar(scale * (1 + exports.newPointLabelTextMarginPercent));
        tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    }
    // Check label's text collision.
    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {
        // Allows to fade persistent and ignore new label.
        return persistent ? PlacementResult.Rejected : PlacementResult.Invisible;
    }
    // Don't allocate space for rejected text. When zooming, this allows placement of a
    // lower priority text element that was displaced by a higher priority one (not
    // present in the new zoom level) before an even lower priority one takes the space.
    // Otherwise the lowest priority text will fade in and back out.
    // TODO: Add a unit test for this scenario.
    if (label.textReservesSpace) {
        screenCollisions.allocate(tmp2DBox);
    }
    // Glyphs arrangement have been changed remove text buffer object which needs to be
    // re-created.
    if (measureText) {
        label.textBufferObject = undefined;
    }
    // Save current placement in label state.
    // TextElementState creates layout snapshot solely for alternative placements which saves
    // memory that could be wasted on unnecessary objects construction.
    labelState.textPlacement = placement;
    return PlacementResult.Ok;
}
/**
 * Applied modified text layout style to TextCanvas for further use.
 * @param textCanvas - TextCanvas reference.
 * @param placement - The text placement to be used.
 */
function applyTextPlacement(textCanvas, placement) {
    // Setup TextCanvas layout settings of the new placement as it is required for further
    // TextBufferObject creation and measurements in addText().
    textCanvas.textLayoutStyle.horizontalAlignment = harp_text_canvas_1.hAlignFromPlacement(placement.h);
    textCanvas.textLayoutStyle.verticalAlignment = harp_text_canvas_1.vAlignFromPlacement(placement.v);
}
/**
 * Places a path label along a given path on a specified text canvas.
 * @param labelState - The state of the path label to place.
 * @param textPath - The text path along which the label will be placed.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param screenCollisions - Used to check collisions with other labels.
 * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's
 * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.
 */
function placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {
    // Recalculate the text bounds for this path label. If measurement fails, the whole
    // label doesn't fit the path and should be discarded.
    tmpMeasurementParams.path = textPath;
    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;
    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;
    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but
    // without storing the result. If the measurement succeeds, the placement work is done
    // twice.
    // This could be done in one step (e.g measureAndAddText). Collision test could be injected
    // in the middle as a function.
    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox, tmpMeasurementParams)) {
        return PlacementResult.Rejected;
    }
    // Coarse collision check.
    tmpCollisionBox.copy(tmpBox.translate(screenPosition));
    if (!screenCollisions.isVisible(tmpCollisionBox)) {
        return PlacementResult.Invisible;
    }
    let checkGlyphCollision = false;
    let candidateBoxes;
    if (!labelState.element.textMayOverlap) {
        candidateBoxes = screenCollisions.search(tmpCollisionBox);
        checkGlyphCollision = candidateBoxes.length > 0;
    }
    const checkGlyphVisible = !screenCollisions.isFullyVisible(tmpCollisionBox);
    // Perform per-character collision checks.
    tmpCollisionBoxes.length = tmpBoxes.length;
    for (let i = 0; i < tmpBoxes.length; ++i) {
        const glyphBox = tmpBoxes[i].translate(screenPosition);
        let collisionBox = tmpCollisionBoxes[i];
        if (collisionBox === undefined) {
            collisionBox = new ScreenCollisions_1.CollisionBox(glyphBox);
            tmpCollisionBoxes[i] = collisionBox;
        }
        else {
            collisionBox.copy(glyphBox);
        }
        if (checkGlyphVisible && !screenCollisions.isVisible(collisionBox)) {
            return PlacementResult.Invisible;
        }
        if (checkGlyphCollision &&
            screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {
            return PlacementResult.Rejected;
        }
    }
    // Allocate collision info if needed.
    if (labelState.element.textReservesSpace) {
        const collisionBox = new ScreenCollisions_1.DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());
        tmpCollisionBoxes.length = 0;
        screenCollisions.allocate(collisionBox);
    }
    return PlacementResult.Ok;
}
exports.placePathLabel = placePathLabel;
/**
 * Check if a given path label is too small to be rendered.
 * @param textElement - The text element to check.
 * @param screenProjector - Used to project coordinates from world to screen space.
 * @param outScreenPoints - Label path projected to screen space.
 * @returns `true` if label is too small, `false` otherwise.
 */
function isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PathLabel);
    // Get the screen points that define the label's segments and create a path with
    // them.
    outScreenPoints.length = 0;
    let anyPointVisible = false;
    for (const pt of textElement.points) {
        // Skip invisible points at the beginning of the path.
        const screenPoint = anyPointVisible
            ? screenProjector.project(pt, tmpScreenPosition)
            : screenProjector.projectOnScreen(pt, tmpScreenPosition);
        if (screenPoint === undefined) {
            continue;
        }
        anyPointVisible = true;
        outScreenPoints.push(tmpScreenPosition.clone());
    }
    // TODO: (HARP-3515)
    //      The rendering of a path label that contains just a single point that is not
    //      visible is impossible, which is problematic with long paths.
    //      Fix: Skip/clip the invisible points at beginning and end of the path to get
    //      the visible part of the path.
    // If not a single point is visible, skip the path
    if (!anyPointVisible) {
        return true;
    }
    // Check/guess if the screen box can hold a string of that length. It is important
    // to guess that value without measuring the font first to save time.
    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
    tmpBox.setFromPoints(outScreenPoints);
    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();
    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {
        textElement.dbgPathTooSmall = true;
        return true;
    }
    return false;
}
exports.isPathLabelTooSmall = isPathLabelTooSmall;
const tmpOrientedBox = new harp_geoutils_1.OrientedBox3();
/**
 * Calculates the world position of the supplied label. The label will be shifted if there is a
 * specified offsetDirection and value to shift it in.
 * @param poiLabel - The label to shift
 * @param projection - The projection, required to compute the correct direction offset for
 *                     spherical projections.
 * @param env - The environment to extract the worldOffset needed to shift the icon in world space,
 *              if configured in the style.
 * @param outWorldPosition - Preallocated vector to store the result in
 * @returns the [[outWorldPosition]] vector.
 */
function getWorldPosition(poiLabel, projection, env, outWorldPosition) {
    var _a, _b;
    const worldOffsetShiftValue = harp_datasource_protocol_1.getPropertyValue((_b = (_a = poiLabel.poiInfo) === null || _a === void 0 ? void 0 : _a.technique) === null || _b === void 0 ? void 0 : _b.worldOffset, env);
    outWorldPosition === null || outWorldPosition === void 0 ? void 0 : outWorldPosition.copy(poiLabel.position);
    if (worldOffsetShiftValue !== null &&
        worldOffsetShiftValue !== undefined &&
        poiLabel.offsetDirection !== undefined) {
        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);
        const offsetDirectionVector = tmpOrientedBox.yAxis;
        const offsetDirectionRad = THREE.MathUtils.degToRad(poiLabel.offsetDirection);
        // Negate to get the normal, i.e. the vector pointing to the sky.
        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);
        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);
    }
    return outWorldPosition;
}
exports.getWorldPosition = getWorldPosition;
//# sourceMappingURL=Placement.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/PlacementStats.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/PlacementStats.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PlacementStats = void 0;
class PlacementStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    clear() {
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    log() {
        const numNotRendered = this.uninitialized +
            this.numPoiTextsInvisible +
            this.tooFar +
            this.numNotVisible +
            this.numCannotAdd;
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("Resorted groups", this.resortedGroups);
        this.m_logger.debug("Total labels", this.total);
        this.m_logger.debug("Rendered labels", this.numRenderedTextElements);
        this.m_logger.debug("Rejected labels", numNotRendered);
        this.m_logger.debug("Unitialized labels", this.uninitialized);
        this.m_logger.debug("Rendered poi icons", this.numRenderedPoiIcons);
        this.m_logger.debug("Rendered poi texts", this.numRenderedPoiTexts);
        this.m_logger.debug("Poi text invisible", this.numPoiTextsInvisible);
        this.m_logger.debug("Too far", this.tooFar);
        this.m_logger.debug("Not visible", this.numNotVisible);
        this.m_logger.debug("Path too small", this.numPathTooSmall);
        this.m_logger.debug("Rejected, max glyphs reached", this.numCannotAdd);
    }
}
exports.PlacementStats = PlacementStats;
//# sourceMappingURL=PlacementStats.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/RenderState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/RenderState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderState = exports.DEFAULT_FADE_TIME = exports.FadingState = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * State of fading.
 */
var FadingState;
(function (FadingState) {
    FadingState[FadingState["Undefined"] = 0] = "Undefined";
    FadingState[FadingState["FadingIn"] = 1] = "FadingIn";
    FadingState[FadingState["FadedIn"] = 2] = "FadedIn";
    FadingState[FadingState["FadingOut"] = -1] = "FadingOut";
    FadingState[FadingState["FadedOut"] = -2] = "FadedOut";
})(FadingState = exports.FadingState || (exports.FadingState = {}));
/**
 * Time to fade in/fade out the labels in milliseconds.
 */
exports.DEFAULT_FADE_TIME = 800;
/**
 * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements
 * in and out, to compute the opacity.
 *
 * @hidden
 */
class RenderState {
    /**
     * Create a `RenderState`.
     *
     * @param fadeTime - The duration of the fading in milliseconds.
     */
    constructor(fadeTime = exports.DEFAULT_FADE_TIME) {
        this.fadeTime = fadeTime;
        /**
         * Current fading value [0..1]
         */
        this.value = 0.0;
        /**
         * Timestamp the fading started.
         */
        this.startTime = 0;
        /**
         * Computed opacity depending on value.
         */
        this.opacity = 1.0;
        this.m_state = FadingState.Undefined;
    }
    /**
     * Reset existing `RenderState` to appear like a fresh state.
     */
    reset() {
        this.m_state = FadingState.Undefined;
        this.value = 0.0;
        this.startTime = 0.0;
        this.opacity = 1.0;
    }
    /**
     * @returns `true` if element state is `FadingState.Undefined`.
     */
    isUndefined() {
        return this.m_state === FadingState.Undefined;
    }
    /**
     * @returns `true` if element is either fading in or fading out.
     */
    isFading() {
        const fading = this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;
        return fading;
    }
    /**
     * @returns `true` if element is fading in.
     */
    isFadingIn() {
        const fadingIn = this.m_state === FadingState.FadingIn;
        return fadingIn;
    }
    /**
     * @returns `true` if element is fading out.
     */
    isFadingOut() {
        const fadingOut = this.m_state === FadingState.FadingOut;
        return fadingOut;
    }
    /**
     * @returns `true` if element is done with fading in.
     */
    isFadedIn() {
        const fadedIn = this.m_state === FadingState.FadedIn;
        return fadedIn;
    }
    /**
     * @returns `true` if element is done with fading out.
     */
    isFadedOut() {
        const fadedOut = this.m_state === FadingState.FadedOut;
        return fadedOut;
    }
    /**
     * @returns `true` if state is neither faded out nor undefined.
     */
    isVisible() {
        return this.m_state !== FadingState.FadedOut && this.m_state !== FadingState.Undefined;
    }
    /**
     * Updates the state to [[FadingState.FadingIn]].
     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains
     * unchanged.
     *
     * @param time - Current time.
     */
    startFadeIn(time) {
        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {
            return;
        }
        if (this.m_state === FadingState.FadingOut) {
            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.value = 1.0 - this.value;
            this.startTime = time - this.value * this.fadeTime;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 0;
        }
        this.m_state = FadingState.FadingIn;
    }
    /**
     * Updates the state to [[FadingState.FadingOut]].
     * If previous state is [[FadingState.FadingOut]] or [[FadingState.FadedOut]] it remains
     * unchanged.
     *
     * @param time - Current time.
     */
    startFadeOut(time) {
        if (this.m_state === FadingState.FadingOut || this.m_state === FadingState.FadedOut) {
            return;
        }
        if (this.m_state === FadingState.FadingIn) {
            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.startTime = time - this.value * this.fadeTime;
            this.value = 1.0 - this.value;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 1;
        }
        this.m_state = FadingState.FadingOut;
    }
    /**
     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or
     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.
     * It does nothing if [[isFading]] !== `true`.
     *
     * @param time - Current time.
     * @param disableFading - `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {
            return;
        }
        if (this.startTime === 0) {
            this.startTime = time;
        }
        const fadingTime = time - this.startTime;
        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;
        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;
        if (disableFading || fadingTime >= this.fadeTime) {
            this.value = 1.0;
            this.opacity = endValue;
            this.m_state =
                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;
        }
        else {
            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value
            // increment).
            this.value = fadingTime / this.fadeTime;
            this.opacity = THREE.MathUtils.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);
            harp_utils_1.assert(this.isFading());
        }
    }
}
exports.RenderState = RenderState;
//# sourceMappingURL=RenderState.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/SimplePath.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimplePath = exports.PathParam = exports.SimpleLineCurve = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * @hidden
 */
class SimpleLineCurve extends THREE.LineCurve {
    constructor(v1, v2) {
        super(v1, v2);
    }
    getLengths() {
        if (this.m_lengths === undefined) {
            this.m_lengths = [0, this.v2.distanceTo(this.v1)];
        }
        return this.m_lengths;
    }
}
exports.SimpleLineCurve = SimpleLineCurve;
/**
 * @hidden
 */
class PathParam {
    constructor(path, index, t) {
        this.path = path;
        this.index = index;
        this.t = t;
    }
    get curve() {
        return this.path.curves[this.index];
    }
    get point() {
        if (this.m_point === undefined) {
            this.m_point = this.curve.getPoint(this.t);
        }
        return this.m_point;
    }
}
exports.PathParam = PathParam;
/**
 * @hidden
 */
class SimplePath extends THREE.Path {
    constructor() {
        super();
    }
    getLengths() {
        if (this.m_cache) {
            return this.m_cache;
        }
        let sum = 0;
        const lengths = new Array();
        lengths.push(0);
        this.curves.forEach(curve => {
            const lineCurve = curve;
            sum += lineCurve.v1.distanceTo(lineCurve.v2);
            lengths.push(sum);
        });
        this.m_cache = lengths;
        return lengths;
    }
    getParamAt(t) {
        const distance = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        for (let index = 0; index < curveLengths.length; ++index) {
            if (curveLengths[index] < distance) {
                continue;
            }
            const diff = curveLengths[index] - distance;
            const curve = this.curves[index];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return new PathParam(this, index, u);
        }
        return null;
    }
}
exports.SimplePath = SimplePath;
//# sourceMappingURL=SimplePath.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextCanvasFactory = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
class TextCanvasFactory {
    /**
     * Creates an instance of text canvas factory.
     * @param m_renderer -
     */
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.m_minGlyphCount = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.
        this.m_maxGlyphCount = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.
    }
    setGlyphCountLimits(min, max) {
        this.m_minGlyphCount = min;
        this.m_maxGlyphCount = max;
    }
    /**
     * Creates text canvas
     * @param fontCatalog - Initial [[FontCatalog]].
     */
    createTextCanvas(fontCatalog) {
        harp_utils_1.assert(this.m_maxGlyphCount > 0);
        return new harp_text_canvas_1.TextCanvas({
            renderer: this.m_renderer,
            fontCatalog,
            minGlyphCount: this.m_minGlyphCount,
            maxGlyphCount: this.m_maxGlyphCount
        });
    }
}
exports.TextCanvasFactory = TextCanvasFactory;
//# sourceMappingURL=TextCanvasFactory.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElement.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElement = exports.LoadingState = exports.poiIsRenderable = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js");
/**
 * Return 'true' if the POI has been successfully prepared for rendering.
 *
 * @param poiInfo - PoiInfo containing information for rendering the POI icon.
 */
function poiIsRenderable(poiInfo) {
    return poiInfo.poiRenderBatch !== undefined;
}
exports.poiIsRenderable = poiIsRenderable;
/**
 * State of loading.
 */
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["Requested"] = 0] = "Requested";
    LoadingState[LoadingState["Loaded"] = 1] = "Loaded";
    LoadingState[LoadingState["Initialized"] = 2] = "Initialized";
})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));
/**
 * `TextElement` is used to create 2D text elements (for example, labels).
 */
let TextElement = /** @class */ (() => {
    class TextElement {
        /**
         * Creates a new `TextElement`.
         *
         * @param text - The text to display.
         * @param points - The position or a list of points for a curved text, both in world space.
         * @param renderParams - `TextElement` text rendering parameters.
         * @param layoutParams - `TextElement` text layout parameters.
         * @param priority - The priority of the `TextElement. Elements with the highest priority get
         *              placed first, elements with priority of `0` are placed last, elements with a
         *              negative value are always rendered, ignoring priorities and allowing overrides.
         * @param xOffset - Optional X offset of this `TextElement` in screen coordinates.
         * @param yOffset - Optional Y offset of this `TextElement` in screen coordinates.
         * @param featureId - Optional number to identify feature (originated from `OmvDataSource`).
         * @param fadeNear - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
         *              label starts fading out (opacity decreases).
         * @param fadeFar - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
         *              label becomes transparent. A value of <= 0.0 disables fading.
         * @param offsetDirection - Direction represented as an angle in degrees clockwise from north to
         * offset the icon in world space.
         */
        constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset, offsetDirection) {
            this.text = text;
            this.points = points;
            this.renderParams = renderParams;
            this.layoutParams = layoutParams;
            this.priority = priority;
            this.xOffset = xOffset;
            this.yOffset = yOffset;
            this.featureId = featureId;
            this.style = style;
            this.fadeNear = fadeNear;
            this.fadeFar = fadeFar;
            this.tileOffset = tileOffset;
            this.offsetDirection = offsetDirection;
            /**
             * Determines visibility. If set to `false`, it will not be rendered.
             */
            this.visible = true;
            /**
             * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.
             */
            this.distanceScale = 0.5;
            /**
             * If specified, determines the render order between `TextElement`s. The number different
             * renderOrders should be as small as possible, because every specific `renderOrder` may result
             * in one or more draw calls.
             *
             * TextElements with the same integer `renderOrder` will be rendered in the same batch.
             *
             * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other
             * map elements.
             *
             * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a
             * lower `renderOrder`.
             */
            this.renderOrder = 0;
            /**
             * If set to `true` the geometry has been already overlaid on elevation.
             */
            this.elevated = false;
            if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {
                this.renderStyle = renderParams;
            }
            if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {
                this.layoutStyle = layoutParams;
            }
            this.type =
                points instanceof THREE.Vector3 ? TextElementType_1.TextElementType.PoiLabel : TextElementType_1.TextElementType.PathLabel;
        }
        /**
         * The text element position or the first point of the path used to render a curved text, both
         * in world space.
         */
        get position() {
            if (this.points instanceof Array) {
                const p = this.points[0];
                return p;
            }
            return this.points;
        }
        /**
         * The list of points in world space used to render the text along a path or `undefined`.
         */
        get path() {
            if (this.points instanceof Array) {
                return this.points;
            }
            return undefined;
        }
        /**
         * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.
         *
         * @default `false`
         */
        get textMayOverlap() {
            return this.mayOverlap === true;
        }
        set textMayOverlap(mayOverlap) {
            this.mayOverlap = mayOverlap;
        }
        /**
         * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not
         * be able to overlap.
         *
         * @default `true`
         */
        get textReservesSpace() {
            return this.reserveSpace !== false;
        }
        set textReservesSpace(reserveSpace) {
            this.reserveSpace = reserveSpace;
        }
        /**
         * Contains additional information about icon to be rendered along with text.
         */
        get poiInfo() {
            return this.m_poiInfo;
        }
        set poiInfo(poiInfo) {
            this.m_poiInfo = poiInfo;
            if (poiInfo !== undefined) {
                if (this.path !== undefined) {
                    this.type = TextElementType_1.TextElementType.LineMarker;
                }
                const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;
                poiInfo.renderOrder = poiRenderOrder;
            }
        }
        /**
         * @returns The style used to render this text element, undefined if not set yet.
         */
        get renderStyle() {
            return this.m_renderStyle;
        }
        /**
         * Sets style used for text rendering.
         * @param style - The style to use.
         */
        set renderStyle(style) {
            this.m_renderStyle = style;
        }
        /**
         * @returns The style used to layout this text element, undefined if not set yet.
         */
        get layoutStyle() {
            return this.m_layoutStyle;
        }
        /**
         * Sets the style used for text layout.
         * @param style - The style to use.
         */
        set layoutStyle(style) {
            this.m_layoutStyle = style;
        }
        hasFeatureId() {
            return this.featureId !== undefined && this.featureId !== 0;
        }
        /**
         * Update the minZoomLevel and maxZoomLevel from the values set in {@link PoiInfo}.
         * Selects the smaller/larger one of the two min/max values for icon and text, because the
         * TextElement is a container for both.
         */
        updateMinMaxZoomLevelsFromPoiInfo() {
            if (this.poiInfo !== undefined) {
                if (this.minZoomLevel === undefined) {
                    this.minZoomLevel = harp_utils_1.MathUtils.min2(this.poiInfo.iconMinZoomLevel, this.poiInfo.textMinZoomLevel);
                }
                if (this.maxZoomLevel === undefined) {
                    this.maxZoomLevel = harp_utils_1.MathUtils.max2(this.poiInfo.iconMaxZoomLevel, this.poiInfo.textMaxZoomLevel);
                }
            }
        }
    }
    /**
     * Text elements with this priority are placed on screen before any others.
     */
    TextElement.HIGHEST_PRIORITY = Number.MAX_SAFE_INTEGER;
    return TextElement;
})();
exports.TextElement = TextElement;
//# sourceMappingURL=TextElement.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementGroup = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * Group of {@link TextElement} sharing same priority.
 */
class TextElementGroup extends harp_utils_1.PriorityListGroup {
}
exports.TextElementGroup = TextElementGroup;
//# sourceMappingURL=TextElementGroup.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementGroupPriorityList = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
/**
 * List of {@link TextElement} groups sorted by priority.
 */
class TextElementGroupPriorityList extends harp_utils_1.GroupedPriorityList {
}
exports.TextElementGroupPriorityList = TextElementGroupPriorityList;
//# sourceMappingURL=TextElementGroupPriorityList.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementGroupState = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const TextElementState_1 = __webpack_require__(/*! ./TextElementState */ "./node_modules/@here/harp-mapview/lib/text/TextElementState.js");
/**
 * `TextElementGroupState` keeps the state of a text element group and each element in it while
 * they're being rendered.
 */
class TextElementGroupState {
    /**
     * Creates the state for specified group.
     * @param group - The group of which the state will be created.
     * @param tileKey - The key of the tile to which this group belongs.
     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].
     */
    constructor(group, tileKey, filter) {
        this.group = group;
        this.tileKey = tileKey;
        this.m_visited = false;
        harp_utils_1.assert(group.elements.length > 0);
        const length = group.elements.length;
        this.m_textElementStates = new Array(length);
        this.m_visited = true;
        // TODO: HARP-7648. Reduce number of allocations here:
        // a) Avoid creating the state for labels that don't pass early placement checks and make
        //    this checks more strict.
        // b) Break label state objects into a set of arrays held at group level, one for each
        //    primitive field in the label state.
        for (let i = 0; i < length; ++i) {
            const textElement = group.elements[i];
            const state = new TextElementState_1.TextElementState(textElement);
            const textDistance = filter(state);
            state.update(textDistance);
            this.m_textElementStates[i] = state;
        }
    }
    /**
     * Indicates whether the group has been submitted to the
     * {@link TextElementsRenderer} in the current frame.
     */
    get visited() {
        return this.m_visited;
    }
    set visited(visited) {
        this.m_visited = visited;
    }
    /**
     * @returns the priority of the text elements in the group.
     */
    get priority() {
        return this.group.priority;
    }
    /**
     * Updates the fading state of all text elements within the group to the specified time.
     * @param time - The time to which the fading state will be updated.
     * @param disableFading - `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined) {
                elementState.updateFading(time, disableFading);
            }
        }
    }
    /**
     * Calls the specified callback for every visible text elements in the group.
     * @param visibleElementsCallback - Functions that will be called for every visible text element
     * in the group.
     */
    traverseVisibleElements(visibleElementsCallback) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined && elementState.visible) {
                visibleElementsCallback(elementState);
            }
        }
    }
    /**
     * Updates the states of elements within the group.
     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].
     */
    updateElements(filter) {
        for (const elementState of this.m_textElementStates) {
            const textDistance = filter(elementState);
            elementState.update(textDistance);
        }
    }
    get size() {
        return this.m_textElementStates.length;
    }
    /**
     * Returns text element states.
     * @returns Array of element states.
     */
    get textElementStates() {
        return this.m_textElementStates;
    }
}
exports.TextElementGroupState = TextElementGroupState;
//# sourceMappingURL=TextElementGroupState.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementState.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementState.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementState = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const LayoutState_1 = __webpack_require__(/*! ./LayoutState */ "./node_modules/@here/harp-mapview/lib/text/LayoutState.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./node_modules/@here/harp-mapview/lib/text/RenderState.js");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js");
/**
 * `TextElementState` keeps the current state of a text element while it's being rendered.
 */
class TextElementState {
    constructor(element) {
        this.element = element;
    }
    get initialized() {
        return this.m_textRenderState !== undefined || this.m_iconRenderStates !== undefined;
    }
    /**
     * @returns `true` if any component of the element is visible, `false` otherwise.
     */
    get visible() {
        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {
            return true;
        }
        const iconRenderState = this.iconRenderState;
        if (iconRenderState !== undefined && iconRenderState.isVisible()) {
            return true;
        }
        const iconRenderStates = this.iconRenderStates;
        if (iconRenderStates === undefined) {
            return false;
        }
        for (const state of iconRenderStates) {
            if (state.isVisible()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return the last text placement used.
     *
     * If the text wasn't yet rendered or have no alternative placements it will fallback to
     * style/theme based placement.
     *
     * @returns [[TextPlacement]] object containing vertical/horizontal align.
     */
    get textPlacement() {
        const themeLayout = this.element.layoutStyle;
        const stateLayout = this.m_textLayoutState;
        // Would be good to test for persistence when getting state layout, but with this
        // most of the isolated placement unit tests will fail.
        const lastPlacement = stateLayout !== undefined
            ? stateLayout.textPlacement
            : {
                h: harp_text_canvas_1.hPlacementFromAlignment(themeLayout.horizontalAlignment),
                v: harp_text_canvas_1.vPlacementFromAlignment(themeLayout.verticalAlignment)
            };
        return lastPlacement;
    }
    /**
     * Set text placement to be used.
     *
     * This may be base text anchor placement as defined by style or alternative placement.
     *
     * @param placement - The new [[TextPlacement]] to be used.
     */
    set textPlacement(placement) {
        if (this.m_textLayoutState === undefined && this.isBaseTextPlacement(placement) === true) {
            // Do nothing, layout state is not required cause we leave the base placement.
            return;
        }
        if (this.m_textLayoutState === undefined) {
            // State is not yet defined, but we have placement to store, either alternative or
            // not yet specified in the context of layoutStyle.
            this.m_textLayoutState = new LayoutState_1.LayoutState(placement);
        }
        else {
            this.m_textLayoutState.textPlacement = placement;
        }
    }
    /**
     * Returns information if the text placement provided is the base one defined in style (theme).
     *
     * @param placement - The [[TextPlacement]] to check.
     * @returns [[true]] if the placement provided is exactly the same as in theme base layout,
     * [[false]] if it differs from the basic layout provided in style or
     * [[undefined]] if the layout style is not yet defined so it is hard to say.
     */
    isBaseTextPlacement(placement) {
        const themeLayout = this.element.layoutStyle;
        if (themeLayout !== undefined) {
            return (harp_text_canvas_1.hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment &&
                harp_text_canvas_1.vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment);
        }
        return undefined;
    }
    /**
     * Resets the element to an initialized state.
     */
    reset() {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.reset();
        }
        if (this.m_textLayoutState !== undefined) {
            if (this.element.layoutStyle !== undefined) {
                this.m_textLayoutState.reset(this.element.layoutStyle);
            }
            else {
                this.m_textLayoutState = undefined;
            }
        }
        if (this.iconRenderState) {
            this.m_iconRenderStates.reset();
        }
        else if (this.m_iconRenderStates !== undefined) {
            for (const renderState of this.m_iconRenderStates) {
                renderState.reset();
            }
        }
        this.m_viewDistance = undefined;
        this.element.textBufferObject = undefined;
    }
    /**
     * Replaces given text element, inheriting its current state.
     * The predecessor text element state is erased.
     * @param predecessor - Text element state to be replaced.
     */
    replace(predecessor) {
        this.m_textRenderState = predecessor.m_textRenderState;
        this.m_textLayoutState = predecessor.m_textLayoutState;
        this.m_iconRenderStates = predecessor.m_iconRenderStates;
        predecessor.m_textRenderState = undefined;
        predecessor.m_textLayoutState = undefined;
        predecessor.m_iconRenderStates = undefined;
        if (this.element.glyphs === undefined) {
            // Use the predecessor glyphs and case array until proper ones are computed.
            this.element.glyphs = predecessor.element.glyphs;
            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;
        }
        this.element.bounds = undefined;
        this.element.textBufferObject = undefined;
    }
    /**
     * Returns the last computed distance of the text element to the camera.
     * @returns Distance to camera.
     */
    get viewDistance() {
        return this.m_viewDistance;
    }
    /**
     * Updates the text element state.
     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    update(viewDistance) {
        if (!this.initialized && viewDistance !== undefined) {
            this.initializeRenderStates();
        }
        this.setViewDistance(viewDistance);
    }
    /**
     * Sets the distance of the element to the current view center.
     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    setViewDistance(viewDistance) {
        this.m_viewDistance = viewDistance;
    }
    /**
     * Return the last distance that has been computed for sorting during placement. This may not be
     * the actual distance if the camera is moving, as the distance is computed only during
     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.
     *
     * @returns 0 or negative distance to camera.
     */
    get renderDistance() {
        return this.element.alwaysOnTop === true
            ? 0
            : this.m_viewDistance !== undefined
                ? -this.m_viewDistance
                : 0;
    }
    /**
     * @returns The text render state.
     */
    get textRenderState() {
        return this.m_textRenderState;
    }
    /**
     * Returns the icon render state for the case where the text element has only one icon.
     * @returns The icon render state if the text element has a single icon, otherwise undefined.
     */
    get iconRenderState() {
        if (this.m_iconRenderStates === undefined) {
            return undefined;
        }
        return this.m_iconRenderStates instanceof RenderState_1.RenderState ? this.m_iconRenderStates : undefined;
    }
    /**
     * Returns the icon render states for text elements with multiple icons.
     * @returns The icon render states if the text element has multiple icons, otherwise undefined.
     */
    get iconRenderStates() {
        if (this.m_iconRenderStates === undefined) {
            return undefined;
        }
        return this.m_iconRenderStates instanceof RenderState_1.RenderState
            ? undefined
            : this.m_iconRenderStates;
    }
    /**
     * Updates the fading state to the specified time.
     * @param time - The current time.
     * @param disableFading - If `True` there will be no fading transitions, i.e., state will go
     * directly from FadedIn to FadedOut and viceversa.
     */
    updateFading(time, disableFading) {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.updateFading(time, disableFading);
        }
        if (this.iconRenderState !== undefined) {
            const iconRenderState = this.m_iconRenderStates;
            iconRenderState.updateFading(time, disableFading);
        }
        else if (this.iconRenderStates !== undefined) {
            for (const renderState of this.m_iconRenderStates) {
                renderState.updateFading(time, disableFading);
            }
        }
    }
    /**
     * Initialize text and icon render states
     */
    initializeRenderStates() {
        var _a;
        harp_utils_1.assert(this.m_textRenderState === undefined);
        harp_utils_1.assert(this.m_textLayoutState === undefined);
        harp_utils_1.assert(this.m_iconRenderStates === undefined);
        const { textFadeTime } = this.element;
        const iconFadeTime = (_a = this.element.poiInfo) === null || _a === void 0 ? void 0 : _a.technique.iconFadeTime;
        if (this.element.type === TextElementType_1.TextElementType.LineMarker) {
            this.m_iconRenderStates = new Array();
            for (const _point of this.element.points) {
                const iconRenderStates = this.m_iconRenderStates;
                const renderState = new RenderState_1.RenderState(iconFadeTime);
                iconRenderStates.push(renderState);
            }
            return;
        }
        this.m_textRenderState = new RenderState_1.RenderState(textFadeTime);
        if (this.element.type === TextElementType_1.TextElementType.PoiLabel) {
            this.m_iconRenderStates = new RenderState_1.RenderState(iconFadeTime);
        }
    }
}
exports.TextElementState = TextElementState;
//# sourceMappingURL=TextElementState.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementStateCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const TextElementGroupState_1 = __webpack_require__(/*! ./TextElementGroupState */ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js");
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsStateCache", { level: harp_utils_1.LogLevel.Log });
/**
 * Label distance tolerance squared in meters. Point labels with the same name that are closer in
 * world space than this value are treated as the same label. Used to identify duplicate labels in
 * overlapping tiles and label replacements at different storage levels.
 */
function getDedupSqDistTolerance(zoomLevel) {
    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.
    const minSqTol = 100;
    const minSqTolLevel = 13;
    const maxLevelDelta = 4;
    const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));
    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a
    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum
    // tolerance zoom level.
    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)
    //tslint:disable-next-line: no-bitwise
    return minSqTol << (levelDelta << 2);
}
const tmpCachedDuplicate = {
    entries: [],
    index: -1
};
function getCacheKey(element) {
    return element.hasFeatureId() ? element.featureId : element.text;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their feature ids.
 * @param elementState - The state of the text element for which the duplicate will be found.
 * @param candidates - The list of candidates to check.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateById(elementState, candidates) {
    // Cached entries with same feature id found, find the entry with the same tile offset.
    const element = elementState.element;
    const duplicateIndex = candidates.findIndex(entry => entry.element.tileOffset === element.tileOffset);
    if (duplicateIndex === -1) {
        return -1;
    }
    const candidate = candidates[duplicateIndex].element;
    harp_utils_1.assert(element.featureId === candidate.featureId);
    if (candidate.text !== element.text) {
        // Labels with different text shouldn't share the same feature id. This points to
        // an issue on the map data side. Submit a ticket to the corresponding map backend
        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),
        // indicating affected labels including tile keys, texts and feature id.
        logger.debug(`Text feature id ${element.featureId} collision between "${element.text} and \
             ${candidate.text}`);
        return undefined;
    }
    return duplicateIndex;
}
// Duplicate criteria for path labels. Candidates are better the longer their paths are.
function isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {
    if (newCandidate.pathLengthSqr === undefined) {
        return false;
    }
    if (oldCandidate.pathLengthSqr === undefined) {
        return false;
    }
    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;
}
// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being
// tested for duplicates.
function isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {
    return newDistance < oldDistance;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their text and distances.
 * @param elementState - The state of the text element for which the duplicate will be found.
 * @param candidates - The list of candidates to check.
 * @param zoomLevel - Current zoom level.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateByText(elementState, candidates, zoomLevel) {
    const element = elementState.element;
    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);
    const entryCount = candidates.length;
    const elementPosition = element.position;
    const elementVisible = elementState.visible;
    let dupIndex = -1;
    let duplicate;
    let dupDistSquared = Infinity;
    const isBetterDuplicate = element.type === TextElementType_1.TextElementType.PoiLabel ? isBetterPointDuplicate : isBetterPathDuplicate;
    for (let i = 0; i < entryCount; ++i) {
        const candidateEntry = candidates[i];
        const cachedElement = candidateEntry.element;
        const areDiffType = element.type !== cachedElement.type;
        const areBothVisible = elementVisible && candidateEntry.visible;
        if (areDiffType || areBothVisible) {
            // Two text elements with different type or visible at the same time are always
            // considered distinct.
            continue;
        }
        const distSquared = elementPosition.distanceToSquared(cachedElement.position);
        if (distSquared > maxSqDistError) {
            // Cached text element is too far away to be a duplicate.
            continue;
        }
        if (duplicate === undefined ||
            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {
            dupIndex = i;
            duplicate = cachedElement;
            dupDistSquared = distSquared;
        }
    }
    return dupIndex;
}
/**
 * Caches the state of text element groups currently rendered as well as the text element states
 * belonging to them, including their fading state and text deduplication information.
 */
class TextElementStateCache {
    constructor() {
        this.m_referenceMap = new Map();
        // Cache for point labels which may have duplicates in same tile or in neighboring tiles.
        this.m_textMap = new Map();
    }
    /**
     * Gets the state corresponding to a given text element group or sets a newly created state if
     * not found. It updates the states of the text elements belonging to the group using the
     * specified parameters.
     * @param textElementGroup - The group of which the state will be obtained.
     * @param tileKey - The key of the tile to which the group belongs.
     * @param textElementFilter - Filter used to decide if a text element must be initialized,
     * @see [[TextElementGroupState]] construction.
     * @returns Tuple with the group state as first element and a boolean indicating whether the
     * state was found in cache (`true`) or newly created (`false`) as second element.
     */
    getOrSet(textElementGroup, tileKey, textElementFilter) {
        let groupState = this.get(textElementGroup);
        if (groupState !== undefined) {
            harp_utils_1.assert(groupState.size === textElementGroup.elements.length);
            groupState.updateElements(textElementFilter);
            return [groupState, true];
        }
        groupState = new TextElementGroupState_1.TextElementGroupState(textElementGroup, tileKey, textElementFilter);
        this.set(textElementGroup, groupState);
        return [groupState, false];
    }
    get size() {
        return this.m_referenceMap.size;
    }
    /**
     * @returns All text element group states in the cache by group priority.
     */
    get sortedGroupStates() {
        if (this.m_sortedGroupStates === undefined) {
            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());
            this.m_sortedGroupStates.sort((a, b) => {
                return b.group.priority - a.group.priority;
            });
        }
        harp_utils_1.assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);
        return this.m_sortedGroupStates;
    }
    /**
     * Updates state of all cached groups, discarding those that are not needed anymore.
     * @param time - The current time.
     * @param disableFading - `True` if fading is currently disabled, `false` otherwise.
     * @param findReplacements - `True` to replace each visible unvisited text element with a
     * visited duplicate.
     * @param zoomLevel - Current zoom level.
     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.
     */
    update(time, disableFading, findReplacements, zoomLevel) {
        const replaceCallback = findReplacements
            ? this.replaceElement.bind(this, zoomLevel)
            : undefined;
        let anyEviction = false;
        for (const [key, groupState] of this.m_referenceMap.entries()) {
            if (groupState.visited) {
                groupState.updateFading(time, disableFading);
            }
            else {
                if (findReplacements) {
                    groupState.traverseVisibleElements(replaceCallback);
                }
                this.m_referenceMap.delete(key);
                this.m_sortedGroupStates = undefined;
                anyEviction = true;
            }
        }
        return anyEviction;
    }
    /**
     * Clears visited state for all text element groups in cache.
     */
    clearVisited() {
        for (const groupState of this.m_referenceMap.values()) {
            groupState.visited = false;
        }
    }
    clearTextCache() {
        this.m_textMap.clear();
    }
    /**
     * Clears the whole cache contents.
     */
    clear() {
        this.m_referenceMap.clear();
        this.m_sortedGroupStates = undefined;
        this.m_textMap.clear();
    }
    /**
     * Removes duplicates for a given text element.
     *
     * @param zoomLevel - Current zoom level.
     * @param elementState - State of the text element to deduplicate.
     * @returns True if it's the remaining element after deduplication, false if it's been marked
     * as duplicate.
     */
    deduplicateElement(zoomLevel, elementState) {
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined) {
            // Text not found so far, add this element to cache.
            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);
            return true;
        }
        if (cacheResult.index === -1) {
            // No duplicate found among elements with same text,add this one to cache.
            cacheResult.entries.push(elementState);
            return true;
        }
        // Duplicate found, check whether there's a label already visible and keep that one.
        const cachedDuplicate = cacheResult.entries[cacheResult.index];
        if (!cachedDuplicate.visible && elementState.visible) {
            // New label is visible, substitute the cached label.
            cacheResult.entries[cacheResult.index] = elementState;
            cachedDuplicate.reset();
            return true;
        }
        return false;
    }
    /**
     * Replaces a visible unvisited text element with a visited duplicate.
     * @param zoomLevel - Current zoom level.
     * @param elementState - State of the text element to deduplicate.
     */
    replaceElement(zoomLevel, elementState) {
        harp_utils_1.assert(elementState.visible);
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined || cacheResult.index === -1) {
            // No replacement found;
            return;
        }
        const replacement = cacheResult.entries[cacheResult.index];
        harp_utils_1.assert(!replacement.visible);
        replacement.replace(elementState);
    }
    /**
     * Gets the state corresponding to a given text element group.
     * @param textElementGroup - The group of which the state will be obtained.
     * @returns The group state if cached, otherwise `undefined`.
     */
    get(textElementGroup) {
        const groupState = this.m_referenceMap.get(textElementGroup);
        if (groupState !== undefined) {
            groupState.visited = true;
        }
        return groupState;
    }
    /**
     * Sets a specified state for a given text element group.
     * @param textElementGroup -  The group of which the state will be set.
     * @param textElementGroupState - The state to set for the group.
     */
    set(textElementGroup, textElementGroupState) {
        harp_utils_1.assert(textElementGroup.elements.length > 0);
        this.m_referenceMap.set(textElementGroup, textElementGroupState);
        this.m_sortedGroupStates = undefined;
    }
    findDuplicate(elementState, zoomLevel) {
        // Point labels may have duplicates (as can path labels), Identify them
        // and keep the one we already display.
        const element = elementState.element;
        const cachedEntries = this.m_textMap.get(getCacheKey(element));
        if (cachedEntries === undefined) {
            // No labels found with the same key.
            return undefined;
        }
        tmpCachedDuplicate.entries = cachedEntries;
        const index = element.hasFeatureId()
            ? findDuplicateById(elementState, cachedEntries)
            : findDuplicateByText(elementState, cachedEntries, zoomLevel);
        if (index === undefined) {
            // Feature id collision, try finding duplicates using text as key.
            element.featureId = undefined;
            return this.findDuplicate(elementState, zoomLevel);
        }
        tmpCachedDuplicate.index = index;
        return tmpCachedDuplicate;
    }
}
exports.TextElementStateCache = TextElementStateCache;
//# sourceMappingURL=TextElementStateCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementType = void 0;
/**
 * Types of text elements.
 */
var TextElementType;
(function (TextElementType) {
    TextElementType[TextElementType["PoiLabel"] = 0] = "PoiLabel";
    TextElementType[TextElementType["PathLabel"] = 1] = "PathLabel";
    TextElementType[TextElementType["LineMarker"] = 2] = "LineMarker";
})(TextElementType = exports.TextElementType || (exports.TextElementType = {}));
//# sourceMappingURL=TextElementType.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TextElementsRenderer = exports.DEFAULT_TEXT_DISTANCE_SCALE = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const DebugContext_1 = __webpack_require__(/*! ../DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
const overlayOnElevation_1 = __webpack_require__(/*! ../geometry/overlayOnElevation */ "./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js");
const PickHandler_1 = __webpack_require__(/*! ../PickHandler */ "./node_modules/@here/harp-mapview/lib/PickHandler.js");
const Placement_1 = __webpack_require__(/*! ./Placement */ "./node_modules/@here/harp-mapview/lib/text/Placement.js");
const PlacementStats_1 = __webpack_require__(/*! ./PlacementStats */ "./node_modules/@here/harp-mapview/lib/text/PlacementStats.js");
const SimplePath_1 = __webpack_require__(/*! ./SimplePath */ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "./node_modules/@here/harp-mapview/lib/text/TextElement.js");
const TextElementsRendererOptions_1 = __webpack_require__(/*! ./TextElementsRendererOptions */ "./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js");
const TextElementStateCache_1 = __webpack_require__(/*! ./TextElementStateCache */ "./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js");
const TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js");
const UpdateStats_1 = __webpack_require__(/*! ./UpdateStats */ "./node_modules/@here/harp-mapview/lib/text/UpdateStats.js");
var Pass;
(function (Pass) {
    Pass[Pass["PersistentLabels"] = 0] = "PersistentLabels";
    Pass[Pass["NewLabels"] = 1] = "NewLabels";
})(Pass || (Pass = {}));
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 */
exports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
/**
 * Maximum number of recommended labels. If more labels are encountered, the "overloaded" mode is
 * set, which modifies the behavior of label placement and rendering, trying to keep delivering an
 * interactive performance. The overloaded mode should not be activated if the {@link MapView} is
 * rendering a static image (camera not moving and no animation running).
 */
const OVERLOAD_LABEL_LIMIT = 20000;
/**
 * If "overloaded" is `true`:
 *
 * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the
 * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_UPDATED_LABEL_LIMIT = 100;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_UPDATE_TIME_LIMIT = 5;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].
 */
const OVERLOAD_PLACE_TIME_LIMIT = 10;
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsRenderer", { level: harp_utils_1.LogLevel.Log });
// Development flag: Enable debug print.
const PRINT_LABEL_DEBUG_INFO = false;
const updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats_1.UpdateStats(logger) : undefined;
const placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats_1.PlacementStats(logger) : undefined;
const tempPosition = new THREE.Vector3();
const tempScreenPosition = new THREE.Vector2();
const tempScreenPoints = [];
const tempPoiScreenPosition = new THREE.Vector2();
const tmpTextBufferCreationParams = {};
const tmpAdditionParams = {};
const tmpBufferAdditionParams = {};
class TileTextElements {
    constructor(tile, group) {
        this.tile = tile;
        this.group = group;
    }
}
class TextElementLists {
    constructor(lists) {
        this.lists = lists;
    }
    get priority() {
        harp_utils_1.assert(this.lists.length > 0);
        // All text element lists here have the same priority.
        return this.lists[0].group.priority;
    }
    /**
     * Sum up the number of elements in all lists.
     */
    count() {
        let n = 0;
        for (const list of this.lists) {
            n += list.group.elements.length;
        }
        return n;
    }
}
function checkIfTextElementsChanged(dataSourceTileList) {
    let textElementsChanged = false;
    dataSourceTileList.forEach(({ renderedTiles }) => {
        renderedTiles.forEach(tile => {
            if (tile.textElementsChanged) {
                tile.textElementsChanged = false;
                textElementsChanged = true;
            }
        });
    });
    return textElementsChanged;
}
function addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {
    tmpAdditionParams.path = path;
    tmpAdditionParams.pathOverflow = pathOverflow;
    tmpAdditionParams.layer = textElement.renderOrder;
    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;
    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);
}
function addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {
    const textElement = textElementState.element;
    const textRenderState = textElementState.textRenderState;
    const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;
    if (opacity === 0) {
        return false;
    }
    // Compute the TextBufferObject when we know we're gonna render this label.
    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;
    if (textElement.textBufferObject === undefined) {
        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);
    }
    const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 &&
        canvas.textRenderStyle.fontSize.backgroundSize > 0;
    tmpBufferAdditionParams.layer = textElement.renderOrder;
    tmpBufferAdditionParams.position = screenPosition;
    tmpBufferAdditionParams.scale = scaleFactor;
    tmpBufferAdditionParams.opacity = opacity;
    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible
        ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity
        : 0.0;
    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);
    return true;
}
function shouldRenderPointText(labelState, viewState, options) {
    const textRenderState = labelState.textRenderState;
    const label = labelState.element;
    const poiInfo = label.poiInfo;
    harp_utils_1.assert(label.type !== TextElementType_1.TextElementType.PathLabel);
    const hasText = textRenderState !== undefined && label.text !== "";
    if (!hasText) {
        return false;
    }
    const visibleInZoomLevel = poiInfo === undefined ||
        viewState.zoomLevel === undefined ||
        harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);
    if (!visibleInZoomLevel) {
        return false;
    }
    const poiTextMaxDistance = Placement_1.getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);
    const visibleAtDistance = label.ignoreDistance === true ||
        labelState.viewDistance === undefined ||
        labelState.viewDistance < poiTextMaxDistance;
    if (!visibleAtDistance) {
        return false;
    }
    // Do not render text if POI cannot be rendered and is not optional.
    return poiInfo === undefined || poiInfo.isValid === true || poiInfo.iconIsOptional !== false;
}
function shouldRenderPoiText(labelState, viewState) {
    // Do not actually render (just allocate space) if camera is moving and
    // renderTextDuringMovements is not true.
    const poiInfo = labelState.element.poiInfo;
    return (!viewState.cameraIsMoving ||
        poiInfo === undefined ||
        poiInfo.renderTextDuringMovements === true);
}
function isPlacementTimeExceeded(startTime) {
    // startTime is set in overload mode.
    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {
        return false;
    }
    const endTime = harp_utils_1.PerformanceTimer.now();
    const elapsedTime = endTime - startTime;
    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {
        logger.debug("Placement time limit exceeded.");
        return true;
    }
    return false;
}
/**
 *
 * Internal class to manage all text rendering.
 */
class TextElementsRenderer {
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * {@link TextElement}s every frame.
     *
     * @param m_viewState - State of the view for which this renderer will draw text.
     * @param m_viewCamera - Camera used by the view for which this renderer will draw text.
     * @param m_viewUpdateCallback - To be called whenever the view needs to be updated.
     * @param m_screenCollisions - General 2D screen occlusion management, may be shared between
     *     instances.
     * @param m_screenProjector - Projects 3D coordinates into screen space.
     * @param m_textCanvasFactory - To create TextCanvas instances.
     * @param m_poiRendererFactory - To create PoiRenderer instances.
     * @param m_poiManager - To prepare pois for rendering.
     * @param m_fontCatalogLoader - To load font catalogs.
     * @param m_theme - Theme defining  text styles.
     * @param options - Configuration options for the text renderer. See
     * [[TextElementsRendererOptions]].
     */
    constructor(m_viewState, m_viewCamera, m_viewUpdateCallback, m_screenCollisions, m_screenProjector, m_textCanvasFactory, m_poiManager, m_poiRendererFactory, m_fontCatalogLoader, m_theme, options) {
        this.m_viewState = m_viewState;
        this.m_viewCamera = m_viewCamera;
        this.m_viewUpdateCallback = m_viewUpdateCallback;
        this.m_screenCollisions = m_screenCollisions;
        this.m_screenProjector = m_screenProjector;
        this.m_textCanvasFactory = m_textCanvasFactory;
        this.m_poiManager = m_poiManager;
        this.m_poiRendererFactory = m_poiRendererFactory;
        this.m_fontCatalogLoader = m_fontCatalogLoader;
        this.m_theme = m_theme;
        this.m_initialized = false;
        this.m_glyphLoadingCount = 0;
        this.m_textRenderers = [];
        this.m_tmpVector = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        this.m_cameraLookAt = new THREE.Vector3();
        this.m_overloaded = false;
        this.m_cacheInvalidated = false;
        this.m_forceNewLabelsPass = false;
        this.m_addNewLabels = true;
        this.m_textElementStateCache = new TextElementStateCache_1.TextElementStateCache();
        this.m_textStyleCache = new TextStyleCache_1.TextStyleCache(this.m_theme);
        this.m_options = Object.assign({}, options);
        TextElementsRendererOptions_1.initializeDefaultOptions(this.m_options);
        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);
    }
    /**
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_options.disableFading = disable;
    }
    get disableFading() {
        return this.m_options.disableFading === true;
    }
    get styleCache() {
        return this.m_textStyleCache;
    }
    get delayLabelsUntilMovementFinished() {
        return this.m_options.delayLabelsUntilMovementFinished === true;
    }
    set delayLabelsUntilMovementFinished(delay) {
        this.m_options.delayLabelsUntilMovementFinished = delay;
    }
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera - Orthographic camera to use.
     */
    renderText(camera) {
        if (!this.initialized) {
            return;
        }
        this.updateGlyphDebugMesh();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.render(camera);
        }
    }
    /**
     * Forces update of text elements in the next call to [[placeText]].
     */
    invalidateCache() {
        this.m_cacheInvalidated = true;
    }
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted() {
        if (this.delayLabelsUntilMovementFinished) {
            this.m_addNewLabels = false;
        }
    }
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished() {
        this.invalidateCache();
        if (this.delayLabelsUntilMovementFinished) {
            this.m_addNewLabels = true;
        }
    }
    /**
     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded() {
        return this.m_overloaded;
    }
    /**
     * Places text elements for the current frame.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     * @param time - Current frame time.
     */
    placeText(dataSourceTileList, time) {
        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);
        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged;
        if (!this.initialize(textElementsAvailable)) {
            return;
        }
        const updateTextElements = this.m_cacheInvalidated ||
            tileTextElementsChanged ||
            this.m_viewState.renderedTilesChanged;
        logger.debug(`FRAME: ${this.m_viewState.frameNumber}, ZOOM LEVEL: ${this.m_viewState.zoomLevel}`);
        if (updateTextElements && this.m_addNewLabels) {
            this.m_textElementStateCache.clearVisited();
            this.updateTextElements(dataSourceTileList);
        }
        const findReplacements = updateTextElements && this.m_addNewLabels;
        const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);
        this.reset();
        if (this.m_addNewLabels) {
            this.prepopulateScreenWithBlockingElements(dataSourceTileList);
        }
        // New text elements must be placed either if text elements were updated in this frame
        // or if any text element group was evicted. The second case happens when the group is not
        // visited anymore and all it's elements just became invisible, which means there's newly
        // available screen space where new text elements could be placed. A common scenario where
        // this happens is zooming in/out: text groups from the old level may still be fading out
        // after all groups in the new level were updated.
        const placeNewTextElements = (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;
        this.placeTextElements(time, placeNewTextElements);
        this.placeOverlayTextElements();
        this.updateTextRenderers();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    addOverlayText(textElements) {
        if (textElements.length === 0) {
            return;
        }
        this.m_overlayTextElements =
            this.m_overlayTextElements === undefined
                ? textElements.slice()
                : this.m_overlayTextElements.concat(textElements);
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    clearOverlayText() {
        this.m_overlayTextElements = [];
    }
    /**
     * @returns Whether there's overlay text to be rendered.
     */
    hasOverlayText() {
        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;
    }
    get overlayText() {
        return this.m_overlayTextElements;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link TextElement}s are found, the order of the results is unspecified.
     *
     * Note: {@link TextElement}s with identical `featureId` or
     * identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickResults - Array filled with pick results.
     */
    pickTextElements(screenPosition, pickResults) {
        const pickHandler = (pickData, pickObjectType) => {
            const textElement = pickData;
            if (textElement === undefined) {
                return;
            }
            let isDuplicate = false;
            if (textElement.featureId !== undefined) {
                isDuplicate = pickResults.some(pickResult => {
                    return (pickResult !== undefined &&
                        pickObjectType === pickResult.type &&
                        ((pickResult.featureId !== undefined &&
                            pickResult.featureId === textElement.featureId) ||
                            (pickResult.userData !== undefined &&
                                pickResult.userData === textElement.userData)));
                });
                if (!isDuplicate) {
                    const pickResult = {
                        type: pickObjectType,
                        point: screenPosition,
                        distance: 0,
                        featureId: textElement.featureId,
                        userData: textElement.userData,
                        text: textElement.text
                    };
                    pickResults.push(pickResult);
                }
            }
        };
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.pickText(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Text);
            });
            textRenderer.poiRenderer.pickTextElements(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Icon);
            });
        }
    }
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading() {
        return this.m_fontCatalogLoader.loading || this.m_glyphLoadingCount > 0;
    }
    /**
     * Waits till all pending resources from any `FontCatalog` are loaded.
     */
    async waitLoaded() {
        const initialized = await this.waitInitialized();
        if (!initialized) {
            return false;
        }
        if (this.m_loadPromise === undefined) {
            return false;
        }
        await this.m_loadPromise;
        return true;
    }
    /**
     * Reset the current text render states of all visible tiles.
     *
     * @remarks
     * All {@link TextElement}s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates() {
        this.m_textElementStateCache.clear();
    }
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage() {
        const memoryUsage = {
            heapSize: 0,
            gpuSize: 0
        };
        for (const renderer of this.m_textRenderers) {
            renderer.textCanvas.getMemoryUsage(memoryUsage);
            renderer.poiRenderer.getMemoryUsage(memoryUsage);
        }
        return memoryUsage;
    }
    get initialized() {
        return this.m_initialized;
    }
    get initializing() {
        return this.m_initPromise !== undefined;
    }
    /**
     * Waits until initialization is done.
     * @returns Promise resolved to true if initialization was done, false otherwise.
     */
    async waitInitialized() {
        if (this.initialized) {
            return true;
        }
        if (!this.initializing) {
            return false;
        }
        await this.m_initPromise;
        return true;
    }
    /**
     * Initializes the text renderer once there's any text element available for rendering.
     * @param textElementsAvailable - Indicates whether there's any text element to be rendered.
     * @returns Whether the text renderer is initialized.
     */
    initialize(textElementsAvailable) {
        if (!this.initialized && !this.initializing && textElementsAvailable) {
            this.initializeDefaultAssets();
            this.m_initPromise = this.initializeTextCanvases().then(() => {
                this.m_initialized = true;
                this.m_initPromise = undefined;
                this.invalidateCache(); // Force cache update after initialization.
                this.m_viewUpdateCallback();
            });
        }
        return this.initialized;
    }
    /**
     * Reset internal state at the beginning of a frame.
     */
    reset() {
        this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);
        this.m_screenCollisions.reset();
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.textCanvas.clear();
            textRenderer.poiRenderer.reset();
        }
    }
    /**
     * Update state at the end of a frame.
     */
    updateTextRenderers() {
        for (const textRenderer of this.m_textRenderers) {
            textRenderer.poiRenderer.update();
        }
    }
    /**
     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].
     * @note These boxes have highest priority, so will block all other labels.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    prepopulateScreenWithBlockingElements(dataSourceTileList) {
        const boxes = [];
        dataSourceTileList.forEach(renderListEntry => {
            const startLinePointProj = new THREE.Vector3();
            const endLinePointProj = new THREE.Vector3();
            for (const tile of renderListEntry.renderedTiles.values()) {
                for (const pathBlockingElement of tile.blockingElements) {
                    if (pathBlockingElement.points.length < 2) {
                        continue;
                    }
                    this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);
                    for (let i = 1; i < pathBlockingElement.points.length; i++) {
                        this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);
                        const line = pathBlockingElement.screenSpaceLines[i - 1];
                        line.start.copy(startLinePointProj);
                        line.end.copy(endLinePointProj);
                        const lineWithBound = {
                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),
                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),
                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),
                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),
                            line
                        };
                        boxes.push(lineWithBound);
                        startLinePointProj.copy(endLinePointProj);
                    }
                }
            }
        });
        this.m_screenCollisions.allocateIBoxes(boxes);
    }
    /**
     * @returns True if whole group was processed for placement,
     * false otherwise (e.g. placement limit reached).
     */
    placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {
        // Unvisited text elements are never placed.
        harp_utils_1.assert(groupState.visited);
        if (this.m_textRenderers.length === 0) {
            logger.warn("No text renderers initialized.");
            return false;
        }
        const shieldGroups = [];
        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;
        const projection = this.m_viewState.projection;
        const elevationProvider = this.m_viewState.elevationProvider;
        const elevationMap = elevationProvider === null || elevationProvider === void 0 ? void 0 : elevationProvider.getDisplacementMap(groupState.tileKey);
        for (const textElementState of groupState.textElementStates) {
            if (pass === Pass.PersistentLabels) {
                if (placementStats) {
                    ++placementStats.total;
                }
            }
            // Limit labels only in new labels pass (Pass.NewLabels).
            else if (maxNumPlacedLabels >= 0 &&
                renderParams.numRenderedTextElements >= maxNumPlacedLabels) {
                logger.debug("Placement label limit exceeded.");
                return false;
            }
            // Skip all labels that are not initialized (didn't pass early placement tests)
            // or don't belong to this pass.
            if (!textElementState.initialized) {
                if (placementStats) {
                    ++placementStats.uninitialized;
                }
                continue;
            }
            if (textElementState.viewDistance === undefined) {
                if (placementStats) {
                    ++placementStats.tooFar;
                }
                continue;
            }
            const elementVisible = textElementState.visible;
            if ((pass === Pass.PersistentLabels && !elementVisible) ||
                (pass === Pass.NewLabels && elementVisible)) {
                continue;
            }
            const textElement = textElementState.element;
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            const poiRenderer = textElementStyle.poiRenderer;
            if (textCanvas === undefined || poiRenderer === undefined) {
                logger.warn("Text canvas or poi renderer not ready.");
                continue;
            }
            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.
            // Check if the label should be hidden.
            if (hiddenKinds !== undefined &&
                textElement.kind !== undefined &&
                hiddenKinds.hasOrIntersects(textElement.kind)) {
                continue;
            }
            if (elevationProvider !== undefined && !textElement.elevated) {
                if (!elevationMap) {
                    this.m_viewUpdateCallback(); // Update view until elevation is loaded.
                    this.m_forceNewLabelsPass = true;
                    continue;
                }
                overlayOnElevation_1.overlayTextElement(textElement, elevationProvider, elevationMap, projection);
            }
            const elementType = textElement.type;
            const isPathLabel = elementType === TextElementType_1.TextElementType.PathLabel;
            // For paths, check if the label may fit.
            if (isPathLabel) {
                if (Placement_1.isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {
                    if (placementStats) {
                        placementStats.numNotVisible++;
                    }
                    if (textElement.dbgPathTooSmall === true) {
                        if (placementStats) {
                            placementStats.numPathTooSmall++;
                        }
                    }
                    textElementState.reset();
                    continue;
                }
            }
            const forceNewPassOnLoaded = true;
            // This ensures that textElement.renderStyle and textElement.layoutStyle are
            // already instantiated and initialized with theme style values.
            if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    if (placementStats) {
                        ++placementStats.numCannotAdd;
                    }
                    logger.warn("layer glyph storage capacity exceeded.");
                    continue;
                }
            }
            // Set the current style for the canvas.
            // This means text canvas has always references (not a copy) to text element styles.
            // The only exception is multi-anchor placement where layoutStyle need to be
            // modified and thus textCanvas will using its own copy of textElement.layoutStyle.
            // See: placePointLabel()
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            switch (elementType) {
                case TextElementType_1.TextElementType.PoiLabel:
                    this.addPoiLabel(textElementState, poiRenderer, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.LineMarker:
                    this.addLineMarkerLabel(textElementState, poiRenderer, shieldGroups, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.PathLabel:
                    this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);
            }
        }
        return true;
    }
    initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {
        // Trigger the glyph load if needed.
        if (textElement.loadingState === TextElement_1.LoadingState.Initialized) {
            return true;
        }
        harp_utils_1.assert(textElementStyle.textCanvas !== undefined);
        const textCanvas = textElementStyle.textCanvas;
        if (textElement.loadingState === undefined) {
            textElement.loadingState = TextElement_1.LoadingState.Requested;
            if (textElement.renderStyle === undefined) {
                textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, textElementStyle.renderParams), textElement.renderParams));
            }
            if (textElement.layoutStyle === undefined) {
                textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, textElementStyle.layoutParams), textElement.layoutParams));
            }
            if (textElement.text === "") {
                textElement.loadingState = TextElement_1.LoadingState.Loaded;
            }
            else {
                const newLoadPromise = textCanvas.fontCatalog
                    .loadCharset(textElement.text, textElement.renderStyle)
                    .then(() => {
                    --this.m_glyphLoadingCount;
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                    // Ensure that text elements still loading glyphs get a chance to
                    // be rendered if there's no text element updates in the next frames.
                    this.m_forceNewLabelsPass =
                        this.m_forceNewLabelsPass || forceNewPassOnLoaded;
                    this.m_viewUpdateCallback();
                });
                if (this.m_glyphLoadingCount === 0) {
                    this.m_loadPromise = undefined;
                }
                ++this.m_glyphLoadingCount;
                this.m_loadPromise =
                    this.m_loadPromise === undefined
                        ? newLoadPromise
                        : Promise.all([this.m_loadPromise, newLoadPromise]);
            }
        }
        if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            textElement.glyphCaseArray = [];
            textElement.bounds = undefined;
            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
            textElement.loadingState = TextElement_1.LoadingState.Initialized;
        }
        // Return true as soon as a text element has some glyphs assigned so that it's rendered.
        // The glyphs may be either the final ones or some temporal glyphs inherited from a
        // predecessor as part of the text element replacement process.
        // See TextElementState.replace().
        return textElement.glyphs !== undefined;
    }
    initializeDefaultAssets() {
        const defaultFontCatalogName = this.m_fontCatalogLoader.initialize(this.m_options.fontCatalog);
        this.m_textStyleCache.initializeDefaultTextElementStyle(defaultFontCatalogName);
    }
    async initializeTextCanvases() {
        const catalogCallback = (name, catalog) => {
            const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog);
            this.m_textRenderers.push({
                fontCatalog: name,
                textCanvas: loadedTextCanvas,
                poiRenderer: this.m_poiRendererFactory.createPoiRenderer(loadedTextCanvas)
            });
        };
        return this.m_fontCatalogLoader.loadCatalogs(catalogCallback).then(() => {
            // Find the default TextCanvas and PoiRenderer.
            let defaultTextCanvas;
            this.m_textRenderers.forEach(textRenderer => {
                if (defaultTextCanvas === undefined) {
                    defaultTextCanvas = textRenderer.textCanvas;
                }
            });
            const defaultPoiRenderer = this.m_poiRendererFactory.createPoiRenderer(defaultTextCanvas);
            this.m_textStyleCache.initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, this.m_textRenderers);
        });
    }
    updateGlyphDebugMesh() {
        const debugGlyphs = DebugContext_1.debugContext.getValue("DEBUG_GLYPHS");
        if (debugGlyphs === undefined) {
            return;
        }
        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {
            this.initializeGlyphDebugMesh();
        }
        harp_utils_1.assert(this.m_debugGlyphTextureCacheMesh !== undefined);
        harp_utils_1.assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);
        this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
        this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
    }
    initializeGlyphDebugMesh() {
        const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;
        // Initialize glyph-debugging mesh.
        const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
        const material = new THREE.MeshBasicMaterial({
            transparent: true,
            depthWrite: false,
            depthTest: false,
            map: defaultFontCatalog.texture
        });
        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);
        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;
        this.m_debugGlyphTextureCacheMesh.visible = false;
        this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
        const wireframe = new THREE.WireframeGeometry(planeGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({
            transparent: true,
            color: 0x999999,
            depthWrite: false,
            depthTest: false
        });
        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
        this.m_debugGlyphTextureCacheWireMesh.visible = false;
        this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
        this.m_textRenderers[0].textCanvas
            .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)
            .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
    }
    /**
     * Visit all visible tiles and add/ their text elements to cache.
     *
     * @remarks
     * The update of {@link TextElement}s is a time consuming process,
     * and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered {@link TextElement}s are stored internally
     * until the next update is done
     * to speed up rendering when no camera movement was detected.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    updateTextElements(dataSourceTileList) {
        logger.debug("updateTextElements");
        if (updateStats) {
            updateStats.clear();
        }
        this.m_textElementStateCache.clearTextCache();
        this.m_cacheInvalidated = false;
        this.checkIfOverloaded(dataSourceTileList);
        // Used with tile offset to compute the x coordinate offset for tiles.
        const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        // TODO: HARP-7648. Skip all data sources that won't contain text.
        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones
        // across all data sources.
        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,
        // including fallbacks if necessary) instead of visible tiles (target tiles that might not
        // be decoded yet).
        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out
        // and back in) due to the delay in decoding the visible tiles.
        dataSourceTileList.forEach(tileList => {
            this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);
        });
        if (updateStats) {
            updateStats.log();
        }
    }
    updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {
        if (updateStats) {
            updateStats.tiles += visibleTiles.length;
        }
        const sortedTiles = visibleTiles;
        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?
        sortedTiles.sort((a, b) => {
            return a.tileKey.mortonCode() - b.tileKey.mortonCode();
        });
        const sortedGroups = [];
        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
        let numTextElementsUpdated = 0;
        for (const textElementLists of sortedGroups) {
            this.selectTextElementsToUpdateByDistance(textElementLists);
            // The value of updateStartTime is set if this.overloaded is true.
            if (updateStartTime !== undefined) {
                // If overloaded and all time is used up, exit early.
                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {
                    const endTime = harp_utils_1.PerformanceTimer.now();
                    const elapsedTime = endTime - updateStartTime;
                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {
                        logger.debug("Update time limit exceeded.");
                        break;
                    }
                }
                // Try not to update too many elements. They will be checked for visibility each
                // frame.
                numTextElementsUpdated += textElementLists.count();
                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {
                    logger.debug("Update label limit exceeded.");
                    break;
                }
            }
        }
    }
    prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {
        if (textElementGroup.elements.length === 0) {
            return;
        }
        const textElementSelection = (textElementState) => {
            let { result, viewDistance } = Placement_1.checkReadyForPlacement(textElementState.element, this.m_viewState, this.m_viewCamera, this.m_poiManager, maxViewDistance);
            if (result === Placement_1.PrePlacementResult.Ok &&
                !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {
                result = Placement_1.PrePlacementResult.Duplicate;
                viewDistance = undefined;
            }
            if (updateStats) {
                updateStats.totalLabels++;
                updateStats.results[result]++;
            }
            return viewDistance;
        };
        const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection);
        if (updateStats) {
            ++updateStats.totalGroups;
            if (!found) {
                ++updateStats.newGroups;
            }
        }
    }
    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
        if (sortedTiles.length === 0) {
            return;
        }
        const tilesToRender = [];
        for (const tile of sortedTiles) {
            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                tilesToRender.push(tile);
            }
        }
        const groupedPriorityLists = new Map();
        for (const tile of tilesToRender) {
            for (const group of tile.textElementGroups.groups.values()) {
                if (group.elements.length === 0) {
                    continue;
                }
                const foundGroup = groupedPriorityLists.get(group.priority);
                if (foundGroup === undefined) {
                    groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));
                }
                else {
                    foundGroup.lists.push(new TileTextElements(tile, group));
                }
            }
        }
        if (groupedPriorityLists.size === 0) {
            return;
        }
        for (const g of groupedPriorityLists) {
            const lists = g[1];
            sortedGroups.push(lists);
        }
        sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        const printTextInfo = false;
        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
            let outString = "";
            for (const textElementLists of sortedGroups) {
                let size = 0;
                for (const tileTextElements of textElementLists.lists) {
                    size += tileTextElements.group.elements.length;
                }
                outString += `priority ${textElementLists.priority} size: ${size}\n`;
            }
            logger.log(outString);
        }
    }
    selectTextElementsToUpdateByDistance(textElementLists) {
        const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
        const maxViewDistance = Placement_1.getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);
        for (const tileTextElements of textElementLists.lists) {
            this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);
        }
    }
    placeTextElements(time, placeNewTextElements) {
        const renderParams = {
            numRenderedTextElements: 0,
            fadeAnimationRunning: false,
            time
        };
        const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        if (placementStats) {
            placementStats.clear();
        }
        if (this.m_textElementStateCache.size === 0) {
            logger.debug("Text element cache empty.");
            return;
        }
        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;
        if (this.m_forceNewLabelsPass) {
            if (!placeNewTextElements) {
                logger.debug("Force new label pass");
            }
            this.m_forceNewLabelsPass = false;
        }
        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;
        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected
        // candidates from previous frame if there's been no placement in this one.
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        let currentPriority = groupStates[0].priority;
        let currentPriorityBegin = 0;
        for (let i = 0; i < groupStates.length; ++i) {
            const textElementGroupState = groupStates[i];
            if (placementStats) {
                ++placementStats.totalGroups;
            }
            const newPriority = textElementGroupState.priority;
            if (placeNew && currentPriority !== newPriority) {
                // Place all new labels of the previous priority before placing the persistent
                // labels of this priority.
                this.placeNewTextElements(currentPriorityBegin, i, renderParams);
                if (isPlacementTimeExceeded(placeStartTime)) {
                    break;
                }
                currentPriority = newPriority;
                currentPriorityBegin = i;
            }
            if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, Pass.PersistentLabels)) {
                break;
            }
            if (isPlacementTimeExceeded(placeStartTime)) {
                break;
            }
        }
        if (placeNew) {
            // Place new text elements of the last priority.
            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);
        }
        if (placementStats) {
            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;
            placementStats.log();
        }
        if (renderParams.fadeAnimationRunning) {
            this.m_viewUpdateCallback();
        }
    }
    placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {
            if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, Pass.NewLabels)) {
                break;
            }
        }
    }
    placeOverlayTextElements() {
        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {
            return;
        }
        const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);
        const screenXOrigin = -screenSize.width / 2.0;
        const screenYOrigin = screenSize.height / 2.0;
        // Place text elements one by one.
        for (const textElement of this.m_overlayTextElements) {
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            if (textCanvas === undefined) {
                continue;
            }
            const forceNewPassOnLoaded = false;
            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                continue;
            }
            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Place text.
            let textPath;
            if (!(textElement.type === TextElementType_1.TextElementType.PathLabel)) {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                tempPosition.x = tempScreenPosition.x;
                tempPosition.y = tempScreenPosition.y;
                tempPosition.z = 0.0;
                addTextToCanvas(textElement, textCanvas, tempPosition);
            }
            else {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin;
                tempScreenPosition.y = screenYOrigin;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                // Get the screen points that define the label's segments and create a path with
                // them.
                // TODO: HARP-7648. Optimize array allocations.
                const screenPoints = [];
                for (const pt of textElement.path) {
                    const pX = tempScreenPosition.x + pt.x * screenSize.width;
                    const pY = tempScreenPosition.y - pt.y * screenSize.height;
                    screenPoints.push(new THREE.Vector2(pX, pY));
                }
                textPath = new SimplePath_1.SimplePath();
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);
            }
        }
    }
    getDistanceScalingFactor(label, distance, lookAtDistance) {
        // Distance scale is based on relation between camera focus point distance and
        // the actual label distance. For labels close to camera look at point the scale
        // remains unchanged, the farther is label from that point the smaller size it is
        // rendered in screen space. This method is unaffected by near and far clipping planes
        // distances, but may be improved by taking FOV into equation or customizing the
        // focus point screen position based on horizon, actual ground, tilt ets.
        let factor = lookAtDistance / distance;
        // The label.distanceScale property defines the influence ratio at which
        // distance affects the final scaling of label.
        factor = 1.0 + (factor - 1.0) * label.distanceScale;
        // Preserve the constraints
        factor = Math.max(factor, this.m_options.labelDistanceScaleMin);
        factor = Math.min(factor, this.m_options.labelDistanceScaleMax);
        return factor;
    }
    getDistanceFadingFactor(label, state, maxVisibilityDist) {
        let distanceFadeValue = 1.0;
        const textDistance = state.viewDistance;
        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {
            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;
            const fadeFar = label.fadeFar;
            if (fadeFar > fadeNear) {
                distanceFadeValue =
                    1.0 -
                        THREE.MathUtils.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);
            }
        }
        return distanceFadeValue;
    }
    addPointLabel(labelState, position, screenPosition, poiRenderer, textCanvas, renderParams, iconIndex) {
        const pointLabel = labelState.element;
        const textRenderState = labelState.textRenderState;
        harp_utils_1.assert(iconIndex === undefined || labelState.iconRenderStates !== undefined);
        const iconRenderState = iconIndex !== undefined
            ? labelState.iconRenderStates[iconIndex]
            : labelState.iconRenderState;
        harp_utils_1.assert(iconRenderState !== undefined);
        // Find the label's original position.
        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
        // Scale the text depending on the label's distance to the camera "zero" plane.
        const textDistance = Placement_1.pointToPlaneDistance(position, this.m_viewState.worldCenter, this.m_cameraLookAt);
        if (pointLabel.fadeFar !== undefined &&
            (pointLabel.fadeFar <= 0.0 ||
                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent.
            if (placementStats) {
                ++placementStats.tooFar;
            }
            return false;
        }
        labelState.setViewDistance(textDistance);
        // Check if there is need to check for screen space for the label's icon.
        const poiInfo = pointLabel.poiInfo;
        let iconRejected = false;
        // Check if icon should be rendered at this zoomLevel
        const renderIcon = poiInfo !== undefined &&
            harp_utils_1.MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) &&
            poiInfo.isValid !== false;
        const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);
        const iconReady = renderIcon && poiRenderer.prepareRender(pointLabel, this.m_viewState.env);
        if (iconReady) {
            const result = Placement_1.placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);
            if (result === Placement_1.PlacementResult.Invisible) {
                iconRenderState.reset();
                if (placementStats) {
                    ++placementStats.numNotVisible;
                }
                return false;
            }
            iconRejected = result === Placement_1.PlacementResult.Rejected;
        }
        else if (renderIcon && poiInfo.isValid !== false) {
            // Ensure that text elements still loading icons get a chance to be rendered if
            // there's no text element updates in the next frames.
            this.m_forceNewLabelsPass = true;
        }
        const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);
        const renderText = shouldRenderPointText(labelState, this.m_viewState, this.m_options);
        // Render the label's text...
        // textRenderState is always defined at this point.
        if (renderText) {
            // Multi point (icons) features (line markers) will use single placement anchor, but
            // single point labels (POIs, etc.) may use multi-placement algorithm.
            const placeResult = Placement_1.placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_viewState.env, this.m_screenCollisions, iconRejected, tempPosition, iconIndex === undefined);
            if (placeResult === Placement_1.PlacementResult.Invisible) {
                if (placementStats) {
                    placementStats.numPoiTextsInvisible++;
                }
                labelState.reset();
                return false;
            }
            const textRejected = placeResult === Placement_1.PlacementResult.Rejected;
            if (!iconRejected) {
                const textIsOptional = pointLabel.poiInfo !== undefined && pointLabel.poiInfo.textIsOptional === true;
                iconRejected = textRejected && !textIsOptional;
            }
            if (textRejected) {
                textRenderState.startFadeOut(renderParams.time);
            }
            const textNeedsDraw = (!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||
                textRenderState.isFading();
            if (textNeedsDraw) {
                if (!textRejected) {
                    textRenderState.startFadeIn(renderParams.time);
                }
                renderParams.fadeAnimationRunning =
                    renderParams.fadeAnimationRunning || textRenderState.isFading();
                if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) &&
                    placementStats) {
                    placementStats.numRenderedPoiTexts++;
                }
            }
        }
        // ... and render the icon (if any).
        if (iconReady) {
            if (iconRejected) {
                iconRenderState.startFadeOut(renderParams.time);
            }
            else {
                iconRenderState.startFadeIn(renderParams.time);
            }
            renderParams.fadeAnimationRunning =
                renderParams.fadeAnimationRunning || iconRenderState.isFading();
            const opacity = iconRenderState.opacity * distanceFadeFactor;
            if (opacity > 0) {
                // Same as for text, don't allocate screen space for an icon that's fading out so
                // that any label blocked by it gets a chance to be placed as soon as any other
                // surrounding new labels.
                const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;
                poiRenderer.renderPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);
                if (placementStats) {
                    placementStats.numRenderedPoiIcons++;
                }
            }
        }
        renderParams.numRenderedTextElements++;
        return true;
    }
    addPoiLabel(labelState, poiRenderer, textCanvas, renderParams) {
        const worldPosition = Placement_1.getWorldPosition(labelState.element, this.m_viewState.projection, this.m_viewState.env, this.m_tmpVector3);
        // Only process labels frustum-clipped labels
        if (this.m_screenProjector.project(worldPosition, tempScreenPosition) === undefined) {
            return false;
        }
        // Add this POI as a point label.
        return this.addPointLabel(labelState, worldPosition, tempScreenPosition, poiRenderer, textCanvas, renderParams);
    }
    addLineMarkerLabel(labelState, poiRenderer, shieldGroups, textCanvas, renderParams) {
        const lineMarkerLabel = labelState.element;
        const path = lineMarkerLabel.points;
        // Early exit if the line marker doesn't have the necessary data.
        const poiInfo = lineMarkerLabel.poiInfo;
        if (path.length === 0 ||
            !poiRenderer.prepareRender(lineMarkerLabel, this.m_viewState.env)) {
            return;
        }
        // Initialize the shield group for this lineMarker.
        let shieldGroup;
        if (poiInfo.shieldGroupIndex !== undefined) {
            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
            if (shieldGroup === undefined) {
                shieldGroup = [];
                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
            }
        }
        const lineTechnique = poiInfo.technique;
        const minDistanceSqr = lineTechnique.minDistance !== undefined
            ? lineTechnique.minDistance * lineTechnique.minDistance
            : 0;
        // Process markers (with shield groups).
        if (minDistanceSqr > 0 && shieldGroup !== undefined) {
            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {
                const point = path[pointIndex];
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {
                    // Find a suitable location for the lineMarker to be placed at.
                    let tooClose = false;
                    for (let j = 0; j < shieldGroup.length; j += 2) {
                        const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                        tooClose = distanceSqr < minDistanceSqr;
                        if (tooClose) {
                            break;
                        }
                    }
                    // Place it as a point label if it's not to close to other marker in the
                    // same shield group.
                    if (!tooClose) {
                        if (this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex)) {
                            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                        }
                    }
                }
            }
        }
        // Process markers (without shield groups).
        else {
            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {
                const point = path[pointIndex];
                // Only process labels frustum-clipped labels
                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {
                    this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex);
                }
            }
        }
    }
    addPathLabel(labelState, screenPoints, textCanvas, renderParams) {
        // TODO: HARP-7649. Add fade out transitions for path labels.
        const textMaxDistance = Placement_1.getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);
        const pathLabel = labelState.element;
        // Limit the text rendering of path labels in the far distance.
        if (!(pathLabel.ignoreDistance === true ||
            labelState.viewDistance === undefined ||
            labelState.viewDistance < textMaxDistance)) {
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        if (pathLabel.fadeFar !== undefined &&
            (pathLabel.fadeFar <= 0.0 ||
                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        // Get the screen points that define the label's segments and create a path with
        // them.
        let textPath = new THREE.Path();
        tempScreenPosition.copy(screenPoints[0]);
        for (let i = 0; i < screenPoints.length - 1; ++i) {
            textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
        }
        // Flip the path if the label is gonna be rendered downwards.
        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
            textPath = new THREE.Path();
            for (let i = screenPoints.length - 1; i > 0; --i) {
                textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
            }
        }
        // Update the real rendering distance to have smooth fading and scaling
        labelState.setViewDistance(Placement_1.computeViewDistance(pathLabel, this.m_viewState.worldCenter, this.m_cameraLookAt));
        const textRenderDistance = -labelState.renderDistance;
        // Scale the text depending on the label's distance to the camera.
        const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);
        const prevSize = textCanvas.textRenderStyle.fontSize.size;
        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;
        if (Placement_1.placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== Placement_1.PlacementResult.Ok) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            if (placementStats) {
                ++placementStats.numNotVisible;
            }
            labelState.textRenderState.reset();
            return false;
        }
        labelState.textRenderState.startFadeIn(renderParams.time);
        let opacity = pathLabel.renderStyle.opacity;
        if (labelState.textRenderState.isFading()) {
            opacity *= labelState.textRenderState.opacity;
            renderParams.fadeAnimationRunning = true;
        }
        if (labelState.textRenderState.opacity === 0) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            return false;
        }
        const prevOpacity = textCanvas.textRenderStyle.opacity;
        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
        const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);
        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
        textCanvas.textRenderStyle.backgroundOpacity =
            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;
        tempPosition.z = labelState.renderDistance;
        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);
        renderParams.numRenderedTextElements++;
        // Restore previous style values for text elements using the same style.
        textCanvas.textRenderStyle.fontSize.size = prevSize;
        textCanvas.textRenderStyle.opacity = prevOpacity;
        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
        return true;
    }
    checkIfOverloaded(dataSourceTileList) {
        // Count the number of TextElements in the scene to see if we have to switch to
        // "overloadMode".
        let numTextElementsInScene = 0;
        dataSourceTileList.forEach(renderListEntry => {
            for (const tile of renderListEntry.renderedTiles.values()) {
                numTextElementsInScene += tile.textElementGroups.count();
            }
        });
        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
        if (newOverloaded && !this.m_overloaded) {
            logger.debug("Overloaded Mode enabled.");
        }
        this.m_overloaded = newOverloaded;
        return this.m_overloaded;
    }
}
exports.TextElementsRenderer = TextElementsRenderer;
//# sourceMappingURL=TextElementsRenderer.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeDefaultOptions = void 0;
const DEFAULT_FONT_CATALOG = "./resources/fonts/Default_FontCatalog.json";
/**
 * Default number of labels/POIs rendered in the scene
 */
const DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;
/**
 * Number of elements that are put into second queue. This second chance queue is used to render
 * TextElements that have not been on screen before. This is a quick source for elements that can
 * appear when the camera moves a bit, before new elements are placed.
 */
const DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;
/**
 * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the
 * far plane (1.0). May be synchronized with fog value ?
 */
const DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
/**
 * Minimum scaling factor that may be applied to labels when their are distant from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
/**
 * Maximum scaling factor that may be applied to labels due to their distance from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
const MIN_GLYPH_COUNT = 1024;
const MAX_GLYPH_COUNT = 32768;
/**
 * Initializes undefined text renderer options to default values.
 * @param options - The options to be initialized.
 */
function initializeDefaultOptions(options) {
    if (options.fontCatalog === undefined) {
        options.fontCatalog = DEFAULT_FONT_CATALOG;
    }
    if (options.minNumGlyphs === undefined) {
        options.minNumGlyphs = MIN_GLYPH_COUNT;
    }
    if (options.maxNumGlyphs === undefined) {
        options.maxNumGlyphs = MAX_GLYPH_COUNT;
    }
    if (options.maxNumVisibleLabels === undefined) {
        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;
    }
    // TODO: Unused so far.
    if (options.numSecondChanceLabels === undefined) {
        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;
    }
    if (options.labelDistanceScaleMin === undefined) {
        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
    }
    if (options.labelDistanceScaleMax === undefined) {
        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
    }
    if (options.maxDistanceRatioForTextLabels === undefined) {
        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.maxDistanceRatioForPoiLabels === undefined) {
        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.disableFading === undefined) {
        options.disableFading = false;
    }
    if (options.delayLabelsUntilMovementFinished === undefined) {
        options.delayLabelsUntilMovementFinished = true;
    }
}
exports.initializeDefaultOptions = initializeDefaultOptions;
//# sourceMappingURL=TextElementsRendererOptions.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextStyleCache = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "./node_modules/@here/harp-mapview/lib/ColorCache.js");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js");
const logger = harp_utils_1.LoggerManager.instance.create("TextStyleCache");
const defaultTextRenderStyle = new harp_text_canvas_1.TextRenderStyle({
    fontSize: {
        unit: harp_text_canvas_1.FontUnit.Pixel,
        size: 32,
        backgroundSize: 8
    },
    color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
    opacity: 1.0,
    backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
    backgroundOpacity: 0.5
});
// By default text layout provides no options for placement, but single alignment.
const defaultTextLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
    verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
    horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center,
    placements: []
});
const DEFAULT_STYLE_NAME = "default";
class TextStyleCache {
    constructor(m_theme) {
        this.m_theme = m_theme;
        this.m_textStyles = new Map();
        this.m_defaultStyle = {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: "",
            renderParams: defaultTextRenderStyle.params,
            layoutParams: defaultTextLayoutStyle.params
        };
    }
    initializeDefaultTextElementStyle(defaultFontCatalogName) {
        if (this.m_theme.textStyles === undefined) {
            this.m_theme.textStyles = [];
        }
        const styles = this.m_theme.textStyles;
        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);
        if (themedDefaultStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(themedDefaultStyle, DEFAULT_STYLE_NAME);
        }
        else if (this.m_theme.defaultTextStyle !== undefined) {
            this.m_defaultStyle = this.createTextElementStyle(this.m_theme.defaultTextStyle, DEFAULT_STYLE_NAME);
        }
        else if (styles.length > 0) {
            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);
        }
        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;
    }
    initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, textRenderers) {
        // Initialize default text style.
        if (this.m_defaultStyle.fontCatalog !== undefined) {
            const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog);
            this.m_defaultStyle.textCanvas =
                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;
            this.m_defaultStyle.poiRenderer =
                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;
        }
        if (this.m_defaultStyle.textCanvas === undefined) {
            if (this.m_defaultStyle.fontCatalog !== undefined) {
                logger.warn(`FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${this.m_defaultStyle.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
            }
            this.m_defaultStyle.textCanvas = defaultTextCanvas;
            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;
        }
        // Initialize theme text styles.
        this.m_theme.textStyles.forEach(element => {
            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
        });
        // tslint:disable-next-line:no-unused-variable
        for (const [, style] of this.m_textStyles) {
            if (style.textCanvas === undefined) {
                if (style.fontCatalog !== undefined) {
                    const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === style.fontCatalog);
                    style.textCanvas =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.textCanvas
                            : undefined;
                    style.poiRenderer =
                        styledTextRenderer !== undefined
                            ? styledTextRenderer.poiRenderer
                            : undefined;
                }
                if (style.textCanvas === undefined) {
                    if (style.fontCatalog !== undefined) {
                        logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle '${style.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);
                    }
                    style.textCanvas = defaultTextCanvas;
                    style.poiRenderer = defaultPoiRenderer;
                }
            }
        }
    }
    /**
     * Retrieves a {@link TextElementStyle} for {@link @here/harp-datasource-protocol#Theme}'s
     * [[TextStyle]] id.
     */
    getTextElementStyle(styleId) {
        let result;
        if (styleId === undefined) {
            result = this.m_defaultStyle;
        }
        else {
            result = this.m_textStyles.get(styleId);
            if (result === undefined) {
                result = this.m_defaultStyle;
            }
        }
        return result;
    }
    /**
     * Gets the appropriate {@link @here/harp-text-canvas#TextRenderStyle}
     * to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     */
    createRenderStyle(tile, technique) {
        const mapView = tile.mapView;
        const zoomLevel = mapView.zoomLevel;
        const discreteZoomLevel = Math.floor(zoomLevel);
        // Environment with $zoom forced to integer to achieve stable interpolated values.
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const defaultRenderParams = this.m_defaultStyle.renderParams;
        // Sets opacity to 1.0 if default and technique attribute are undefined.
        const defaultOpacity = harp_utils_1.getOptionValue(defaultRenderParams.opacity, 1.0);
        // Interpolate opacity but only on discreet zoom levels (step interpolation).
        let opacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);
        let color;
        // Store color (RGB) in cache and multiply opacity value with the color alpha channel.
        if (technique.color !== undefined) {
            let hexColor = DecodedTileHelpers_1.evaluateColorProperty(technique.color, discreteZoomEnv);
            if (hexColor !== undefined) {
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexColor);
                    opacity = opacity * alpha;
                    hexColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexColor);
                }
                color = ColorCache_1.ColorCache.instance.getColor(hexColor);
            }
        }
        // Sets background size to 0.0 if default and technique attribute is undefined.
        const defaultBackgroundSize = harp_utils_1.getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);
        const backgroundSize = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);
        const hasBackgroundDefined = technique.backgroundColor !== undefined &&
            technique.backgroundSize !== undefined &&
            backgroundSize > 0;
        // Sets background opacity to 1.0 if default and technique value is undefined while
        // background size and color is specified, otherwise set value in default render
        // params or 0.0 if neither set. Makes label opaque when backgroundColor and
        // backgroundSize are set.
        const defaultBackgroundOpacity = harp_utils_1.getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);
        let backgroundOpacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity), discreteZoomEnv);
        let backgroundColor;
        // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.
        if (technique.backgroundColor !== undefined) {
            let hexBgColor = DecodedTileHelpers_1.evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);
            if (hexBgColor !== undefined) {
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexBgColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexBgColor);
                    backgroundOpacity = backgroundOpacity * alpha;
                    hexBgColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexBgColor);
                }
                backgroundColor = ColorCache_1.ColorCache.instance.getColor(hexBgColor);
            }
        }
        const renderParams = {
            fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),
                backgroundSize
            },
            fontStyle: technique.fontStyle === "Regular" ||
                technique.fontStyle === "Bold" ||
                technique.fontStyle === "Italic" ||
                technique.fontStyle === "BoldItalic"
                ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                : defaultRenderParams.fontStyle,
            fontVariant: technique.fontVariant === "Regular" ||
                technique.fontVariant === "AllCaps" ||
                technique.fontVariant === "SmallCaps"
                ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                : defaultRenderParams.fontVariant,
            rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
            color: harp_utils_1.getOptionValue(color, harp_utils_1.getOptionValue(defaultRenderParams.color, harp_text_canvas_1.DefaultTextStyle.DEFAULT_COLOR)),
            backgroundColor: harp_utils_1.getOptionValue(backgroundColor, harp_utils_1.getOptionValue(defaultRenderParams.backgroundColor, harp_text_canvas_1.DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),
            opacity,
            backgroundOpacity
        };
        const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;
        const renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, themeRenderParams), renderParams));
        return renderStyle;
    }
    /**
     * Create the appropriate {@link @here/harp-text-canvas#TextLayoutStyle}
     * to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param tile - The {@link Tile} to process.
     * @param technique - Label's technique.
     */
    createLayoutStyle(tile, technique) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: floorZoomLevel }, mapView.env);
        const defaultLayoutParams = this.m_defaultStyle.layoutParams;
        const hAlignment = harp_datasource_protocol_1.getPropertyValue(technique.hAlignment, discreteZoomEnv);
        const vAlignment = harp_datasource_protocol_1.getPropertyValue(technique.vAlignment, discreteZoomEnv);
        // Text alternative placements are currently supported only for PoiTechnique.
        const textPlacements = harp_datasource_protocol_1.isPoiTechnique(technique)
            ? harp_datasource_protocol_1.getPropertyValue(technique.placements, discreteZoomEnv)
            : null;
        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(hAlignment, vAlignment, textPlacements);
        const wrapping = harp_datasource_protocol_1.getPropertyValue(technique.wrappingMode, discreteZoomEnv);
        const wrappingMode = wrapping === "None" || wrapping === "Character" || wrapping === "Word"
            ? harp_text_canvas_1.WrappingMode[wrapping]
            : defaultLayoutParams.wrappingMode;
        const layoutParams = {
            tracking: (_a = harp_datasource_protocol_1.getPropertyValue(technique.tracking, discreteZoomEnv)) !== null && _a !== void 0 ? _a : defaultLayoutParams.tracking,
            leading: (_b = harp_datasource_protocol_1.getPropertyValue(technique.leading, discreteZoomEnv)) !== null && _b !== void 0 ? _b : defaultLayoutParams.leading,
            maxLines: (_c = harp_datasource_protocol_1.getPropertyValue(technique.maxLines, discreteZoomEnv)) !== null && _c !== void 0 ? _c : defaultLayoutParams.maxLines,
            lineWidth: (_d = harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, discreteZoomEnv)) !== null && _d !== void 0 ? _d : defaultLayoutParams.lineWidth,
            canvasRotation: (_e = harp_datasource_protocol_1.getPropertyValue(technique.canvasRotation, discreteZoomEnv)) !== null && _e !== void 0 ? _e : defaultLayoutParams.canvasRotation,
            lineRotation: (_f = harp_datasource_protocol_1.getPropertyValue(technique.lineRotation, discreteZoomEnv)) !== null && _f !== void 0 ? _f : defaultLayoutParams.lineRotation,
            wrappingMode,
            horizontalAlignment,
            verticalAlignment,
            placements
        };
        const themeLayoutParams = this.getTextElementStyle(technique.style);
        const layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, themeLayoutParams), layoutParams));
        return layoutStyle;
    }
    createTextElementStyle(style, styleName) {
        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(style.hAlignment, style.vAlignment, style.placements);
        return {
            name: styleName,
            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),
            renderParams: {
                fontName: style.fontName,
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: 32,
                    backgroundSize: style.backgroundSize || 8
                },
                fontStyle: style.fontStyle === "Regular" ||
                    style.fontStyle === "Bold" ||
                    style.fontStyle === "Italic" ||
                    style.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[style.fontStyle]
                    : undefined,
                fontVariant: style.fontVariant === "Regular" ||
                    style.fontVariant === "AllCaps" ||
                    style.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[style.fontVariant]
                    : undefined,
                rotation: style.rotation,
                color: style.color !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.color)
                    : undefined,
                backgroundColor: style.backgroundColor !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)
                    : undefined,
                opacity: style.opacity,
                backgroundOpacity: style.backgroundOpacity
            },
            layoutParams: {
                tracking: style.tracking,
                leading: style.leading,
                maxLines: style.maxLines,
                lineWidth: style.lineWidth,
                canvasRotation: style.canvasRotation,
                lineRotation: style.lineRotation,
                wrappingMode: style.wrappingMode === "None" ||
                    style.wrappingMode === "Character" ||
                    style.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]
                    : harp_text_canvas_1.WrappingMode.Word,
                verticalAlignment,
                horizontalAlignment,
                placements
            }
        };
    }
}
exports.TextStyleCache = TextStyleCache;
function parseAlignmentAndPlacements(hAlignment, vAlignment, placementsTokens) {
    // Currently supported only for PoiTechnique.
    const placements = placementsTokens
        ? parseTechniquePlacements(placementsTokens)
        : undefined;
    return harp_text_canvas_1.resolvePlacementAndAlignment(parseTechniqueHAlignValue(hAlignment), parseTechniqueVAlignValue(vAlignment), placements);
}
function parseTechniqueHAlignValue(hAlignment) {
    return hAlignment === "Left" || hAlignment === "Center" || hAlignment === "Right"
        ? harp_text_canvas_1.HorizontalAlignment[hAlignment]
        : defaultTextLayoutStyle.horizontalAlignment;
}
function parseTechniqueVAlignValue(vAlignment) {
    return vAlignment === "Above" || vAlignment === "Center" || vAlignment === "Below"
        ? harp_text_canvas_1.VerticalAlignment[vAlignment]
        : defaultTextLayoutStyle.verticalAlignment;
}
function parseTechniquePlacements(placementsString) {
    // Parse placement properties if available.
    const placements = [];
    const placementsTokens = placementsString
        ? placementsString
            .toUpperCase()
            .replace(" ", "")
            .split(",")
        : [];
    placementsTokens.forEach(p => {
        const val = parseTechniquePlacementValue(p);
        if (val !== undefined) {
            placements.push(val);
        }
    });
    return placements;
}
function parseTechniquePlacementValue(p) {
    // May be only literal of single or two characters.
    if (p.length < 1 || p.length > 2) {
        return undefined;
    }
    // If no value is specified for vertical/horizontal placement it is by default center.
    const textPlacement = {
        h: harp_text_canvas_1.HorizontalPlacement.Center,
        v: harp_text_canvas_1.VerticalPlacement.Center
    };
    // Firstly try to find vertical placement.
    let modifier = p.charAt(0);
    let found = true;
    switch (modifier) {
        // Top / north
        case harp_datasource_protocol_1.PlacementToken.Top:
        case harp_datasource_protocol_1.PlacementToken.North:
            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Top;
            break;
        // Bottom / south
        case harp_datasource_protocol_1.PlacementToken.Bottom:
        case harp_datasource_protocol_1.PlacementToken.South:
            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Bottom;
            break;
        default:
            found = false;
            if (p.length === 2) {
                // For 2 characters tag both vertical/horizontal should be defined.
                return undefined;
            }
    }
    if (found && p.length === 1) {
        return textPlacement;
    }
    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);
    switch (modifier) {
        // Right / east
        case harp_datasource_protocol_1.PlacementToken.Right:
        case harp_datasource_protocol_1.PlacementToken.East:
            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Right;
            break;
        // Left / west
        case harp_datasource_protocol_1.PlacementToken.Left:
        case harp_datasource_protocol_1.PlacementToken.West:
            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Left;
            break;
        default:
            // Either for single character or multi-char tag, we must surrender.
            return undefined;
    }
    return textPlacement;
}
//# sourceMappingURL=TextStyleCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TileTextStyleCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileTextStyleCache = void 0;
class TileTextStyleCache {
    constructor(tile) {
        this.textRenderStyles = [];
        this.textLayoutStyles = [];
        this.tile = tile;
    }
    clear() {
        this.textRenderStyles.length = 0;
        this.textLayoutStyles.length = 0;
    }
    getRenderStyle(technique) {
        let style = this.textRenderStyles[technique._index];
        if (style === undefined) {
            style = this.textRenderStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(this.tile, technique);
        }
        return style;
    }
    getLayoutStyle(technique) {
        let style = this.textLayoutStyles[technique._index];
        if (style === undefined) {
            style = this.textLayoutStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(this.tile, technique);
        }
        return style;
    }
}
exports.TileTextStyleCache = TileTextStyleCache;
//# sourceMappingURL=TileTextStyleCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/UpdateStats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/UpdateStats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateStats = void 0;
const Placement_1 = __webpack_require__(/*! ./Placement */ "./node_modules/@here/harp-mapview/lib/text/Placement.js");
class UpdateStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results = new Array(Placement_1.PrePlacementResult.Count);
        this.results.fill(0);
    }
    clear() {
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results.fill(0);
    }
    log() {
        this.m_logger.debug("Tiles", this.tiles);
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("New groups", this.newGroups);
        this.m_logger.debug("Total labels", this.totalLabels);
        this.m_logger.debug("Placed labels", this.results[Placement_1.PrePlacementResult.Ok]);
        this.m_logger.debug("Invisible", this.results[Placement_1.PrePlacementResult.Invisible]);
        this.m_logger.debug("Poi not ready", this.results[Placement_1.PrePlacementResult.NotReady]);
        this.m_logger.debug("Too far", this.results[Placement_1.PrePlacementResult.TooFar]);
        this.m_logger.debug("Duplicate", this.results[Placement_1.PrePlacementResult.Duplicate]);
    }
}
exports.UpdateStats = UpdateStats;
//# sourceMappingURL=UpdateStats.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isWorkerBootstrapResponse = exports.isWorkerBootstrapRequest = void 0;
function isWorkerBootstrapRequest(message) {
    return (message &&
        message.type === "worker-bootstrap-request" &&
        Array.isArray(message.dependencies));
}
exports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;
function isWorkerBootstrapResponse(message) {
    return (message &&
        message.type === "worker-bootstrap-response" &&
        Array.isArray(message.resolvedDependencies));
}
exports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;
//# sourceMappingURL=WorkerBootstrapDefs.js.map

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerLoader = void 0;
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerLoader");
/**
 * Set of `Worker` loading and initialization helpers:
 *  - starting Worker from URL with fallback to XHR+blob {@link WorkerLoader.startWorker}
 *  - waiting for proper worker initialization, see {@link WorkerLoader.waitWorkerInitialized}
 */
let WorkerLoader = /** @class */ (() => {
    class WorkerLoader {
        /**
         * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.
         * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful
         * initialization.
         * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to
         * [[startWorkerBlob]].
         *
         * We must resolve/reject promise at some time, so it is expected that any sane application will
         * be able to load worker code in some amount of time.
         * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).
         *
         * This method is needed as browsers in general forbid to load worker if it's not on 'same
         * origin' regardless of Content-Security-Policy.
         *
         * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows
         * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but
         * this may change.
         *
         * Following snippet setups CSP, so workers can be started from blob urls:
         *
         *     <head>
         *         <meta http-equiv="Content-Security-Policy" content="child-src blob:">
         *     </head>
         *
         * Tested on:
         *   * Chrome 67 / Linux, Window, OSX, Android
         *   * Firefox 60 / Linux, Windows, OSX
         *   * Edge 41 / Windows
         *   * Safari 11 / OSX
         *   * Samsung Internet 7.2
         *
         * See
         *  * https://benohead.com/cross-domain-cross-browser-web-workers/
         *  * MapBox
         *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
         *    * https://github.com/mapbox/mapbox-gl-js/issues/2658
         *    * https://github.com/mapbox/mapbox-gl-js/issues/559
         *    * https://github.com/mapbox/mapbox-gl-js/issues/6058
         *
         * Findings:
         *
         * * Chrome reports CSP by exception when constructing [[Worker]] instance.
         * * Firefox reports CSP errors when loading in first event:
         *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888
         * * Firefox 62, Chrome 67 obeys `<meta http-equiv="Content-Security-Policy">` with
         *   `worker-src blob:` but doesn't obey `worker-src URL` when used
         * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported
         *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)
         *
         * @param scriptUrl - web worker script URL
         * @param timeout - timeout in milliseconds, in which worker should set initial message
         *    (default 10 seconds)
         */
        static startWorker(scriptUrl, timeout = 10000) {
            if (scriptUrl.startsWith("blob:")) {
                return this.startWorkerImmediately(scriptUrl, timeout);
            }
            if (this.directlyFallbackToBlobBasedLoading) {
                return this.startWorkerBlob(scriptUrl, timeout);
            }
            return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {
                if (typeof window !== "undefined") {
                    const pageUrl = window.location.href;
                    const fullScriptUrl = new URL(scriptUrl, pageUrl).href;
                    if (harp_utils_1.getUrlOrigin(fullScriptUrl) === harp_utils_1.getUrlOrigin(pageUrl)) {
                        throw error;
                    }
                    logger.log("#startWorker: cross-origin worker construction failed, trying load with blob");
                    this.directlyFallbackToBlobBasedLoading = true;
                    return WorkerLoader.startWorkerBlob(scriptUrl, timeout);
                }
                else {
                    throw error;
                }
            });
        }
        /**
         * Start worker, loading it immediately from `scriptUrl`. Waits (using
         * [[waitWorkerInitialized]]) for successful worker start.
         *
         * @param scriptUrl - web worker script URL
         */
        static startWorkerImmediately(scriptUrl, timeout) {
            try {
                const worker = new Worker(scriptUrl);
                return this.waitWorkerInitialized(worker, timeout);
            }
            catch (error) {
                return Promise.reject(error);
            }
        }
        /**
         * Start worker "via blob" by first loading worker script code with [[fetch]], creating `Blob`
         * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for
         * successful worker start.
         *
         * @param scriptUrl - web worker script URL
         */
        static startWorkerBlob(scriptUrl, timeout) {
            return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {
                return this.startWorkerImmediately(blobUrl, timeout);
            });
        }
        /**
         * Fetch script source as `Blob` url.
         *
         * Reuses results, if there are many simultaneous requests.
         *
         * @param scriptUrl - web worker script URL
         * @return promise that resolves to url of a `Blob` with script source code
         */
        static fetchScriptSourceToBlobUrl(scriptUrl) {
            let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
            if (loadingPromise !== undefined) {
                return loadingPromise;
            }
            loadingPromise = fetch(scriptUrl)
                .then(response => response.text())
                .catch(error => {
                throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
            })
                .then(scriptSource => {
                this.sourceLoaderCache.delete(scriptUrl);
                const blob = new Blob([scriptSource], { type: "application/javascript" });
                return URL.createObjectURL(blob);
            });
            this.sourceLoaderCache.set(scriptUrl, loadingPromise);
            return loadingPromise;
        }
        /**
         * Waits for successful Web Worker start.
         *
         * Expects that worker script sends initial message.
         *
         * If first event is `message` then assumes that worker has been loaded sussesfully and promise
         * resolves to `worker` object passed as argument.
         *
         * If first event is 'error', then it is assumed that worker failed to load and promise is
         * rejected.
         *
         * (NOTE: The initial 'message' - if received - is immediately replayed using worker's
         * `dispatchEvent`, so application code can also consume it as confirmation of successful
         * worker initialization.
         *
         * We must resolve/reject promise at some time, so it is expected that any sane application will
         * be able to load worker code in some amount of time.
         *
         * @param worker - [[Worker]] instance to be checked
         * @param timeout - timeout in milliseconds, in which worker should set initial message
         * @returns `Promise` that resolves to `worker` on success
         */
        static waitWorkerInitialized(worker, timeout) {
            return new Promise((resolve, reject) => {
                const firstMessageCallback = (event) => {
                    const message = event.data;
                    if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {
                        const dependencies = message.dependencies;
                        const resolvedDependencies = [];
                        for (const dependency of dependencies) {
                            const resolved = this.dependencyUrlMapping[dependency];
                            if (!resolved) {
                                cleanup();
                                reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +
                                    ` as needed by worker script.`));
                                return;
                            }
                            resolvedDependencies.push(resolved);
                        }
                        const response = {
                            type: "worker-bootstrap-response",
                            resolvedDependencies
                        };
                        worker.postMessage(response);
                        return;
                    }
                    cleanup();
                    resolve(worker);
                    // We've just consumed first message from worker before client has any chance to
                    // even call `addEventListener` on it, so here after resolve, we wait next tick and
                    // replay message so user has chance to intercept it in its own handler.
                    setTimeout(() => {
                        worker.dispatchEvent(event);
                    }, 0);
                };
                const errorCallback = (error) => {
                    cleanup();
                    // Error events do not carry any useful information on tested browsers, so we assume
                    // that any error before 'firstMessageCallback' as failed Worker initialization.
                    let message = "Error during worker initialization";
                    if (error.message) {
                        message = message + `: ${error.message}`;
                    }
                    if (typeof error.filename === "string" && typeof error.lineno === "number") {
                        message = message + ` in ${error.filename}:${error.lineno}`;
                    }
                    reject(new Error(message));
                };
                const cleanup = () => {
                    clearTimeout(timerId);
                    worker.removeEventListener("message", firstMessageCallback);
                    worker.removeEventListener("error", errorCallback);
                };
                worker.addEventListener("error", errorCallback);
                worker.addEventListener("message", firstMessageCallback);
                const timerId = setTimeout(() => {
                    cleanup();
                    reject(new Error("Timeout exceeded when waiting for first message from worker."));
                }, timeout);
            });
        }
    }
    WorkerLoader.directlyFallbackToBlobBasedLoading = false;
    WorkerLoader.sourceLoaderCache = new Map();
    WorkerLoader.dependencyUrlMapping = {};
    return WorkerLoader;
})();
exports.WorkerLoader = WorkerLoader;
//# sourceMappingURL=WorkerLoader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-materials/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Materials defining the appearance of map objects.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/CirclePointsMaterial */ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/CopyMaterial */ "./node_modules/@here/harp-materials/lib/CopyMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/DisplacementFeature */ "./node_modules/@here/harp-materials/lib/DisplacementFeature.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/EdgeMaterial */ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/GroundAtmosphereMaterial */ "./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/IconMaterial */ "./node_modules/@here/harp-materials/lib/IconMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterialsDefs */ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MSAAMaterial */ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/SepiaShader */ "./node_modules/@here/harp-materials/lib/SepiaShader.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/SkyAtmosphereMaterial */ "./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/SolidLineMaterial */ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Utils */ "./node_modules/@here/harp-materials/lib/Utils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/VignetteShader */ "./node_modules/@here/harp-materials/lib/VignetteShader.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CirclePointsMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const vertexShader = `
uniform float size;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
uniform vec3 diffuse;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
let CirclePointsMaterial = /** @class */ (() => {
    class CirclePointsMaterial extends THREE.ShaderMaterial {
        /**
         * Constructs a new `CirclePointsMaterial`.
         *
         * @param parameters - The constructor's parameters.
         */
        constructor(parameters = {}) {
            const { size, color, opacity } = parameters, shaderParams = __rest(parameters, ["size", "color", "opacity"]);
            shaderParams.name = "CirclePointsMaterial";
            shaderParams.vertexShader = vertexShader;
            shaderParams.fragmentShader = fragmentShader;
            shaderParams.uniforms = {
                size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
                diffuse: new THREE.Uniform(new THREE.Color()),
                opacity: new THREE.Uniform(1.0)
            };
            shaderParams.depthTest = false;
            shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });
            super(shaderParams);
            // Blending needs to always be enabled to support smooth edges
            Utils_1.enforceBlending(this);
            this.type = "CirclePointsMaterial";
            this.m_color = this.uniforms.diffuse.value;
            this.m_opacity = this.uniforms.opacity.value;
            if (size !== undefined) {
                this.size = size;
            }
            if (color !== undefined) {
                this.color = color;
            }
            if (opacity !== undefined) {
                this.opacity = opacity;
            }
        }
        /**
         * Gets the circle screen size.
         */
        get size() {
            return this.uniforms.size.value;
        }
        /**
         * Sets the circle screen size.
         */
        set size(size) {
            this.uniforms.size.value = size;
        }
        /**
         * Get circle opacity.
         */
        get opacity() {
            return this.m_opacity;
        }
        /**
         * Set circle opacity.
         */
        set opacity(opacity) {
            this.m_opacity = opacity;
            // Base constructor may set opacity before uniform being created.
            if (this.uniforms && this.uniforms.opacity) {
                this.uniforms.opacity.value = opacity;
            }
        }
        /**
         * Gets the diffuse.
         */
        get color() {
            return this.m_color;
        }
        /**
         * Sets the diffuse.
         */
        set color(color) {
            this.m_color.set(color);
        }
    }
    CirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;
    return CirclePointsMaterial;
})();
exports.CirclePointsMaterial = CirclePointsMaterial;
//# sourceMappingURL=CirclePointsMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CopyMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CopyMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CopyMaterial = exports.CopyShader = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * The base shader to use for {@link @here/harp-mapview#MapView}'s
 * composing passes, like {@link MSAAMaterial}.
 */
exports.CopyShader = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
/**
 * The material is used for composing.
 */
class CopyMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `CopyMaterial`.
     *
     * @param uniforms - The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            name: "CopyMaterial",
            uniforms,
            vertexShader: exports.CopyShader.vertexShader,
            fragmentShader: exports.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.CopyMaterial = CopyMaterial;
//# sourceMappingURL=CopyMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/DisplacementFeature.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/DisplacementFeature.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasDisplacementFeature = void 0;
/**
 * Determines whether a given material supports displacement maps for elevation overlay.
 * @param material - The material to check.
 * @returns Whether the given material supports displacement maps for elevation overlay.
 */
function hasDisplacementFeature(material) {
    return "displacementMap" in material;
}
exports.hasDisplacementFeature = hasDisplacementFeature;
//# sourceMappingURL=DisplacementFeature.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/EdgeMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const vertexSource = `
#define EDGE_DEPTH_OFFSET 0.0001

attribute vec4 color;

// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are
// already defined
#ifndef SHADER_NAME
attribute vec3 position;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
#endif

uniform vec3 edgeColor;
uniform float edgeColorMix;

#ifdef USE_DISPLACEMENTMAP
attribute vec3 normal;
attribute vec2 uv;
uniform sampler2D displacementMap;
#endif

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {

    #ifdef USE_COLOR
    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);
    #else
    vColor = edgeColor.rgb;
    #endif

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    #ifdef USE_DISPLACEMENTMAP
    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;
    // After projection gl_Position contains clip space coordinates of each vertex
    // before perspective division (1 / w), thus only vertexes with -w < z < w should
    // be displayed and offset. We offset only those edges which z coordinate in NDC
    // space is between: -inf < z < 1
    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;
    gl_Position.z -= depthOffset;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
let EdgeMaterial = /** @class */ (() => {
    class EdgeMaterial extends THREE.RawShaderMaterial {
        /**
         * Constructs a new `EdgeMaterial`.
         *
         * @param params - `EdgeMaterial` parameters.
         */
        constructor(params) {
            const defines = {};
            const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;
            const hasExtrusion = params !== undefined &&
                params.extrusionRatio !== undefined &&
                params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&
                params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            if (hasDisplacementMap) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            if (hasExtrusion) {
                Utils_1.setShaderDefine(defines, "USE_EXTRUSION", true);
            }
            const shaderParams = {
                name: "EdgeMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                    edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                    extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
                    displacementMap: new THREE.Uniform(hasDisplacementMap ? params.displacementMap : new THREE.Texture())
                },
                depthWrite: false,
                defines
            };
            super(shaderParams);
            Utils_1.enforceBlending(this);
            MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
            MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
            // Apply initial parameter values.
            if (params !== undefined) {
                if (params.color !== undefined) {
                    // Color may be set directly on object (omitting class setter), because we already
                    // know that is does no require any special handling nor material update
                    // (see: set color()).
                    this.color.set(params.color);
                }
                if (params.colorMix !== undefined) {
                    this.colorMix = params.colorMix;
                }
                if (params.fadeNear !== undefined) {
                    this.fadeNear = params.fadeNear;
                }
                if (params.fadeFar !== undefined) {
                    this.fadeFar = params.fadeFar;
                }
                if (params.displacementMap !== undefined) {
                    this.displacementMap = params.displacementMap;
                }
                if (params.extrusionRatio !== undefined) {
                    this.extrusionRatio = params.extrusionRatio;
                }
            }
        }
        /**
         * Edge color.
         */
        get color() {
            return this.uniforms.edgeColor.value;
        }
        set color(value) {
            this.uniforms.edgeColor.value.copy(value);
        }
        /**
         * Color mix value. Mixes between vertexColors and edgeColor.
         */
        get colorMix() {
            return this.uniforms.edgeColorMix.value;
        }
        set colorMix(value) {
            if (this.uniforms.edgeColorMix.value === value) {
                return;
            }
            this.uniforms.edgeColorMix.value = value;
            Utils_1.setShaderMaterialDefine(this, "USE_COLOR", value > 0.0);
        }
        get fadeNear() {
            return this.uniforms.fadeNear.value;
        }
        set fadeNear(value) {
            this.uniforms.fadeNear.value = value;
        }
        get fadeFar() {
            return this.uniforms.fadeFar.value;
        }
        set fadeFar(value) {
            if (this.uniforms.fadeFar.value === value) {
                return;
            }
            this.uniforms.fadeFar.value = value;
            Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
        }
        get extrusionRatio() {
            return this.uniforms.extrusionRatio.value;
        }
        set extrusionRatio(value) {
            if (this.uniforms.extrusionRatio.value === value) {
                return;
            }
            this.uniforms.extrusionRatio.value = value;
            // NOTE: We could also disable shader extrusion chunks when it hits
            // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.
            const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
            Utils_1.setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
        }
        get displacementMap() {
            return this.uniforms.displacementMap.value;
        }
        set displacementMap(map) {
            if (this.uniforms.displacementMap.value === map) {
                return;
            }
            this.uniforms.displacementMap.value = map;
            const useDisplacementMap = map !== null;
            if (useDisplacementMap) {
                this.uniforms.displacementMap.value.needsUpdate = true;
            }
            Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
        }
    }
    EdgeMaterial.DEFAULT_COLOR = 0x000000;
    EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;
    return EdgeMaterial;
})();
exports.EdgeMaterial = EdgeMaterial;
//# sourceMappingURL=EdgeMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/GroundAtmosphereMaterial.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GroundAtmosphereMaterial = exports.GroundAtmosphereShader = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const EQUATORIAL_RADIUS = 6378137.0;
/**
 * `GroundAtmosphereShader`.
 *
 * Describes shading of atmosphere as seen from outer space.
 */
exports.GroundAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),
        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),
        // Environment settings:
        // atmosphere inner and outer radius, camera height, light mode
        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector4(
        // Maximum inner radius
        EQUATORIAL_RADIUS * 1.001, 
        // Maximum outer radius
        EQUATORIAL_RADIUS * 1.025, 
        // Camera height
        0, 
        // Toggles the light modes:
        // 0 - light always directly overhead,
        // 1 - lighting uses light direction: uniform u_lightDirectionWorld
        1)),
        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),
        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),
        offset: new THREE.Uniform(33.0),
        exponent: new THREE.Uniform(0.6),
        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far
    },
    vertexShader: `

    #define IMPROVE_INTERSECT_PRECISION 1
    #define IMPROVE_DOT_PRECISION 1

    precision highp float;
    precision highp int;

    attribute vec4 position;

    // Base mandatory uniforms
    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Km = 0.0015;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 25.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        1.0 / pow(0.650, 4.0), // Red
        1.0 / pow(0.570, 4.0), // Green
        1.0 / pow(0.475, 4.0)); // Blue

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_1.default.atmosphere_common_utils}
    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for ground.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE.
    //
    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir, bool dynamicLighting)
    {
        // Retrieve environment variables
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be moved to const or define(s) at further optimizations:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

#if !defined(IMPROVE_DOT_PRECISION)
        vec3 v3Dir = normalize(v3Pos);
#endif

#ifdef CAMERA_IN_SPACE

        // Calculate first point of camera ray and sphere intersection.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection, setting it to
        // the length of ray passed through atmosphere
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;
        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);

#else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten
        // fFar -= 0.0;
        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);
#endif

#if defined(IMPROVE_DOT_PRECISION)
        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
#else
        float fCameraAngle = dot(-v3Ray, v3Dir);
#endif
        float fCameraScale = scale(fCameraAngle);

        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.
#if defined(IMPROVE_DOT_PRECISION)
        // The light angle for given light source may be calculated as:
        // angle = dot(vLightDir, v3Dir) / length(v3Dir);
        // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)
        float fLightAngle = conditionalBranchFree(dynamicLighting, dot(vLightDir, v3Pos) / length(v3Pos), 1.0);
#else
        float fLightAngle = conditionalBranchFree(dynamicLighting, dot(vLightDir, v3Dir), 1.0);
#endif
        float fLightScale = scale(fLightAngle);

        float fCameraOffset = fDepth * fCameraScale;
        float fTemp = (fLightScale + fCameraScale);

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i = 0; i < nSamples; i++)
        {
            float fHeight = length(v3SamplePoint);
            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
            float fScatter = fDepth * fTemp - fCameraOffset;
            // Compute color factors
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);
            // Move to the next point
            v3SamplePoint += v3SampleRay;
        }

        AtmosphereColor color;
        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);
        // Calculate the attenuation factor for the ground
        color.rayleigh = v3Attenuate;

        return color;
    }

    void main(void)
    {
        float fLightMode = u_atmosphereEnv.w;
        bool bDynamicLight = fLightMode != 0.0;

        vec3 vLightDir = conditionalBranchFree(bDynamicLight,
            u_lightDirectionWorld,
            u_eyePositionWorld);
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir, bDynamicLight);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;
        v_vertToOrigin = normalize(position.xyz);

        gl_Position = u_modelViewProjection * position;
    }
    `,
    fragmentShader: `

    // Exposure correction gives more subtle gradients on the ground.
    #define CORRECT_EXPOSURE 1
    #define FADE_DEPTH 1
    #define NIGHT_LOCAL 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_1.default.atmosphere_common_utils}
    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;
        float fLightMode = u_atmosphereEnv.w;
        bool bDynamicLight = fLightMode != 0.0;

        vec3 vLightDir = conditionalBranchFree(bDynamicLight,
            u_lightDirectionWorld,
            u_eyePositionWorld);
        vLightDir = normalize(vLightDir);

        // GPU gems mix of ground solution, with custom alpha settings
        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;

        // Not needed for HDR frame buffer
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Interesting results with exposure factor: 2.0, 3.5, 4.0
        cRgb = correctExposure(cRgb, 3.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Base atmosphere opacity
        float fAtmosphereAlpha = 1.0;

        // Factor based on the distance of camera atmosphere and ground, results are:
        // 0.0 = camera on the ground surface,
        // 1.0 = at the outer edge of the atmosphere.
        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);
    #ifdef FADE_DEPTH
        // Fade alpha based on the distance of camera between atmosphere layers
        #ifdef FADE_DEPTH_LINEAR
            fAtmosphereAlpha *= fDepthFactor;
        #else
            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);
        #endif
    #endif

#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)
        // Adjust factor based on time of day, results are:
        // 0.0 = night,
        // 1.0 = day.
    #ifdef NIGHT_GLOBAL
        // Global night fade based on camera and light orientation
        float fNightFactor = conditionalBranchFree(bDynamicLight,
            clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0),
             1.0);
        fNightFactor = pow(fNightFactor, 0.5);
    #else // NIGHT_LOCAL
        float fNightFactor = conditionalBranchFree(bDynamicLight,
            clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0),
            1.0);
        fNightFactor = pow(fNightFactor, 0.8);
    #endif
#endif

    #ifdef FADE_NIGHT
        // Adjust alpha for night side of the globe
        fAtmosphereAlpha *= fNightFactor;
    #endif

    #ifdef DARKEN_NIGHT
        // Change the brightness depending on night / day side.
        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,
        // but it is much more GPU consuming.
        const float minBrightness = 0.5;
        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);
        cRgb *= fDarkenFactor;
    #endif

    #ifdef EXPOSURE_DEPTH
        // Control exposure depending from ground distance
        float exposureBoost = 3.0 - fDepthFactor;
        cRgb = correctExposure(cRgb, exposureBoost);
    #endif

        // Experimental fading out of focus point - similar to fresnel effect in top view.
        // This fade is handy to better expose cartographic/map features in screen center.
        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;
        fFocusFactor = pow(fFocusFactor, 2.5);
        fAtmosphereAlpha *= fFocusFactor;

        // Integrate all features
        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);
    }
    `
};
class GroundAtmosphereMaterial extends THREE.RawShaderMaterial {
    constructor(params) {
        const defines = {};
        defines.CAMERA_IN_SPACE = "";
        const shaderParams = {
            name: "GroundAtmosphereMaterial",
            vertexShader: exports.GroundAtmosphereShader.vertexShader,
            fragmentShader: exports.GroundAtmosphereShader.fragmentShader,
            uniforms: exports.GroundAtmosphereShader.uniforms,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.FrontSide,
            blending: THREE.NormalBlending,
            fog: false
        };
        super(shaderParams);
    }
    setDynamicLighting(enableLighting) {
        this.uniforms.u_atmosphereEnv.value.w = enableLighting ? 1.0 : 0.0;
    }
    /**
     * Set maximum outer radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025
     */
    set outerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.y = radius;
    }
    get outerRadius() {
        return this.uniforms.u_atmosphereEnv.value.y;
    }
    /**
     * Set maximum inner radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.001.
     */
    set innerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.x = radius;
    }
    get innerRadius() {
        return this.uniforms.u_atmosphereEnv.value.x;
    }
    /**
     * Updates the uniform data of a material used to render an atmosphere.
     *
     * This includes only uniforms that may change frame by frame, other uniforms are
     * accessed with convenient material setters and getters.
     *
     * @param shaderMaterial - Material which uniforms will be updated.
     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.
     * @param lightDirection - The light directional vector in world space.
     * @param camera - Camera used in rendering.
     */
    updateUniforms(shaderMaterial, object, camera, lightDirection) {
        const cameraInfo = this.getCameraInfo(object, camera);
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_atmosphereEnv &&
                shaderMaterial.uniforms.u_hsvCorrection &&
                shaderMaterial.uniforms.u_eyePositionWorld &&
                shaderMaterial.uniforms.u_modelViewProjection &&
                shaderMaterial.uniforms.u_lightDirectionWorld) {
                const eyePos = cameraInfo.eyePos;
                const mvp = cameraInfo.modelViewProjection;
                const cameraHeight = cameraInfo.eyeHeight;
                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                const cameraInSpace = cameraHeight > this.outerRadius;
                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                shaderMaterial.needsUpdate = needsUpdate0 || needsUpdate1;
            }
            else {
                throw Error("Atmosphere material has missing uniforms");
            }
        }
        else {
            throw Error("Wrong object used, only Material objects are supported");
        }
    }
    /*
     * Calculate camera position used in vertex shader of atmosphere materials.
     *
     * @param object -
     * @param camera - Camera used to get the eye position.
     */
    getCameraInfo(object, camera, reverse = false) {
        if (reverse) {
            const modelMatrix = new THREE.Matrix4().identity();
            const viewMatrix = new THREE.Matrix4().getInverse(object.matrixWorld).transpose();
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            object.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            camera.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
        else {
            const modelMatrix = object.matrixWorld;
            const viewMatrix = camera.matrixWorldInverse;
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            camera.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            object.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            // Normally we would return simply camera position, but since camera is not moving in
            // the globe view only the world, we need to calculate eye relative to object position.
            eyePos.sub(objectPos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
    }
}
exports.GroundAtmosphereMaterial = GroundAtmosphereMaterial;
//# sourceMappingURL=GroundAtmosphereMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHighPrecisionLineMaterial = exports.HighPrecisionLineMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const vertexSource = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuse * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuse, opacity );
    #endif
}`;
/**
 * Material designed to render high precision lines (ideal for position-sensible data).
 */
let HighPrecisionLineMaterial = /** @class */ (() => {
    class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {
        /**
         * Constructs a new `HighPrecisionLineMaterial`.
         *
         * @param params - `HighPrecisionLineMaterial` parameters.
         */
        constructor(params) {
            Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
            const shaderParams = {
                name: "HighPrecisionLineMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),
                    opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),
                    u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                    u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                    u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
                }
            };
            Object.assign(shaderParams, params);
            super(shaderParams);
            this.type = "HighPrecisionLineMaterial";
            this.isHighPrecisionLineMaterial = true;
            // Apply initial parameter values.
            if (params !== undefined) {
                if (params.color !== undefined) {
                    this.color.set(params.color);
                }
                if (params.opacity !== undefined) {
                    this.opacity = params.opacity;
                }
            }
            this.updateTransparencyFeature();
        }
        /**
         * Line color.
         */
        get color() {
            return this.uniforms.diffuse.value;
        }
        set color(value) {
            this.uniforms.diffuse.value.copy(value);
        }
        updateTransparencyFeature() {
            this.transparent = this.opacity < 1.0 ? true : false;
        }
    }
    HighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;
    HighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;
    return HighPrecisionLineMaterial;
})();
exports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;
function isHighPrecisionLineMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionLineMaterial === true);
}
exports.isHighPrecisionLineMaterial = isHighPrecisionLineMaterial;
//# sourceMappingURL=HighPrecisionLineMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHighPrecisionPointMaterial = exports.HighPrecisionPointMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const vertexSource = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
/**
 * Material designed to render high precision points (ideal for position-sensible data).
 */
let HighPrecisionPointMaterial = /** @class */ (() => {
    class HighPrecisionPointMaterial extends THREE.PointsMaterial {
        /**
         * Constructs a new `HighPrecisionPointMaterial`.
         *
         * @param params - `HighPrecisionPointMaterial` parameters.
         */
        constructor(params) {
            Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
            const shaderParams = params;
            super(shaderParams);
            this.type = "HighPrecisionPointMaterial";
            this.vertexShader = vertexSource;
            this.fragmentShader = THREE.ShaderChunk.points_frag;
            this.fog = false;
            this.uniforms = {
                diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),
                opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),
                size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),
                scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),
                map: new THREE.Uniform(new THREE.Texture()),
                uvTransform: new THREE.Uniform(new THREE.Matrix3()),
                u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
            };
            this.isHighPrecisionPointMaterial = true;
            // Apply initial parameter values.
            if (params !== undefined) {
                if (params.color !== undefined) {
                    this.color.set(params.color);
                }
                if (params.opacity !== undefined) {
                    this.opacity = params.opacity;
                }
                if (params.size !== undefined) {
                    this.size = params.size;
                }
                if (params.scale !== undefined) {
                    this.scale = params.scale;
                }
                if (params.uvTransform !== undefined) {
                    this.uvTransform = params.uvTransform;
                }
                if (params.map !== undefined) {
                    this.map = params.map;
                }
            }
        }
        /**
         *  Point scale.
         */
        get scale() {
            return this.uniforms.scale.value;
        }
        set scale(value) {
            this.uniforms.scale.value = value;
        }
        /**
         * UV transformation matrix.
         */
        get uvTransform() {
            return this.uniforms.uvTransform.value;
        }
        set uvTransform(value) {
            this.uniforms.uvTransform.value = value;
        }
    }
    HighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;
    HighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;
    HighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;
    HighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;
    return HighPrecisionPointMaterial;
})();
exports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;
function isHighPrecisionPointMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionPointMaterial === true);
}
exports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;
//# sourceMappingURL=HighPrecisionPointMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/IconMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/IconMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IconMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const vertexSource = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
/**
 * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to
 * apply opacity.
 */
class IconMaterial extends THREE.RawShaderMaterial {
    /**
     * Constructs a new `IconMaterial`.
     *
     * @param params - `IconMaterial` parameters.
     */
    constructor(params) {
        // tslint:disable-next-line: deprecation
        const shaderParams = {
            name: "IconMaterial",
            vertexShader: vertexSource,
            fragmentShader: fragmentSource,
            uniforms: {
                map: new THREE.Uniform(params.map)
            },
            depthTest: true,
            depthWrite: false,
            transparent: true,
            vertexColors: true,
            premultipliedAlpha: true,
            blending: THREE.NormalBlending
        };
        super(shaderParams);
    }
    /**
     * Icon texture map/atlas.
     */
    get map() {
        return this.uniforms.map.value;
    }
}
exports.IconMaterial = IconMaterial;
//# sourceMappingURL=IconMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LuminosityHighPassShader = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.
 */
exports.LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1.0 },
        smoothWidth: { value: 1.0 },
        defaultColor: { value: new THREE.Color(0x000000) },
        defaultOpacity: { value: 0.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};
//# sourceMappingURL=LuminosityHighPassShader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MSAAMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MSAAMaterial = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ "./node_modules/@here/harp-materials/lib/CopyMaterial.js");
/**
 * The material to use for the quad of the {@link @here/harp-mapview#MSAARenderPass}
 * in the composing.
 */
class MSAAMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `MSAAMaterial`.
     *
     * @param uniforms - The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            uniforms,
            vertexShader: CopyMaterial_1.CopyShader.vertexShader,
            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.MSAAMaterial = MSAAMaterial;
//# sourceMappingURL=MSAAMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterials.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapMeshStandardMaterial = exports.MapMeshDepthMaterial = exports.MapMeshBasicMaterial = exports.ExtrusionFeatureMixin = exports.ExtrusionFeature = exports.FadingFeatureMixin = exports.FadingFeature = exports.DisplacementFeatureMixin = exports.hasExtrusionFeature = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js");
const ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js");
const FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js");
const ShadowChunks_1 = __webpack_require__(/*! ./ShaderChunks/ShadowChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js");
const emptyTexture = new THREE.Texture();
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..maxVisibilityRange].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance - Distance from the camera (range: [0, 1]).
 * @param visibilityRange - object describing maximum and minimum visibility range - distances
 * from camera at which objects won't be rendered anymore.
 */
function cameraToWorldDistance(distance, visibilityRange) {
    return distance * visibilityRange.maximum;
}
/**
 * Provides common interface from mixin to internal material defines and shader uniforms.
 *
 * Call this function just after [THREE.Material] is constructed, so in derived classes after
 * super c-tor call.
 * @param mixin - The mixin that will add features to [[THREE.Material]].
 * @param material - The material that mixin feature is being applied.
 */
function linkMixinWithMaterial(mixin, material) {
    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.
    // In such case create it manually, such defines will be also injected to the shader
    // via generic THREE.js code - see THREE/WebGLProgram.js.
    if (material.defines === undefined) {
        material.defines = {};
    }
    // Link internal THREE.js material defines with mixin reference.
    // Those defines are usually created in Material c-tor, if not we have fallback above.
    mixin.shaderDefines = material.defines;
    // Prepare map for holding uniforms references from the actual shader, but check if
    // it was not already created with other mixin feature.
    if (mixin.shaderUniforms === undefined) {
        mixin.shaderUniforms = {};
    }
    // Shader uniforms may not be linked at this stage, they are injected available via Shader
    // object in onBeforeCompile callback, see: linkMixinWithShader().
}
/**
 * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.
 *
 * Function injects features (mixin) specific shader uniforms to material's shader, it also
 * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full
 * uniforms map (both feature specific and internal ones).
 * This function should be called before material's shader is pre-compiled, so the new uniforms
 * from the mixin feature are known to shader processor. The best place to use is
 * [[Material.onBeforeCompile]].
 * @param mixin - The mixin feature being applied to the material.
 * @param shader - The actual shader linked to the [[THREE.Material]].
 */
function linkMixinWithShader(mixin, shader) {
    Object.assign(shader.uniforms, mixin.shaderUniforms);
    mixin.shaderUniforms = shader.uniforms;
}
/**
 * Determines whether a given material supports extrusion.
 * @param material The material to check.
 * @returns Whether the given material supports extrusion.
 */
function hasExtrusionFeature(material) {
    return "extrusionRatio" in material;
}
exports.hasExtrusionFeature = hasExtrusionFeature;
var DisplacementFeature;
(function (DisplacementFeature) {
    /**
     * Checks if feature is enabled (displacement map defined).
     *
     * @param displacementMaterial -
     */
    function isEnabled(displacementMaterial) {
        return displacementMaterial.displacementMap !== null;
    }
    DisplacementFeature.isEnabled = isEnabled;
    /**
     * Update the internals of the `DisplacementFeature` depending on the value of
     * [[displacementMap]].
     *
     * @param displacementMaterial - DisplacementFeature
     */
    function updateDisplacementFeature(displacementMaterial) {
        harp_utils_1.assert(displacementMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        const useDisplacementMap = isEnabled(displacementMaterial);
        // Whenever displacement feature state changes (between enabled/disabled) material will be
        // re-compiled, forcing new shader chunks to be added (or removed).
        const needsUpdate = Utils_1.setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
        displacementMaterial.needsUpdate = needsUpdate;
        // Update texture after change.
        if (useDisplacementMap) {
            const texture = displacementMaterial.displacementMap;
            texture.needsUpdate = true;
            displacementMaterial.shaderUniforms.displacementMap.value = texture;
        }
        else if (needsUpdate) {
            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
        }
    }
    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;
    /**
     * This function should be called on implementors of DisplacementFeature in the
     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to
     * apply displacement maps.
     *
     * @param displacementMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(displacementMaterial, shader) {
        if (!isEnabled(displacementMaterial)) {
            return;
        }
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are required for this material, we use one define working as a flag,
        // which enables/disables some chunks of shader code.
        linkMixinWithShader(displacementMaterial, shader);
        // Append the displacement map chunk to the vertex shader.
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    }
    DisplacementFeature.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
class DisplacementFeatureMixin {
    constructor() {
        this.m_displacementMap = null;
    }
    // This is here to keep tslint from reporting a missing property, the getter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    get displacementMap() {
        return this.m_displacementMap;
    }
    // This is here to keep tslint from reporting a missing property, the setter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    set displacementMap(map) {
        this.setDisplacementMap(map);
    }
    getDisplacementMap() {
        return this.m_displacementMap;
    }
    setDisplacementMap(map) {
        if (map !== this.m_displacementMap) {
            this.m_displacementMap = map;
            DisplacementFeature.updateDisplacementFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[displacementMap]]
     */
    addDisplacementProperties() {
        Object.defineProperty(this, "displacementMap", {
            get: () => {
                return this.getDisplacementMap();
            },
            set: val => {
                this.setDisplacementMap(val);
            }
        });
    }
    /**
     * Apply the displacementMap value from the parameters to the respective properties.
     */
    applyDisplacementParameters(params) {
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        const uniforms = this.shaderUniforms;
        uniforms.displacementMap = new THREE.Uniform(emptyTexture);
        uniforms.displacementScale = new THREE.Uniform(1);
        uniforms.displacementBias = new THREE.Uniform(0);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.displacementMap !== undefined) {
                this.setDisplacementMap(params.displacementMap);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            DisplacementFeature.onBeforeCompile(this, shader);
        });
        // Require material update at least once, because of new shader chunks added.
        this.needsUpdate = DisplacementFeature.isEnabled(this);
    }
    /**
     * Copy displacementMap from other DisplacementFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyDisplacementParameters(source) {
        this.setDisplacementMap(source.displacementMap);
        return this;
    }
}
exports.DisplacementFeatureMixin = DisplacementFeatureMixin;
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Checks if feature is enabled based on feature params.
     *
     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.
     * This function is crucial for shader switching (chunks injection), whenever feature state
     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)
     * whenever fading params are reasonable, even if it causes full fade in, no transparency.
     *
     * @param fadingMaterial - FadingFeature.
     */
    function isEnabled(fadingMaterial) {
        // NOTE: We could also check if full fade is not achieved, then feature could be
        // disabled, but causing material re-compile.
        return (fadingMaterial.fadeNear !== undefined &&
            fadingMaterial.fadeFar !== undefined &&
            fadingMaterial.fadeFar > 0);
    }
    FadingFeature.isEnabled = isEnabled;
    /**
     * Checks if feature is defined based on feature params.
     *
     * Fading feature will be defined if fadeNear and fadeFar are defined, their values
     * are not checked for reasonable values.
     *
     * @param fadingMaterial FadingFeature.
     */
    function isDefined(fadingMaterial) {
        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;
    }
    FadingFeature.isDefined = isDefined;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial - FadingFeature
     */
    function updateFadingFeature(fadingMaterial) {
        harp_utils_1.assert(fadingMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // Update entire material to add/remove shader fading chunks, this happens when we
        // enable/disable fading after material creation. Feature is marked via dummy define, which
        // informs about fading feature state, even if such define is not required to control
        // feature state, it makes it easy to check for shader changes.
        const useFading = isEnabled(fadingMaterial);
        const needsUpdate = Utils_1.setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
        // Enable/disable entire feature with material re-compile, this will also cause
        // new uniforms injection.
        fadingMaterial.needsUpdate = needsUpdate;
        // Check if shader uniforms references are already set in onBeforeCompile callback.
        harp_utils_1.assert(fadingMaterial.shaderUniforms.fadeNear !== undefined &&
            fadingMaterial.shaderUniforms.fadeFar !== undefined);
        // Update shader internal uniforms only if fading is enabled.
        if (useFading) {
            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
            if (needsUpdate) {
                Utils_1.enableBlending(fadingMaterial);
            }
        }
        // Perform one time update of uniforms to defaults when feature disabled (for clarity).
        else if (needsUpdate) {
            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;
            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;
            Utils_1.disableBlending(fadingMaterial);
        }
    }
    FadingFeature.updateFadingFeature = updateFadingFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (!isEnabled(fadingMaterial)) {
            return;
        }
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not required for this material, so the fading shader chunks
        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature
        // attached and easy control its state, but this define may be stripped out if needed.
        linkMixinWithShader(fadingMaterial, shader);
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As three.js is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object - [[THREE.Object3D]] to prepare for rendering.
     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for
     * actual camera setup.
     * @param fadeNear - The fadeNear value to set in the material.
     * @param fadeFar - The fadeFar value to set in the material.
     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback - If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
        // tslint:disable-next-line:no-unused-variable
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, viewRanges);
            fadingMaterial.fadeFar =
                fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, viewRanges);
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        const needsUpdate = value !== this.m_fadeNear;
        if (needsUpdate) {
            this.m_fadeNear = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        const needsUpdate = value !== this.m_fadeFar;
        if (needsUpdate) {
            this.m_fadeFar = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        this.shaderUniforms.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
        this.shaderUniforms.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        });
        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.
        this.needsUpdate = FadingFeature.isEnabled(this);
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.
     *
     * @param extrusionMaterial -
     */
    function isEnabled(extrusionMaterial) {
        return (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN);
    }
    ExtrusionFeature.isEnabled = isEnabled;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial - ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        harp_utils_1.assert(extrusionMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // Setup shader define that when changed will force material re-compile.
        const useExtrusion = isEnabled(extrusionMaterial);
        // Use shader define as marker if feature is enabled/disabled, this is not necessary
        // required, but material requires update (re-compile) anyway to add/remove shader chunks.
        const needsUpdate = Utils_1.setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
        // Enable/disable entire feature with material re-compile.
        extrusionMaterial.needsUpdate = needsUpdate;
        // Update uniform with new value
        if (useExtrusion) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio;
        }
        // Reset uniform to default, one time only, when feature is disabled (just for clarity).
        else if (needsUpdate) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (!isEnabled(extrusionMaterial)) {
            return;
        }
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them. No defines are required to preprocess
        // shader chunks, but we utilize one just to note the feature is enabled/disabled
        // (easier debugging), this define may be easily stripped out or replaced with simple
        // boolean flag.
        linkMixinWithShader(extrusionMaterial, shader);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 *
 * @remarks
 * There is some special handling for the extrusionRatio property, which is animated via
 * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is
 * using [[extrusionRatio]] setter and getter to update
 * extrusion in a way that works well with the mixin and EdgeMaterial.
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        const needsUpdate = value !== this.m_extrusion;
        if (needsUpdate) {
            this.m_extrusion = value;
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        if (params && params.zFightingWorkaround === true) {
            this.shaderDefines.ZFIGHTING_WORKAROUND = "";
        }
        // Create uniform with default value, this ensures that it is always created,
        // so no need for checks in setters.
        this.shaderUniforms.extrusionRatio = new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        });
        this.needsUpdate = ExtrusionFeature.isEnabled(this);
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        if (source.extrusionRatio !== undefined) {
            this.setExtrusionRatio(source.extrusionRatio);
        }
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        this.addDisplacementProperties();
        this.applyDisplacementParameters(params);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        this.copyDisplacementParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    get displacementMap() {
        return null;
    }
    // tslint:disable-next-line:no-unused-variable
    set displacementMap(value) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    setDisplacementMap(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
    addDisplacementProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyDisplacementParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyDisplacementParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
class MapMeshDepthMaterial extends THREE.MeshDepthMaterial {
    constructor(params) {
        super(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        // We need to set these to false, because otherwise three.js complains that there are
        // outputs of the vertex shader not used in the pixel shader, the properties in question
        // are `vExtrusionRatio` and `vExtrusionAxis`.
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: false }));
        this.flatShading = false;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in{@link ExtrusionFeatureMixin}, see below:
    //
    // applyMixinsWithoutProperties(...);
    //
    // Mixin declarations start ---------------------------------------------------------
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshDepthMaterial = MapMeshDepthMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params - `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        if ((params === null || params === void 0 ? void 0 : params.removeDiffuseLight) === true) {
            this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, shader => {
                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace("#include <lights_physical_pars_fragment>", ShadowChunks_1.simpleLightingShadowChunk);
            });
        }
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    // tslint:disable-next-line: explicit-override
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    /** @override */
    get displacementMap() {
        return super.displacementMap === undefined ? null : super.displacementMap;
    }
    /** @override */
    set displacementMap(map) {
        if (map === this.displacementMap) {
            return;
        }
        if (!map || !this.displacementMap) {
            this.needsUpdate = true;
        }
        if (map) {
            map.needsUpdate = true;
        }
        super.displacementMap = map;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    // tslint:disable-next-line:no-unused-variable
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    // tslint:disable-next-line:no-unused-variable
    set extrusionRatio(value) {
        // to be overridden
    }
    /**
     * This is needed to simplify the lighting calculation, currently there is no support for
     * switching this at runtime. It is required here to be a property because the parameters
     * are applied to this material, and if this isn't here, three.js will complain that the
     * property is missing.
     * @internal
     */
    get removeDiffuseLight() {
        return false;
    }
    /** @internal */
    set removeDiffuseLight(val) {
        // Stays empty.
    }
    addFadingProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyFadingParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    applyExtrusionParameters(params) {
        // to be overridden
    }
    // tslint:disable-next-line:no-unused-variable
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);
//# sourceMappingURL=MapMeshMaterials.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtrusionFeatureDefs = void 0;
var ExtrusionFeatureDefs;
(function (ExtrusionFeatureDefs) {
    /**
     * Minimum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;
    /**
     * Maximum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;
    /**
     * Buildings height used whenever no height-data is present or height is very small.
     *
     * Used to avoid z-fighting between ground plane and building.
     */
    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.01;
})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));
//# sourceMappingURL=MapMeshMaterialsDefs.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SepiaShader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SepiaShader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SepiaShader = void 0;
/**
 * `SepiaShader`.
 */
exports.SepiaShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};
//# sourceMappingURL=SepiaShader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    atmosphere_common_utils: `

    float conditionalBranchFree(bool condition, float primary, float secondary) {
        // Interpolate between primary and secondary:
        // result = secondary * (1 - factor) + primary * factor
        // where:
        // factor = float(condition)
        return mix(secondary, primary, float(condition));
    }

    vec3 conditionalBranchFree(bool condition, vec3 primary, vec3 secondary) {
        return mix(secondary, primary, float(condition));
    }
    `,
    atmosphere_vertex_utils: `

    const float RayleighScaleDepth = 0.25;

    struct AtmosphereColor
    {
        vec3 mie;
        vec3 rayleigh;
    };

    float scale(float cosAngle)
    {
        float x = 1.0 - cosAngle;
        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
    }

    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x0 (first point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),
        // we change the equation that gives better results especially around the poles.
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Intersection points distances are defined as follows:
        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a
        // we search for x0:
        return 0.5 * (-fB - sqrt(fDet));
    }

    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x1 (second point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Compute second intersection distance:
        // x1 = (-b + sqrt(det)) / 2*a
        return 0.5 * (-fB + sqrt(fDet));
    }
    `,
    atmosphere_fragment_utils: `

    // Branch free RGB to HSV conversion.
    // Based on article:
    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
    // and optimized OpenGL SL algorithm
    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
    vec3 rgb2Hsv(vec3 c)
    {
        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        // Ternary operator may be used explicitly if compiler can use fast conditional move.
        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);
        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));
        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    // Branch free HSV to RGB conversion
    vec3 hsv2Rgb(vec3 c)
    {
        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);
        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);
    }

    vec3 correctExposure(vec3 rgb, float exposure)
    {
        const vec3 fullColor = vec3(1.0);
        return fullColor - exp(-exposure * rgb);
    }

    vec3 correctColor(vec3 rgb, vec3 hsvShift)
    {
        const float e = 0.0000001;
        // Convert rgb color to hsv
        vec3 hsv = rgb2Hsv(rgb);
        // Shift hue value with angle wrapping
        hsv.x = mod(hsv.x + hsvShift.x, 1.0);
        // Shift and clamp saturation
        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);
        // Change value if it is significant (greater then epsilon)
        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;
        // Convert shifted hsv back to rgb
        return hsv2Rgb(hsv);
    }
    `
};
//# sourceMappingURL=AtmosphereChunks.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ../MapMeshMaterialsDefs */ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js");
const MIN_BUILDING_HEIGHT_SQUARED = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;
exports.default = {
    extrusion_pars_vertex: `
// Add define so we can check for it in the outline effect (see Outline.ts).
#define HAS_EXTRUSION_PARS_VERTEX
// Extrusion axis (xyz: vector, w: factor).
attribute vec4 extrusionAxis;
uniform float extrusionRatio;
#ifdef FLAT_SHADED
varying vec4 vExtrusionAxis;
#endif
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#endif
`,
    extrusion_vertex: `
#define HAS_EXTRUSION_VERTEX
#ifdef ZFIGHTING_WORKAROUND
// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.
const float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};
float extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);
vExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;
#else
float vExtrusionRatio = extrusionRatio;
#endif
transformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);
#ifdef FLAT_SHADED
vExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);
#endif
`,
    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded
    // geometries, computes the normal either with the extrusion axis or fragment derivatives based
    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).
    extrusion_normal_fragment_begin: `
#ifdef FLAT_SHADED
    // Flattened this divergent path to prevent undefined behaviour in the following derivatives
    // functions. For more info:
    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches

    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...
    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));
    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));
    vec3 normal = cross( fdx, fdy );
    if (vExtrusionAxis.w > 0.999999) {
        normal = vExtrusionAxis.xyz;
    }
    normal = normalize(normal);
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);
			bitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);
		#endif
	#endif
#endif
// non perturbed normal for clearcoat among others
vec3 geometryNormal = normal;
`,
    extrusion_pars_fragment: `
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#else
uniform float extrusionRatio;
#endif
varying vec4 vExtrusionAxis;
`,
    extrusion_fragment: `
#ifndef ZFIGHTING_WORKAROUND
float vExtrusionRatio = extrusionRatio;
#endif
gl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );
`
};
//# sourceMappingURL=ExtrusionChunks.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The shader chunks have their lines "#ifdef USE_FADING" commented out, because currently the
 * mesh materials use individually created shader strings based on the materials settings.
 * @see [[FadingMeshBasicMaterial]]
 **/
exports.default = {
    fading_pars_vertex: `
varying float fadingDepth;
`,
    fading_vertex: `
fadingDepth = -mvPosition.z;
`,
    fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
    fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};
//# sourceMappingURL=FadingChunks.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineCapsModes = void 0;
/**
 * Lists supported line caps types/modes.
 */
var LineCapsModes;
(function (LineCapsModes) {
    LineCapsModes[LineCapsModes["CAPS_NONE"] = 0] = "CAPS_NONE";
    LineCapsModes[LineCapsModes["CAPS_SQUARE"] = 1] = "CAPS_SQUARE";
    LineCapsModes[LineCapsModes["CAPS_ROUND"] = 2] = "CAPS_ROUND";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_IN"] = 3] = "CAPS_TRIANGLE_IN";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_OUT"] = 4] = "CAPS_TRIANGLE_OUT";
})(LineCapsModes = exports.LineCapsModes || (exports.LineCapsModes = {}));
exports.default = {
    extrude_line_vert_func: `
vec3 extrudeLine(
        in vec3 vertexPosition,
        in float linePosition,
        in float extrusionWidth,
        in vec4 bitangent,
        in vec3 tangent,
        in float tanHalfAngle,
        inout vec2 uv
    ) {
    vec3 result = vertexPosition;
    // Retrieve the angle between this segment and the previous one (stored in the bitangent w
    // component).
    float angle = bitangent.w;
    // Extrude according to the angle between segments to properly render narrow joints...
    if (angle != 0.0) {
        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);
        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;
    }
    // ... or extrude in a simple manner for segments that keep the same direction.
    else {
        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;
        uv.x = linePosition + uv.x * extrusionWidth;
    }
    uv.y *= extrusionWidth;
    return result;
}
`,
    round_edges_and_add_caps: `
#define CAPS_NONE ${LineCapsModes.CAPS_NONE}
#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}
#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}
#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}
#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}

float roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {
    // Compute the line's width to length ratio.
    float widthRatio = range.y / range.x;

    // Compute the inner segment distance (same for all cap mode).
    float dist = abs(coords.y);
    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);
    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);
    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));
    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));

    #if CAPS_MODE != CAPS_ROUND
    // Compute the caps mask.
    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);
    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);
    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);
    float capMask = capRangeMask * max(beginCapMask, endCapMask);

    // Compute the outer segment distance (specific for each cap mode).
    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;
    #if CAPS_MODE == CAPS_NONE
    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);
    #elif CAPS_MODE == CAPS_SQUARE
    dist = mix(dist, max(abs(coords.y), capDist), capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_OUT
    dist = mix(dist, abs(coords.y) + capDist, capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_IN
    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);
    #endif
    #endif // CAPS_MODE != CAPS_ROUND

    return dist;
}
`,
    tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
    high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};
//# sourceMappingURL=LinesChunks.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ShadowChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleLightingShadowChunk = void 0;
/**
 * This shader chunk replaces the default lighting in the standard material, the problem with this
 * is that the final pixel color is the addition of the material color and the light, this means
 * that the final map's rendered color is vastly different from that configured by the designers.
 * This chunk removes the extra highlight by providing just two colors, the material color when not
 * in shadow and a reduced color value when in shadow (currently 50% of the material's color).
 */
exports.simpleLightingShadowChunk = `
    struct PhysicalMaterial {
        vec3	diffuseColor;
        float	specularRoughness;
        vec3	specularColor;
    };

    #define DEFAULT_SPECULAR_COEFFICIENT 0.04

    void RE_Direct_Physical( const in IncidentLight directLight,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
        // directLight.color is the light color * shadow, internally three.js uses a step function, so
        // this value is either the light color or black. in order to lighten up the shadows, we
        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to
        // the material's diffuse color.
        #if defined(USE_SHADOWMAP)
            reflectedLight.directDiffuse = (0.5 * directLight.color +
                vec3(0.5,0.5,0.5)) * material.diffuseColor;
        #else
            reflectedLight.directDiffuse = material.diffuseColor;
        #endif
    }

    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)
    }

    void RE_IndirectSpecular_Physical( const in vec3 radiance,
        const in vec3 irradiance,
        const in vec3 clearcoatRadiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight) {
            // Disable specular reflection of light.
    }

    #define RE_Direct               RE_Direct_Physical
    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical
    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical
`;
//# sourceMappingURL=ShadowChunks.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SkyAtmosphereMaterial.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyAtmosphereMaterial = exports.SkyAtmosphereShader = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const EQUATORIAL_RADIUS = 6378137.0;
/**
 * `SkyAtmosphereShader`.
 *
 * Describes shading of atmosphere as seen from outer space.
 */
exports.SkyAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),
        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),
        // Environment settings:
        // atmosphere inner and outer radius, camera height, light mode
        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector4(
        // Maximum inner radius
        EQUATORIAL_RADIUS, 
        // Maximum outer radius
        EQUATORIAL_RADIUS * 1.025, 
        // Camera height
        0, 
        // Toggles the light modes:
        // 0 - light always directly overhead,
        // 1 - lighting uses light direction: uniform u_lightDirectionWorld
        1)),
        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),
        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),
        offset: new THREE.Uniform(33.0),
        exponent: new THREE.Uniform(0.6),
        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far
    },
    vertexShader: `
    precision highp float;
    precision highp int;

    attribute vec4 position;

    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km = 0.0015;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 15.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)
        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)
        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_1.default.atmosphere_common_utils}
    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for sky.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE
    //
    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir, bool dynamicLighting)
    {
        // Unpack attributes
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be const or define(s) at further optimization:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

    #ifdef CAMERA_IN_SPACE

        // Calculate the closest intersection of the ray with the outer
        // atmosphere, this is the first point of the ray passing through the atmosphere dome.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;

        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;
        float fStartDepth = exp(-1.0 / RayleighScaleDepth );
        float fStartOffset = fStartDepth * scale(fStartAngle);

    #else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        float height = length(v3Start);
        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));
        float fStartAngle = dot(v3Ray, v3Start) / height;
        float fStartOffset = depth * scale(fStartAngle);

    #endif

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i=0; i < nSamples; i++)
        {
            float height = length(v3SamplePoint);
            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));
            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;
            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;
            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (depth * fScaledLength);
            v3SamplePoint += v3SampleRay;
        }

        // Scale the Mie and Rayleigh colors and set up output of the function
        AtmosphereColor color;
        color.mie = v3BaseColor * KmESun;
        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);
        return color;
    }

    void main(void)
    {
        float fLightMode = u_atmosphereEnv.w;
        bool bDynamicLight = fLightMode != 0.0;

        vec3 vLightDir = conditionalBranchFree(bDynamicLight,
            u_lightDirectionWorld,
            u_eyePositionWorld);
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir, bDynamicLight);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;

        gl_Position = u_modelViewProjection * position;
    }
    `,
    fragmentShader: `
    // Because of harsh light distribution the exposure correction is always enabled for the sky.
    #define CORRECT_EXPOSURE 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_1.default.atmosphere_common_utils}
    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;
        float fLightMode = u_atmosphereEnv.w;
        bool bDynamicLight = fLightMode != 0.0;

        vec3 vLightDir = conditionalBranchFree(bDynamicLight,
            u_lightDirectionWorld,
            u_eyePositionWorld);
        vLightDir = normalize(vLightDir);

        // NOTE:
        // For better precision normalization may be added on fragment (for mobile devices)
        // while in vertex shader may be left un-normalized
        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);
        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);
        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);
        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);

        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;

        // Sky produces very harsh lighting effect so exposure correction is always enabled.
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Exposure factor may be exposed to uniform variable.
        cRgb = correctExposure(cRgb, 2.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)
        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);

        // Alter alpha based on time of day (0.0 = night , 1.0 = day)
        float fNightAlpha = conditionalBranchFree(bDynamicLight,
            clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0),
            1.0);
        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);

        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));
    }
    `
};
class SkyAtmosphereMaterial extends THREE.RawShaderMaterial {
    constructor(params) {
        // Import shader chunks
        const defines = {};
        defines.CAMERA_IN_SPACE = "";
        const shaderParams = {
            name: "SkyAtmosphereMaterial",
            vertexShader: exports.SkyAtmosphereShader.vertexShader,
            fragmentShader: exports.SkyAtmosphereShader.fragmentShader,
            uniforms: exports.SkyAtmosphereShader.uniforms,
            transparent: true,
            depthTest: true,
            depthWrite: false,
            side: THREE.BackSide,
            blending: THREE.NormalBlending,
            fog: false
        };
        super(shaderParams);
    }
    setDynamicLighting(enableLighting) {
        this.uniforms.u_atmosphereEnv.value.w = enableLighting ? 1.0 : 0.0;
    }
    /**
     * Set maximum outer radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025
     */
    set outerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.y = radius;
    }
    get outerRadius() {
        return this.uniforms.u_atmosphereEnv.value.y;
    }
    /**
     * Set maximum inner radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]].
     */
    set innerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.x = radius;
    }
    get innerRadius() {
        return this.uniforms.u_atmosphereEnv.value.x;
    }
    /**
     * Updates the uniform data of a material used to render an atmosphere.
     *
     * This includes only uniforms that may change frame by frame, other uniforms are
     * accessed with convenient material setters and getters.
     *
     * @param shaderMaterial - Material which uniforms will be updated.
     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.
     * @param lightDirection - The light directional vector in world space.
     * @param camera - Camera used in rendering.
     */
    updateUniforms(shaderMaterial, object, camera, lightDirection) {
        const cameraInfo = this.getCameraInfo(object, camera);
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_atmosphereEnv &&
                shaderMaterial.uniforms.u_hsvCorrection &&
                shaderMaterial.uniforms.u_eyePositionWorld &&
                shaderMaterial.uniforms.u_modelViewProjection &&
                shaderMaterial.uniforms.u_lightDirectionWorld) {
                const eyePos = cameraInfo.eyePos;
                const mvp = cameraInfo.modelViewProjection;
                const cameraHeight = cameraInfo.eyeHeight;
                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                const cameraInSpace = cameraHeight > this.outerRadius;
                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                shaderMaterial.needsUpdate = needsUpdate0 || needsUpdate1;
            }
            else {
                throw Error("Atmosphere material has missing uniforms");
            }
        }
        else {
            throw Error("Wrong object used, only Material objects are supported");
        }
    }
    /*
     * Calculate camera position used in vertex shader of atmosphere materials.
     *
     * @param object -
     * @param camera - Camera used to get the eye position.
     */
    getCameraInfo(object, camera, reverse = false) {
        if (reverse) {
            const modelMatrix = new THREE.Matrix4().identity();
            const viewMatrix = new THREE.Matrix4().getInverse(object.matrixWorld).transpose();
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            object.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            camera.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
        else {
            const modelMatrix = object.matrixWorld;
            const viewMatrix = camera.matrixWorldInverse;
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            camera.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            object.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            // Normally we would return simply camera position, but since camera is not moving in
            // the globe view only the world, we need to calculate eye relative to object position.
            eyePos.sub(objectPos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
    }
}
exports.SkyAtmosphereMaterial = SkyAtmosphereMaterial;
//# sourceMappingURL=SkyAtmosphereMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SolidLineMaterial.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidLineMaterial = exports.LineDashesModes = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/@here/harp-materials/lib/Utils.js");
const LineCapsDefinesMapping = {
    None: LinesChunks_1.LineCapsModes.CAPS_NONE,
    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,
    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,
    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,
    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT
};
const DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {
    const defineKey = lineCapsName;
    const defineValue = LineCapsDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var LineDashesModes;
(function (LineDashesModes) {
    LineDashesModes[LineDashesModes["DASHES_SQUARE"] = 0] = "DASHES_SQUARE";
    LineDashesModes[LineDashesModes["DASHES_ROUND"] = 1] = "DASHES_ROUND";
    LineDashesModes[LineDashesModes["DASHES_DIAMOND"] = 2] = "DASHES_DIAMOND";
})(LineDashesModes = exports.LineDashesModes || (exports.LineDashesModes = {}));
const LineDashesDefinesMapping = {
    Square: LineDashesModes.DASHES_SQUARE,
    Round: LineDashesModes.DASHES_ROUND,
    Diamond: LineDashesModes.DASHES_DIAMOND
};
const DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {
    const defineKey = lineDashesName;
    const defineValue = LineDashesDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
/**
 * The vLength contains the actual line length, it's needed for the creation of line caps by
 * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`
 */
/**
 * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was
 * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on
 * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than
 * the full line length.
 */
const tmpColor = new THREE.Color();
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec3 extrusionCoord;
attribute vec3 position;
attribute vec4 bitangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform float offset;
uniform vec2 drawRange;

#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    // Calculate the segment.
    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;
    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;

    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.
    float linePos = mix(segment.x, segment.y, segmentPos);
    vec2 extrusionDir = sign(extrusionCoord.xy);
    // Precompute to avoid computing multiple times
    float tanHalfAngle = tan(bitangent.w / 2.0);
    float extrusionFactor = extrusionDir.y * tanHalfAngle;

    // Calculate the extruded vertex position (and scale the extrusion direction).
    vec3 pos = extrudeLine(
        position, linePos, extrusionWidth + outlineWidth, bitangent, tangent, tanHalfAngle,
        extrusionDir);

    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).
    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);
    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);

    // Adjust the segment to fit the drawRange.
    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;
    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {
        vCoords.zw += 1.0;
    }
    if (vCoords.z < drawRange.x) {
        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);
    }
    if (vCoords.w > drawRange.y) {
        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);
    }

    // Transform position.
    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    // Shift the line based on the offset, where the bitangent is the cross product of the average
    // of the two direction vectors (the previous and next segment directions) and the normal of
    // the line (facing into the sky). The w component is the angle between the two segments.
    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how
    // much we need to extend the offset. Note, orthough this looks complicated we are doing this
    // in the vertex shader, so it should not cause a performance issue.
    pos += bitangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Pass extruded position to fragment shader.
    #ifdef USE_TILE_CLIP
    vPosition = pos;
    #endif

    #ifdef USE_COLOR
    // Pass vertex color to fragment shader.
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform vec3 outlineColor;
uniform float opacity;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform vec2 tileSize;
uniform vec2 drawRange;

#ifdef USE_DASHED_LINE
uniform float dashSize;
uniform float gapSize;
uniform vec3 dashColor;

#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}
#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}
#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif

varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

#include <round_edges_and_add_caps>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {
    float alpha = opacity;
    vec3 outputDiffuse = diffuse;

    #ifdef USE_TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).
    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);
    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).
    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;

    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope
    // of distToChange increases (i.e. the line is further away).
    float width = fwidth(distToEdge);
    alpha *= (1.0 - smoothstep(-width, width, distToEdge));

    #ifdef USE_DASHED_LINE
    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).
    float d = dashSize / vRange.x;
    float g = gapSize / vRange.x;
    float distToDashOrigin = mod(vCoords.x, d + g) / d;

    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the
    // dashBlendFactor similarly on how we did it for the line opacity.
    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);
    #if DASHES_MODE == DASHES_ROUND
    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));
    #elif DASHES_MODE == DASHES_DIAMOND
    distToDashEdge -= distToCenter * 0.5;
    #endif
    float dashWidth = fwidth(distToDashEdge);
    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);

    #ifdef USE_DASH_COLOR
    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);
    #endif
    #endif

    #ifdef USE_OUTLINE
    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and
    // compute the outlineBlendFactor (used to mix line and outline colors).
    float distToOutline = distToCenter - 1.0;
    float outlineWidth = fwidth(distToOutline);
    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);

    // Mix the colors using the different computed factors.
    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);
    outputDiffuse = mix(
      mix(
        mix(outlineColor, diffuse, colorBlendFactor),
        outputDiffuse,
        dashBlendFactor
      ),
      outlineColor,
      outlineBlendFactor
    );
    #else
    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);
    #endif
    #endif

    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    // Multiply the alpha by the dashBlendFactor.
    #if defined(USE_OUTLINE)
    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);
    #else
    alpha *= 1.0 - dashBlendFactor;
    #endif
    #endif

    #ifdef USE_COLOR
    gl_FragColor = vec4( outputDiffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( outputDiffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render solid variable-width lines.
 */
let SolidLineMaterial = /** @class */ (() => {
    class SolidLineMaterial extends THREE.RawShaderMaterial {
        /**
         * Constructs a new `SolidLineMaterial`.
         *
         * @param params - `SolidLineMaterial` parameters.
         */
        constructor(params) {
            var _a;
            Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
            MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
            // Setup default defines.
            const defines = {
                CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND,
                DASHES_MODE: LineDashesModes.DASHES_SQUARE
            };
            // Prepare defines based on params passed in, before super class c-tor, this ensures
            // proper set for shader compilation, without need to re-compile.
            let fogParam = true;
            let opacityParam = 1.0;
            let displacementMap;
            if (params !== undefined) {
                fogParam = params.fog === true;
                if (fogParam) {
                    Utils_1.setShaderDefine(defines, "USE_FOG", true);
                }
                opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;
                displacementMap = params.displacementMap;
                if (displacementMap !== undefined) {
                    Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
                }
                const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;
                if (hasOutline) {
                    Utils_1.setShaderDefine(defines, "USE_OUTLINE", true);
                }
            }
            const shaderParams = {
                name: "SolidLineMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: THREE.UniformsUtils.merge([
                    {
                        diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                        outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
                        offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),
                        opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                        tileSize: new THREE.Uniform(new THREE.Vector2()),
                        fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                        fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                        displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),
                        drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
                        dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),
                        gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)
                    },
                    // We need the fog uniforms available when we use `fog` setter as the internal
                    // recompilation cannot add or remove uniforms.
                    THREE.UniformsLib.fog
                ]),
                defines,
                // No need to pass overridden `fog` and `opacity` params they will be set
                // after super c-tor call.
                fog: fogParam,
                opacity: opacityParam
            };
            super(shaderParams);
            // Required to satisfy compiler error if fields has no initializer or are not definitely
            // assigned in the constructor, this also mimics ShaderMaterial set of defaults
            // for overridden props.
            this.m_fog = fogParam;
            this.m_opacity = opacityParam;
            Utils_1.enforceBlending(this);
            this.extensions.derivatives = true;
            // Apply initial parameter values.
            if (params !== undefined) {
                if (params.color !== undefined) {
                    tmpColor.set(params.color);
                    this.color = tmpColor;
                }
                if (params.outlineColor !== undefined) {
                    tmpColor.set(params.outlineColor);
                    this.outlineColor = tmpColor;
                }
                if (params.lineWidth !== undefined) {
                    this.lineWidth = params.lineWidth;
                }
                if (params.outlineWidth !== undefined) {
                    this.outlineWidth = params.outlineWidth;
                }
                if (params.opacity !== undefined) {
                    this.opacity = params.opacity;
                }
                if (params.depthTest !== undefined) {
                    this.depthTest = params.depthTest;
                }
                if (params.depthWrite !== undefined) {
                    this.depthWrite = params.depthWrite;
                }
                if (params.fadeNear !== undefined) {
                    this.fadeNear = params.fadeNear;
                }
                if (params.fadeFar !== undefined) {
                    this.fadeFar = params.fadeFar;
                }
                if (params.displacementMap !== undefined) {
                    this.displacementMap = params.displacementMap;
                }
                if (params.caps !== undefined) {
                    this.caps = params.caps;
                }
                if (params.drawRangeStart !== undefined) {
                    this.drawRangeStart = params.drawRangeStart;
                }
                if (params.drawRangeEnd !== undefined) {
                    this.drawRangeEnd = params.drawRangeEnd;
                }
                if (params.dashes !== undefined) {
                    this.dashes = params.dashes;
                }
                if (params.dashColor !== undefined) {
                    tmpColor.set(params.dashColor);
                    this.dashColor = tmpColor;
                }
                if (params.dashSize !== undefined) {
                    this.dashSize = params.dashSize;
                }
                if (params.gapSize !== undefined) {
                    this.gapSize = params.gapSize;
                }
                if (params.fog !== undefined) {
                    this.fog = params.fog;
                }
                this.offset = (_a = params.offset) !== null && _a !== void 0 ? _a : 0;
            }
            // ShaderMaterial overrides requires invalidation cause super c-tor may set this
            // properties before related `defines` and `uniforms` were created.
            this.invalidateFog();
            this.invalidateOpacity();
        }
        /**
         * Overrides THREE.Material.fog flag to add support for custom shader.
         *
         * @param enable - Whether we want to enable the fog.
         */
        set fog(enable) {
            this.m_fog = enable;
            // Function may be called from THREE.js cause we override setter,
            // in this case defines are not yet initialized and require late invalidation in
            // SolidLineMaterial c-tor.
            if (this.defines !== undefined) {
                Utils_1.setShaderMaterialDefine(this, "USE_FOG", enable);
            }
        }
        /**
         * Checks if fog is enabled.
         */
        get fog() {
            return this.m_fog && Utils_1.getShaderMaterialDefine(this, "USE_FOG") === true;
        }
        /**
         * Sets the offset used to shift the line in world space perpendicular to the direction.
         */
        set offset(offset) {
            this.uniforms.offset.value = offset;
        }
        /**
         * @return The offset to shift the line in world space perpendicular to the direction.
         */
        get offset() {
            return this.uniforms.offset.value;
        }
        /**
         * The method to call to recompile a material to enable/disable outline effect
         *
         * @param enable - Whether we want to use outline.
         */
        set outline(enable) {
            Utils_1.setShaderMaterialDefine(this, "USE_OUTLINE", enable);
        }
        /**
         * Checks if outline is enabled.
         */
        get outline() {
            return Utils_1.getShaderMaterialDefine(this, "USE_OUTLINE") === true;
        }
        /**
         * Line opacity.
         */
        get opacity() {
            return this.m_opacity;
        }
        set opacity(value) {
            this.m_opacity = value;
            // Setting opacity before uniform being created requires late invalidation,
            // call to invalidateOpacity() is done at the end of c-tor.
            if (this.uniforms !== undefined) {
                this.uniforms.opacity.value = value;
            }
        }
        /**
         * Line color.
         */
        get color() {
            return this.uniforms.diffuse.value;
        }
        set color(value) {
            this.uniforms.diffuse.value.copy(value);
        }
        /**
         * Outline color.
         *
         * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.
         */
        get outlineColor() {
            return this.uniforms.outlineColor.value;
        }
        set outlineColor(value) {
            this.uniforms.outlineColor.value.copy(value);
        }
        /**
         * Dash color.
         *
         * @note The property [[gapSize]] need to be set to enable dashed line.
         */
        get dashColor() {
            return this.uniforms.dashColor.value;
        }
        set dashColor(value) {
            this.uniforms.dashColor.value.copy(value);
            Utils_1.setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
        }
        /**
         * Line width.
         */
        get lineWidth() {
            return this.uniforms.extrusionWidth.value * 2;
        }
        set lineWidth(value) {
            this.uniforms.extrusionWidth.value = value / 2;
        }
        /**
         * Outline width.
         */
        get outlineWidth() {
            return this.uniforms.outlineWidth.value;
        }
        set outlineWidth(value) {
            this.uniforms.outlineWidth.value = value;
            this.outline = value > 0.0;
        }
        /**
         * Size of the dashed segments.
         *
         * @note Ths [[gapSize]] need to be also set to enable dashed line.
         * @see gapSize.
         */
        get dashSize() {
            return this.uniforms.dashSize.value;
        }
        set dashSize(value) {
            this.uniforms.dashSize.value = value;
        }
        /**
         * Size of the gaps between dashed segments.
         *
         * @note You may also need to set [[dashSize]].
         * @see dashSize.
         */
        get gapSize() {
            return this.uniforms.gapSize.value;
        }
        set gapSize(value) {
            this.uniforms.gapSize.value = value;
            Utils_1.setShaderMaterialDefine(this, "USE_DASHED_LINE", value > 0.0);
        }
        /**
         * Caps mode.
         */
        get caps() {
            let result = "Round";
            const capsMode = Utils_1.getShaderMaterialDefine(this, "CAPS_MODE");
            // Sanity check if material define is numerical and has direct mapping to LineCaps type.
            if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
                result = DefinesLineCapsMapping[capsMode];
            }
            return result;
        }
        set caps(value) {
            // Line caps mode may be set directly from theme, thus we need to check value
            // for correctness and provide string to define mapping in fragment shader.
            if (LineCapsDefinesMapping.hasOwnProperty(value)) {
                Utils_1.setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value]);
            }
        }
        /**
         * Dashes mode.
         */
        get dashes() {
            let result = "Square";
            const dashesMode = Utils_1.getShaderMaterialDefine(this, "DASHES_MODE");
            // Sanity check if material define is numerical and has direct mapping to LineDashes type.
            if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
                result = DefinesLineDashesMapping[dashesMode];
            }
            return result;
        }
        set dashes(value) {
            // Line dashes mode may be set directly from theme, thus we need to check value
            // for correctness and provide string to define mapping in fragment shader.
            if (LineDashesDefinesMapping.hasOwnProperty(value)) {
                Utils_1.setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value]);
            }
        }
        get fadeNear() {
            return this.uniforms.fadeNear.value;
        }
        set fadeNear(value) {
            this.uniforms.fadeNear.value = value;
        }
        get fadeFar() {
            return this.uniforms.fadeFar.value;
        }
        set fadeFar(value) {
            this.uniforms.fadeFar.value = value;
            Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
        }
        get displacementMap() {
            return this.uniforms.displacementMap.value;
        }
        set displacementMap(map) {
            if (this.uniforms.displacementMap.value === map) {
                return;
            }
            this.uniforms.displacementMap.value = map;
            const useDisplacementMap = map !== null;
            if (useDisplacementMap) {
                this.uniforms.displacementMap.value.needsUpdate = true;
            }
            Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
        }
        get drawRangeStart() {
            return this.uniforms.drawRange.value.x;
        }
        set drawRangeStart(value) {
            this.uniforms.drawRange.value.x = value;
        }
        get drawRangeEnd() {
            return this.uniforms.drawRange.value.y;
        }
        set drawRangeEnd(value) {
            this.uniforms.drawRange.value.y = value;
        }
        set clipTileSize(tileSize) {
            this.uniforms.tileSize.value.copy(tileSize);
            const useTileClip = tileSize.x > 0 && tileSize.y > 0;
            Utils_1.setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
        }
        get clipTileSize() {
            return this.uniforms.tileSize.value;
        }
        invalidateFog() {
            if (this.m_fog !== Utils_1.getShaderMaterialDefine(this, "USE_FOG")) {
                Utils_1.setShaderMaterialDefine(this, "USE_FOG", this.m_fog);
            }
        }
        invalidateOpacity() {
            if (this.m_opacity !== this.uniforms.opacity.value) {
                this.uniforms.opacity.value = this.m_opacity;
            }
        }
    }
    SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
    SolidLineMaterial.DEFAULT_WIDTH = 1.0;
    SolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;
    SolidLineMaterial.DEFAULT_OPACITY = 1.0;
    SolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;
    SolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;
    SolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;
    SolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;
    SolidLineMaterial.DEFAULT_OFFSET = 0.0;
    return SolidLineMaterial;
})();
exports.SolidLineMaterial = SolidLineMaterial;
//# sourceMappingURL=SolidLineMaterial.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/Utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShaderDefine = exports.setShaderDefine = exports.getShaderMaterialDefine = exports.setShaderMaterialDefine = exports.disableBlending = exports.enableBlending = exports.enforceBlending = exports.insertShaderInclude = exports.DEFINE_BOOL_FALSE = exports.DEFINE_BOOL_TRUE = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Values for boolean shader defines
 */
exports.DEFINE_BOOL_TRUE = "";
exports.DEFINE_BOOL_FALSE = undefined;
/**
 * Insert shader includes after another shader include.
 *
 * @param shaderContent - Original string.
 * @param shaderName - String to append to.
 * @param insertedShaderName - String to append after string `shaderA`.
 * @param addTab - If `true`, a tab character will be inserted before `shaderB`.
 */
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    const tabChar = addTab === true ? "\t" : "";
    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
    return result;
}
exports.insertShaderInclude = insertShaderInclude;
/**
 * THREE.js is enabling blending only when transparent is `true` or when a blend mode
 * different than `NormalBlending` is set.
 * Since we don't want to set transparent to true and mess up the render order we set
 * `CustomBlending` with the same parameters as the `NormalBlending`.

 * @param material - `Material` that should use blending
 * @note This function should not be used in frame update after material has been passed to WebGL.
 * In such cases use [[enableBlending]] instead.
 */
function enforceBlending(material) {
    if (material.transparent) {
        // Nothing to do
        return;
    }
    enableBlending(material);
    material.forcedBlending = true;
}
exports.enforceBlending = enforceBlending;
/**
 * Enable alpha blending using THREE.CustomBlending setup.
 *
 * Function enables blending using one of predefined modes, for both color and alpha components:
 * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled
 * for this material.
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @param material - The material or material parameters to modify.
 */
function enableBlending(material) {
    if (material.transparent || material.forcedBlending) {
        // Nothing to do
        return;
    }
    material.blending = THREE.CustomBlending;
    if (material.premultipliedAlpha === true) {
        material.blendSrc = THREE.OneFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
    else {
        material.blendSrc = THREE.SrcAlphaFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
}
exports.enableBlending = enableBlending;
/**
 * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].
 *
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @see enableBlending.
 * @param material - The material or material parameters to modify.
 */
function disableBlending(material) {
    if (material.transparent || material.forcedBlending) {
        // Nothing to do
        return;
    }
    material.blending = THREE.NormalBlending;
}
exports.disableBlending = disableBlending;
/**
 * Setup material shader _define_ using two allowable semantics.
 *
 * Function accepts two types of values for shader preprocessor _define_:
 * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,
 * such defines may be handled in the shader using __#ifdef__ semantics:
 * ```
 * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)
 * // do something
 * #endif
 * ```
 *
 * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some
 * code or even set compile time constants affecting shaders math:
 * ```
 * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0
 * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)
 * #endif
 * ```
 * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.
 *
 * @param material - The [[THREE.ShaderMaterial]] which shader _define_ will be set.
 * @param key - Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.
 * @param value - The value to be set as number or boolean specifying if preprocessor define
 * should be defined or not.
 * @returns [[true]] if material has been forced to update (re-compile) due to define changes,
 * return [[false]] whenever define has not been changed.
 */
function setShaderMaterialDefine(material, key, value) {
    harp_utils_1.assert(material.defines !== undefined, "Do not use this function in ShaderMaterial derived c-tor.");
    const semanticValue = getShaderMaterialDefine(material, key);
    const needsUpdate = value !== semanticValue;
    // Nothing to change - early exit
    if (!needsUpdate) {
        return false;
    }
    setShaderDefine(material.defines, key, value);
    material.needsUpdate = needsUpdate;
    return true;
}
exports.setShaderMaterialDefine = setShaderMaterialDefine;
/**
 * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.
 *
 * The semantic used in entire engine assumes that preprocessor defines may have only binary
 * (defined / not defined) or numerical values, this ensures consistency in the shaders and
 * materials code.
 * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but
 * not numerical value it returns [[true]], otherwise returns number.
 * @see setShaderMaterialDefine.
 *
 * @param material - The material which shader defines are accessed.
 * @param key - The _define_ name (identifier).
 * @param fallbackValue - The value returned when material `defines` are not initialized yet,
 * specified by default as [[false]], provide your own default if you expect numeric value.
 */
function getShaderMaterialDefine(material, key, fallbackValue = false) {
    if (material.defines === undefined) {
        return fallbackValue;
    }
    return getShaderDefine(material.defines, key);
}
exports.getShaderMaterialDefine = getShaderMaterialDefine;
/**
 * Sets new value of 'define' regardless of current value set.
 *
 * Update `defines` map with new key and value, if key is already occupied it overrides its value.
 * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before
 * material is create (i.e. in c-tor).
 *
 * @param defines - Shader `defines` stored in key-value map.
 * @param key - The key used to identify _define_.
 * @param value - The value to be stored.
 * @returns [[true]] if define has actually changed, false is stayed the same.
 * @see setShaderMaterialDefine.
 */
function setShaderDefine(defines, key, value) {
    let updated = false;
    if (typeof value === "number") {
        updated = defines[key] !== value;
        defines[key] = value;
    }
    else if (value === true) {
        updated = defines[key] !== exports.DEFINE_BOOL_TRUE;
        defines[key] = exports.DEFINE_BOOL_TRUE;
    }
    else if (value === false && defines[key] !== undefined) {
        // Sets to DEFINE_BOOL_FALSE === undefined
        delete defines[key];
        updated = true;
    }
    return updated;
}
exports.setShaderDefine = setShaderDefine;
/**
 * Acquire shader 'define' value from `defines` map.
 *
 * If there is no value under [[key]] specified, function returns false, otherwise result is
 * true or numeric value if there is a number stored.
 * @param defines - The `defines` map.
 * @param key - The identifier of the _define_.
 */
function getShaderDefine(defines, key) {
    const currentValue = defines[key];
    const semanticValue = currentValue === exports.DEFINE_BOOL_FALSE
        ? false
        : currentValue === exports.DEFINE_BOOL_TRUE
            ? true
            : currentValue;
    return semanticValue;
}
exports.getShaderDefine = getShaderDefine;
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/VignetteShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/VignetteShader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VignetteShader = void 0;
/**
 * `VignetteShader`.
 */
exports.VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};
//# sourceMappingURL=VignetteShader.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * HERE OMV Data source.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/OmvDataFilter */ "./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvDataSource */ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvRestClient */ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ "./node_modules/@here/harp-omv-datasource/lib/GeoJsonDataProvider.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/GeoJsonDataProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/GeoJsonDataProvider.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonDataProvider = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const logger = harp_utils_1.LoggerManager.instance.create("GeoJsonDataProvider");
let missingTilerServiceInfoEmitted = false;
/**
 * GeoJson [[DataProvider]]. Automatically handles tiling and simplification of static GeoJson.
 */
class GeoJsonDataProvider {
    /**
     * Constructs a new `GeoJsonDataProvider`.
     *
     * @param name - Name to be used to reference this `DataProvider`
     * @param input - URL of the GeoJSON, or a GeoJSON.
     * @param options - Optional
     * @returns New `GeoJsonDataProvider`.
     */
    constructor(name, input, options) {
        this.name = name;
        this.input = input;
        this.m_registered = false;
        this.m_tiler =
            (options && options.tiler) ||
                harp_mapview_1.ConcurrentTilerFacade.getTiler("omv-tiler", options && options.workerTilerUrl);
    }
    async connect() {
        try {
            await this.m_tiler.connect();
        }
        catch (error) {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingTilerServiceInfoEmitted) {
                logger.info("Unable to start GeoJson tiler service in worker. Use " +
                    " 'OmvTilerService.start();' in decoder script.");
                missingTilerServiceInfoEmitted = true;
            }
            throw error;
        }
        await this.m_tiler.registerIndex(this.name, this.input);
        this.m_registered = true;
    }
    updateInput(input) {
        this.input = input;
        this.m_tiler.updateIndex(this.name, this.input);
    }
    ready() {
        return this.m_registered;
    }
    async getTile(tileKey) {
        return this.m_tiler.getTile(this.name, tileKey);
    }
}
exports.GeoJsonDataProvider = GeoJsonDataProvider;
//# sourceMappingURL=GeoJsonDataProvider.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvGenericFeatureModifier = exports.ComposedDataFilter = exports.OmvGenericFeatureFilter = exports.OmvFeatureFilterDescriptionBuilder = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js");
/**
 * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well
 * as an [[OmvFeatureModifier]].
 *
 */
class OmvFeatureFilterDescriptionBuilder {
    /**
     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as
     * well as an [[OmvFeatureModifier]].
     *
     * @param processLayersDefault - If `true`, all unspecified layers will be processed.
     * If `false`, all unspecified layers will be ignored.
     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If
     * `false`, all unspecified point features will be ignored.
     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If
     * `false`, all unspecified line features will be ignored.
     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be
     * processed. If `false`, all unspecified polygon features will be ignored.
     */
    constructor(options) {
        this.m_processLayersDefault = true;
        this.m_processPointsDefault = true;
        this.m_processLinesDefault = true;
        this.m_processPolygonsDefault = true;
        this.m_layersToProcess = new Array();
        this.m_layersToIgnore = new Array();
        this.m_pointsToProcess = new Array();
        this.m_ignoredPoints = new Array();
        this.m_linesToProcess = new Array();
        this.m_linesToIgnore = new Array();
        this.m_polygonsToProcess = new Array();
        this.m_polygonsToIgnore = new Array();
        this.m_kindsToProcess = [];
        this.m_kindsToIgnore = [];
        if (options) {
            this.m_processLayersDefault =
                options.processLayersDefault !== undefined ? options.processLayersDefault : true;
            this.m_processPointsDefault =
                options.processPointsDefault !== undefined ? options.processPointsDefault : true;
            this.m_processLinesDefault =
                options.processLinesDefault !== undefined ? options.processLinesDefault : true;
            this.m_processPolygonsDefault =
                options.processPolygonsDefault !== undefined
                    ? options.processPolygonsDefault
                    : true;
        }
    }
    /**
     * Add a layer that should be processed.
     *
     * @param layer - Layer name to be matched.
     * @param match - Match condition.
     */
    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToProcess.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a layer that should be ignored.
     *
     * @param layer - Layer name to be matched.
     * @param match - Match condition.
     */
    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToIgnore.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a valid point feature.
     *
     * @param options - Feature options.
     */
    processPoint(options) {
        this.addItem(this.m_pointsToProcess, options);
    }
    /**
     * Add valid point features.
     *
     * @param options - Multi feature options.
     */
    processPoints(options) {
        this.addItems(this.m_pointsToProcess, options);
    }
    /**
     * Add a point feature that should be ignored.
     *
     * @param options - Feature options.
     */
    ignorePoint(options) {
        this.addItem(this.m_ignoredPoints, options);
    }
    /**
     * Add point features that should be ignored.
     *
     * @param options - Multi feature options.
     */
    ignorePoints(options) {
        this.addItems(this.m_ignoredPoints, options);
    }
    /**
     * Add a valid line feature.
     *
     * @param options - Feature options.
     */
    processLine(options) {
        this.addItem(this.m_linesToProcess, options);
    }
    /**
     * Add valid line features.
     *
     * @param options - Multi feature options.
     */
    processLines(options) {
        this.addItems(this.m_linesToProcess, options);
    }
    /**
     * Ignore a line feature.
     *
     * @param options - Feature options.
     */
    ignoreLine(options) {
        this.addItem(this.m_linesToIgnore, options);
    }
    /**
     * Ignore line features.
     *
     * @param options - Multi feature options.
     */
    ignoreLines(options) {
        this.addItems(this.m_linesToIgnore, options);
    }
    /**
     * Add a valid polygon feature.
     *
     * @param options - Feature options.
     */
    processPolygon(options) {
        this.addItem(this.m_polygonsToProcess, options);
    }
    /**
     * Add valid polygon features.
     *
     * @param options - Multi feature options.
     */
    processPolygons(options) {
        this.addItems(this.m_polygonsToProcess, options);
    }
    /**
     * Ignore a valid polygon feature.
     *
     * @param options - Feature options.
     */
    ignorePolygon(options) {
        this.addItem(this.m_polygonsToIgnore, options);
    }
    /**
     * Ignore polygon features.
     *
     * @param options - Multi feature options.
     */
    ignorePolygons(options) {
        this.addItems(this.m_polygonsToIgnore, options);
    }
    /**
     * Add all the specified strings as "enabledKinds".
     *
     * @param {string[]} enabledKinds List of kinds that should be generated.
     */
    processKinds(enabledKinds) {
        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);
    }
    /**
     * Add all the specified strings as "disabledKinds".
     *
     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.
     */
    ignoreKinds(disabledKinds) {
        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);
    }
    /**
     * Create a filter description that can be passed as an option to the [[OmvDataSource]].
     */
    createDescription() {
        return {
            processLayersDefault: this.m_processLayersDefault,
            processPointsDefault: this.m_processPointsDefault,
            processLinesDefault: this.m_processLinesDefault,
            processPolygonsDefault: this.m_processPolygonsDefault,
            layersToProcess: this.m_layersToProcess,
            layersToIgnore: this.m_layersToIgnore,
            pointsToProcess: this.m_pointsToProcess,
            pointsToIgnore: this.m_ignoredPoints,
            linesToProcess: this.m_linesToProcess,
            linesToIgnore: this.m_linesToIgnore,
            polygonsToProcess: this.m_polygonsToProcess,
            polygonsToIgnore: this.m_polygonsToIgnore,
            kindsToProcess: this.m_kindsToProcess,
            kindsToIgnore: this.m_kindsToIgnore
        };
    }
    addItem(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomType !== undefined
                ? Array.isArray(options.geomType)
                    ? options.geomType
                    : [options.geomType]
                : undefined,
            classes: [
                {
                    value: options.featureClass,
                    match: options.matchClass === undefined
                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                        : options.matchClass
                }
            ],
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
    addItems(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomTypes !== undefined
                ? Array.isArray(options.geomTypes)
                    ? options.geomTypes
                    : [options.geomTypes]
                : undefined,
            classes: options.featureClasses,
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
}
exports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;
/**
 * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`
 * features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureFilter {
    constructor(description) {
        this.description = description;
        if (this.description.kindsToProcess.length > 0) {
            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);
        }
        if (this.description.kindsToIgnore.length > 0) {
            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);
        }
    }
    static matchLayer(layer, layerItems, level) {
        for (const layerItem of layerItems) {
            if (level < layerItem.minLevel || level > layerItem.maxLevel) {
                continue;
            }
            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {
                return true;
            }
        }
        return false;
    }
    wantsLayer(layer, level) {
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {
            return true;
        }
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {
            return false;
        }
        return this.description.processLayersDefault;
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);
    }
    wantsKind(kind) {
        // undefined -> no way to filter
        if (kind === undefined) {
            return true;
        }
        return (!(this.disabledKinds !== undefined &&
            this.disabledKinds.hasOrIntersects(kind)) ||
            (this.enabledKinds !== undefined &&
                this.enabledKinds.hasOrIntersects(kind)));
    }
    get hasKindFilter() {
        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;
    }
    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {
        for (const item of itemsToProcess) {
            if (level < item.minLevel || level > item.maxLevel) {
                continue;
            }
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return true;
            }
        }
        for (const item of itemsToIgnore) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {
                return false;
            }
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;
/**
 * An [[OmvFeatureFilter]] implementation that delegates all filter decision
 * returning `true` for any predicate if all delegates return `true`.
 */
class ComposedDataFilter {
    constructor(filters) {
        this.filters = filters;
    }
    get hasKindFilter() {
        return this.filters.reduce((result, filter) => result && filter.hasKindFilter, true);
    }
    wantsLayer(layer, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);
    }
    wantsKind(kind) {
        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);
    }
}
exports.ComposedDataFilter = ComposedDataFilter;
/**
 * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter
 * `TileData` features before they are completely decoded.
 *
 * @hidden
 */
class OmvGenericFeatureModifier {
    constructor(description) {
        this.description = description;
    }
    static matchItems(layerName, featureClass, items) {
        for (const item of items) {
            if (item.classes !== undefined) {
                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {
                    continue;
                }
                for (const matchClass of item.classes) {
                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static matchAttribute(layerName, env, items) {
        for (const item of items) {
            if (item.featureAttribute !== undefined) {
                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&
                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {
                    return true;
                }
            }
        }
        return false;
    }
    doProcessPointFeature(layer, env) {
        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);
    }
    doProcessLineFeature(layer, env) {
        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);
    }
    doProcessPolygonFeature(layer, env) {
        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);
    }
    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {
        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {
            return defaultResult;
        }
        let featureClass;
        const featureClassThing = env.lookup("class");
        if (featureClassThing !== undefined && featureClassThing !== null) {
            featureClass = featureClassThing.toString();
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {
            return true;
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {
            return false;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {
            return true;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {
            return false;
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;
//# sourceMappingURL=OmvDataFilter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvDataSource = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "./node_modules/@here/harp-geoutils/index.js");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "./node_modules/@here/harp-mapview-decoder/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js");
const OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js");
const logger = harp_utils_1.LoggerManager.instance.create("OmvDataSource");
/**
 * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.
 *
 * @param params - The parameters passed into the OmvDataSource.
 */
function getDataProvider(params) {
    if (params.dataProvider) {
        return params.dataProvider;
    }
    else if (params.baseUrl ||
        params.url) {
        return new OmvRestClient_1.OmvRestClient(params);
    }
    else {
        throw new Error("OmvDataSource: missing url, baseUrl or dataProvider params");
    }
}
let missingOmvDecoderServiceInfoEmitted = false;
/**
 * The default vector tile service.
 */
const hereVectorTileBaseUrl = "https://vector.hereapi.com/v2/vectortiles/base/mc";
/**
 * Default options for the HERE Vector Tile service.
 */
const hereVectoTileDefaultOptions = {
    baseUrl: hereVectorTileBaseUrl,
    apiFormat: OmvRestClient_1.APIFormat.XYZOMV,
    styleSetName: "tilezen",
    authenticationMethod: {
        method: OmvRestClient_1.AuthenticationMethod.QueryString,
        name: "apikey"
    },
    copyrightInfo: [
        {
            id: "here.com",
            year: new Date().getFullYear(),
            label: "HERE",
            link: "https://legal.here.com/terms"
        }
    ]
};
const defaultOptions = new Map([
    [hereVectorTileBaseUrl, hereVectoTileDefaultOptions]
]);
/**
 * Tests if the given object has custom data provider.
 * @param object -
 */
function hasCustomDataProvider(object) {
    return object.dataProvider !== undefined;
}
/**
 * Add service specific default values.
 *
 * @param params - The configuration settings of the data source.
 */
function completeDataSourceParameters(params) {
    var _a;
    if (!hasCustomDataProvider(params) && params.url === undefined) {
        const baseUrl = (_a = params.baseUrl) !== null && _a !== void 0 ? _a : hereVectorTileBaseUrl;
        const completedParams = Object.assign(Object.assign({}, defaultOptions.get(baseUrl)), params);
        return Object.assign(Object.assign({}, completedParams), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: new OmvRestClient_1.OmvRestClient(completedParams) });
    }
    return Object.assign(Object.assign({}, params), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: getDataProvider(params) });
}
class OmvDataSource extends harp_mapview_decoder_1.TileDataSource {
    constructor(m_params) {
        var _a, _b, _c, _d, _e;
        super(m_params.tileFactory || new harp_mapview_decoder_1.TileFactory(OmvTile_1.OmvTile), Object.assign({ styleSetName: (_a = m_params.styleSetName) !== null && _a !== void 0 ? _a : "omv", concurrentDecoderServiceName: OmvDecoderDefs_1.OMV_TILE_DECODER_SERVICE_TYPE, minDataLevel: (_b = m_params.minDataLevel) !== null && _b !== void 0 ? _b : 1, maxDataLevel: (_c = m_params.maxDataLevel) !== null && _c !== void 0 ? _c : 17, storageLevelOffset: (_d = m_params.storageLevelOffset) !== null && _d !== void 0 ? _d : -1 }, completeDataSourceParameters(m_params)));
        this.m_params = m_params;
        this.cacheable = true;
        this.addGroundPlane =
            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;
        this.m_decoderOptions = {
            showMissingTechniques: this.m_params.showMissingTechniques === true,
            filterDescription: this.m_params.filterDescr,
            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,
            featureModifiers: this.m_params.featureModifierId
                ? [this.m_params.featureModifierId]
                : undefined,
            politicalView: this.m_params.politicalView,
            skipShortLabels: this.m_params.skipShortLabels,
            storageLevelOffset: (_e = m_params.storageLevelOffset) !== null && _e !== void 0 ? _e : -1,
            enableElevationOverlay: this.m_params.enableElevationOverlay === true
        };
        this.maxGeometryHeight = harp_utils_1.getOptionValue(m_params.maxGeometryHeight, harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT);
    }
    /** @override */
    async connect() {
        try {
            await super.connect();
        }
        catch (error) {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingOmvDecoderServiceInfoEmitted) {
                logger.info("Unable to create decoder service in worker. Use " +
                    " 'OmvTileDecoderService.start();' in decoder script.");
                missingOmvDecoderServiceInfoEmitted = true;
            }
            throw error;
        }
        this.configureDecoder(undefined, undefined, undefined, this.m_decoderOptions);
    }
    /**
     * Remove the current data filter.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     */
    removeDataFilter() {
        this.configureDecoder(undefined, undefined, undefined, {
            filterDescription: null
        });
    }
    /**
     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].
     * Will be applied to the decoder, which might be shared with other omv datasources.
     *
     * @param filterDescription - Data filter description created with
     * [[OmvFeatureFilterDescriptionBuilder]].
     */
    setDataFilter(filterDescription) {
        this.m_decoderOptions.filterDescription =
            filterDescription !== null ? filterDescription : undefined;
        this.configureDecoder(undefined, undefined, undefined, {
            filterDescription,
            featureModifiers: this.m_decoderOptions.featureModifiers,
            politicalView: this.m_decoderOptions.politicalView
        });
    }
    /** @override */
    shouldPreloadTiles() {
        return true;
    }
    /** @override */
    setLanguages(languages) {
        if (languages !== undefined) {
            this.configureDecoder(undefined, undefined, languages, undefined);
        }
    }
    /** @override */
    setPoliticalView(politicalView) {
        // Just in case users mess with letters' casing.
        politicalView = politicalView === null || politicalView === void 0 ? void 0 : politicalView.toLowerCase();
        if (this.m_decoderOptions.politicalView !== politicalView) {
            this.m_decoderOptions.politicalView = politicalView;
            this.configureDecoder(undefined, undefined, undefined, {
                filterDescription: this.m_decoderOptions.filterDescription,
                featureModifiers: this.m_decoderOptions.featureModifiers,
                politicalView: politicalView !== undefined ? politicalView : ""
            });
        }
    }
    /** @override */
    get storageLevelOffset() {
        return super.storageLevelOffset;
    }
    /** @override */
    set storageLevelOffset(levelOffset) {
        super.storageLevelOffset = levelOffset;
        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;
        this.configureDecoder(undefined, undefined, undefined, {
            storageLevelOffset: this.storageLevelOffset
        });
    }
    /** @override */
    setEnableElevationOverlay(enable) {
        if (this.m_decoderOptions.enableElevationOverlay !== enable) {
            this.m_decoderOptions.enableElevationOverlay = enable;
            this.configureDecoder(undefined, undefined, undefined, {
                enableElevationOverlay: enable
            });
        }
    }
    configureDecoder(styleSet, definitions, languages, options) {
        this.clearCache();
        this.decoder.configure(styleSet, definitions, languages, options);
        this.mapView.markTilesDirty(this);
    }
}
exports.OmvDataSource = OmvDataSource;
//# sourceMappingURL=OmvDataSource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvDebugLabelsTile = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "./node_modules/@here/harp-datasource-protocol/index.js");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
const DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ "./node_modules/@here/harp-mapview/lib/DebugContext.js");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "./node_modules/@here/harp-text-canvas/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js");
const OmvTile_1 = __webpack_require__(/*! ./OmvTile */ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 1,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterialWF = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterialWF.wireframe = true;
const debugCircleMaterial2WF = new THREE.MeshBasicMaterial({
    color: 0x8080ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterial2WF.wireframe = true;
const debugBlackCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugBlueCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x0000ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth,
    opacity: 0.75,
    transparent: true
});
const textRenderStyle = new harp_text_canvas_1.TextRenderStyle();
const textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();
textRenderStyle.fontSize = {
    unit: harp_text_canvas_1.FontUnit.Point,
    size: 9,
    backgroundSize: 0
};
textRenderStyle.opacity = 0.75;
textRenderStyle.backgroundOpacity = 0.75;
textRenderStyle.color = new THREE.Color(0.8, 0.2, 0.2);
// Set maximum priority.
const PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;
class OmvDebugLabelsTile extends OmvTile_1.OmvTile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
    /** @override */
    loadingFinished() {
        this.addLabelDebugInfo();
    }
    /**
     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.
     */
    addLabelDebugInfo() {
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_TEXT_PATHS", true)
        const debugTextPaths = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS");
        const debugTextPathsFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS_FULL");
        const debugTextPoisFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_POIS_FULL");
        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {
            return;
        }
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const decodedTile = this.decodedTile;
        tileGeometryCreator.createTextElements(this, decodedTile);
        const colorMap = new Map();
        // allow limiting to specific names and/or index. There can be many paths with the same text
        const textFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.TEXT");
        const indexFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.INDEX");
        const env = this.mapView.env;
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
        }
        const centerX = this.center.x;
        const centerY = this.center.y;
        const centerZ = this.center.z;
        const pointScale = this.mapView.pixelToWorld;
        const worldOffsetX = this.computeWorldOffsetX();
        let pointLabelIndex = 0;
        if (this.textElementGroups.count() > 0) {
            const bluePointGeometry = new THREE.BufferGeometry();
            const bluePointIndices = new Array();
            const bluePointPositions = new Array();
            const addedTextElements = [];
            this.textElementGroups.forEach((textElement) => {
                if (textElement.path !== undefined) {
                    return;
                }
                const x = textElement.position.x - centerX;
                const y = textElement.position.y - centerY;
                const z = 5 - centerZ;
                // bluePointIndices.push(bluePointPositions.length / 3);
                // bluePointPositions.push(x, y, z);
                const pointSize = pointScale * 3;
                bluePointPositions.push(x, y - pointSize, z);
                bluePointPositions.push(x + pointSize, y, z);
                bluePointPositions.push(x, y + pointSize, z);
                bluePointPositions.push(x - pointSize, y, z);
                const pointIndex = bluePointPositions.length / 3;
                bluePointIndices.push(pointIndex - 4);
                bluePointIndices.push(pointIndex - 3);
                bluePointIndices.push(pointIndex - 2);
                bluePointIndices.push(pointIndex - 4);
                bluePointIndices.push(pointIndex - 2);
                bluePointIndices.push(pointIndex - 1);
                if (debugTextPoisFull) {
                    const offsetXY = pointSize * 0.5;
                    const label = `${textElement.text} [${pointLabelIndex}]`;
                    const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX + offsetXY, y + centerY + offsetXY, z + centerZ), textRenderStyle, textLayoutStyle, PRIORITY_ALWAYS, 0.0, 0.0);
                    labelElement.minZoomLevel = 0;
                    labelElement.mayOverlap = true;
                    labelElement.reserveSpace = false;
                    labelElement.alwaysOnTop = true;
                    labelElement.ignoreDistance = true;
                    labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;
                    labelElement._isDebug = true;
                    addedTextElements.push(labelElement);
                }
                pointLabelIndex++;
            });
            for (const labelElement of addedTextElements) {
                this.addTextElement(labelElement);
            }
            if (bluePointIndices.length > 0) {
                bluePointGeometry.addGroup(0, bluePointIndices.length, 0);
                bluePointGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(bluePointPositions), 3));
                bluePointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(bluePointIndices), 1));
                const bluePointMesh = new THREE.Mesh(bluePointGeometry, debugBlueCircleMaterial);
                bluePointMesh.renderOrder = PRIORITY_ALWAYS;
                this.objects.push(bluePointMesh);
            }
        }
        if (this.preparedTextPaths !== undefined) {
            const lineGeometry = new THREE.BufferGeometry();
            const lineIndices = new Array();
            const linePositions = new Array();
            const redPointGeometry = new THREE.BufferGeometry();
            const redPointIndices = new Array();
            const redPointPositions = new Array();
            const blackPointGeometry = new THREE.BufferGeometry();
            const blackPointIndices = new Array();
            const blackPointPositions = new Array();
            let baseVertex = 0;
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique) || textPath._isDebug !== undefined) {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, env)));
                }
                baseVertex = linePositions.length / 3;
                const text = textPath.text;
                const elementIndex = this.preparedTextPaths.indexOf(textPath);
                const createDebugInfo = (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&
                    (indexFilter === undefined || indexFilter === elementIndex);
                if (createDebugInfo) {
                    const zHeight = 10;
                    for (let i = 0; i < textPath.path.length; i += 3) {
                        const pathIndex = i / 3;
                        const x = textPath.path[i] - centerX;
                        const y = textPath.path[i + 1] - centerY;
                        // raise it a bit, so we get identify connectivity visually by tilting
                        const z = zHeight + textPath.path[i + 2] + i / 3 - centerZ;
                        if (debugTextPaths) {
                            linePositions.push(x, y, z);
                        }
                        const isRedPoint = i === 0;
                        if (debugTextPathsFull || isRedPoint) {
                            const pointSize = pointScale * (isRedPoint ? 6 : 4);
                            const positions = isRedPoint ? redPointPositions : blackPointPositions;
                            const indices = isRedPoint ? redPointIndices : blackPointIndices;
                            positions.push(x, y - pointSize, z);
                            positions.push(x + pointSize, y, z);
                            positions.push(x, y + pointSize, z);
                            positions.push(x - pointSize, y, z);
                            const pointIndex = positions.length / 3;
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 3);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 4);
                            indices.push(pointIndex - 2);
                            indices.push(pointIndex - 1);
                            if (debugTextPathsFull) {
                                // give point index a label
                                const label = pathIndex % 5 === 0
                                    ? text + ":" + pathIndex
                                    : Number(pathIndex).toString();
                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX, y + centerY, z + centerZ), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue(technique.priority || 0, env), technique.xOffset || 0.0, technique.yOffset || 0.0);
                                labelElement.minZoomLevel = technique.minZoomLevel;
                                labelElement.mayOverlap = true;
                                labelElement.reserveSpace = false;
                                labelElement.alwaysOnTop = true;
                                labelElement.ignoreDistance = true;
                                labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;
                                this.addTextElement(labelElement);
                            }
                        }
                    }
                    // the lines of a path share a common geometry
                    const N = textPath.path.length / 3;
                    for (let i = 0; i < N; ++i) {
                        if (i > 0) {
                            lineIndices.push(baseVertex + i);
                        }
                        if (i + 1 < N) {
                            lineIndices.push(baseVertex + i);
                        }
                    }
                }
            }
            if (lineIndices.length > 0) {
                lineGeometry.addGroup(0, lineIndices.length, 0);
                lineGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(linePositions), 3));
                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));
                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);
                lineMesh.renderOrder = PRIORITY_ALWAYS - 2;
                this.objects.push(lineMesh);
            }
            if (redPointIndices.length > 0) {
                redPointGeometry.addGroup(0, redPointIndices.length, 0);
                redPointGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(redPointPositions), 3));
                redPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1));
                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);
                redPointMesh.renderOrder = PRIORITY_ALWAYS;
                this.objects.push(redPointMesh);
            }
            if (blackPointIndices.length > 0) {
                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);
                blackPointGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3));
                blackPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1));
                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);
                blackPointMesh.renderOrder = PRIORITY_ALWAYS - 1;
                this.objects.push(blackPointMesh);
            }
        }
    }
}
exports.OmvDebugLabelsTile = OmvDebugLabelsTile;
//# sourceMappingURL=OmvDebugLabelsTile.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OMV_TILER_SERVICE_TYPE = exports.OMV_TILE_DECODER_SERVICE_TYPE = exports.OmvGeometryType = exports.OmvFilterString = exports.FeatureModifierId = void 0;
/**
 * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.
 */
var FeatureModifierId;
(function (FeatureModifierId) {
    /**
     * Generic feature modifier used when no other modifiers are defined.
     *
     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default
     * if no other feature modifier is used.
     */
    FeatureModifierId[FeatureModifierId["default"] = 0] = "default";
    /**
     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.
     */
    FeatureModifierId[FeatureModifierId["tomTom"] = 1] = "tomTom";
})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));
/**
 * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.
 */
var OmvFilterString;
(function (OmvFilterString) {
    /**
     * Match condition.
     */
    let StringMatch;
    (function (StringMatch) {
        /** Matches any. */
        StringMatch[StringMatch["Any"] = 0] = "Any";
        /** Exact match. */
        StringMatch[StringMatch["Match"] = 1] = "Match";
        /** Matches if a test string starts with a filter string. */
        StringMatch[StringMatch["StartsWith"] = 2] = "StartsWith";
        /** Matches if a test string contains a filter string. */
        StringMatch[StringMatch["Contains"] = 3] = "Contains";
        /** Matches if a test string ends with a filter string. */
        StringMatch[StringMatch["EndsWith"] = 4] = "EndsWith";
    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));
    /**
     * Check for a string against a filter.
     *
     * @param str - The string to check against a filter.
     * @param filterString - The filter containing the match condition.
     * @returns `true` if the match condition is satisfied.
     */
    function matchString(str, filterString) {
        switch (filterString.match) {
            case OmvFilterString.StringMatch.Any:
                return true;
            case OmvFilterString.StringMatch.Match:
                return str === filterString.value;
            case OmvFilterString.StringMatch.StartsWith:
                return filterString.value.startsWith(str);
            case OmvFilterString.StringMatch.EndsWith:
                return filterString.value.endsWith(str);
            default:
                return str.indexOf(filterString.value) >= 0;
        }
    }
    OmvFilterString.matchString = matchString;
})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));
var OmvGeometryType;
(function (OmvGeometryType) {
    OmvGeometryType[OmvGeometryType["UNKNOWN"] = 0] = "UNKNOWN";
    OmvGeometryType[OmvGeometryType["POINT"] = 1] = "POINT";
    OmvGeometryType[OmvGeometryType["LINESTRING"] = 2] = "LINESTRING";
    OmvGeometryType[OmvGeometryType["POLYGON"] = 3] = "POLYGON";
})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));
/**
 * Default OMV tile decoder service type.
 *
 * Used for requesting decoder services using [[WorkerServiceManager]].
 */
exports.OMV_TILE_DECODER_SERVICE_TYPE = "omv-tile-decoder";
/**
 * Default OMV tiler service type.
 *
 * Used for requesting tiler services using [[WorkerServiceManager]].
 */
exports.OMV_TILER_SERVICE_TYPE = "omv-tiler";
//# sourceMappingURL=OmvDecoderDefs.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvRestClient = exports.AuthenticationTypeAccessToken = exports.AuthenticationTypeTomTomV1 = exports.AuthenticationTypeBearer = exports.AuthenticationMethod = exports.APIFormat = void 0;
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "./node_modules/@here/harp-transfer-manager/index.js");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "./node_modules/@here/harp-utils/index.web.js");
const logger = harp_utils_1.LoggerManager.instance.create("OmvRestClient");
// tslint:disable:max-line-length
var APIFormat;
(function (APIFormat) {
    /**
     * Use the REST API format of HERE Vector Tiles Server component version 1.
     *
     * Documentation:
     *  https://developer.here.com/documentation/vector-tiles-api/dev_guide/index.html
     *
     * Usage:
     *
     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv
     *
     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:
     *
     *     Authorization: Bearer $authenticationToken
     *
     * Format definition:
     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`
     *
     * Default authentication method used: [[AuthenticationTypeBearer]].
     */
    APIFormat[APIFormat["HereV1"] = 0] = "HereV1";
    /**
     * Use the REST API format of Mapbox Vector Tile API v4.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`
     *
     * Sample URL:
     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["MapboxV4"] = 1] = "MapboxV4";
    /**
     * Use the REST API format of XYZ Vector Tile API in MVT format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZMVT"] = 2] = "XYZMVT";
    /**
     * Use the REST API format of XYZ Vector Tile API in JSON format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZJson"] = 3] = "XYZJson";
    /**
     * Use the REST API format of XYZ Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZOMV"] = 4] = "XYZOMV";
    /**
     * Use the REST API format of Tomtoms Vector Tile API v1.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`
     *
     * Sample URL:
     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`
     *
     * Default authentication method used: [[AuthenticationTypeTomTomV1]].
     */
    APIFormat[APIFormat["TomtomV1"] = 5] = "TomtomV1";
    /**
     * Use the REST API format of XYZ Space Vector Tile API in OMV format.
     *
     * Usage:
     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZSpace"] = 6] = "XYZSpace";
})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["QueryString"] = 0] = "QueryString";
    AuthenticationMethod[AuthenticationMethod["AuthorizationHeader"] = 1] = "AuthorizationHeader";
})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));
/**
 * Authentication method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeBearer = {
    method: AuthenticationMethod.AuthorizationHeader,
    name: "Bearer"
};
/**
 * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeTomTomV1 = {
    method: AuthenticationMethod.QueryString,
    name: "key"
};
exports.AuthenticationTypeAccessToken = {
    method: AuthenticationMethod.QueryString,
    name: "access_token"
};
/**
 * REST client supporting getting protobuf OMV Tile from REST-based servers.
 */
class OmvRestClient {
    constructor(params) {
        this.params = params;
        this.downloadManager =
            params.downloadManager === undefined
                ? harp_transfer_manager_1.TransferManager.instance()
                : params.downloadManager;
        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;
    }
    /** Overriding abstract method, in this case doing nothing. */
    async connect() {
        // not needed
    }
    /** Overriding abstract method, in this case always returning `true`. */
    ready() {
        return true;
    }
    /**
     * Asynchronously fetches a tile from this restful server.
     *
     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is
     * returned.
     *
     * @example
     * ```typescript
     * const response = layer.getTile(tileKey);
     * if (!response.ok) {
     *     // a network error happened
     *     console.error("Unable to download tile", response.statusText);
     *     return;
     * }
     * if (response.status === 404) {
     *     // 404 -, no data exists at the given tile. Do nothing.
     *     return;
     * }
     *
     * // the response is ok and contains data, access it e.g. as arrayBuffer:
     * const payload = await response.arrayBuffer();
     * ```
     *
     * @param tileKey - The tile key of the tile.
     * @param tileRequestInit - Optional request options to be passed to fetch when downloading a
     * tile.
     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.
     */
    async getTile(tileKey, abortSignal) {
        const init = { signal: abortSignal };
        let tileUrl = this.dataUrl(tileKey);
        const authenticationCode = await this.getActualAuthenticationCode();
        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);
        tileUrl = this.addQueryParams(tileUrl, this.urlParams);
        if (this.params.apiFormat === APIFormat.XYZJson) {
            return this.downloadManager.downloadJson(tileUrl, init);
        }
        return this.downloadManager.downloadArrayBuffer(tileUrl, init);
    }
    /**
     * Get actual authentication code/token for this request according to configuration.
     */
    async getActualAuthenticationCode() {
        if (typeof this.params.authenticationCode === "string") {
            return this.params.authenticationCode;
        }
        else if (this.params.authenticationCode !== undefined) {
            return this.params.authenticationCode();
            // tslint:disable-next-line: deprecation
        }
        else if (this.params.getBearerToken !== undefined) {
            // tslint:disable-next-line: deprecation
            return this.params.getBearerToken();
        }
        else {
            return undefined;
        }
    }
    /**
     * Get default authnentication method basing on apiFormat and other params.
     */
    getDefaultAuthMethod() {
        // tslint:disable-next-line: deprecation
        if (this.params.getBearerToken !== undefined) {
            return exports.AuthenticationTypeBearer;
        }
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
                return exports.AuthenticationTypeBearer;
            case APIFormat.MapboxV4:
            case APIFormat.XYZOMV:
            case APIFormat.XYZMVT:
            case APIFormat.XYZSpace:
            case APIFormat.XYZJson:
                return exports.AuthenticationTypeAccessToken;
            case APIFormat.TomtomV1:
                return exports.AuthenticationTypeTomTomV1;
            default:
                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);
                return undefined;
        }
    }
    /**
     * Apply athentication code/token using configured (or default) authentication method.
     *
     * @param url -
     * @param init - request extra data
     * @param authenticationCode - authentication/token to be applied
     * @return new url to be used
     */
    applyAuthCode(url, init, authenticationCode) {
        if (authenticationCode === undefined) {
            return url;
        }
        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();
        if (authMethod === undefined) {
            return url;
        }
        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {
            if (init.headers === undefined) {
                init.headers = new Headers();
            }
            const authType = authMethod.name || "Bearer";
            init.headers.append("Authorization", `${authType} ${authenticationCode}`);
        }
        else if (authMethod.method === AuthenticationMethod.QueryString) {
            const attrName = authMethod.name || "access_token";
            const authParams = {};
            authParams[attrName] = authenticationCode;
            url = this.addQueryParams(url, authParams);
        }
        return url;
    }
    /**
     * Get actual tile URL depending on configured API format.
     */
    dataUrl(tileKey) {
        if (this.params.url !== undefined) {
            return this.params.url
                .replace("{x}", String(tileKey.column))
                .replace("{y}", String(tileKey.row))
                .replace("{z}", String(tileKey.level));
        }
        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ||
            this.params.apiFormat === APIFormat.XYZJson
            ? "_"
            : "/");
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
            case APIFormat.XYZOMV:
                path += "/omv";
                break;
            case APIFormat.MapboxV4:
                path += ".mvt";
                break;
            case APIFormat.XYZMVT:
                path += ".mvt";
                break;
            case APIFormat.XYZJson:
                break;
            case APIFormat.XYZSpace:
                path += ".mvt";
                break;
            case APIFormat.TomtomV1:
                path += ".pbf";
                break;
            default:
                logger.warn(`Not supported API format: ${this.params.apiFormat}`);
                break;
        }
        return this.params.baseUrl + path;
    }
    addQueryParams(url, queryParams) {
        let queryString = "";
        let concatinator = url.indexOf("?") !== -1 ? "&" : "?";
        Object.getOwnPropertyNames(queryParams).forEach(property => {
            const prop = property;
            queryString += concatinator + prop + "=" + queryParams[prop];
            if (concatinator === "?") {
                concatinator = "&";
            }
        });
        return url + queryString;
    }
}
exports.OmvRestClient = OmvRestClient;
//# sourceMappingURL=OmvRestClient.js.map

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvTile.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvTile = void 0;
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "./node_modules/@here/harp-mapview/index.js");
class OmvTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
}
exports.OmvTile = OmvTile;
//# sourceMappingURL=OmvTile.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * SDF based text rendering for TypeScript.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/rendering/FontCatalog */ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/TextCanvas */ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/MaterialUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/TextCanvas.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextCanvas = exports.DEFAULT_TEXT_CANVAS_LAYER = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js");
const TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js");
const PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js");
const MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js");
const tempTextPosition = new THREE.Vector3();
const tempTextBounds = {
    array: [new THREE.Box2()],
    offset: 0
};
let tempVertexBuffer = new Float32Array();
/**
 * Default's [[TextCanvas]] layer identifier.
 */
exports.DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
let TextCanvas = /** @class */ (() => {
    class TextCanvas {
        /**
         * Constructs a new `TextCanvas`.
         *
         * @param params - `TextCanvas` construction parameters.
         *
         * @returns New `TextCanvas`.
         */
        constructor(params) {
            this.m_renderer = params.renderer;
            this.m_fontCatalog = params.fontCatalog;
            this.minGlyphCount = params.minGlyphCount;
            this.maxGlyphCount = params.maxGlyphCount;
            if (params.material === undefined) {
                this.m_ownsMaterial = true;
                this.m_material = MaterialUtils_1.createSdfTextMaterial({ fontCatalog: params.fontCatalog });
            }
            else {
                this.m_ownsMaterial = false;
                this.m_material = params.material;
            }
            if (params.backgroundMaterial === undefined) {
                this.m_ownsBgMaterial = true;
                this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({
                    fontCatalog: params.fontCatalog,
                    isBackground: true
                });
            }
            else {
                this.m_ownsBgMaterial = false;
                this.m_bgMaterial = params.backgroundMaterial;
            }
            this.m_defaultLayer = {
                id: exports.DEFAULT_TEXT_CANVAS_LAYER,
                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
            };
            this.m_layers = [this.m_defaultLayer];
            this.m_currentTextRenderStyle = new TextStyle_1.TextRenderStyle().copy(TextCanvas.defaultTextRenderStyle);
            this.m_currentTextLayoutStyle = new TextStyle_1.TextLayoutStyle().copy(TextCanvas.defaultTextLayoutStyle);
            this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();
            this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();
        }
        /**
         * Currently active [[FontCatalog]].
         */
        get fontCatalog() {
            return this.m_fontCatalog;
        }
        set fontCatalog(value) {
            this.m_fontCatalog = value;
            const material = this.m_material;
            material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
            material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
            material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
            const bgMaterial = this.m_bgMaterial;
            bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
            bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
            bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
        }
        /**
         * Currently active text rendering material.
         */
        get material() {
            return this.m_material;
        }
        set material(value) {
            if (this.m_ownsMaterial) {
                this.m_material.dispose();
                this.m_ownsMaterial = false;
            }
            this.m_material = value;
            for (const layer of this.m_layers) {
                layer.storage.mesh.material = this.m_material;
            }
        }
        /**
         * Currently active text background rendering material.
         */
        get backgroundMaterial() {
            return this.m_bgMaterial;
        }
        set backgroundMaterial(value) {
            if (this.m_ownsBgMaterial) {
                this.m_bgMaterial.dispose();
                this.m_ownsBgMaterial = false;
            }
            this.m_bgMaterial = value;
            for (const layer of this.m_layers) {
                layer.storage.backgroundMesh.material = this.m_bgMaterial;
            }
        }
        /**
         * Currently active text rendering style.
         */
        get textRenderStyle() {
            return this.m_currentTextRenderStyle;
        }
        set textRenderStyle(style) {
            this.m_currentTextRenderStyle.copy(style);
        }
        /**
         * Currently active text layout style.
         */
        get textLayoutStyle() {
            return this.m_currentTextLayoutStyle;
        }
        set textLayoutStyle(style) {
            this.m_currentTextLayoutStyle.copy(style);
        }
        /**
         * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
         */
        clear() {
            for (const layer of this.m_layers) {
                layer.storage.clear();
            }
            this.m_currentTextRenderStyle.copy(TextCanvas.defaultTextRenderStyle);
            this.m_currentTextLayoutStyle.copy(TextCanvas.defaultTextLayoutStyle);
        }
        /**
         * Renders the content of this `TextCanvas`.
         *
         * @param camera - Orthographic camera.
         * @param target - Optional render target.
         * @param clear - Optional render target clear operation.
         */
        render(camera, target, clear) {
            this.m_fontCatalog.update(this.m_renderer);
            let oldTarget = null;
            if (target !== undefined) {
                oldTarget = this.m_renderer.getRenderTarget();
                this.m_renderer.setRenderTarget(target);
            }
            if (clear === true) {
                this.m_renderer.clear(true);
            }
            for (const layer of this.m_layers) {
                layer.storage.update();
                this.m_renderer.render(layer.storage.scene, camera);
            }
            if (target !== undefined) {
                this.m_renderer.setRenderTarget(oldTarget);
            }
        }
        /**
         * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
         * input `layerId`, it just returns this one instead.
         *
         * @param layerId - Desired layer identifier.
         *
         * @returns Created [[TextCanvasLayer]].
         */
        addLayer(layerId) {
            let result = this.getLayer(layerId);
            if (result === undefined) {
                result = {
                    id: layerId,
                    storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
                };
                this.m_layers.push(result);
                this.m_layers.sort((a, b) => {
                    return a.id - b.id;
                });
            }
            return result;
        }
        /**
         * Retrieves a specific `TextCanvas` rendering layer.
         *
         * @param layerId - Desired layer identifier.
         *
         * @returns Selected [[TextCanvasLayer]].
         */
        getLayer(layerId) {
            return this.m_layers.find(layer => layer.id === layerId);
        }
        /**
         * Retrieves all `TextCanvas` rendering layers.
         *
         * @returns Array of [[TextCanvasLayer]]s.
         */
        getAllLayers() {
            return this.m_layers;
        }
        /**
         * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
         * [[TextLayoutStyle]] will influence the results of this function.
         *
         * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
         * @param outputBounds - Output text bounding box.
         * @param params - Optional measurement parameters.
         *
         * @returns Result of the measurement. If `false`, some error occurred during execution and the
         * input text couldn't be properly measured.
         */
        measureText(text, outputBounds, params) {
            tempTextPosition.set(0, 0, 0);
            let path;
            let pathOverflow;
            let upperCaseArray;
            let outputCharacterBounds;
            if (params !== undefined) {
                path = params.path;
                pathOverflow = params.pathOverflow;
                outputCharacterBounds = params.outputCharacterBounds;
                if (params.path !== undefined) {
                    const pathOrigin = params.path.getPoint(0);
                    if (pathOrigin === null) {
                        return false;
                    }
                    tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);
                }
                if (params.letterCaseArray) {
                    upperCaseArray = params.letterCaseArray;
                }
            }
            return this.placeText({
                input: text,
                layer: this.m_defaultLayer,
                textPath: path,
                textPathOverflow: pathOverflow,
                bounds: outputBounds,
                individualBounds: outputCharacterBounds,
                letterCaseArray: upperCaseArray
            });
        }
        /**
         * Adds the input text to this `TextCanvas` in the specified screen position. The current
         * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
         *
         * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
         * @param position - Screen position.
         * @param params - Optional addition parameters.
         *
         * @returns Result of the addition. If `false`, some error occurred during execution and the
         * input text couldn't be properly added.
         */
        addText(text, position, params) {
            tempTextPosition.copy(position);
            let path;
            let pathOverflow;
            let upperCaseArray;
            let targetLayer = this.m_defaultLayer;
            if (params !== undefined) {
                path = params.path;
                pathOverflow = params.pathOverflow;
                if (params.layer !== undefined) {
                    let tempLayer = this.getLayer(params.layer);
                    if (tempLayer === undefined) {
                        tempLayer = this.addLayer(params.layer);
                    }
                    targetLayer = tempLayer;
                }
                if (params.path !== undefined) {
                    tempTextPosition.set(0, 0, tempTextPosition.z);
                }
                if (params.letterCaseArray) {
                    upperCaseArray = params.letterCaseArray;
                }
            }
            const prevDrawCount = targetLayer.storage.drawCount;
            const result = this.placeText({
                input: text,
                textPath: path,
                textPathOverflow: pathOverflow,
                layer: targetLayer,
                letterCaseArray: upperCaseArray
            });
            if (result && params !== undefined) {
                if (params.updatePosition === true) {
                    position.copy(tempTextPosition);
                }
                if (params.pickingData !== undefined) {
                    targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
                }
            }
            else if (!result) {
                targetLayer.storage.m_drawCount = prevDrawCount;
            }
            return result;
        }
        /**
         * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
         * result of performing the `addText` function for the input text in the screen origin.
         *
         * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
         * @param params - Optional creation parameters.
         *
         * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
         * retrieved from the current [[FontCatalog]]).
         */
        createTextBufferObject(text, params) {
            tempTextPosition.set(0, 0, 0);
            let glyphArray;
            let upperCaseArray;
            const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
            if (typeof text !== "string") {
                glyphArray = text;
                if (params !== undefined && params.letterCaseArray) {
                    upperCaseArray = params.letterCaseArray;
                }
            }
            else {
                upperCaseArray = [];
                glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);
                if (glyphArray === undefined) {
                    return undefined;
                }
            }
            let path;
            let pathOverflow;
            let textBounds;
            let characterBounds;
            let renderStyle;
            let layoutStyle;
            if (params !== undefined) {
                path = params.path;
                pathOverflow = params.pathOverflow;
                if (params.outputBounds === true) {
                    textBounds = new THREE.Box2();
                }
                if (params.outputCharacterBounds === true) {
                    characterBounds = [];
                }
                if (params.storeStyles === true) {
                    renderStyle = this.m_currentTextRenderStyle.clone();
                    layoutStyle = this.m_currentTextLayoutStyle.clone();
                }
            }
            this.placeText({
                input: text,
                layer: this.m_defaultLayer,
                computeTextBuffer: true,
                textPath: path,
                textPathOverflow: pathOverflow,
                bounds: textBounds,
                individualBounds: characterBounds,
                letterCaseArray: upperCaseArray
            });
            return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
        }
        /**
         * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
         * be provided to override the attributes stored in the buffer.
         *
         * @param textBufferObject - [[TextBufferObject]] to add.
         * @param params - Optional addition parameters.
         *
         * @returns Result of the addition. If `false`, some error occurred during execution and the
         * input text couldn't be properly added.
         */
        addTextBufferObject(textBufferObject, params) {
            var _a;
            let targetLayer = this.m_defaultLayer;
            let position;
            let scale;
            let rotation;
            let color;
            let opacity;
            let bgColor;
            let bgOpacity;
            if (params !== undefined) {
                if (params.layer !== undefined) {
                    let tempLayer = this.getLayer(params.layer);
                    if (tempLayer === undefined) {
                        tempLayer = this.addLayer(params.layer);
                    }
                    targetLayer = tempLayer;
                }
                position = (_a = params.position) === null || _a === void 0 ? void 0 : _a.clone();
                scale = params.scale;
                rotation = params.rotation;
                color = params.color;
                opacity = params.opacity;
                bgColor = params.backgroundColor;
                bgOpacity = params.backgroundOpacity;
            }
            const prevDrawCount = targetLayer.storage.drawCount;
            const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
            if (result && params !== undefined) {
                if (params.pickingData !== undefined) {
                    targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
                }
            }
            else if (!result) {
                targetLayer.storage.m_drawCount = prevDrawCount;
            }
            return result;
        }
        /**
         * Executes the `pickCallback` for all previously stored picking data for text covering the
         * specified screen position.
         *
         * @param screenPosition - Screen coordinate of picking position.
         * @param pickCallback - Callback to be called for every picked element.
         */
        pickText(position, callback) {
            for (const layer of this.m_layers) {
                layer.storage.pick(position, callback);
            }
        }
        /**
         * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
         *
         * @param info - The info object to increment with the values from this `TextCanvas`.
         */
        getMemoryUsage(info) {
            this.m_fontCatalog.updateMemoryUsage(info);
            for (const layer of this.m_layers) {
                layer.storage.updateMemoryUsage(info);
            }
        }
        // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs
        // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for
        // the input (as a whole or on a per-character basis).
        placeText(params) {
            if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
                if (params.bounds !== undefined) {
                    params.bounds.min.set(0, 0);
                    params.bounds.max.set(0, 0);
                }
                if (params.individualBounds !== undefined) {
                    params.individualBounds.length = 0;
                }
                return true;
            }
            let glyphArray;
            let smallCapsTransformations;
            const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
            if (typeof params.input !== "string") {
                glyphArray = params.input;
                if (params.letterCaseArray) {
                    smallCapsTransformations = params.letterCaseArray;
                }
            }
            else {
                smallCapsTransformations = [];
                glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);
                if (glyphArray === undefined) {
                    return false;
                }
            }
            let glyphBounds;
            if (params.individualBounds !== undefined) {
                tempTextBounds.array = params.individualBounds;
                tempTextBounds.offset = 0;
                glyphBounds = tempTextBounds;
            }
            if (params.bounds !== undefined) {
                params.bounds.min.set(Infinity, Infinity);
                params.bounds.max.set(-Infinity, -Infinity);
            }
            if (params.computeTextBuffer === true) {
                tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);
            }
            const isPath = params.textPath !== undefined;
            const typesettingParams = {
                glyphs: glyphArray,
                fontCatalog: this.m_fontCatalog,
                textRenderStyle: this.m_currentTextRenderStyle,
                textLayoutStyle: this.m_currentTextLayoutStyle,
                position: tempTextPosition,
                geometry: params.layer.storage,
                smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,
                globalBounds: params.bounds,
                individualBounds: glyphBounds,
                vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined
            };
            let result = true;
            if (isPath) {
                Object.assign(typesettingParams, {
                    path: params.textPath,
                    pathOverflow: params.textPathOverflow === true
                });
                result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
            }
            else {
                result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
            }
            if (glyphBounds !== undefined) {
                glyphBounds.array.length = glyphBounds.offset;
            }
            return result;
        }
    }
    TextCanvas.defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();
    TextCanvas.defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();
    return TextCanvas;
})();
exports.TextCanvas = TextCanvas;
//# sourceMappingURL=TextCanvas.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FontCatalog = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js");
const GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const ASSETS_PATH = "_Assets/";
const BOLD_ASSETS_PATH = "_BoldAssets/";
const ITALIC_ASSETS_PATH = "_ItalicAssets/";
const BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
const REPLACEMENT_PATH = "_Assets/Extra/";
/**
 * Collection of font assets used to render glyphs when using a [[TextCanvas]].
 *
 * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed
 * to cover the widest Unicode code point range possible. In order to manage all these assets
 * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and
 * assets for a block are only loaded once a glyph belonging to that block is requested.
 *
 * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture
 * resource, which can be sampled to render all currently loaded glyphs.
 *
 */
class FontCatalog {
    /**
     * @hidden
     * Creates a new FontCatalog.
     *
     * @param url - FontCatalog's URL.
     * @param name - FontCatalog's name.
     * @param type - FontCatalog's type (sdf or msdf).
     * @param size - FontCatalog's glyph size (pixels).
     * @param maxWidth - FontCatalog's maximum glyph width (pixels).
     * @param maxHeight - FontCatalog's maximum glyph height (pixels).
     * @param distanceRange - Distance range used to generate the SDF bitmaps.
     * @param fonts - Array of supported fonts.
     * @param unicodeBlocks - Array of supported Unicode blocks.
     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     * @param m_replacementGlyph - [[GlyphData]] to be used whenever a Unicode code point is not
     * supported by this `FontCatalog`.
     *
     * @returns New FontCatalog.
     */
    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        this.url = url;
        this.name = name;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = new Map();
        this.m_loadingPages = new Map();
        this.m_loadingGlyphs = new Map();
        this.m_loadedJson = new Map();
        this.m_loadedPages = new Map();
        this.m_loadedGlyphs = new Map();
    }
    /**
     * Loads a `FontCatalog`.
     *
     * @param url - Asset url.
     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     *
     * @returns `FontCatalog` Promise.
     */
    static async load(path, maxCodePointCount) {
        const url = new URL(path, window.location.href);
        const fontCatalog = await FontCatalog.loadJSON(url.href);
        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
        const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
        const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;
        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;
        replacementTexture.minFilter = THREE.NearestFilter;
        replacementTexture.needsUpdate = true;
        const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
        const replacementGlyph = new GlyphData_1.GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont);
        const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
        return fontCatalogInfo;
    }
    static async loadTexture(url) {
        return new Promise(resolve => {
            new THREE.TextureLoader().load(url, resolve);
        });
    }
    static async loadJSON(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`${url} Status Text:  ${response.statusText}`);
        }
        const rawJSON = await response.text();
        return JSON.parse(rawJSON);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.fonts.length = 0;
        this.unicodeBlocks.length = 0;
        this.m_glyphTextureCache.dispose();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Removes all loaded (and loading) assets.
     */
    clear() {
        this.m_glyphTextureCache.clear();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer - WebGLRenderer.
     */
    update(renderer) {
        this.m_glyphTextureCache.update(renderer);
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_glyphTextureCache.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_glyphTextureCache.textureSize;
    }
    /**
     * Current internal loading state.
     */
    get isLoading() {
        return (this.m_loadingJson.size > 0 ||
            this.m_loadingPages.size > 0 ||
            this.m_loadingGlyphs.size > 0);
    }
    /**
     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls
     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.
     *
     * @param block - Requested [[UnicodeBlock]].
     * @param font - [[Font]] to retrieve this Unicode block from.
     * @param fontStyle - [[FontStyle]] assets to load.
     * @param loadPages - If `true`, all pages in this Unicode block will also be loaded.
     *
     * @returns Loaded Unicode Block json.
     */
    async loadBlock(block, font, fontStyle, loadPages) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        let json = this.m_loadedJson.get(jsonPath);
        if (json === undefined) {
            let jsonPromise = this.m_loadingJson.get(jsonPath);
            if (jsonPromise === undefined) {
                try {
                    jsonPromise = FontCatalog.loadJSON(jsonPath);
                    this.m_loadingJson.set(jsonPath, jsonPromise);
                    json = await jsonPromise;
                    this.m_loadingJson.delete(jsonPath);
                    this.m_loadedJson.set(jsonPath, json);
                }
                catch (e) {
                    // tslint:disable-next-line:no-console
                    console.error(e);
                    this.m_loadingJson.delete(jsonPath);
                }
            }
            else {
                json = await jsonPromise;
            }
        }
        const pagePromises = [];
        if (loadPages === true) {
            for (const page of json.pages) {
                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
            }
        }
        await Promise.all(pagePromises);
        return json;
    }
    /**
     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).
     * Safe to call when no assets for this block have been loaded.
     *
     * @param block - Requested [[UnicodeBlock]].
     * @param font - [[Font]] to remove this Unicode block from.
     * @param fontStyle - [[FontStyle]] assets to remove.
     */
    removeBlock(block, font, fontStyle) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        const json = this.m_loadedJson.get(jsonPath);
        if (json !== undefined) {
            for (const page of json.pages) {
                const pagePath = `${assetsPath}/${page}`;
                this.m_loadingPages.delete(pagePath);
                this.m_loadedPages.delete(pagePath);
            }
            this.m_loadingJson.delete(jsonPath);
            this.m_loadedJson.delete(jsonPath);
        }
    }
    /**
     * Loads all the required glyphs needed to render the input text. Character repetition will not
     * be considered, and only styled assets (with applied font selection, style and variants) will
     * be loaded.
     *
     * @param input - Input text.
     * @param style - Specific [[TextRenderStyle]] for which glyphs will be loaded.
     *
     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.
     */
    async loadCharset(input, style) {
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||
            style.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
            return s.indexOf(c) + 1 ? "" : c;
        });
        const glyphPromises = [];
        for (const char of charset) {
            const codePoint = char.codePointAt(0);
            const font = this.getFont(codePoint, fontName);
            const fontHash = `${font.name}_${fontStyle}`;
            const glyphHash = `${fontHash}_${codePoint}`;
            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
            if (fontGlyphMap === undefined) {
                fontGlyphMap = new Map();
                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
            }
            const glyph = fontGlyphMap.get(codePoint);
            if (glyph === undefined) {
                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
                if (glyphPromise === undefined) {
                    if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {
                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
                        fontGlyphMap.set(codePoint, replacementGlyph);
                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                        continue;
                    }
                    let charUnicodeBlock;
                    for (const block of this.unicodeBlocks) {
                        if (codePoint >= block.min && codePoint <= block.max) {
                            charUnicodeBlock = block;
                            break;
                        }
                    }
                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                    glyphPromise.then((loadedGlyph) => {
                        this.m_loadingGlyphs.delete(glyphHash);
                        fontGlyphMap.set(codePoint, loadedGlyph);
                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                    });
                }
                glyphPromises.push(glyphPromise);
            }
            else if (!this.m_glyphTextureCache.has(glyphHash)) {
                glyphPromises.push(Promise.resolve(glyph));
                this.m_glyphTextureCache.add(glyphHash, glyph);
            }
        }
        return Promise.all(glyphPromises);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for a specific character.
     * Returns `undefined` if the assets for this glyph haven't been loaded yet.
     *
     * @param codePoint - Character's Unicode code point.
     * @param font - [[Font]] to get this glyph from.
     * @param fontStyle - Specific [[FontStyle]] to get glyphs for.
     *
     * @returns [[GlyphData]] for this code point.
     */
    getGlyph(codePoint, font, fontStyle) {
        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
        if (fontGlyphMap === undefined) {
            return undefined;
        }
        return fontGlyphMap.get(codePoint);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for the specified text.
     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.
     *
     * @param input - Input text.
     * @param style - Specific [[TextRenderStyle]] to get glyphs for.
     * @param letterCaseArray - Array containing the original letter case for the requested glyphs.
     *
     * @returns Array containing [[GlyphData]] for each character of the input text.
     */
    getGlyphs(input, style, letterCaseArray) {
        const result = [];
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const fontVariant = style.fontVariant;
        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;
        for (const character of input) {
            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
            for (const char of transformedCharacter) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const glyphData = this.getGlyph(codePoint, font, fontStyle);
                if (glyphData !== undefined) {
                    result.push(glyphData);
                    if (letterCaseArray !== undefined) {
                        letterCaseArray.push(char !== character);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Gets the best matched font for a specific character.
     *
     * @param codePoint - Character's Unicode code point.
     * @param fontName - Font name suggestion.
     *
     * @returns Best matched font.
     */
    getFont(codePoint, fontName) {
        let selectedFontName = this.fonts[0].name;
        for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
                selectedFontName =
                    fontName !== undefined &&
                        block.fonts.find(element => {
                            return element === fontName;
                        }) !== undefined
                        ? fontName
                        : block.fonts[0];
                break;
            }
        }
        return this.fonts.find(element => {
            return element.name === selectedFontName;
        });
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.
     *
     * @param info - The info object to increment with the values from this `FontCatalog`.
     */
    updateMemoryUsage(info) {
        let numBytes = 0;
        for (const block of this.unicodeBlocks) {
            numBytes += (block.max - block.min) * 2;
        }
        // Always stored in RGBA internally.
        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
        for (const page in this.m_loadedPages.entries) {
            if (this.m_loadedPages.get(page) !== undefined) {
                const loadedPage = this.m_loadedPages.get(page);
                if (loadedPage !== undefined) {
                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                }
            }
        }
        info.heapSize += numBytes + textureBytes;
        info.gpuSize += textureBytes;
    }
    createReplacementGlyph(codePoint, char, font) {
        const replacementGlyph = this.m_replacementGlyph.clone();
        replacementGlyph.codePoint = codePoint;
        replacementGlyph.character = char;
        replacementGlyph.font = font;
        return replacementGlyph;
    }
    async loadAssets(codePoint, fontStyle, block, font) {
        const json = await this.loadBlock(block, font, fontStyle);
        if (json === undefined) {
            return this.m_replacementGlyph;
        }
        const sourceGlyphData = json.chars.find(char => char.id === codePoint);
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
        const texture = await this.loadPage(texturePath);
        const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);
        return glyphData;
    }
    async loadPage(pagePath) {
        let page = this.m_loadedPages.get(pagePath);
        if (page === undefined) {
            let pagePromise = this.m_loadingPages.get(pagePath);
            if (pagePromise === undefined) {
                pagePromise = FontCatalog.loadTexture(pagePath);
                this.m_loadingPages.set(pagePath, pagePromise);
                page = await pagePromise;
                page.wrapS = THREE.ClampToEdgeWrapping;
                page.wrapT = THREE.ClampToEdgeWrapping;
                page.minFilter = THREE.NearestFilter;
                page.needsUpdate = true;
                if (this.m_loadingPages.delete(pagePath)) {
                    this.m_loadedPages.set(pagePath, page);
                }
                this.m_loadingPages.delete(pagePath);
            }
            else {
                page = await pagePromise;
            }
        }
        return page;
    }
    getAssetsPath(fontStyle, font) {
        let fontStylePath = ASSETS_PATH;
        switch (fontStyle) {
            case TextStyle_1.FontStyle.Bold:
                if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.Italic:
                if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.BoldItalic:
                if (font.boldItalic !== undefined) {
                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                }
                else if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                else if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
        }
        return `${this.url}/${this.name}${fontStylePath}${font.name}`;
    }
}
exports.FontCatalog = FontCatalog;
//# sourceMappingURL=FontCatalog.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlyphData = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * Structure containing all the required information necessary to render a BMFont glyph using
 * [[TextCanvas]].
 */
class GlyphData {
    /**
     * Creates a new `GlyphData` object.
     *
     * @param codePoint - Unicode code point.
     * @param block - Unicode block.
     * @param width - Glyph' width.
     * @param height - Glyph' height.
     * @param advanceX - Amount of pixel to move after placing this glyph.
     * @param offsetX - Horizontal offset from the glyph' origin.
     * @param offsetY - Vertical offset from the glyph' origin.
     * @param u0 - Glyph' left texture coordinate.
     * @param v0 - Glyph' bottom texture coordinate.
     * @param u1 - Glyph' right texture coordinate.
     * @param v1 - Glyph' top texture coordinate.
     * @param texture - Glyph' source texture atlas page.
     * @param font - Glyph' font.
     *
     * @returns New `GlyphData`.
     */
    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        /**
         * Array containing the positions for all corners of this glyph.
         */
        this.positions = [];
        /**
         * Array containing the source texture coordinates for all corners of this glyph.
         * Used to sample the original texture atlas pages.
         */
        this.sourceTextureCoordinates = [];
        /**
         * Array containing the dynamic texture coordinates for all corners of this glyph.
         * Used to sample the dynamic texture atlas page.
         */
        this.dynamicTextureCoordinates = [];
        /**
         * Source texture atlas' page copy index.
         */
        this.copyIndex = 0;
        /**
         * Flag indicating if glyph can be currently rendered.
         */
        this.isInCache = false;
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);
        const left = this.offsetX;
        const right = left + this.width;
        const top = font.metrics.lineHeight - this.offsetY;
        const bottom = top - this.height;
        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));
        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));
    }
    /**
     * Clone this `GlyphData`.
     *
     * @returns Cloned `GlyphData`.
     */
    clone() {
        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font);
    }
}
exports.GlyphData = GlyphData;
//# sourceMappingURL=GlyphData.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlyphTextureCache = void 0;
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "./node_modules/@here/harp-lrucache/index.js");
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js");
const TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js");
/**
 * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined
 * by the maximum number of texture units available on a pixel shader for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS
 */
const MAX_NUM_COPY_PAGES = 8;
/**
 * Maximum texture size supported. This amount is determined by the maximum texture size supported
 * for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE
 */
const MAX_TEXTURE_SIZE = 4096;
/**
 * @hidden
 * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].
 * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.
 */
class GlyphTextureCache {
    /**
     * Creates a `GlyphTextureCache` object.
     *
     * @param capacity - Cache's maximum glyph capacity.
     * @param entryWidth - Maximum entry width.
     * @param entryHeight - Maximum entry height.
     *
     * @returns New `GlyphTextureCache`.
     */
    constructor(capacity, entryWidth, entryHeight) {
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        const nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            // tslint:disable-next-line:no-console
            console.warn("GlyphTextureCache texture size (" +
                this.m_textureSize.x +
                ", " +
                this.m_textureSize.y +
                ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" +
                MAX_TEXTURE_SIZE +
                ").\n" +
                "This could result in rendering errors on some devices.\n" +
                "Please consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE.Scene();
        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = new Set();
        this.m_copyTransform = new THREE.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
        this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial();
        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE.BufferGeometry();
        this.m_copyGeometry.setAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.setAttribute("uv", this.m_copyUVAttribute);
        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial();
        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry = new THREE.BufferGeometry();
        this.m_clearGeometry.setAttribute("position", this.m_clearPositionAttribute);
        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.m_entryCache.clear();
        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
        this.m_rt.dispose();
        this.m_clearMaterial.dispose();
        this.m_copyMaterial.dispose();
        this.m_copyTextureSet.clear();
        this.m_clearGeometry.dispose();
        this.m_copyGeometry.dispose();
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_rt.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_textureSize;
    }
    /**
     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested
     * entry will be replaced.
     *
     * @param hash - Entry's hash.
     * @param glyph - Entry's glyph data.
     */
    add(hash, glyph) {
        const entry = this.m_entryCache.get(hash);
        if (entry !== undefined) {
            return;
        }
        const oldestEntry = this.m_entryCache.oldest;
        if (oldestEntry === null) {
            throw new Error("GlyphTextureCache is uninitialized!");
        }
        this.clearCacheEntry(oldestEntry.value);
        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
    }
    /**
     * Checks if an entry is in the cache.
     *
     * @param hash - Entry's hash.
     *
     * @returns Test result.
     */
    has(hash) {
        return this.m_entryCache.has(hash);
    }
    /**
     * Retrieves an entry from the cache.
     *
     * @param hash - Entry's hash.
     *
     * @returns Retrieval result.
     */
    get(hash) {
        return this.m_entryCache.get(hash);
    }
    /**
     * Clears the internal LRUCache.
     */
    clear() {
        this.m_copyGeometryDrawCount = 0;
        this.m_clearGeometryDrawCount = 0;
        this.m_entryCache.clear();
        this.m_copyTextureSet.clear();
        this.initCacheEntries();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer - WebGLRenderer.
     */
    update(renderer) {
        let oldRenderTarget = null;
        const willClearGeometry = this.m_clearGeometryDrawCount > 0;
        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
        if (willClearGeometry || willCopyGeometry) {
            oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.m_rt);
        }
        if (willClearGeometry) {
            if (this.m_clearGeometry.index === null) {
                throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
            }
            this.m_clearPositionAttribute.needsUpdate = true;
            this.m_clearPositionAttribute.updateRange.offset = 0;
            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
            this.m_clearGeometry.index.needsUpdate = true;
            this.m_clearGeometry.index.updateRange.offset = 0;
            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
            this.m_clearMesh.visible = true;
            this.m_copyMesh.visible = false;
            renderer.render(this.m_scene, this.m_camera);
            this.m_clearGeometryDrawCount = 0;
            this.m_clearMesh.visible = false;
        }
        if (willCopyGeometry) {
            if (this.m_copyGeometry.index === null) {
                throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
            }
            this.m_copyVertexBuffer.needsUpdate = true;
            this.m_copyVertexBuffer.updateRange.offset = 0;
            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
            this.m_copyGeometry.index.needsUpdate = true;
            this.m_copyGeometry.index.updateRange.offset = 0;
            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
            this.m_copyMesh.visible = true;
            const srcPages = Array.from(this.m_copyTextureSet);
            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
                    const pageIndex = pageOffset + i;
                    if (pageIndex < this.m_copyTextureSet.size) {
                        this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                    }
                }
                renderer.render(this.m_scene, this.m_camera);
            }
            this.m_copyTextureSet.clear();
            this.m_copyGeometryDrawCount = 0;
        }
        if (willClearGeometry || willCopyGeometry) {
            renderer.setRenderTarget(oldRenderTarget);
        }
    }
    initCacheEntries() {
        const dummyMetrics = {
            size: 0,
            distanceRange: 0,
            base: 0,
            lineHeight: 0,
            lineGap: 0,
            capHeight: 0,
            xHeight: 0
        };
        const dummyFont = {
            name: "",
            metrics: dummyMetrics,
            charset: ""
        };
        const dummyGlyphData = new GlyphData_1.GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);
        for (let i = 0; i < this.m_cacheHeight; i++) {
            for (let j = 0; j < this.m_cacheWidth; j++) {
                const dummyEntry = {
                    glyphData: dummyGlyphData,
                    location: new THREE.Vector2(j, i)
                };
                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
            }
        }
    }
    copyGlyphToCache(hash, glyph, cacheLocation) {
        this.m_copyTextureSet.add(glyph.texture);
        let copyTextureIndex = 0;
        for (const value of this.m_copyTextureSet.values()) {
            if (value === glyph.texture) {
                break;
            }
            copyTextureIndex++;
        }
        glyph.copyIndex = copyTextureIndex;
        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
        }
        if (this.m_copyGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_copyGeometryDrawCount * 4;
        const baseIndex = this.m_copyGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
        }
        if (this.m_copyGeometry.index === null) {
            throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
        }
        this.m_copyGeometry.index.setX(baseIndex, baseVertex);
        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_copyGeometryDrawCount;
        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
        glyph.dynamicTextureCoordinates[0].set(u0, v0);
        glyph.dynamicTextureCoordinates[1].set(u1, v0);
        glyph.dynamicTextureCoordinates[2].set(u0, v1);
        glyph.dynamicTextureCoordinates[3].set(u1, v1);
        glyph.isInCache = true;
        this.m_entryCache.set(hash, {
            glyphData: glyph,
            location: cacheLocation
        });
    }
    clearCacheEntry(entry) {
        entry.glyphData.isInCache = false;
        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        if (this.m_clearGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_clearGeometryDrawCount * 4;
        const baseIndex = this.m_clearGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
        }
        if (this.m_clearGeometry.index === null) {
            throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
        }
        this.m_clearGeometry.index.setX(baseIndex, baseVertex);
        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_clearGeometryDrawCount;
    }
}
exports.GlyphTextureCache = GlyphTextureCache;
//# sourceMappingURL=GlyphTextureCache.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextBufferObject = void 0;
/**
 * Object containing vertex buffer data generated by [[TextCanvas]].
 */
class TextBufferObject {
    /**
     * Constructs a new `TextBufferObject`.
     *
     * @param glyphs - Input glyphs.
     * @param buffer - Buffer containing the data generated by [[TextCanvas]].
     * @param bounds - Optional text bounds.
     * @param characterBounds - Optional character bounds.
     * @param textRenderStyle - [[TextRenderStyle]] applied by [[TextCanvas]].
     * @param textLayoutStyle - [[TextLayoutStyle]] applied by [[TextCanvas]].
     *
     * @returns New `TextBufferObject`.
     */
    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
        this.glyphs = glyphs;
        this.buffer = buffer;
        this.bounds = bounds;
        this.characterBounds = characterBounds;
        this.textRenderStyle = textRenderStyle;
        this.textLayoutStyle = textLayoutStyle;
    }
}
exports.TextBufferObject = TextBufferObject;
//# sourceMappingURL=TextBufferObject.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TextGeometry = exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD = exports.VERTICES_PER_QUAD = exports.INDEX_BUFFER_STRIDE = exports.VERTEX_BUFFER_STRIDE = exports.MAX_CAPACITY = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
exports.MAX_CAPACITY = 65536;
exports.VERTEX_BUFFER_STRIDE = 16;
exports.INDEX_BUFFER_STRIDE = 1;
exports.VERTICES_PER_QUAD = 4;
exports.INDICES_PER_QUAD = 6;
exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;
exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].
 */
class TextGeometry {
    /**
     * Creates a new `TextGeometry`.
     *
     * @param material - Material used to render foreground glyphs.
     * @param backgroundMaterial - Material used to render background glyphs.
     * @param initialSize - Initial amount of glyphs that can be stored.
     * @param capacity - Maximum glyph capacity.
     *
     * @returns New `TextGeometry`.
     */
    constructor(scene, material, backgroundMaterial, initialSize, capacity) {
        this.scene = scene;
        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray = new Array(this.m_currentCapacity);
        this.m_mesh = new THREE.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    /**
     * Count of currently drawn glyphs.
     */
    get drawCount() {
        return this.m_drawCount;
    }
    /**
     * Mesh used to render foreground glyphs.
     */
    get mesh() {
        return this.m_mesh;
    }
    /**
     * Mesh used to render background glyphs.
     */
    get backgroundMesh() {
        return this.m_bgMesh;
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_geometry.dispose();
    }
    /**
     * Clear the geometry.
     */
    clear() {
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingCount = 0;
    }
    /**
     * Update the GPU resources to reflect the latest additions to the geometry.
     */
    update() {
        if (this.drawCount > this.m_updateOffset) {
            this.m_vertexBuffer.needsUpdate = true;
            this.m_vertexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_vertexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.needsUpdate = true;
            this.m_indexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
        }
        this.m_updateOffset = this.m_drawCount;
        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);
    }
    /**
     * Add a new glyph to the `TextGeometry`.
     *
     * @param glyphData - [[GlyphData]] holding the glyph description.
     * @param corners - Transformed glyph corners.
     * @param weight - Foreground glyph sampling weight.
     * @param bgWeight - Foreground glyph sampling weight.
     * @param mirrored - If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).
     * @param style - Currently set [[TextRenderStyle]].
     *
     * @returns Result of the addition.
     */
    add(glyphData, corners, weight, bgWeight, mirrored, style) {
        if (this.m_drawCount >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;
        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
        }
        this.m_indexBuffer.setX(baseIndex, baseVertex);
        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_drawCount;
        return true;
    }
    /**
     * Add a new glyph to a text buffer.
     *
     * @param buffer - Target buffer where glyph attributes will be stored.
     * @param offset - Offset of the target buffer.
     * @param glyphData - [[GlyphData]] holding the glyph description.
     * @param corners - Transformed glyph corners.
     * @param weight - Foreground glyph sampling weight.
     * @param bgWeight - Foreground glyph sampling weight.
     * @param mirrored - If `true`, UVs will be mirrored (needed for RTL punctuation).
     * @param style - Currently set [[TextRenderStyle]].
     */
    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;
            buffer[vertexOffset] = corners[i].x;
            buffer[vertexOffset + 1] = corners[i].y;
            buffer[vertexOffset + 2] = corners[i].z;
            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
            buffer[vertexOffset + 6] = weight;
            buffer[vertexOffset + 7] = bgWeight;
            buffer[vertexOffset + 8] = style.color.r;
            buffer[vertexOffset + 9] = style.color.g;
            buffer[vertexOffset + 10] = style.color.b;
            buffer[vertexOffset + 11] = style.opacity;
            buffer[vertexOffset + 12] = style.backgroundColor.r;
            buffer[vertexOffset + 13] = style.backgroundColor.g;
            buffer[vertexOffset + 14] = style.backgroundColor.b;
            buffer[vertexOffset + 15] = style.backgroundOpacity;
        }
    }
    /**
     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can
     * be passed to override the passed attribute data.
     *
     * @param textBufferObject - [[TextBufferObject]] containing computed glyphs.
     * @param position - Override position value.
     * @param scale - Override scale value.
     * @param rotation - Override rotation value.
     * @param color - Override color value.
     * @param opacity - Override opacity value.
     * @param bgColor - Override background color value.
     * @param bgOpacity - Override background opacity value.
     *
     * @returns Result of the addition.
     */
    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const s = scale || 1.0;
        const r = rotation || 0.0;
        const cosR = Math.cos(r);
        const sinR = Math.sin(r);
        const offsetX = position !== undefined ? position.x : 0.0;
        const offsetY = position !== undefined ? position.y : 0.0;
        const offsetZ = position !== undefined ? position.z : 0.0;
        const buffer = textBufferObject.buffer;
        const rot = buffer[3];
        const rotSign = rot < 0 ? -1.0 : 1.0;
        const red = color !== undefined ? color.r : buffer[8];
        const green = color !== undefined ? color.g : buffer[9];
        const blue = color !== undefined ? color.b : buffer[10];
        const alpha = opacity !== undefined ? opacity : buffer[11];
        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];
        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];
        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];
        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];
        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;
        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            const glyph = textBufferObject.glyphs[i];
            if (!glyph.isInCache) {
                return false;
            }
            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];
            const w = buffer[srcOffset + 6];
            const bw = buffer[srcOffset + 7];
            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {
                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];
                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];
                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;
                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);
                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
            }
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);
        }
        this.m_drawCount += textBufferObject.glyphs.length;
        return true;
    }
    /**
     * Adds picking data for glyphs from the specified start until the last glyph added.
     *
     * @param startIdx - First glyph index that this picking data is associated to.
     * @param endIdx - Last glyph index that this picking data is associated to.
     * @param pickingData - Picking data to be added.
     */
    addPickingData(startIdx, endIdx, pickingData) {
        if (this.m_pickingCount >= this.m_currentCapacity) {
            return false;
        }
        this.m_pickingDataArray[this.m_pickingCount] = {
            start: Math.min(startIdx, this.capacity),
            end: Math.min(endIdx, this.capacity),
            data: pickingData
        };
        ++this.m_pickingCount;
        return true;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs
     * are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pick(screenPosition, pickCallback) {
        for (const pickingData of this.m_pickingDataArray) {
            if (pickingData === undefined) {
                return;
            }
            for (let i = pickingData.start; i < pickingData.end; ++i) {
                const positionIndex = i * exports.VERTICES_PER_QUAD;
                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x < minX) {
                    continue;
                }
                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x > maxX) {
                    continue;
                }
                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y < minY) {
                    continue;
                }
                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y > maxY) {
                    continue;
                }
                pickCallback(pickingData.data);
                break;
            }
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.
     *
     * @param info - The info object to increment with the values from this `TextGeometry`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +
            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    resizeBuffers(size) {
        this.m_currentCapacity = size;
        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);
        newVertexBuffer.set(this.m_vertexBuffer.array);
        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);
        newIndexBuffer.set(this.m_indexBuffer.array);
        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry.dispose();
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray.length = this.m_currentCapacity;
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
}
exports.TextGeometry = TextGeometry;
//# sourceMappingURL=TextGeometry.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdfTextMaterial = exports.GlyphCopyMaterial = exports.GlyphClearMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const SdfShaderChunks = {
    sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
    sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
    sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
    sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
    sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(sample.r, sample.g, sample.b);
            #else
            return sample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE.ShaderChunk, SdfShaderChunks);
const clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
const copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 sample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);
        else sample = texture2D(page7, vUv.xy);

        gl_FragColor = sample;
    }`;
const sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
const sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
/**
 * @hidden
 * Material used for clearing glyphs from a [[GlyphTextureCache]].
 */
class GlyphClearMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphClearMaterial`.
     *
     * @returns New `GlyphClearMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphClearMaterial",
            vertexShader: clearVertexSource,
            fragmentShader: clearFragmentSource,
            uniforms: {},
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphClearMaterial = GlyphClearMaterial;
/**
 * @hidden
 * Material used for copying glyphs into a [[GlyphTextureCache]].
 */
class GlyphCopyMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `GlyphCopyMaterial`.
     *
     * @returns New `GlyphCopyMaterial`.
     */
    constructor() {
        const shaderParams = {
            name: "GlyphCopyMaterial",
            vertexShader: copyVertexSource,
            fragmentShader: copyFragmentSource,
            uniforms: {
                pageOffset: new THREE.Uniform(0.0),
                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)
            },
            depthTest: false,
            depthWrite: false
        };
        super(shaderParams);
    }
}
exports.GlyphCopyMaterial = GlyphCopyMaterial;
/**
 * Material designed to render transformable, high quality SDF text.
 */
class SdfTextMaterial extends THREE.RawShaderMaterial {
    /**
     * Creates a new `SdfTextMaterial`.
     *
     * @param params - Material parameters.
     *
     * @returns New `SdfTextMaterial`.
     */
    constructor(params) {
        const shaderParams = {
            name: "SdfTextMaterial",
            vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,
            fragmentShader: params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,
            uniforms: {
                sdfTexture: new THREE.Uniform(params.texture),
                sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
            },
            defines: {
                MSDF: params.isMsdf ? 1.0 : 0.0,
                BG_TEXT: params.isBackground ? 1.0 : 0.0
            },
            depthTest: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            transparent: true
        };
        super(shaderParams);
        this.extensions.derivatives = true;
    }
}
exports.SdfTextMaterial = SdfTextMaterial;
//# sourceMappingURL=TextMaterials.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePlacementAndAlignment = exports.TextLayoutStyle = exports.TextRenderStyle = exports.DefaultTextStyle = exports.vPlacementFromAlignment = exports.hPlacementFromAlignment = exports.vAlignFromPlacement = exports.hAlignFromPlacement = exports.WrappingMode = exports.HorizontalPlacement = exports.VerticalPlacement = exports.HorizontalAlignment = exports.VerticalAlignment = exports.FontVariant = exports.FontStyle = exports.FontUnit = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Vertical position of text area relative to the placement context (point, line).
 */
var VerticalPlacement;
(function (VerticalPlacement) {
    VerticalPlacement[VerticalPlacement["Top"] = 0] = "Top";
    VerticalPlacement[VerticalPlacement["Center"] = -0.5] = "Center";
    VerticalPlacement[VerticalPlacement["Bottom"] = -1] = "Bottom";
})(VerticalPlacement = exports.VerticalPlacement || (exports.VerticalPlacement = {}));
/**
 * Horizontal position of text element relative to the placement context (point, line).
 *
 * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,
 * cause when you place text on the right side of point (or icon) it will be left-aligned.
 */
var HorizontalPlacement;
(function (HorizontalPlacement) {
    HorizontalPlacement[HorizontalPlacement["Left"] = -1] = "Left";
    HorizontalPlacement[HorizontalPlacement["Center"] = -0.5] = "Center";
    HorizontalPlacement[HorizontalPlacement["Right"] = 0] = "Right";
})(HorizontalPlacement = exports.HorizontalPlacement || (exports.HorizontalPlacement = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].
 * Horizontal alignments are exactly opposite to the placements.
 */
function hAlignFromPlacement(hP) {
    return hP;
}
exports.hAlignFromPlacement = hAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].
 */
function vAlignFromPlacement(vP) {
    return vP;
}
exports.vAlignFromPlacement = vAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].
 * Horizontal placements are exactly opposite to the alignment values.
 */
function hPlacementFromAlignment(hA) {
    return hA;
}
exports.hPlacementFromAlignment = hPlacementFromAlignment;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].
 */
function vPlacementFromAlignment(vA) {
    return vA;
}
exports.vPlacementFromAlignment = vPlacementFromAlignment;
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
    DefaultTextStyle.DEFAULT_PLACEMENTS = [];
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? Object.assign({}, params.fontSize) : {
                unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
            },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color.clone()
                : DefaultTextStyle.DEFAULT_COLOR.clone(),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor.clone()
                : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = Object.assign({}, value);
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color.copy(value);
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor.copy(value);
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this [[TextRenderStyle]].
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns Cloned [[TextRenderStyle]].
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextRenderStyle]] properties into this object instance.
     *
     * @param source - The source object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(source) {
        // Given that all source and this params are always defined:
        this.m_params.fontName = source.fontName;
        this.m_params.fontSize = Object.assign({}, source.fontSize);
        this.m_params.fontStyle = source.fontStyle;
        this.m_params.fontVariant = source.fontVariant;
        this.m_params.rotation = source.rotation;
        this.m_params.color.copy(source.color);
        this.m_params.backgroundColor.copy(source.backgroundColor);
        this.m_params.opacity = source.opacity;
        this.m_params.backgroundOpacity = source.backgroundOpacity;
        return this;
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        // Solve alignment and placement dependencies and fallbacks.
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements);
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment,
            horizontalAlignment,
            placements
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Text placement options relative to label anchor (origin).
     *
     * @note [[TextPlacement]]s options may override alignment settings.
     */
    get placements() {
        return this.m_params.placements;
    }
    set placements(value) {
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value);
        this.m_params.horizontalAlignment = horizontalAlignment;
        this.m_params.verticalAlignment = verticalAlignment;
        this.m_params.placements = placements;
    }
    /**
     * Clone this [[TextLayoutStyle]].
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns Cloned [[TextLayoutStyle]].
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextLayoutStyle]] properties into this object instance.
     *
     * @param other - The object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(other) {
        this.params = Object.assign({}, other.params);
        return this;
    }
}
exports.TextLayoutStyle = TextLayoutStyle;
/**
 * Deduce alignment and placement attributes depending on the availability.
 *
 * If placement is defined it may override alignment settings, if no attributes are
 * provided they may be retrieved from defaults.
 *
 * @param hAlignment - The optional horizontal alignment.
 * @param vAlignment - The vertical alignment - optional.
 * @param placementsOpt - Possible text placements - optional.
 * @internal
 */
function resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {
    var _a;
    // Make a deep copy or create new array from defaults.
    const placements = (_a = placementsOpt === null || placementsOpt === void 0 ? void 0 : placementsOpt.map(v => (Object.assign({}, v)))) !== null && _a !== void 0 ? _a : DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => (Object.assign({}, v)));
    // Ignore alignment attributes when placements attributes are defined or provide default
    // values if none of them are provided.
    // NOTE: Alignment override may be removed if we decide to support both attributes.
    const horizontalAlignment = placements.length > 0
        ? hAlignFromPlacement(placements[0].h)
        : hAlignment !== null && hAlignment !== void 0 ? hAlignment : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
    const verticalAlignment = placements.length > 0
        ? vAlignFromPlacement(placements[0].v)
        : vAlignment !== null && vAlignment !== void 0 ? vAlignment : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
    return { horizontalAlignment, verticalAlignment, placements };
}
exports.resolvePlacementAndAlignment = resolvePlacementAndAlignment;
//# sourceMappingURL=TextStyle.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineTypesetter = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * [[Typesetter]] implementation that handles multi-line complex layout text.
 */
class LineTypesetter {
    /**
     * Creates a `LineTypesetter` object.
     *
     * @returns New `LineTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
    }
    /**
     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple
     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,
     * such as:
     * - Maximum line width.
     * - Word and character wrapping.
     * - Maximum number of lines.
     * - Vertical and horizontal alignment.
     * - Leading (spacing between lines).
     *
     * @param params - Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_currentParams.position.y +=
            this.m_currentParams.textLayoutStyle.verticalAlignment *
                this.m_currentParams.glyphs[0].font.metrics.capHeight *
                this.m_tempScale;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // Compute line origin and height.
        const origin = this.m_currentParams.position.x;
        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +
            this.m_currentParams.textLayoutStyle.leading;
        // Initialize line-breaking and wrapping variables.
        let lineStartIdx = 0;
        let glyphWrapIdx = 0;
        let wordWrapIdx = 0;
        let lineStartX = 0;
        let lineCurrX = 0;
        let glyphWrapX = 0;
        let wordWrapX = 0;
        let lineCount = 0;
        let isBidirectionalLine = false;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                break;
            }
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);
            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);
            // Check if this line should be treated as bidirectional.
            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectionalLine = true;
            }
            // Advance the line's current X offset (only for printable characters).
            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                lineCurrX +=
                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                        this.m_tempScale *
                        (this.m_tempSmallCaps
                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                            : 1.0);
            }
            // If this is the first character in a line, update the line's X offset values (needed
            // to properly center and wrap).
            if (i === lineStartIdx) {
                lineStartX = lineCurrX;
                glyphWrapX = lineCurrX;
                wordWrapX = lineCurrX;
            }
            // Check if should break the current line.
            if (isNewLine ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Character &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&
                    wordWrapX !== lineStartX)) {
                // Perform wrapping.
                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {
                    let wrapPointIdx = glyphWrapIdx;
                    let wrapPointX = glyphWrapX;
                    // Only wrap words when more than a single word fits into the current line.
                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                        wordWrapX !== lineStartX) {
                        wrapPointIdx = wordWrapIdx;
                        wrapPointX = wordWrapX;
                    }
                    lineCurrX = wrapPointX;
                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                }
                // Calculate the correct starting position for the line base on alignment, and place
                // all glyphs in it.
                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                this.m_currentParams.position.x =
                    this.m_currentParams.position.x + lineCurrX * lineAlignment;
                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                    return false;
                }
                // Update the line position.
                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                this.m_currentParams.position.x = origin;
                // Find the beginning of a new line (removing trailing white spaces).
                while (i !== lineStartIdx &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
                    ++i;
                }
                lineStartIdx = i + 1;
                if (lineStartIdx === this.m_currentParams.glyphs.length) {
                    break;
                }
                // Only reset the line's direction when a new line character is found (to keep
                // correct bidirectional behaviour when a bidirectional run is placed between
                // multiple lines).
                if (isNewLine) {
                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                    this.m_tempRunDirection = this.m_tempLineDirection;
                }
                // Reset the line placement parameters.
                lineStartX = 0;
                lineCurrX = 0;
                glyphWrapIdx = lineStartIdx;
                glyphWrapX = 0;
                wordWrapIdx = lineStartIdx;
                wordWrapX = 0;
                isBidirectionalLine = false;
                lineCount++;
            }
            // If not, should if we should record any new wrapping points.
            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                !isWhiteSpace) {
                // Update the per-glyph wrapping point.
                glyphWrapIdx = i;
                glyphWrapX = lineCurrX;
                // Update the word wrapping point (only if mode is correctly set and we are
                // currently placed at the end of a word).
                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||
                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                    wordWrapIdx = i;
                    wordWrapX = lineCurrX;
                }
            }
        }
        // If we still haven't placed all characters, place a final line.
        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&
            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                : this.m_currentParams.textLayoutStyle.horizontalAlignment;
            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                return false;
            }
        }
        return true;
    }
    // Place characters alongside a line. Text direction is taken into account, and text is broken
    // into directional runs.
    placeLine(startIdx, endIdx, direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(startIdx, endIdx, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        // Initialize line placement parameters.
        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
        const origin = position.x;
        let offset = 0;
        let runStart = startIdx;
        for (let i = startIdx; i <= endIdx; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (isRTL) {
                    position.x = origin + offset;
                }
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                if (!isRTL) {
                    position.x = origin + offset;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
            // Advance the offset position in the line.
            offset +=
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)
                        : 1.0) *
                    direction;
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart <= endIdx) {
            if (isRTL) {
                position.x = origin + offset;
            }
            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                return false;
            }
            if (!isRTL) {
                position.x = origin + offset;
            }
        }
        return true;
    }
    // Place a directional run of index inside a line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Advance the current position and proceed to next glyph in the run.
            position.set(position.x +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.cos(textLayoutStyle.lineRotation), position.y +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.sin(textLayoutStyle.lineRotation), position.z);
        }
        return true;
    }
}
exports.LineTypesetter = LineTypesetter;
//# sourceMappingURL=LineTypesetter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathTypesetter = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * [[Typesetter]] implementation that arranges glyphs alongside a specified path.
 */
class PathTypesetter {
    /**
     * Creates a `PathTypesetter` object.
     *
     * @returns New `PathTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE.Vector3();
        this.m_tempPathLength = 0.0;
        this.m_tempPathOffset = 0.0;
    }
    /**
     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single
     * bidirectional line that follows the specified path. Characters will be orientated and placed
     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and
     * [[HorizontalAlignment]].
     *
     * @param params - Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_tempPathLength = this.m_currentParams.path.getLength();
        this.m_tempPathOffset = 0.0;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // To be able to properly set the horizontal alignment on a path, we need to first retrieve
        // how much of the path the input text covers, so we can calculate the correct initial
        // offset.
        let isBidirectional = false;
        let pathWidth = 0.0;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectional = true;
            }
            pathWidth +=
                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                        : 1.0);
        }
        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +
            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /
                this.m_tempPathLength, 0), 1);
        // Place the input text as a single path line.
        return this.placeLine(this.m_tempLineDirection, isBidirectional);
    }
    // Place characters alongside a path line. Text direction is taken into account, and text is
    // broken into directional runs.
    placeLine(direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        // Initialize line placement parameters.
        let runStart = 0;
        for (let i = runStart; i < glyphDataArray.length; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart < glyphDataArray.length) {
            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                return false;
            }
        }
        return true;
    }
    // Place a directional run of index inside a path line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        const path = this.m_currentParams.path;
        const defaultGlyphRotation = textRenderStyle.rotation;
        const normalDisplacement = textLayoutStyle.verticalAlignment *
            glyphDataArray[0].font.metrics.capHeight *
            this.m_tempScale;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Update the current interpolated path position and angle.
            const textPoint = path.getPoint(this.m_tempPathOffset);
            if (textPoint === null) {
                return this.m_currentParams.pathOverflow;
            }
            const tangent = path.getTangent(this.m_tempPathOffset);
            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
            const angle = Math.atan2(tangent.y, tangent.x);
            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
            textRenderStyle.rotation = defaultGlyphRotation + angle;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                this.m_tempCorners[j].x -= position.x;
                this.m_tempCorners[j].y -= position.y;
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Restore the original glyph rotation.
            textRenderStyle.rotation = defaultGlyphRotation;
            // Advance the current position and proceed to next glyph in the run.
            this.m_tempPathOffset +=
                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /
                    this.m_tempPathLength;
        }
        return true;
    }
}
exports.PathTypesetter = PathTypesetter;
//# sourceMappingURL=PathTypesetter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextualArabicConverter = void 0;
var ContextualForm;
(function (ContextualForm) {
    ContextualForm[ContextualForm["Initial"] = 0] = "Initial";
    ContextualForm[ContextualForm["Medial"] = 1] = "Medial";
    ContextualForm[ContextualForm["Final"] = 2] = "Final";
})(ContextualForm || (ContextualForm = {}));
var CombinedForm;
(function (CombinedForm) {
    CombinedForm[CombinedForm["Isolated"] = 0] = "Isolated";
    CombinedForm[CombinedForm["Connected"] = 1] = "Connected";
})(CombinedForm || (CombinedForm = {}));
/**
 * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms
 * (in Unicode Block 'Arabic Presentation Forms-B').
 */
class ContextualArabicConverter {
    constructor() {
        this.m_singleCharactersMap = new Map();
        this.m_combinedCharactersMap = new Map();
        // Single characters.
        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA
        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA
        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE
        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA
        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW
        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA
        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF
        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH
        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA
        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH
        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH
        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM
        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH
        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH
        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL
        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL
        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH
        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN
        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN
        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN
        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD
        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD
        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH
        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH
        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN
        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN
        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL
        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH
        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF
        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF
        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM
        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM
        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON
        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH
        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW
        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA
        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH
        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH
        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh
        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh
        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh
        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf
        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh
        // Combined characters.
        this.m_combinedCharactersMap.set(0x0644, new Map());
        // LAM_ALEF_MADDA
        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);
        // LAM_ALEF_HAMZA_ABOVE
        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);
        // LAM_ALEF_HAMZA_BELOW
        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);
        // LAM_ALEF
        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);
        // Neutral characters.
        this.m_neutralCharacters = [
            0x0610,
            0x0612,
            0x0613,
            0x0614,
            0x0615,
            0x064b,
            0x064c,
            0x064d,
            0x064e,
            0x064f,
            0x0650,
            0x0651,
            0x0652,
            0x0653,
            0x0654,
            0x0655,
            0x0656,
            0x0657,
            0x0658,
            0x0670,
            0x06d6,
            0x06d7,
            0x06d8,
            0x06d9,
            0x06da,
            0x06db,
            0x06dc,
            0x06df,
            0x06e0,
            0x06e1,
            0x06e2,
            0x06e3,
            0x06e4,
            0x06e7,
            0x06e8,
            0x06ea,
            0x06eb,
            0x06ec,
            0x06ed // ARABIC SMALL LOW MEEM
        ];
    }
    static get instance() {
        if (this.m_instance === undefined) {
            this.m_instance = new ContextualArabicConverter();
        }
        return this.m_instance;
    }
    /**
     * Converts isolated arabic characters into their contextual form.
     *
     * @param input - String with isolated arabic characters.
     */
    convert(input) {
        let output = "";
        for (let i = 0; i < input.length; ++i) {
            const currentCodePoint = input.charCodeAt(i);
            // Only process arabic characters in the map.
            if (this.isArabicCharacter(currentCodePoint)) {
                // Find the first previous non-neutral character.
                let prevIndex = i - 1;
                for (; prevIndex >= 0; --prevIndex) {
                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                        break;
                    }
                }
                // Check if the previous character has ligatures with following characters.
                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;
                if (prevCodePoint !== undefined) {
                    const prevMap = this.getCharacterMap(prevCodePoint);
                    if (prevMap === undefined ||
                        (prevMap[ContextualForm.Initial] === undefined &&
                            prevMap[ContextualForm.Medial] === undefined)) {
                        prevCodePoint = undefined;
                    }
                }
                // Find the first next non-neutral character.
                let nextIndex = i + 1;
                for (; nextIndex < input.length; ++nextIndex) {
                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                        break;
                    }
                }
                // Check if the next character has ligatures with previous characters.
                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;
                if (nextCodePoint !== undefined) {
                    const nextMap = this.getCharacterMap(nextCodePoint);
                    if (nextMap === undefined ||
                        (nextMap[ContextualForm.Medial] === undefined &&
                            nextMap[ContextualForm.Final] === undefined)) {
                        nextCodePoint = undefined;
                    }
                }
                // Check for Lam Alef combinated forms.
                if (currentCodePoint === 0x0644 &&
                    nextCodePoint !== undefined &&
                    (nextCodePoint === 0x0622 ||
                        nextCodePoint === 0x0623 ||
                        nextCodePoint === 0x0625 ||
                        nextCodePoint === 0x0627)) {
                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                    if (prevCodePoint !== undefined) {
                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);
                    }
                    else {
                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);
                    }
                    // Skip the next character and continue.
                    ++i;
                    continue;
                }
                // Check for single character contextual forms.
                const map = this.getCharacterMap(currentCodePoint);
                // Intermediate.
                if (prevCodePoint !== undefined &&
                    nextCodePoint !== undefined &&
                    map[ContextualForm.Medial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Medial]);
                }
                // Final.
                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Final]);
                }
                // Initial.
                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Initial]);
                }
                // Isolated.
                else {
                    output += String.fromCharCode(currentCodePoint);
                }
            }
            else {
                output += String.fromCharCode(currentCodePoint);
            }
        }
        return output;
    }
    isArabicCharacter(codePoint) {
        return this.m_singleCharactersMap.has(codePoint);
    }
    getCharacterMap(codePoint) {
        return this.m_singleCharactersMap.get(codePoint);
    }
    getCombinedCharacterMap(codePoint, nextCodePoint) {
        const map = this.m_combinedCharactersMap.get(codePoint);
        if (map !== undefined) {
            return map.get(nextCodePoint);
        }
        return undefined;
    }
    isNeutral(codePoint) {
        for (const character of this.m_neutralCharacters) {
            if (character === codePoint) {
                return true;
            }
        }
        return false;
    }
}
exports.ContextualArabicConverter = ContextualArabicConverter;
//# sourceMappingURL=ContextualArabicConverter.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSdfTextMaterial = void 0;
const TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js");
/**
 * Helper function designed to create [[SdfTextMaterials]] that can be rendered using
 * [[TextCanvas]].
 *
 * @param params - Material parameters.
 *
 * @returns New `SdfTextMaterial`.
 */
function createSdfTextMaterial(params) {
    return new TextMaterials_1.SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource
    });
}
exports.createSdfTextMaterial = createSdfTextMaterial;
//# sourceMappingURL=MaterialUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypesettingUtils = void 0;
const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js");
/**
 * Collection of different constants and utility functions used by [[Typesetter]]s.
 */
var TypesettingUtils;
(function (TypesettingUtils) {
    /**
     * Ratio between EMs and Pixels.
     */
    TypesettingUtils.EM_TO_PX = 16.0;
    /**
     * Ratio between Points and Pixels.
     */
    TypesettingUtils.PT_TO_PX = 1.25;
    /**
     * Angle used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;
    /**
     * Horizontal offset used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);
    /**
     * Convert between any size specified in any [[FontUnit]] to pixels.
     *
     * @param size - Font size (specified in `unit`).
     * @param unit - Size unit.
     * @param originalSize - Original size (pixels)
     *
     * @returns Pixel size.
     */
    function getPixelSize(size, unit, originalSize) {
        let result = size;
        switch (unit) {
            case TextStyle_1.FontUnit.Em:
                result *= TypesettingUtils.EM_TO_PX;
                break;
            case TextStyle_1.FontUnit.Point:
                result *= TypesettingUtils.PT_TO_PX;
                break;
            case TextStyle_1.FontUnit.Percent:
                result *= (1.0 / 100) * originalSize;
                break;
        }
        return result;
    }
    TypesettingUtils.getPixelSize = getPixelSize;
    /**
     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.
     *
     * @param glyphs - Array containing [[TransformedGlyphData]].
     * @param index - Index to `glyphDataArray`.
     * @param fontVariant - Currently active [[FontVariant]].
     *
     * @returns Glyph `SmallCaps` scale.
     */
    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;
        return isSmallCaps
            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight
            : 1.0;
    }
    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;
    /**
     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].
     *
     * @param glyphs - Array containing [[GlyphData]].
     * @param offset - `glyphDataArray` offset.
     *
     * @returns Strong direction.
     */
    function getDirection(glyphs, offset) {
        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        let index = offset;
        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&
            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
            index < glyphs.length - 1) {
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1.0) {
            result = glyphs[index].direction;
        }
        return result;
    }
    TypesettingUtils.getDirection = getDirection;
    /**
     * Computes the transformation matrix for a glyph.
     *
     * @param transform - Matrix used to store the results.
     * @param position - Glyph' position.
     * @param scale - Glyph' scale.
     * @param rotation - [[TextCanvas]] rotation.
     * @param localRotation - Glyph' local rotation.
     */
    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(rotation);
        const localCosAngle = Math.cos(localRotation);
        const localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);
    }
    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;
    /**
     * Updates the supplied bounds with the computed screen-space corners for a given glyph.
     *
     * @param corners - Glyph' corners.
     * @param globalBounds - Global text bounds.
     * @param individualBounds - Individual per-character bounds.
     */
    function updateBounds(corners, globalBounds, individualBounds) {
        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== undefined) {
            if (individualBounds.array[individualBounds.offset] !== undefined) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            }
            else {
                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    }
    TypesettingUtils.updateBounds = updateBounds;
})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));
//# sourceMappingURL=TypesettingUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnicodeUtils = void 0;
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [
        [0x000a, 0x000d],
        [0x0085, 0x0085],
        [0x2028, 0x2029]
    ];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [
        [0x0000, 0x001f],
        [0x007f, 0x009f]
    ];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [
        [0x0030, 0x0039],
        [0x0660, 0x0669],
        [0x06f0, 0x06f9]
    ];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint - Character's Unicode code point.
     * @param block - Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));
//# sourceMappingURL=UnicodeUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Provides a manager that orchestrates downloading URLs, particularly static map resources.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./src/TransferManager */ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredPromise = void 0;
/**
 *
 * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.
 * This class allows wrapping other promises or long running functions for later execution.
 * @internal
 * @hidden
 */
class DeferredPromise {
    /**
     * Constructs a new [[DeferredPromise]]
     * @param executor - Async function that should be executed at a later point in time.
     */
    constructor(executor) {
        this.executor = executor;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
        });
    }
    /**
     * When `exec` is called the deferred executor function is executed.
     */
    exec() {
        this.executor()
            .then(result => this.resolveFunc(result))
            .catch(error => this.rejectFunc(error));
    }
}
exports.DeferredPromise = DeferredPromise;
//# sourceMappingURL=DeferredPromise.js.map

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/TransferManager.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferManager = void 0;
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
__webpack_require__(/*! @here/harp-fetch */ "./node_modules/@here/harp-fetch/index.web.js");
const DeferredPromise_1 = __webpack_require__(/*! ./DeferredPromise */ "./node_modules/@here/harp-transfer-manager/src/DeferredPromise.js");
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
let TransferManager = /** @class */ (() => {
    class TransferManager {
        /**
         * Constructs a new [[TransferManager]].
         *
         * @param fetchFunction - The default fetch function to use.
         * @param maxRetries - The maximum amount to try to re-fetch a resource.
         */
        constructor(fetchFunction = fetch, maxRetries = 5) {
            this.fetchFunction = fetchFunction;
            this.maxRetries = maxRetries;
            this.activeDownloadCount = 0;
            this.downloadQueue = new Array();
            this.activeDownloads = new Map();
        }
        /**
         * Returns a default instance of [[TransferManager]].
         */
        static instance() {
            return TransferManager.defaultInstance;
        }
        static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
            try {
                const response = await fetchFunction(url, init);
                if (response.status !== 503 || retryCount > maxRetries) {
                    return response;
                }
            }
            catch (err) {
                if (err.hasOwnProperty("isCancelled") ||
                    (err.hasOwnProperty("name") && err.name === "AbortError") ||
                    retryCount > maxRetries) {
                    throw err;
                }
            }
            return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init));
        }
        static waitFor(milliseconds) {
            return new Promise(resolve => setTimeout(resolve, milliseconds));
        }
        /**
         * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.
         *
         * Note: This method merges multiple downloads of the same string URL to
         * only one request. The init parameter is ignored if the download is merged.
         * Call [[download]] instead to download the resource without merging.
         *
         * @param url - The URL or RequestInfo to download
         * @param init - Optional extra parameters for the download.
         */
        downloadJson(url, init) {
            return this.downloadAs(response => response.json(), url, init);
        }
        /**
         * Downloads a binary object. Merges downloads of string URLS if requested multiple times.
         *
         * Note: This method merges multiple downloads of the same string URL to
         * only one request. The init parameter is ignored if the download is merged.
         * Call [[download]] instead to download the resource without merging.
         *
         * @param url - The URL or RequestInfo to download
         * @param init - Optional extra parameters for the download
         */
        downloadArrayBuffer(url, init) {
            return this.download(url, init).then(response => response.arrayBuffer());
        }
        /**
         * Downloads a URL and returns the response.
         *
         * Does not merge multiple requests to the same URL.
         *
         * @param url - The URL or RequestInfo to download.
         * @param init - Optional extra parameters for the download.
         */
        download(url, init) {
            if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
                const deferred = new DeferredPromise_1.DeferredPromise(() => this.doDownload(url, init));
                this.downloadQueue.push(deferred);
                return deferred.promise;
            }
            return this.doDownload(url, init);
        }
        async doDownload(url, init) {
            try {
                ++this.activeDownloadCount;
                const response = await TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);
                this.onDownloadDone();
                return response;
            }
            catch (error) {
                this.onDownloadDone();
                throw error;
            }
        }
        onDownloadDone() {
            --this.activeDownloadCount;
            this.execDeferredDownload();
        }
        execDeferredDownload() {
            const future = this.downloadQueue.pop();
            if (future === undefined) {
                return;
            }
            future.exec();
        }
        downloadAs(converter, url, init) {
            const cacheKey = url;
            const pendingFetch = this.activeDownloads.get(cacheKey);
            if (pendingFetch !== undefined) {
                return Promise.resolve(pendingFetch);
            }
            const newFetch = this.download(url, init)
                .then(response => {
                this.activeDownloads.delete(cacheKey);
                if (response.ok) {
                    return converter(response);
                }
                throw new Error(JSON.stringify(response));
            })
                .catch(err => {
                this.activeDownloads.delete(cacheKey);
                throw err;
            });
            this.activeDownloads.set(cacheKey, newFetch);
            return newFetch;
        }
    }
    /**
     * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
     * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
     * so on.
     */
    TransferManager.retryTimeout = 500;
    /**
     * The amount of maximum parallel downloads to allow.
     */
    TransferManager.maxParallelDownloads = 16;
    TransferManager.defaultInstance = new TransferManager();
    return TransferManager;
})();
exports.TransferManager = TransferManager;
//# sourceMappingURL=TransferManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/index-common.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/index-common.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./lib/GroupedPriorityList */ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Logger */ "./node_modules/@here/harp-utils/lib/Logger/index.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Math2D */ "./node_modules/@here/harp-utils/lib/Math2D.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/MathUtils */ "./node_modules/@here/harp-utils/lib/MathUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Mixins */ "./node_modules/@here/harp-utils/lib/Mixins.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/assert */ "./node_modules/@here/harp-utils/lib/assert.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/CachedResource */ "./node_modules/@here/harp-utils/lib/CachedResource.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ContextLogger */ "./node_modules/@here/harp-utils/lib/ContextLogger.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/PerformanceTimer */ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/ObjectUtils */ "./node_modules/@here/harp-utils/lib/ObjectUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/OptionsUtils */ "./node_modules/@here/harp-utils/lib/OptionsUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/UriResolver */ "./node_modules/@here/harp-utils/lib/UriResolver.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/UrlUtils */ "./node_modules/@here/harp-utils/lib/UrlUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/Functions */ "./node_modules/@here/harp-utils/lib/Functions.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/SampleBilinear */ "./node_modules/@here/harp-utils/lib/SampleBilinear.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/AuthenticationUtils */ "./node_modules/@here/harp-utils/lib/AuthenticationUtils.js"), exports);
//# sourceMappingURL=index-common.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-utils/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./index-common */ "./node_modules/@here/harp-utils/index-common.js"), exports);
__exportStar(__webpack_require__(/*! ./lib/UrlPlatformUtils.web */ "./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js"), exports);
//# sourceMappingURL=index.web.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/AuthenticationUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/AuthenticationUtils.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=AuthenticationUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/CachedResource.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/CachedResource.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=CachedResource.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ContextLogger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ContextLogger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextLogger = void 0;
/**
 * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`
 * before first actual log message.
 */
class ContextLogger {
    /**
     * Construct a context-aware logger that logs to `m_logger`.
     */
    constructor(m_logger, headerMessage) {
        this.m_logger = m_logger;
        this.headerMessage = headerMessage;
        this.context = [];
        this.m_headerLogged = false;
        // They, are public member functions it's just tslint who doesn't understand this.
        // tslint:disable:member-ordering
        this.warn = this.createLogMethod("warn");
        this.info = this.createLogMethod("info");
        this.error = this.createLogMethod("error");
    }
    /**
     * Push "attribute-like" context.
     *
     * Following log messages will be prefixed with `name` or `.name` depending on current context.
     */
    pushAttr(name) {
        this.context.push(`${this.context.length > 0 ? "." : ""}${name}`);
    }
    /**
     * Push "index-like" context.
     *
     * Following log messages will be prefixed with `[index]`.
     */
    pushIndex(index) {
        this.context.push(`[${index}]`);
    }
    pop() {
        this.context.pop();
    }
    // tslint:enable:member-ordering
    createLogMethod(severity) {
        return (message, ...rest) => {
            if (!this.m_headerLogged) {
                this.m_logger.info(this.headerMessage);
                this.m_headerLogged = true;
            }
            this.m_logger[severity](`${this.context.join("")}: ${message}`, ...rest);
        };
    }
}
exports.ContextLogger = ContextLogger;
//# sourceMappingURL=ContextLogger.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Functions.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Functions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.chainCallbacks = void 0;
/**
 * Chains two functions for further assigning as one wrapped callback function
 */
function chainCallbacks(f1, f2) {
    return function (...args) {
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
exports.chainCallbacks = chainCallbacks;
//# sourceMappingURL=Functions.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GroupedPriorityList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupedPriorityList = exports.PriorityListGroup = void 0;
/**
 * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same
 * (integer) priority.
 */
class PriorityListGroup {
    constructor(priority, elements = new Array()) {
        this.priority = priority;
        this.elements = elements;
    }
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone() {
        return new PriorityListGroup(this.priority, this.elements.slice());
    }
    /**
     * Removes an element from the group.
     * @param element - The element to remove.
     * @returns true if the element was removed, false if it was not found in the group.
     */
    remove(element) {
        const foundIndex = this.elements.indexOf(element);
        if (foundIndex === -1) {
            return false;
        }
        this.elements.splice(foundIndex, 1);
        return true;
    }
}
exports.PriorityListGroup = PriorityListGroup;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
class GroupedPriorityList {
    constructor() {
        this.groups = new Map();
    }
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element - Element to be added.
     */
    add(element) {
        this.getGroup(element.priority).elements.push(element);
    }
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element - Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element) {
        const group = this.findGroup(element.priority);
        if (group !== undefined && group.remove(element)) {
            if (group.elements.length === 0) {
                this.groups.delete(group.priority);
            }
            return true;
        }
        return false;
    }
    /**
     * Remove all internal {@link PriorityListGroup}s.
     */
    clear() {
        this.groups.clear();
    }
    /**
     * Merge another {@link GroupedPriorityList} into this one.
     *
     * @param other - Other group to merge.
     */
    merge(other) {
        for (const otherGroup of other.groups) {
            const group = this.findGroup(otherGroup[1].priority);
            if (group === undefined) {
                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                continue;
            }
            group.elements = group.elements.concat(otherGroup[1].elements);
        }
        return this;
    }
    clone() {
        const clone = new GroupedPriorityList();
        for (const [priority, group] of this.groups) {
            clone.groups.set(priority, group.clone());
        }
        return clone;
    }
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun) {
        for (const group of this.groups) {
            group[1].elements.forEach(fun);
        }
    }
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count() {
        let n = 0;
        for (const group of this.groups) {
            n += group[1].elements.length;
        }
        return n;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    findGroup(priority) {
        const normalizedPriority = Math.floor(priority);
        const group = this.groups.get(normalizedPriority);
        return group;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    getGroup(priority) {
        let group = this.findGroup(priority);
        if (group === undefined) {
            const normalizedPriority = Math.floor(priority);
            group = new PriorityListGroup(normalizedPriority);
            this.groups.set(group.priority, group);
        }
        return group;
    }
}
exports.GroupedPriorityList = GroupedPriorityList;
//# sourceMappingURL=GroupedPriorityList.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleChannel = void 0;
/**
 * Class for the default console channel.
 */
class ConsoleChannel {
    error(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.error(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.debug(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.info(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.log(message, ...optionalParams);
    }
    trace(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.trace(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        // tslint:disable-next-line:no-console
        console.warn(message, ...optionalParams);
    }
}
exports.ConsoleChannel = ConsoleChannel;
//# sourceMappingURL=ConsoleChannel.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/IChannel.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/IChannel.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=IChannel.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ILogger.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerOptions = exports.LogLevel = void 0;
/**
 * Enum log levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Log"] = 2] = "Log";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warn"] = 4] = "Warn";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Logger options to configure logger
 */
class LoggerOptions {
}
exports.LoggerOptions = LoggerOptions;
//# sourceMappingURL=ILogger.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/Logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/Logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js");
/**
 * Logger class.
 */
class Logger {
    constructor(name, m_channel, options) {
        this.name = name;
        this.m_channel = m_channel;
        this.enabled = true;
        this.level = ILogger_1.LogLevel.Trace;
        if (options !== undefined) {
            this.update(options);
        }
    }
    error(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {
            this.m_channel.error(this.prefix, message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {
            this.m_channel.debug(this.prefix, message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {
            this.m_channel.info(this.prefix, message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {
            this.m_channel.log(this.prefix, message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {
            this.m_channel.trace(this.prefix, message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {
            this.m_channel.warn(this.prefix, message, ...optionalParams);
        }
    }
    update(options) {
        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;
        this.level = options.level === undefined ? this.level : options.level;
    }
    get prefix() {
        return this.name + ":";
    }
}
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerManager = void 0;
const LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js");
/**
 * The LoggerManager class implements a singleton object that handles logging.
 *
 * Example:
 *
 * ```typescript
 *
 * const logger = LoggerManager.instance.create("MyFontLoaderClass");
 * if (missingFonts.length > 0) {
 *     logger.error("These fonts can not be loaded: ", missingFonts);
 * } else {
 *     logger.log("All fonts have been loaded.");
 * }
 * ```
 */
class LoggerManager {
    static get instance() {
        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());
    }
}
exports.LoggerManager = LoggerManager;
//# sourceMappingURL=LoggerManager.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerManagerImpl = void 0;
const ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/@here/harp-utils/lib/Logger/Logger.js");
const WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js");
/**
 * LoggerManagerImpl is the class for the singleton instance of the logger manager.
 * It handles channels and loggers.
 */
class LoggerManagerImpl {
    constructor() {
        this.m_loggers = [];
        this.channel =
            typeof self === "undefined" || typeof self.document !== "undefined"
                ? new ConsoleChannel_1.ConsoleChannel()
                : new WorkerChannel_1.WorkerChannel();
    }
    getLoggerNames() {
        return this.m_loggers.map(logger => logger.name);
    }
    getLogger(name) {
        return this.m_loggers.find(logger => logger.name === name);
    }
    create(loggerName, options = {}) {
        if (this.m_levelSetForAll !== undefined &&
            (options.level === undefined || options.level < this.m_levelSetForAll)) {
            options.level = this.m_levelSetForAll;
        }
        const logger = new Logger_1.Logger(loggerName, this.channel, options);
        this.m_loggers.push(logger);
        return logger;
    }
    dispose(logger) {
        const found = this.m_loggers.indexOf(logger);
        if (found < 0) {
            throw new Error(`Cannot unregister "${logger}" : no such logger registered.`);
        }
        this.m_loggers.splice(found, 1);
    }
    updateAll(options) {
        for (const logger of this.m_loggers) {
            logger.update(options);
        }
    }
    update(loggerName, config) {
        for (const logger of this.m_loggers) {
            if (logger.name === loggerName) {
                logger.update(config);
            }
        }
    }
    enableAll(enabled) {
        for (const logger of this.m_loggers) {
            logger.enabled = enabled;
        }
    }
    enable(loggerName, value) {
        this.update(loggerName, { enabled: value });
    }
    setLogLevelForAll(level) {
        this.m_levelSetForAll = level;
        for (const logger of this.m_loggers) {
            logger.level = level;
        }
    }
    setLogLevel(loggerName, level) {
        this.update(loggerName, { level });
    }
    setChannel(channel) {
        this.channel = channel;
    }
}
exports.LoggerManagerImpl = LoggerManagerImpl;
//# sourceMappingURL=LoggerManagerImpl.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiChannel = void 0;
/**
 * Class allowing mixing several channels.
 */
class MultiChannel {
    constructor(...channels) {
        this.channels = [];
        this.channels = channels;
    }
    error(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.warn(message, ...optionalParams);
        }
    }
}
exports.MultiChannel = MultiChannel;
//# sourceMappingURL=MultiChannel.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerChannel = exports.WORKERCHANNEL_MSG_TYPE = void 0;
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js");
exports.WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
/**
 * The class for the worker channel.
 */
class WorkerChannel {
    error(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Error
        };
        self.postMessage(workerMessage);
    }
    debug(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Debug
        };
        self.postMessage(workerMessage);
    }
    info(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Info
        };
        self.postMessage(workerMessage);
    }
    log(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Log
        };
        self.postMessage(workerMessage);
    }
    trace(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Trace
        };
        self.postMessage(workerMessage);
    }
    warn(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Warn
        };
        self.postMessage(workerMessage);
    }
}
exports.WorkerChannel = WorkerChannel;
//# sourceMappingURL=WorkerChannel.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./ConsoleChannel */ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js"), exports);
__exportStar(__webpack_require__(/*! ./IChannel */ "./node_modules/@here/harp-utils/lib/Logger/IChannel.js"), exports);
__exportStar(__webpack_require__(/*! ./ILogger */ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js"), exports);
__exportStar(__webpack_require__(/*! ./Logger */ "./node_modules/@here/harp-utils/lib/Logger/Logger.js"), exports);
__exportStar(__webpack_require__(/*! ./LoggerManager */ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js"), exports);
__exportStar(__webpack_require__(/*! ./MultiChannel */ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js"), exports);
__exportStar(__webpack_require__(/*! ./WorkerChannel */ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Math2D.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Math2D.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Math2D = void 0;
var Math2D;
(function (Math2D) {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    class Box {
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        constructor(x = 0, y = 0, w = 0, h = 0) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Set new values to all properties of the box.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Test box for inclusion of point.
         *
         * @param x - X coordinate of point.
         * @param y - Y coordinate of point.
         */
        contains(x, y) {
            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
        }
        /**
         * Test box for inclusion of another box.
         *
         * @param other - Box 2 to test for inclusion.
         */
        containsBox(other) {
            const xmax = other.x + other.w;
            const ymax = other.y + other.h;
            return (this.contains(other.x, other.y) &&
                this.contains(xmax, other.y) &&
                this.contains(other.x, ymax) &&
                this.contains(xmax, ymax));
        }
        /**
         * Test two boxes for intersection.
         *
         * @param other - Box 2 to test for intersection.
         */
        intersects(other) {
            return (this.x <= other.x + other.w &&
                this.x + this.w >= other.x &&
                this.y <= other.y + other.h &&
                this.y + this.h >= other.y);
        }
    }
    Math2D.Box = Box;
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns Squared distance between the two points
     */
    function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    }
    Math2D.distSquared = distSquared;
    /**
     * Computes the squared length of a line.
     *
     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    function computeSquaredLineLength(line) {
        let squaredLineLength = 0;
        const length = line.length - 4;
        for (let i = 0; i < length; i += 3) {
            const xDiff = line[i + 3] - line[i];
            const yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    }
    Math2D.computeSquaredLineLength = computeSquaredLineLength;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px - Test point X
     * @param py - Test point y
     * @param l0x - Line segment start X
     * @param l0y - Line segment start Y
     * @param l1x - Line segment end X
     * @param l1y - Line segment end Y
     * @returns Squared distance between point and line segment
     */
    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    }
    Math2D.distToSegmentSquared = distToSegmentSquared;
})(Math2D = exports.Math2D || (exports.Math2D = {}));
//# sourceMappingURL=Math2D.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/MathUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/MathUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathUtils = void 0;
var MathUtils;
(function (MathUtils) {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     *
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.
     *
     * Given two known points the linear interpolant between these points may be presented as
     * straight line. This means that for given factor change the resulting change of return
     * value is always const.
     * @see https://en.wikipedia.org/wiki/Linear_interpolation
     *
     * @param edge0 -
     * @param edge1 -
     * @param factor - Interpolation factor that ranges between: 0 <= x <= 1.
     */
    function lerp(edge0, edge1, factor) {
        return edge0 * (1 - factor) + edge1 * factor;
    }
    MathUtils.lerp = lerp;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    function smoothStep(edge0, edge1, x) {
        // Scale, bias and saturate x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * (3 - 2 * x);
    }
    MathUtils.smoothStep = smoothStep;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    function smootherStep(edge0, edge1, x) {
        // Scale, and clamp x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    MathUtils.smootherStep = smootherStep;
    /**
     * Maps a number from one range to another.
     *
     * @param val - The incoming value to be converted.
     * @param inMin - Lower bound of the value's current range.
     * @param inMax - Upper bound of the value's current range.
     * @param outMin - Lower bound of the value's target range.
     * @param outMax - Upper bound of the value's target range.
     */
    function map(val, inMin, inMax, outMin, outMax) {
        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    MathUtils.map = map;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    function min2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.min(result, b);
        }
        return result;
    }
    MathUtils.min2 = min2;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    function max2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.max(result, b);
        }
        return result;
    }
    MathUtils.max2 = max2;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value - Value to check.
     * @param lowerBound - The lower bound to check the value against.
     * @param upperBound - The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    function isClamped(value, lowerBound, upperBound) {
        if (lowerBound !== undefined && value < lowerBound) {
            return false;
        }
        if (upperBound !== undefined && value > upperBound) {
            return false;
        }
        return true;
    }
    MathUtils.isClamped = isClamped;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue -
     * @param endValue -
     * @param time -
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    function easeInOutCubic(startValue, endValue, time) {
        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    }
    MathUtils.easeInOutCubic = easeInOutCubic;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));
//# sourceMappingURL=MathUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Mixins.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Mixins.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyMixinsWithoutProperties = exports.applyMixins = void 0;
/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods and properties into.
 * @param baseCtors - Class to take all methods and properties from.
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods into.
 * @param baseCtors - Class to take all methods from.
 */
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (descriptor !== undefined &&
                descriptor.get === undefined &&
                name !== "constructor") {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}
exports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;
//# sourceMappingURL=Mixins.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ObjectUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ObjectUtils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = exports.cloneDeep = void 0;
/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
function cloneDeep(obj) {
    const cache = new Map();
    function cloneInternal(src) {
        if (src === null) {
            return null;
        }
        else if (typeof src === "object") {
            const cached = cache.get(src);
            if (cached !== undefined) {
                return cached;
            }
            if (Array.isArray(src)) {
                const result = [];
                cache.set(src, result);
                result.length = src.length;
                for (let i = 0; i < result.length; ++i) {
                    result[i] = cloneInternal(src[i]);
                }
                return result;
            }
            else if (src instanceof Date) {
                const result = new Date(src.getTime());
                cache.set(src, result);
                return result;
            }
            else if (src instanceof RegExp) {
                const result = new RegExp(src.source, src.flags);
                cache.set(src, result);
                return result;
            }
            else if (src.constructor !== Object) {
                throw new Error("cloneDeep doesn't support objects with custom prototypes");
            }
            else {
                const result = {};
                cache.set(src, result);
                for (const key in src) {
                    if (src.hasOwnProperty(key)) {
                        result[key] = cloneInternal(src[key]);
                    }
                }
                return result;
            }
        }
        else {
            // string, number, boolean, undefined and functions are returned as is
            return src;
        }
    }
    const r = cloneInternal(obj);
    cache.clear();
    return r;
}
exports.cloneDeep = cloneDeep;
/**
 * Pick `props` from `object.
 *
 * Runtime version of `Pick<T,K>`.
 */
function pick(object, props) {
    const result = {};
    for (const propName of props) {
        if (object.hasOwnProperty(propName)) {
            result[propName] = object[propName];
        }
    }
    return result;
}
exports.pick = pick;
//# sourceMappingURL=ObjectUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/OptionsUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/OptionsUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeWithOptions = exports.getOptionValue = void 0;
function getOptionValue(...values) {
    for (const candidate of values) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return undefined;
}
exports.getOptionValue = getOptionValue;
/**
 * Merge options into existing parameters object.
 *
 * Convenience helper with _similar_ semantics as:
 *
 *     const finalParams1 = { ...defaults, ... options };
 *     const finalParams2 = Object.assign({}, defaults, options);
 *
 * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.
 * `defaults` is used as _parameters_ template.
 *
 * This doc uses following notion of `option` and `parameter` terms:
 * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object
 *    * `parameter` usually have sensible and usually used default
 *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)
 *    * `parameter` can be overriden by specyfying `option` with same name
 * * `option` means value that may be passed optionally, overrides `parameter` value with same name
 *
 * Usage:
 *
 *     interface FooParams {
 *         useTextures: boolean;
 *         opacity: number;
 *     }
 *
 *     const FOO_DEFAULTS: FooParams = {
 *         useTextures: true,
 *         opacity: 0.8
 *     };
 *
 *     type FooOptions = Partial<FooParams>;
 *
 *     function doSomething(options: FooOptions) {
 *         const params = mergeWithOptions(FOO_DEFAULTS, options);
 *             // typeof params === FooParams
 *             // params.opacity = 0.5
 *             // params.useTextures = true
 *             // params.someOtherOptionFromOtherApi is not defined
 *     }
 *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};
 *     doSomething(opt);
 *
 * Rationale:
 *   * both `Object.assign` and spread operator copy extra options
 *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist
 *     in options object
 *
 * @param parameters - parmeters template object holding all expected parameters
 * @param options - options object
 * @returns new object with `parameters` overriden by values from `options`
 */
function mergeWithOptions(parameters, options) {
    // NOTE: `as object` needed due to TypeScript bug:
    //       https://github.com/Microsoft/TypeScript/issues/14409
    // tslint:disable-next-line:no-object-literal-type-assertion
    const result = Object.assign({}, parameters);
    if (options === undefined || options === null) {
        return result;
    }
    for (const prop in parameters) {
        if (parameters.hasOwnProperty(prop)) {
            const optionValue = options[prop];
            if (optionValue !== undefined && optionValue !== null) {
                result[prop] = optionValue;
            }
        }
    }
    return result;
}
exports.mergeWithOptions = mergeWithOptions;
//# sourceMappingURL=OptionsUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/PerformanceTimer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceTimer = void 0;
/* tslint:disable:max-line-length */
/**
 * See:
 * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now
 */
/* tslint:ensable:max-line-length */
let PerformanceTimer = /** @class */ (() => {
    class PerformanceTimer {
        /**
         * Returns timestamp in milliseconds since page load.
         *
         * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,
         * otherwise it is in milliseconds. Timespans are computed by taking the difference between two
         * samples.
         *
         * Example:
         * ```typescript
         * const now = PerformanceTimer.now();
         * // call some expensive function for which you want to check the duration.
         * const end = PerformanceTimer.now();
         * const elapsedTime = end - now;
         * ```
         */
        static now() {
            return PerformanceTimer.nowFunc();
        }
        static getNowFunc() {
            if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
                return () => performance.now();
            }
            // fall back to Date.getTime()
            return () => {
                return new Date().getTime();
            };
        }
    }
    // tslint:disable-next-line:no-unused-variable
    PerformanceTimer.instance = new PerformanceTimer();
    PerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();
    return PerformanceTimer;
})();
exports.PerformanceTimer = PerformanceTimer;
//# sourceMappingURL=PerformanceTimer.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/SampleBilinear.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/SampleBilinear.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleBilinear = void 0;
/**
 * Returns a bilinear-interpolated texture sample for a given texture.
 * @param texture - Two-dimensional texture to sample.
 * @param width - Texture width.
 * @param height - Texture height.
 * @param u - Number between 0 and 1 representing the location to sample in the width dimension.
 * @param v - Number between 0 and 1 representing the location to sample in the height dimension.
 */
function sampleBilinear(texture, width, height, u, v) {
    const maxXIndex = width - 1;
    const maxYIndex = height - 1;
    // Compute the x and y coordinates relative to the mesh size.
    const xIndex = u * maxXIndex;
    const xIndexFloor = Math.floor(xIndex);
    const yIndex = v * maxYIndex;
    const yIndexFloor = Math.floor(yIndex);
    const swIndex = yIndexFloor * width + xIndexFloor;
    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;
    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;
    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;
    const swElevation = texture[swIndex];
    const seElevation = texture[seIndex];
    const nwElevation = texture[nwIndex];
    const neElevation = texture[neIndex];
    // Get the fractional components to do bilinear interpolation.
    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;
    const xFracInverse = 1 - xFrac;
    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;
    const yFracInverse = 1 - yFrac;
    // The interpolation is the sum of the four closest neighbours each
    // multiplied by the diagonal areas.
    const result = swElevation * xFracInverse * yFracInverse +
        seElevation * xFrac * yFracInverse +
        nwElevation * xFracInverse * yFrac +
        neElevation * xFrac * yFrac;
    return result;
}
exports.sampleBilinear = sampleBilinear;
//# sourceMappingURL=SampleBilinear.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UriResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UriResolver.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeUriResolvers = exports.RelativeUriResolver = exports.PrefixMapUriResolver = void 0;
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "./node_modules/@here/harp-utils/lib/UrlUtils.js");
/**
 * Basic, import-map like {@link UriResolver}.
 *
 * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.
 *
 * In definitions, `key` is matched against input uri with following strategy:
 *  - `key` without trailing `/` -> `key` and input `uri` must be identical
 *  - `key` with trailing `/`, -> `key` is treated as "package prefix", so `uri` must start with
 *    `key`
 *
 * Example:
 * ```
 * {
 *     "local://poiMasterList": "/assets/poiMasterList.json"
 *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`
 *     "local://icons/": "/assets/icons/"
 *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to
 *        // `/assets/icons/ANYPATH
 * }
 * ```
 * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).
 */
class PrefixMapUriResolver {
    constructor(definitions) {
        this.definitions = definitions;
    }
    resolveUri(uri) {
        return Object.keys(this.definitions).reduce((r, key) => {
            if (key.endsWith("/") && r.startsWith(key)) {
                const newPrefix = this.definitions[key];
                return newPrefix + r.substr(key.length);
            }
            else if (r === key) {
                return this.definitions[key];
            }
            return r;
        }, uri);
    }
}
exports.PrefixMapUriResolver = PrefixMapUriResolver;
/**
 * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.
 */
class RelativeUriResolver {
    constructor(parentUri) {
        this.parentUri = parentUri;
    }
    resolveUri(uri) {
        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);
    }
}
exports.RelativeUriResolver = RelativeUriResolver;
/**
 * Compose URI resolvers.
 *
 * Creates new {@link UriResolver} that applies resolvers in orders or arguments.
 *
 * Example:
 *
 *     const themeUrl = ...; // url of parent object
 *     const childUrlResolver = composeUrlResolvers(
 *           new RelativeUriResolver(themeUrl),
 *           defaultUrlResolver
 *     );
 */
function composeUriResolvers(...resolvers) {
    return {
        resolveUri(originalUrl) {
            return resolvers.reduce((url, resolver) => {
                if (resolver !== undefined) {
                    return resolver.resolveUri(url);
                }
                else {
                    return url;
                }
            }, originalUrl);
        }
    };
}
exports.composeUriResolvers = composeUriResolvers;
//# sourceMappingURL=UriResolver.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAppBaseUrl = void 0;
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "./node_modules/@here/harp-utils/lib/UrlUtils.js");
/**
 * Get base URL for from where relative URLs will be loaded.
 *
 * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL
 * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
 *
 * * In node, it resolves to `file://${process.cwd()}`.
 */
function getAppBaseUrl() {
    return UrlUtils_1.baseUrl(window.location.href);
}
exports.getAppBaseUrl = getAppBaseUrl;
//# sourceMappingURL=UrlPlatformUtils.web.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlUtils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUrlHostAndProtocol = exports.getUrlOrigin = exports.baseUrl = exports.resolveReferenceUri = void 0;
/**
 * Resolve URI of referenced object w.r.t parent URI.
 *
 * Resolves `childUri` as it would be loaded from location specified by `parentUri`.
 *
 * If `childUri` is absolute, then it is returned unchanged.
 * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.
 *
 * See [[baseUri]] for reference how base URL of `parentUri` is determined.
 *
 * Supports `http:`, `https:`, `file:`, `data:` schemes.
 *
 * Examples:
 *
 *     // normal case, child is sibling
 *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent is "folder", so child is just located in this folder
 *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent looks like leaf, so last component is stripped
 *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png
 *
 *     // origin-absolute URL, takes only origin from parent
 *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json
 *
 * @param parentUri - URI of parent resource
 * @param childUri - URI of child as referenced from parent resource
 * @return `childUrl` as if anchored in location of `parentUrl`
 */
function resolveReferenceUri(parentUri, childUri) {
    if (absoluteUrlWithOriginRe.test(childUri)) {
        return childUri;
    }
    else if (childUri.startsWith("/")) {
        const origin = getUrlOrigin(parentUri);
        return origin + childUri;
    }
    else {
        if (childUri.startsWith("./")) {
            childUri = childUri.substr(2);
        }
        const parentBaseUrl = baseUrl(parentUri);
        return parentBaseUrl + childUri;
    }
}
exports.resolveReferenceUri = resolveReferenceUri;
const absoluteUrlWithOriginRe = new RegExp("^(((?:[a-z]+:)?//)|(file:/)|(data:))", "i");
/**
 * Returns base URL of given resource URL.
 *
 * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if
 * `url` ends with name component it is treated as "leaf", so last path component is removed.
 *
 * Standalone files (without any folder structure) are considered relative to `./`.
 *
 * Examples:
 * ```
 *     https://foo.com/themes/a.json -> https://foo.com/themes/
 *     https://foo.com/themes/ -> https://foo.com/themes/
 *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf
 *     themes/day.json -> themes/
 *     themes -> ./
 * ```
 */
function baseUrl(url) {
    if (url === undefined) {
        return "./";
    }
    let idx = url.indexOf("#");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.indexOf("?");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
exports.baseUrl = baseUrl;
/**
 * Get `origin` part of URL.
 *
 * @example
 *    https://example.com/foo -> https://example.com
 *    //example.com:8080/ -> //example.com:8080
 *    file:///etc/hosts ->
 *
 * @param url - input URL
 * @return origin of given URL
 */
function getUrlOrigin(url) {
    if (url === undefined) {
        return "";
    }
    const parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    }
    else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    }
    else if (parsed.host) {
        return "//" + parsed.host;
    }
    else if (parsed.protocol) {
        return parsed.protocol + "//";
    }
    else {
        return "";
    }
}
exports.getUrlOrigin = getUrlOrigin;
/**
 * Parse `host` and `protocol` part from URL.
 */
function getUrlHostAndProtocol(url) {
    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    const match = url.match(urlOriginRe);
    if (!match) {
        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
exports.getUrlHostAndProtocol = getUrlHostAndProtocol;
//# sourceMappingURL=UrlUtils.js.map

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/assert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExists = exports.assert = void 0;
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
//TODO: Make assertHandler configurable
/**
 * Implementation of assert as a development help
 *
 * Note - this is deliberately a global function so that minimizers remove the
 * entire call when building for production.
 *
 * @hidden
 * @param condition - Condition to match, if false, throws an Error(message)
 * @param message - Optional message, defaults to "ASSERTION failed"
 */
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== undefined ? message : "ASSERTION failed");
        }
    }
}
exports.assert = assert;
function assertExists(element, message) {
    if (!isProduction) {
        if (element === undefined || element === null) {
            throw new Error(message !== undefined ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
exports.assertExists = assertExists;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/src/Tween.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/src/Tween.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */


var _Group = function () {
	this._tweens = {};
	this._tweensAddedDuringUpdate = {};
};

_Group.prototype = {
	getAll: function () {

		return Object.keys(this._tweens).map(function (tweenId) {
			return this._tweens[tweenId];
		}.bind(this));

	},

	removeAll: function () {

		this._tweens = {};

	},

	add: function (tween) {

		this._tweens[tween.getId()] = tween;
		this._tweensAddedDuringUpdate[tween.getId()] = tween;

	},

	remove: function (tween) {

		delete this._tweens[tween.getId()];
		delete this._tweensAddedDuringUpdate[tween.getId()];

	},

	update: function (time, preserve) {

		var tweenIds = Object.keys(this._tweens);

		if (tweenIds.length === 0) {
			return false;
		}

		time = time !== undefined ? time : TWEEN.now();

		// Tweens are updated in "batches". If you add a new tween during an update, then the
		// new tween will be updated in the next batch.
		// If you remove a tween during an update, it may or may not be updated. However,
		// if the removed tween was added during the current batch, then it will not be updated.
		while (tweenIds.length > 0) {
			this._tweensAddedDuringUpdate = {};

			for (var i = 0; i < tweenIds.length; i++) {

				var tween = this._tweens[tweenIds[i]];

				if (tween && tween.update(time) === false) {
					tween._isPlaying = false;

					if (!preserve) {
						delete this._tweens[tweenIds[i]];
					}
				}
			}

			tweenIds = Object.keys(this._tweensAddedDuringUpdate);
		}

		return true;

	}
};

var TWEEN = new _Group();

TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function () {
	return TWEEN._nextId++;
};


// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use self.performance.now if it is available.
else if (typeof (self) !== 'undefined' &&
         self.performance !== undefined &&
		 self.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	TWEEN.now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	TWEEN.now = function () {
		return new Date().getTime();
	};
}


TWEEN.Tween = function (object, group) {
	this._object = object;
	this._valuesStart = {};
	this._valuesEnd = {};
	this._valuesStartRepeat = {};
	this._duration = 1000;
	this._repeat = 0;
	this._repeatDelayTime = undefined;
	this._yoyo = false;
	this._isPlaying = false;
	this._reversed = false;
	this._delayTime = 0;
	this._startTime = null;
	this._easingFunction = TWEEN.Easing.Linear.None;
	this._interpolationFunction = TWEEN.Interpolation.Linear;
	this._chainedTweens = [];
	this._onStartCallback = null;
	this._onStartCallbackFired = false;
	this._onUpdateCallback = null;
	this._onRepeatCallback = null;
	this._onCompleteCallback = null;
	this._onStopCallback = null;
	this._group = group || TWEEN;
	this._id = TWEEN.nextId();

};

TWEEN.Tween.prototype = {
	getId: function () {
		return this._id;
	},

	isPlaying: function () {
		return this._isPlaying;
	},

	to: function (properties, duration) {

		this._valuesEnd = Object.create(properties);

		if (duration !== undefined) {
			this._duration = duration;
		}

		return this;

	},

	duration: function duration(d) {
		this._duration = d;
		return this;
	},

	start: function (time) {

		this._group.add(this);

		this._isPlaying = true;

		this._onStartCallbackFired = false;

		this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
		this._startTime += this._delayTime;

		for (var property in this._valuesEnd) {

			// Check if an Array was provided as property value
			if (this._valuesEnd[property] instanceof Array) {

				if (this._valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (this._object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			this._valuesStart[property] = this._object[property];

			if ((this._valuesStart[property] instanceof Array) === false) {
				this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

		}

		return this;

	},

	stop: function () {

		if (!this._isPlaying) {
			return this;
		}

		this._group.remove(this);
		this._isPlaying = false;

		if (this._onStopCallback !== null) {
			this._onStopCallback(this._object);
		}

		this.stopChainedTweens();
		return this;

	},

	end: function () {

		this.update(Infinity);
		return this;

	},

	stopChainedTweens: function () {

		for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
			this._chainedTweens[i].stop();
		}

	},

	group: function (group) {
		this._group = group;
		return this;
	},

	delay: function (amount) {

		this._delayTime = amount;
		return this;

	},

	repeat: function (times) {

		this._repeat = times;
		return this;

	},

	repeatDelay: function (amount) {

		this._repeatDelayTime = amount;
		return this;

	},

	yoyo: function (yoyo) {

		this._yoyo = yoyo;
		return this;

	},

	easing: function (easingFunction) {

		this._easingFunction = easingFunction;
		return this;

	},

	interpolation: function (interpolationFunction) {

		this._interpolationFunction = interpolationFunction;
		return this;

	},

	chain: function () {

		this._chainedTweens = arguments;
		return this;

	},

	onStart: function (callback) {

		this._onStartCallback = callback;
		return this;

	},

	onUpdate: function (callback) {

		this._onUpdateCallback = callback;
		return this;

	},

	onRepeat: function onRepeat(callback) {

		this._onRepeatCallback = callback;
		return this;

	},

	onComplete: function (callback) {

		this._onCompleteCallback = callback;
		return this;

	},

	onStop: function (callback) {

		this._onStopCallback = callback;
		return this;

	},

	update: function (time) {

		var property;
		var elapsed;
		var value;

		if (time < this._startTime) {
			return true;
		}

		if (this._onStartCallbackFired === false) {

			if (this._onStartCallback !== null) {
				this._onStartCallback(this._object);
			}

			this._onStartCallbackFired = true;
		}

		elapsed = (time - this._startTime) / this._duration;
		elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

		value = this._easingFunction(elapsed);

		for (property in this._valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (this._valuesStart[property] === undefined) {
				continue;
			}

			var start = this._valuesStart[property] || 0;
			var end = this._valuesEnd[property];

			if (end instanceof Array) {

				this._object[property] = this._interpolationFunction(end, value);

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof (end) === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof (end) === 'number') {
					this._object[property] = start + (end - start) * value;
				}

			}

		}

		if (this._onUpdateCallback !== null) {
			this._onUpdateCallback(this._object, elapsed);
		}

		if (elapsed === 1) {

			if (this._repeat > 0) {

				if (isFinite(this._repeat)) {
					this._repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in this._valuesStartRepeat) {

					if (typeof (this._valuesEnd[property]) === 'string') {
						this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
					}

					if (this._yoyo) {
						var tmp = this._valuesStartRepeat[property];

						this._valuesStartRepeat[property] = this._valuesEnd[property];
						this._valuesEnd[property] = tmp;
					}

					this._valuesStart[property] = this._valuesStartRepeat[property];

				}

				if (this._yoyo) {
					this._reversed = !this._reversed;
				}

				if (this._repeatDelayTime !== undefined) {
					this._startTime = time + this._repeatDelayTime;
				} else {
					this._startTime = time + this._delayTime;
				}

				if (this._onRepeatCallback !== null) {
					this._onRepeatCallback(this._object);
				}

				return true;

			} else {

				if (this._onCompleteCallback !== null) {

					this._onCompleteCallback(this._object);
				}

				for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					this._chainedTweens[i].start(this._startTime + this._duration);
				}

				return false;

			}

		}

		return true;

	}
};


TWEEN.Easing = {

	Linear: {

		None: function (k) {

			return k;

		}

	},

	Quadratic: {

		In: function (k) {

			return k * k;

		},

		Out: function (k) {

			return k * (2 - k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return - 0.5 * (--k * (k - 2) - 1);

		}

	},

	Cubic: {

		In: function (k) {

			return k * k * k;

		},

		Out: function (k) {

			return --k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);

		}

	},

	Quartic: {

		In: function (k) {

			return k * k * k * k;

		},

		Out: function (k) {

			return 1 - (--k * k * k * k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return - 0.5 * ((k -= 2) * k * k * k - 2);

		}

	},

	Quintic: {

		In: function (k) {

			return k * k * k * k * k;

		},

		Out: function (k) {

			return --k * k * k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);

		}

	},

	Sinusoidal: {

		In: function (k) {

			return 1 - Math.cos(k * Math.PI / 2);

		},

		Out: function (k) {

			return Math.sin(k * Math.PI / 2);

		},

		InOut: function (k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));

		}

	},

	Exponential: {

		In: function (k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);

		},

		Out: function (k) {

			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

		}

	},

	Circular: {

		In: function (k) {

			return 1 - Math.sqrt(1 - k * k);

		},

		Out: function (k) {

			return Math.sqrt(1 - (--k * k));

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

		},

		Out: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

		}

	},

	Back: {

		In: function (k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);

		},

		Out: function (k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;

		},

		InOut: function (k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

		}

	},

	Bounce: {

		In: function (k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

		},

		Out: function (k) {

			if (k < (1 / 2.75)) {
				return 7.5625 * k * k;
			} else if (k < (2 / 2.75)) {
				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
			} else if (k < (2.5 / 2.75)) {
				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
			} else {
				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
			}

		},

		InOut: function (k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

	},

	Bezier: function (v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;

	},

	CatmullRom: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

		}

	},

	Utils: {

		Linear: function (p0, p1, t) {

			return (p1 - p0) * t + p0;

		},

		Bernstein: function (n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);

		},

		Factorial: (function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;

			};

		})(),

		CatmullRom: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
(function (root) {

	if (true) {

		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return TWEEN;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else {}

})(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/csscolorparser/csscolorparser.js":
/*!*******************************************************!*\
  !*** ./node_modules/csscolorparser/csscolorparser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "rebeccapurple": [102,51,153,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

if ( Number.isInteger === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

	Number.isInteger = function ( value ) {

		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

	};

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( 'name' in Function.prototype === false ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	Object.assign = function ( target ) {

		if ( target === undefined || target === null ) {

			throw new TypeError( 'Cannot convert undefined or null to object' );

		}

		const output = Object( target );

		for ( let index = 1; index < arguments.length; index ++ ) {

			const source = arguments[ index ];

			if ( source !== undefined && source !== null ) {

				for ( const nextKey in source ) {

					if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

						output[ nextKey ] = source[ nextKey ];

					}

				}

			}

		}

		return output;

	};

}

const REVISION = '117';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const FrontFaceDirectionCW = 0;
const FrontFaceDirectionCCW = 1;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const Uncharted2ToneMapping = 3;
const CineonToneMapping = 4;
const ACESFilmicToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const SphericalReflectionMapping = 305;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author thezwap
 */

var _lut = [];

for ( var i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

var MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		var cos = Math.cos;
		var sin = Math.sin;

		var c2 = cos( b / 2 );
		var s2 = sin( b / 2 );

		var c13 = cos( ( a + c ) / 2 );
		var s13 = sin( ( a + c ) / 2 );

		var c1_3 = cos( ( a - c ) / 2 );
		var s1_3 = sin( ( a - c ) / 2 );

		var c3_1 = cos( ( c - a ) / 2 );
		var s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Object.defineProperties( Vector2.prototype, {

	"width": {

		get: function () {

			return this.x;

		},

		set: function ( value ) {

			this.x = value;

		}

	},

	"height": {

		get: function () {

			return this.y;

		},

		set: function ( value ) {

			this.y = value;

		}

	}

} );

Object.assign( Vector2.prototype, {

	isVector2: true,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	cross: function ( v ) {

		return this.x * v.y - this.y * v.x;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	},

	random: function () {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( throwOnDegenerate !== undefined ) {

			console.warn( "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	},

	scale: function ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	},

	rotate: function ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	},

	translate: function ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils = {

	getDataURL: function ( image ) {

		var canvas;

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		} else if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			var context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.internalFormat = null;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );
	this.center = new Vector2( 0, 0 );
	this.rotation = 0;

	this.matrixAutoUpdate = true;
	this.matrix = new Matrix3();

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Texture,

	isTexture: true,

	updateMatrix: function () {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		var output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = MathUtils.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				var url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( var i = 0, l = image.length; i < l; i ++ ) {

						url.push( ImageUtils.getDataURL( image[ i ] ) );

					}

				} else {

					// process single image

					url = ImageUtils.getDataURL( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

} );

Object.defineProperty( Texture.prototype, "needsUpdate", {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Object.defineProperties( Vector4.prototype, {

	"width": {

		get: function () {

			return this.z;

		},

		set: function ( value ) {

			this.z = value;

		}

	},

	"height": {

		get: function () {

			return this.w;

		},

		set: function ( value ) {

			this.w = value;

		}

	}

} );

Object.assign( Vector4.prototype, {

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	},

	random: function () {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

} );

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.texture.image = {};
	this.texture.image.width = width;
	this.texture.image.height = height;

	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.texture.image.width = width;
			this.texture.image.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.samples = 4;

}

WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

	constructor: WebGLMultisampleRenderTarget,

	isWebGLMultisampleRenderTarget: true,

	copy: function ( source ) {

		WebGLRenderTarget.prototype.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	},

	multiplyQuaternionsFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		var x0 = src0[ srcOffset0 ];
		var y0 = src0[ srcOffset0 + 1 ];
		var z0 = src0[ srcOffset0 + 2 ];
		var w0 = src0[ srcOffset0 + 3 ];

		var x1 = src1[ srcOffset1 ];
		var y1 = src1[ srcOffset1 + 1 ];
		var z1 = src1[ srcOffset1 + 2 ];
		var w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	},

	setFromUnitVectors: function ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var EPS = 0.000001;

		var r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	},

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();
var _quaternion = new Quaternion();

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	},

	applyAxisAngle: function ( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyNormalMatrix: function ( m ) {

		return this.applyMatrix3( m ).normalize();

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( v ) {

		var denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		var scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	},

	projectOnPlane: function ( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	},

	reflect: function ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	},

	angleTo: function ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	setFromMatrix3Column: function ( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	},

	random: function () {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

} );

var _v1 = new Vector3();
var _m1 = new Matrix4();
var _zero = new Vector3( 0, 0, 0 );
var _one = new Vector3( 1, 1, 1 );
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	},

	extractRotation: function ( m ) {

		// this method does not support reflection matrices

		var te = this.elements;
		var me = m.elements;

		var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		return this.compose( _zero, q, _one );

	},

	lookAt: function ( eye, target, up ) {

		var te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	},

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( x, y, z ) {

		var te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		if ( throwOnDegenerate !== undefined ) {

			console.warn( "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate." );

		}

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	},

	decompose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	},

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

var _matrix = new Matrix4();
var _quaternion$1 = new Quaternion();

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	},

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function ( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$1.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$1, newOrder );

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	enableAll: function () {

		this.mask = 0xffffffff | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	disableAll: function () {

		this.mask = 0;

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );

let _object3DId = 0;

const _v1$1 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();

const _position = new Vector3();
const _scale = new Vector3();
const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3( 1, 0, 0 );
const _yAxis = new Vector3( 0, 1, 0 );
const _zAxis = new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$1.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$1.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		var parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.inverse() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new Quaternion();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, _quaternion$2, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			var parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				var shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

						var shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			var shapes = extractFromCache( meta.shapes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.environment = null;
	this.fog = null;

	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Scene,

	isScene: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

var _points = [
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3()
];

var _vector$1 = new Vector3();

var _box = new Box3();

// triangle centered vertices

var _v0 = new Vector3();
var _v1$2 = new Vector3();
var _v2 = new Vector3();

// triangle edge vectors

var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();

var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}


Object.assign( Box3.prototype, {

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function ( center, size ) {

		var halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	},

	setFromObject: function ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	expandByObject: function ( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		var geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox );
			_box.applyMatrix4( object.matrixWorld );

			this.union( _box );

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: function ( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$1 );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	},

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	},

	intersectsTriangle: function ( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0.subVectors( triangle.a, _center );
		_v1$2.subVectors( triangle.b, _center );
		_v2.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$2, _v0 );
		_f1.subVectors( _v2, _v1$2 );
		_f2.subVectors( _v0, _v2 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		var axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0, _v1$2, _v2, _extents );

	},

	clampPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function ( point ) {

		var clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	},

	getBoundingSphere: function ( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$1 ).length() * 0.5;

		return target;

	},

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function ( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

function satForAxes( axes, v0, v1, v2, extents ) {

	var i, j;

	for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		var p0 = v0.dot( _testAxis );
		var p1 = v1.dot( _testAxis );
		var p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

var _box$1 = new Box3();

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : - 1;

}

Object.assign( Sphere.prototype, {

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function ( points, optionalCenter ) {

		var center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$1.setFromPoints( points ).getCenter( center );

		}

		var maxRadiusSq = 0;

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	isEmpty: function () {

		return ( this.radius < 0 );

	},

	makeEmpty: function () {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	},

	clampPoint: function ( point, target ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	},

	getBoundingBox: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

} );

var _vector$2 = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();

var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal = new Vector3();

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );

}

Object.assign( Ray.prototype, {

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function ( t ) {

		this.origin.copy( this.at( t, _vector$2 ) );

		return this;

	},

	closestPointToPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		var directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function ( point ) {

		var directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$2.distanceToSquared( point );

	},

	distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var a01 = - this.direction.dot( _segDir );
		var b0 = _diff.dot( this.direction );
		var b1 = - _diff.dot( _segDir );
		var c = _diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	},

	intersectSphere: function ( sphere, target ) {

		_vector$2.subVectors( sphere.center, this.origin );
		var tca = _vector$2.dot( this.direction );
		var d2 = _vector$2.dot( _vector$2 ) - tca * tca;
		var radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		var thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		var t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		var t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	},

	intersectsSphere: function ( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	},

	intersectPlane: function ( plane, target ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	},

	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, target ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	},

	intersectsBox: function ( box ) {

		return this.intersectBox( box, _vector$2 ) !== null;

	},

	intersectTriangle: function ( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		var DdN = this.direction.dot( _normal );
		var sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		var QdN = - sign * _diff.dot( _normal );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	},

	applyMatrix4: function ( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();

function Plane( normal, constant ) {

	// normal is assumed to be normalized

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Object.assign( Plane.prototype, {

	isPlane: true,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	},

	setFromCoplanarPoints: function ( a, b, c ) {

		var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	},

	intersectLine: function ( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3();

		}

		var direction = line.delta( _vector1 );

		var denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return undefined;

		}

		var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return undefined;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	},

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function ( matrix, optionalNormalMatrix ) {

		var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	},

	translate: function ( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

var _v0$1 = new Vector3();
var _v1$3 = new Vector3();
var _v2$1 = new Vector3();
var _v3 = new Vector3();

var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Object.assign( Triangle, {

	getNormal: function ( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		var targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	},

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	getBarycoord: function ( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$1.subVectors( point, a );

		var dot00 = _v0$1.dot( _v0$1 );
		var dot01 = _v0$1.dot( _v1$3 );
		var dot02 = _v0$1.dot( _v2$1 );
		var dot11 = _v1$3.dot( _v1$3 );
		var dot12 = _v1$3.dot( _v2$1 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	},

	containsPoint: function ( point, a, b, c ) {

		Triangle.getBarycoord( point, a, b, c, _v3 );

		return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

	},

	getUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3.x );
		target.addScaledVector( uv2, _v3.y );
		target.addScaledVector( uv3, _v3.z );

		return target;

	},

	isFrontFacing: function ( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

} );

Object.assign( Triangle.prototype, {

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	getArea: function () {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	},

	getMidpoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	getNormal: function ( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	},

	getPlane: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	getBarycoord: function ( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	},

	getUV: function ( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	isFrontFacing: function ( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	},

	intersectsBox: function ( box ) {

		return box.intersectsTriangle( this );

	},

	closestPointToPoint: function ( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		var a = this.a, b = this.b, c = this.c;
		var v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		var d1 = _vab.dot( _vap );
		var d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		var d3 = _vab.dot( _vbp );
		var d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		var vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		var d5 = _vab.dot( _vcp );
		var d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		var vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		var va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		var denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

Object.assign( Color.prototype, {

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	},

	setColorName: function ( style ) {

		// color keywords
		var hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function ( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	},

	convertLinearToGamma: function ( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	},

	copySRGBToLinear: function ( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	},

	copyLinearToSRGB: function ( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	},

	convertSRGBToLinear: function () {

		this.copySRGBToLinear( this );

		return this;

	},

	convertLinearToSRGB: function () {

		this.copyLinearToSRGB( this );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function ( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	lerpHSL: function ( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

} );

Color.NAMES = _colorKeywords;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = ( color && color.isColor ) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Object.assign( Face3.prototype, {

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.flatShading = false;
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = AlwaysStencilFunc;
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = KeepStencilOp;
	this.stencilZFail = KeepStencilOp;
	this.stencilZPass = KeepStencilOp;
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function () {},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.flatShading === true ) data.flatShading = this.flatShading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _vector$3 = new Vector3();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix3( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix4( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyNormalMatrix( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.transformDirection( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = {
					name: morphTargets[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = {
					name: morphNormals[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		if ( vertices.length > 0 && faces.length === 0 ) {

			console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

		}

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

var _m1$2 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		var tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	setFromPoints: function ( points ) {

		var position = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
				attribute.name = morphTarget.name;

				array.push( attribute.copyVector3sArray( morphTarget.data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;
		var morphAttributesPosition = this.morphAttributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$4 );

						_vector$4.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$4 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		var position = this.attributes.position;
		var morphAttributesPosition = this.morphAttributes.position;

		if ( position ) {

			// first, find the center of the bounding sphere

			var center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$4 );

						_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$4 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			var maxRadiusSq = 0;

			for ( var i = 0, il = position.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					var morphTargetsRelative = this.morphTargetsRelative;

					for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$4.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$4.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				for ( var i = 0, il = index.count; i < il; i += 3 ) {

					vA = indices[ i + 0 ] * 3;
					vB = indices[ i + 1 ] * 3;
					vC = indices[ i + 2 ] * 3;

					pA.fromArray( positions, vA );
					pB.fromArray( positions, vB );
					pC.fromArray( positions, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ vA ] += cb.x;
					normals[ vA + 1 ] += cb.y;
					normals[ vA + 2 ] += cb.z;

					normals[ vB ] += cb.x;
					normals[ vB + 1 ] += cb.y;
					normals[ vB + 2 ] += cb.z;

					normals[ vC ] += cb.x;
					normals[ vC + 1 ] += cb.y;
					normals[ vC + 2 ] += cb.z;

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeOffset = attribute2.itemSize * offset;
			var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal;

		for ( var i = 0, il = normals.count; i < il; i ++ ) {

			_vector$4.x = normals.getX( i );
			_vector$4.y = normals.getY( i );
			_vector$4.z = normals.getZ( i );

			_vector$4.normalize();

			normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			var array = attribute.array;
			var itemSize = attribute.itemSize;
			var normalized = attribute.normalized;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		// attributes

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		var morphAttributes = this.morphAttributes;

		for ( name in morphAttributes ) {

			var morphArray = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

				var attribute = morphAttribute[ i ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		var groups = this.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var attributeData = attribute.toJSON();

			if ( attribute.name !== '' ) attributeData.name = attribute.name;

			data.data.attributes[ key ] = attributeData;

		}

		var morphAttributes = {};
		var hasMorphAttributes = false;

		for ( var key in this.morphAttributes ) {

			var attributeArray = this.morphAttributes[ key ];

			var array = [];

			for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

				var attribute = attributeArray[ i ];

				var attributeData = attribute.toJSON();

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				array.push( attributeData );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var name, i, l;

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// index

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		var attributes = source.attributes;

		for ( name in attributes ) {

			var attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone() );

		}

		// morph attributes

		var morphAttributes = source.morphAttributes;

		for ( name in morphAttributes ) {

			var array = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone() );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		var groups = source.groups;

		for ( i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();

var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();

var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();

var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();

var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();

var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial();

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		return this;

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;
		var matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		if ( geometry.isBufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var position = geometry.attributes.position;
			var morphPosition = geometry.morphAttributes.position;
			var morphTargetsRelative = geometry.morphTargetsRelative;
			var uv = geometry.attributes.uv;
			var uv2 = geometry.attributes.uv2;
			var groups = geometry.groups;
			var drawRange = geometry.drawRange;
			var i, j, il, jl;
			var group, groupMaterial;
			var start, end;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( i = 0, il = groups.length; i < il; i ++ ) {

						group = groups[ i ];
						groupMaterial = material[ group.materialIndex ];

						start = Math.max( group.start, drawRange.start );
						end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( j = start, jl = end; j < jl; j += 3 ) {

							a = index.getX( j );
							b = index.getX( j + 1 );
							c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					start = Math.max( 0, drawRange.start );
					end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( i = start, il = end; i < il; i += 3 ) {

						a = index.getX( i );
						b = index.getX( i + 1 );
						c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( i = 0, il = groups.length; i < il; i ++ ) {

						group = groups[ i ];
						groupMaterial = material[ group.materialIndex ];

						start = Math.max( group.start, drawRange.start );
						end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( j = start, jl = end; j < jl; j += 3 ) {

							a = j;
							b = j + 1;
							c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					start = Math.max( 0, drawRange.start );
					end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( i = start, il = end; i < il; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			var fvA, fvB, fvC;
			var isMultiMaterial = Array.isArray( material );

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var uvs;

			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

				if ( intersection ) {

					if ( uvs && uvs[ f ] ) {

						var uvs_f = uvs[ f ];
						_uvA.copy( uvs_f[ 0 ] );
						_uvB.copy( uvs_f[ 1 ] );
						_uvC.copy( uvs_f[ 2 ] );

						intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	var intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA.fromBufferAttribute( position, a );
	_vB.fromBufferAttribute( position, b );
	_vC.fromBufferAttribute( position, c );

	var morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

			var influence = morphInfluences[ i ];
			var morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC ), influence );

			}

		}

		_vA.add( _morphA );
		_vB.add( _morphB );
		_vC.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA );
		object.boneTransform( b, _vB );
		object.boneTransform( c, _vC );

	}

	var intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA.fromBufferAttribute( uv, a );
			_uvB.fromBufferAttribute( uv, b );
			_uvC.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		if ( uv2 ) {

			_uvA.fromBufferAttribute( uv2, a );
			_uvB.fromBufferAttribute( uv2, b );
			_uvC.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		var face = new Face3( a, b, c );
		Triangle.getNormal( _vA, _vB, _vC, face.normal );

		intersection.face = face;

	}

	return intersection;

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var _geometryId = 0; // Geometry uses even numbers as Id
var _m1$3 = new Matrix4();
var _obj$1 = new Object3D();
var _offset$1 = new Vector3();

function Geometry() {

	Object.defineProperty( this, 'id', { value: _geometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Geometry,

	isGeometry: true,

	applyMatrix4: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$3.makeRotationX( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$3.makeRotationY( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$3.makeRotationZ( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$3.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$3.makeScale( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj$1.lookAt( vector );

		_obj$1.updateMatrix();

		this.applyMatrix4( _obj$1.matrix );

		return this;

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		if ( attributes.position === undefined ) {

			console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
			return this;

		}

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		for ( var i = 0; i < positions.length; i += 3 ) {

			scope.vertices.push( new Vector3().fromArray( positions, i ) );

			if ( colors !== undefined ) {

				scope.colors.push( new Color().fromArray( colors, i ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexColors = ( colors === undefined ) ? [] : [
				scope.colors[ a ].clone(),
				scope.colors[ b ].clone(),
				scope.colors[ c ].clone() ];

			var vertexNormals = ( normals === undefined ) ? [] : [
				new Vector3().fromArray( normals, a * 3 ),
				new Vector3().fromArray( normals, b * 3 ),
				new Vector3().fromArray( normals, c * 3 )
			];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [
					new Vector2().fromArray( uvs, a * 2 ),
					new Vector2().fromArray( uvs, b * 2 ),
					new Vector2().fromArray( uvs, c * 2 )
				] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [
					new Vector2().fromArray( uvs2, a * 2 ),
					new Vector2().fromArray( uvs2, b * 2 ),
					new Vector2().fromArray( uvs2, c * 2 )
				] );

			}

		}

		var groups = geometry.groups;

		if ( groups.length > 0 ) {

			for ( var i = 0; i < groups.length; i ++ ) {

				var group = groups[ i ];

				var start = group.start;
				var count = group.count;

				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

					if ( indices !== undefined ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

					} else {

						addFace( j, j + 1, j + 2, group.materialIndex );

					}

				}

			}

		} else {

			if ( indices !== undefined ) {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			} else {

				for ( var i = 0; i < positions.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset$1 ).negate();

		this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

		return this;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix4( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( ! ( geometry && geometry.isGeometry ) ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			colors1 = this.colors,
			colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs2 = geometry.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];

			for ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {

				var uvs2 = faceVertexUvs2[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {

					uvsCopy.push( uvs2[ k ].clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ! ( mesh && mesh.isMesh ) ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	setFromPoints: function ( points ) {

		this.vertices = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return this;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		var i, il, j, jl, k, kl;

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		var vertices = source.vertices;

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		var colors = source.colors;

		for ( i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		var faces = source.faces;

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		var morphTargets = source.morphTargets;

		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		var morphNormals = source.morphNormals;

		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

			var morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		var skinWeights = source.skinWeights;

		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		var skinIndices = source.skinIndices;

		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		var lineDistances = source.lineDistances;

		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// BoxGeometry

class BoxGeometry extends Geometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

}

// BoxBufferGeometry

class BoxBufferGeometry extends BufferGeometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		super();

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	var dst = {};

	for ( var u in src ) {

		dst[ u ] = {};

		for ( var p in src[ u ] ) {

			var property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	var merged = {};

	for ( var u = 0; u < uniforms.length; u ++ ) {

		var tmp = cloneUniforms( uniforms[ u ] );

		for ( var p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = default_vertex;
	this.fragmentShader = default_fragment;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = Object.assign( {}, source.extensions );

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = {};

	for ( var name in this.uniforms ) {

		var uniform = this.uniforms[ name ];
		var value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	var extensions = {};

	for ( var key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return MathUtils.RAD2DEG * 2 * Math.atan(
			Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

var fov = 90, aspect = 1;

function CubeCamera( near, far, renderTarget ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

		console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
		return;

	}

	this.renderTarget = renderTarget;

	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.layers = this.layers;
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.layers = this.layers;
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.layers = this.layers;
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.layers = this.layers;
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.layers = this.layers;
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.layers = this.layers;
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.update = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var currentXrEnabled = renderer.xr.enabled;
		var currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	};

	this.clear = function ( renderer, color, depth, stencil ) {

		var currentRenderTarget = renderer.getRenderTarget();

		for ( var i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( renderTarget, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */

function WebGLCubeRenderTarget( size, options, dummy ) {

	if ( Number.isInteger( options ) ) {

		console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

		options = dummy;

	}

	WebGLRenderTarget.call( this, size, size, options );

}

WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {

	this.texture.type = texture.type;
	this.texture.format = texture.format;
	this.texture.encoding = texture.encoding;

	var scene = new Scene();

	var shader = {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: [

			"varying vec3 vWorldDirection;",

			"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",

			"	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",

			"}",

			"void main() {",

			"	vWorldDirection = transformDirection( position, modelMatrix );",

			"	#include <begin_vertex>",
			"	#include <project_vertex>",

			"}"

		].join( '\n' ),

		fragmentShader: [

			"uniform sampler2D tEquirect;",

			"varying vec3 vWorldDirection;",

			"#include <common>",

			"void main() {",

			"	vec3 direction = normalize( vWorldDirection );",

			"	vec2 sampleUV = equirectUv( direction );",

			"	gl_FragColor = texture2D( tEquirect, sampleUV );",

			"}"

		].join( '\n' ),
	};

	var material = new ShaderMaterial( {

		type: 'CubemapFromEquirect',

		uniforms: cloneUniforms( shader.uniforms ),
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		side: BackSide,
		blending: NoBlending

	} );

	material.uniforms.tEquirect.value = texture;

	var mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );

	scene.add( mesh );

	var camera = new CubeCamera( 1, 10, this );
	camera.update( renderer, scene );

	mesh.geometry.dispose();
	mesh.material.dispose();

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data || null, width: width || 1, height: height || 1 };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;

	this.needsUpdate = true;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

var _sphere$1 = new Sphere();
var _vector$5 = new Vector3();

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Object.assign( Frustum.prototype, {

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromProjectionMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	},

	intersectsSprite: function ( sprite ) {

		_sphere$1.center.set( 0, 0, 0 );
		_sphere$1.radius = 0.7071067811865476;
		_sphere$1.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	},

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function ( box ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			var plane = planes[ i ];

			// corner at max distance

			_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

} );

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation() {

	var context = null;
	var isAnimating = false;
	var animationLoop = null;

	function onAnimationFrame( time, frame ) {

		if ( isAnimating === false ) return;

		animationLoop( time, frame );

		context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAttributes( gl, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		var array = attribute.array;
		var usage = attribute.usage;

		var buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		var type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			type = 5123;

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		var array = attribute.array;
		var updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		var data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		var data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// PlaneGeometry

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	this.mergeVertices();

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

// PlaneBufferGeometry

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	width = width || 1;
	height = height || 1;

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices.push( x, - y, 0 );

			normals.push( 0, 0, 1 );

			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );

		}

	}

	// indices

	for ( iy = 0; iy < gridY; iy ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshtoon_frag: meshtoon_frag,
	meshtoon_vert: meshtoon_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new Color( 0x000000 ) },
			transparency: { value: 0 },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

	var clearColor = new Color( 0x000000 );
	var clearAlpha = 0;

	var planeMesh;
	var boxMesh;

	var currentBackground = null;
	var currentBackgroundVersion = 0;
	var currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		var background = scene.background;

		// Ignore background in AR
		// TODO: Reconsider this.

		var xr = renderer.xr;
		var session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxBufferGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						type: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			var texture = background.isWebGLCubeRenderTarget ? background.texture : background;

			boxMesh.material.uniforms.envMap.value = texture;
			boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== texture.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = texture.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new ShaderMaterial( {
						type: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha ) {

			clearColor.set( color );
			clearAlpha = alpha !== undefined ? alpha : 1;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count, primcount ) {

		if ( primcount === 0 ) return;

		var extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	var maxTextures = gl.getParameter( 34930 );
	var maxVertexTextures = gl.getParameter( 35660 );
	var maxTextureSize = gl.getParameter( 3379 );
	var maxCubemapSize = gl.getParameter( 34076 );

	var maxAttributes = gl.getParameter( 34921 );
	var maxVertexUniforms = gl.getParameter( 36347 );
	var maxVaryings = gl.getParameter( 36348 );
	var maxFragmentUniforms = gl.getParameter( 36349 );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, attributes, info ) {

	var geometries = new WeakMap();
	var wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries.get( geometry );

		if ( buffergeometry.index !== null ) {

			attributes.remove( buffergeometry.index );

		}

		for ( var name in buffergeometry.attributes ) {

			attributes.remove( buffergeometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		geometries.delete( geometry );

		var attribute = wireframeAttributes.get( buffergeometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( buffergeometry );

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		var buffergeometry = geometries.get( geometry );

		if ( buffergeometry ) return buffergeometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		if ( geometry.isBufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry.isGeometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries.set( geometry, buffergeometry );

		info.memory.geometries ++;

		return buffergeometry;

	}

	function update( geometry ) {

		var index = geometry.index;
		var geometryAttributes = geometry.attributes;

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		for ( var name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		var indices = [];

		var geometryIndex = geometry.index;
		var geometryPosition = geometry.attributes.position;
		var version = 0;

		if ( geometryIndex !== null ) {

			var array = geometryIndex.array;
			version = geometryIndex.version;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = geometryPosition.array;
			version = geometryPosition.version;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		attributes.update( attribute, 34963 );

		//

		var previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		var currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			var geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count, primcount ) {

		if ( primcount === 0 ) return;

		var extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLInfo( gl ) {

	var memory = {
		geometries: 0,
		textures: 0
	};

	var render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		instanceCount = instanceCount || 1;

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	var influencesList = {};
	var morphInfluences = new Float32Array( 8 );

	function update( object, geometry, material, program ) {

		var objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		var length = objectInfluences === undefined ? 0 : objectInfluences.length;

		var influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( var i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		// Remove current morphAttributes

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			if ( influence[ 1 ] !== 0 ) {

				if ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );
				if ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );

			}

		}

		// Collect influences

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		// Add morphAttributes

		var morphInfluencesSum = 0;

		for ( var i = 0; i < 8; i ++ ) {

			var influence = influences[ i ];

			if ( influence ) {

				var index = influence[ 0 ];
				var value = influence[ 1 ];

				if ( value ) {

					if ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );
					if ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;
					continue;

				}

			}

			morphInfluences[ i ] = 0;

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( gl, geometries, attributes, info ) {

	var updateMap = new WeakMap();

	function update( object ) {

		var frame = info.render.frame;

		var geometry = object.geometry;
		var buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			if ( geometry.isGeometry ) {

				buffergeometry.updateFromObject( object );

			}

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			attributes.update( object.instanceMatrix, 34962 );

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	format = format !== undefined ? format : RGBFormat;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author Takahiro https://github.com/takahirox
 */

function DataTexture2DArray( data, width, height, depth ) {

	Texture.call( this, null );

	this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;

}

DataTexture2DArray.prototype = Object.create( Texture.prototype );
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;

/**
 * @author Artur Trzesiok
 */

function DataTexture3D( data, width, height, depth ) {

	// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in DataTexture3D directly.
	//
	//	var texture = new THREE.DataTexture3D( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839

	Texture.call( this, null );

	this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;


}

DataTexture3D.prototype = Object.create( Texture.prototype );
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;

/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array( 16 );
var mat3array = new Float32Array( 9 );
var mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( var i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( var i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		r[ i ] = textures.allocateTextureUnit();

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or MatrixN)

function setValueM2( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

function setValueT3D1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

function setValueV2i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// uint

function setValueV1ui( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}

// Array of scalars
function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}


// Array of vectors (flat or from THREE classes)

function setValueV2fArray( gl, v ) {

	var data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	var data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	var data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (flat or from THREE clases)

function setValueM2Array( gl, v ) {

	var data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	var data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	var data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	var n = v.length;

	var units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	var n = v.length;

	var units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	var cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			var map = container.map, next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	var n = gl.getProgramParameter( program, 35718 );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getShaderErrors( gl, shader, type ) {

	var status = gl.getShaderParameter( shader, 35713 );
	var log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	var source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case Uncharted2ToneMapping:
			toneMappingName = 'Uncharted2';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	var chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, 35721 );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	var string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	var string = '';

	for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[ i \]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

	if ( parameters.precision === "highp" ) {

		precisionstring += "\n#define HIGH_PRECISION";

	} else if ( parameters.precision === "mediump" ) {

		precisionstring += "\n#define MEDIUM_PRECISION";

	} else if ( parameters.precision === "lowp" ) {

		precisionstring += "\n#define LOW_PRECISION";

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters ) {

	var gl = renderer.getContext();

	var defines = parameters.defines;

	var vertexShader = parameters.vertexShader;
	var fragmentShader = parameters.fragmentShader;
	var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	var envMapModeDefine = generateEnvMapModeDefine( parameters );
	var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	var customDefines = generateDefines( defines );

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			' attribute mat4 instanceMatrix;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?
				ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {

		var isGLSL3ShaderMaterial = false;

		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

		if ( parameters.isShaderMaterial &&
			vertexShader.match( versionRegex ) !== null &&
			fragmentShader.match( versionRegex ) !== null ) {

			isGLSL3ShaderMaterial = true;

			vertexShader = vertexShader.replace( versionRegex, '' );
			fragmentShader = fragmentShader.replace( versionRegex, '' );

		}

		// GLSL 3.0 conversion

		prefixVertex = [
			'#version 300 es\n',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#version 300 es\n',
			'#define varying in',
			isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
			isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, extensions, capabilities ) {

	var programs = [];

	var isWebGL2 = capabilities.isWebGL2;
	var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	var floatVertexTextures = capabilities.floatVertexTextures;
	var precision = capabilities.precision;
	var maxVertexUniforms = capabilities.maxVertexUniforms;
	var vertexTextures = capabilities.vertexTextures;

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	var parameterNames = [
		"precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",
		"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
		"lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
		"sheen"
	];

	function getShaderObject( material, shaderID ) {

		var shaderobject;

		if ( shaderID ) {

			var shader = ShaderLib[ shaderID ];

			shaderobject = {
				name: material.type,
				uniforms: UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			};

		} else {

			shaderobject = {
				name: material.type,
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			};

		}

		return shaderobject;

	}

	function allocateBones( object ) {

		var skeleton = object.skeleton;
		var bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {

		var fog = scene.fog;
		var environment = material.isMeshStandardMaterial ? scene.environment : null;

		var envMap = material.envMap || environment;

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var shaderobject = getShaderObject( material, shaderID );
		material.onBeforeCompile( shaderobject, renderer );

		var currentRenderTarget = renderer.getRenderTarget();

		var parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: shaderobject.name,

			uniforms: shaderobject.uniforms,
			vertexShader: shaderobject.vertexShader,
			fragmentShader: shaderobject.fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial,
			isShaderMaterial: material.isShaderMaterial,

			precision: precision,

			instancing: object.isInstancedMesh === true,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,
			rendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,

			onBeforeCompile: material.onBeforeCompile

		};

		return parameters;

	};

	this.getProgramCacheKey = function ( parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( var name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === undefined ) {

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.onBeforeCompile.toString() );

		return array.join();

	};

	this.acquireProgram = function ( parameters, cacheKey ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function ( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = new WeakMap();

	function get( object ) {

		var map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	var renderItems = [];
	var renderItemsIndex = 0;

	var opaque = [];
	var transparent = [];

	var defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		var renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			var renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {
		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	var lists = new WeakMap();

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		lists.delete( scene );

	}

	function get( scene, camera ) {

		var cameras = lists.get( scene );
		var list;
		if ( cameras === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, new WeakMap() );
			lists.get( scene ).set( camera, list );

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			list = cameras.get( camera );
			if ( list === undefined ) {

				list = new WebGLRenderList();
				cameras.set( camera, list );

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function UniformsCache() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



var nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights() {

	var cache = new UniformsCache();

	var shadowCache = ShadowUniformsCache();

	var state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	var vector3 = new Vector3();
	var matrix4 = new Matrix4();
	var matrix42 = new Matrix4();

	function setup( lights, shadows, camera ) {

		var r = 0, g = 0, b = 0;

		for ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		var directionalLength = 0;
		var pointLength = 0;
		var spotLength = 0;
		var rectAreaLength = 0;
		var hemiLength = 0;

		var numDirectionalShadows = 0;
		var numPointShadows = 0;
		var numSpotShadows = 0;

		var viewMatrix = camera.matrixWorldInverse;

		lights.sort( shadowCastingLightsFirst );

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			var color = light.color;
			var intensity = light.intensity;
			var distance = light.distance;

			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( var j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				var uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				var uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				var uniforms = cache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		var hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	return {
		setup: setup,
		state: state
	};

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLRenderState() {

	var lights = new WebGLLights();

	var lightsArray = [];
	var shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( camera ) {

		lights.setup( lightsArray, shadowsArray, camera );

	}

	var state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates() {

	var renderStates = new WeakMap();

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		renderStates.delete( scene );

	}

	function get( scene, camera ) {

		var renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState();
			renderStates.set( scene, new WeakMap() );
			renderStates.get( scene ).set( camera, renderState );

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			if ( renderStates.get( scene ).has( camera ) === false ) {

				renderState = new WebGLRenderState();
				renderStates.get( scene ).set( camera, renderState );

			} else {

				renderState = renderStates.get( scene ).get( camera );

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDistanceMaterial';

	this.referencePosition = new Vector3();
	this.nearDistance = 1;
	this.farDistance = 1000;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.fog = false;

	this.setValues( parameters );

}

MeshDistanceMaterial.prototype = Object.create( Material.prototype );
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.referencePosition.copy( source.referencePosition );
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	return this;

};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

	var _frustum = new Frustum(),

		_shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {};

	var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	var shadowMaterialVertical = new ShaderMaterial( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	} );

	var shadowMaterialHorizonal = shadowMaterialVertical.clone();
	shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;

	var fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		"position",
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		var currentRenderTarget = _renderer.getRenderTarget();
		var activeCubeFace = _renderer.getActiveCubeFace();
		var activeMipmapLevel = _renderer.getActiveMipmapLevel();

		var _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( var i = 0, il = lights.length; i < il; i ++ ) {

			var light = lights[ i ];
			var shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			_shadowMapSize.copy( shadow.mapSize );

			var shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

				if ( _shadowMapSize.x > maxTextureSize ) {

					_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > maxTextureSize ) {

					_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			var viewportCount = shadow.getViewportCount();

			for ( var vp = 0; vp < viewportCount; vp ++ ) {

				var viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		var geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizonal pass

		shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		var material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		var material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		var result = null;

		var getMaterialVariant = getDepthMaterialVariant;
		var customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			var useMorphing = false;

			if ( material.morphTargets === true ) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			var useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			var useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				var geometry = _objects.update( object );
				var material = object.material;

				if ( Array.isArray( material ) ) {

					var groups = geometry.groups;

					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

						var group = groups[ k ];
						var groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							var depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					var depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( 34921 );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var enabledCapabilities = {};

	var currentProgram = null;

	var currentBlendingEnabled = null;
	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( 35661 );

	var lineWidthAvailable = false;
	var version = 0;
	var glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			var extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, normalized, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	var equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		var extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	var factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( ! currentBlendingEnabled ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		var flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		var stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentProgram = null;

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		vertexAttribPointer: vertexAttribPointer,
		enable: enable,
		disable: disable,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	var isWebGL2 = capabilities.isWebGL2;
	var maxTextures = capabilities.maxTextures;
	var maxCubemapSize = capabilities.maxCubemapSize;
	var maxTextureSize = capabilities.maxTextureSize;
	var maxSamples = capabilities.maxSamples;

	var _videoTextures = new WeakMap();
	var _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	var useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		var scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

				var width = floor( scale * image.width );
				var height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		var textureProperties = properties.get( texture );

		// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
		textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		var internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );

	}

	//

	var textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		var textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );

			var isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
			var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			var cubeImage = [];

			for ( var i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

			}

			var image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( 34067, texture, supportsMips );

			var mipmaps;

			if ( isCompressed ) {

				for ( var i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( var j = 0; j < mipmaps.length; j ++ ) {

						var mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				mipmaps = texture.mipmaps;

				for ( var i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						for ( var j = 0; j < mipmaps.length; j ++ ) {

							var mipmap = mipmaps[ j ];
							var mipmapImage = mipmap.image[ i ].image;

							state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

						}

					} else {

						state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						for ( var j = 0; j < mipmaps.length; j ++ ) {

							var mipmap = mipmaps[ j ];

							state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length;

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		} else {

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, properties.get( texture ).__webglTexture );

	}

	var wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	var filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		var textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );

		var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		var supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = utils.convert( renderTarget.texture.format );
		var glType = utils.convert( renderTarget.texture.type );
		var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			var glInternalFormat = 33189;

			if ( isMultisample ) {

				var depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		_gl.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		_gl.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures ++;

		var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {

			renderTarget.texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					var glFormat = utils.convert( renderTarget.texture.format );
					var glType = utils.convert( renderTarget.texture.type );
					var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
					var samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					_gl.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, renderTarget.texture, supportsMips );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 34067, null );

		} else {

			state.bindTexture( 3553, textureProperties.__webglTexture );
			setTextureParameters( 3553, renderTarget.texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 3553, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;
		var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				var renderTargetProperties = properties.get( renderTarget );

				_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				var width = renderTarget.width;
				var height = renderTarget.height;
				var mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		var frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	var warnedTexture2D = false;
	var warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}

		// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
		// TODO: unify these code paths
		if ( ( texture && texture.isCubeTexture ) ||
			( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

			// CompressedTexture can have Array in image :/

			// this function alone should take care of cube textures
			setTextureCube( texture, slot );

		} else {

			// assumed: texture property of THREE.WebGLCubeRenderTarget
			setTextureCubeDynamic( texture, slot );

		}

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

/**
 * @author thespite / http://www.twitter.com/thespite
 */

function WebGLUtils( gl, extensions, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		var extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera( array ) {

	PerspectiveCamera.call( this );

	this.cameras = array || [];

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group,

	isGroup: true

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebXRController() {

	this._targetRay = null;
	this._grip = null;

}

Object.assign( WebXRController.prototype, {

	constructor: WebXRController,

	getTargetRaySpace: function () {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;

		}

		return this._targetRay;

	},

	getGripSpace: function () {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;

		}

		return this._grip;

	},

	dispatchEvent: function ( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		return this;

	},

	disconnect: function ( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		return this;

	},

	update: function ( inputSource, frame, referenceSpace ) {

		var inputPose = null;
		var gripPose = null;

		var targetRay = this._targetRay;
		var grip = this._grip;

		if ( inputSource ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

				}

			}

			if ( grip !== null && inputSource.gripSpace ) {

				gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

				if ( gripPose !== null ) {

					grip.matrix.fromArray( gripPose.transform.matrix );
					grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager( renderer, gl ) {

	var scope = this;

	var session = null;

	var framebufferScaleFactor = 1.0;

	var referenceSpace = null;
	var referenceSpaceType = 'local-floor';

	var pose = null;

	var controllers = [];
	var inputSourcesMap = new Map();

	//

	var cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	var cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	var cameras = [ cameraL, cameraR ];

	var cameraVR = new ArrayCamera();
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	var _currentDepthNear = null;
	var _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( index ) {

		var controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getTargetRaySpace();

	};

	this.getControllerGrip = function ( index ) {

		var controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getGripSpace();

	};

	//

	function onSessionEvent( event ) {

		var controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			controller.dispatchEvent( { type: event.type } );

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			controller.disconnect( inputSource );

		} );

		inputSourcesMap.clear();

		//

		renderer.setFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	function onRequestReferenceSpace( value ) {

		referenceSpace = value;

		animation.setContext( session );
		animation.start();

		scope.isPresenting = true;

		scope.dispatchEvent( { type: 'sessionstart' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

		}

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );

			var attributes = gl.getContextAttributes();

			if ( attributes.xrCompatible !== true ) {

				gl.makeXRCompatible();

			}

			var layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			var baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

		}

	};

	function updateInputSources( event ) {

		var inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( var i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( var i = 0; i < event.removed.length; i ++ ) {

			var inputSource = event.removed[ i ];
			var controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( var i = 0; i < event.added.length; i ++ ) {

			var inputSource = event.added[ i ];
			var controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'connected', data: inputSource } );

			}

		}

	}

	//

	var cameraLPos = new Vector3();
	var cameraRPos = new Vector3();

	/**
	 * @author jsantell / https://www.jsantell.com/
	 *
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		var ipd = cameraLPos.distanceTo( cameraRPos );

		var projL = cameraL.projectionMatrix.elements;
		var projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		var left = near * leftFov;
		var right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		var zOffset = ipd / ( - leftFov + rightFov );
		var xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		var near2 = near + zOffset;
		var far2 = far + zOffset;
		var left2 = left - xOffset;
		var right2 = right + ( ipd - xOffset );
		var top2 = topFov * far / far2 * near2;
		var bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		var parent = camera.parent;
		var cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( var i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );

		var children = camera.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		// update projection matrix for proper view frustum culling

		if ( cameras.length === 2 ) {

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

		} else {

			// assume single camera setup (AR)

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		}

		return cameraVR;

	};

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			var views = pose.views;
			var baseLayer = session.renderState.baseLayer;

			renderer.setFramebuffer( baseLayer.framebuffer );

			var cameraVRNeedsUpdate = false;

			// check if it's necessary to rebuild cameraVR's camera list

			if ( views.length !== cameraVR.cameras.length ) {

				cameraVR.cameras.length = 0;
				cameraVRNeedsUpdate = true;

			}

			for ( var i = 0; i < views.length; i ++ ) {

				var view = views[ i ];
				var viewport = baseLayer.getViewport( view );

				var camera = cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

				if ( cameraVRNeedsUpdate === true ) {

					cameraVR.cameras.push( camera );

				}

			}

		}

		//

		var inputSources = session.inputSources;

		for ( var i = 0; i < controllers.length; i ++ ) {

			var controller = controllers[ i ];
			var inputSource = inputSources[ i ];

			controller.update( inputSource, frame, referenceSpace );

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, environment, pixelRatio, height ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material, environment );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, environment );

			} else {

				refreshUniformsStandard( uniforms, material, environment );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material, environment ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		var envMap = material.envMap || environment;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			uniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		var uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material, environment ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap || environment ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, environment ) {

		refreshUniformsStandard( uniforms, material, environment );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === BackSide ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transparency.value = material.transparency;

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	var currentRenderList = null;
	var currentRenderState = null;

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		_isContextLost = false,

		// internal state cache

		_framebuffer = null,

		_currentActiveCubeFace = 0,
		_currentActiveMipmapLevel = 0,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,

		// geometry and program caching

		_currentGeometryProgram = {
			geometry: null,
			program: null,
			wireframe: false
		},

		_currentCamera = null,
		_currentArrayCamera = null,

		_currentViewport = new Vector4(),
		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		//

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,
		_opaqueSort = null,
		_transparentSort = null,

		_viewport = new Vector4( 0, 0, _width, _height ),
		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3();

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	var _gl;

	try {

		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw new Error( 'Error creating WebGL context with your selected attributes.' );

			} else {

				throw new Error( 'Error creating WebGL context.' );

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	var extensions, capabilities, state, info;
	var properties, textures, attributes, geometries, objects;
	var programCache, materials, renderLists, renderStates;

	var background, morphtargets, bufferRenderer, indexedBufferRenderer;

	var utils;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		if ( capabilities.isWebGL2 === false ) {

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

		}

		extensions.get( 'OES_texture_float_linear' );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		attributes = new WebGLAttributes( _gl, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl );
		programCache = new WebGLPrograms( _this, extensions, capabilities );
		materials = new WebGLMaterials( properties );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates();

		background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	var xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// shadow map

	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

	this.shadowMap = shadowMap;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new Vector4();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function () {

		return background.getClearColor();

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		objects.dispose();

		xr.dispose();

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		initGLContext();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( 34962, buffers.position );
			_gl.bufferData( 34962, object.positionArray, 35048 );

			state.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( 34962, buffers.normal );
			_gl.bufferData( 34962, object.normalArray, 35048 );

			state.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( 34962, buffers.uv );
			_gl.bufferData( 34962, object.uvArray, 35048 );

			state.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( 34962, buffers.color );
			_gl.bufferData( 34962, object.colorArray, 35048 );

			state.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( 4, 0, object.count );

		object.count = 0;

	};

	var tempScene = new Scene();

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)

		var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		var program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		var updateBuffers = false;

		if ( _currentGeometryProgram.geometry !== geometry.id ||
			_currentGeometryProgram.program !== program.id ||
			_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

			_currentGeometryProgram.geometry = geometry.id;
			_currentGeometryProgram.program = program.id;
			_currentGeometryProgram.wireframe = material.wireframe === true;
			updateBuffers = true;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

			updateBuffers = true;

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var attribute;
		var renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, geometry, material, program );

			if ( index !== null ) {

				_gl.bindBuffer( 34963, attribute.buffer );

			}

		}

		//

		var dataCount = ( index !== null ) ? index.count : position.count;

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( geometry, drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			var instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( geometry, drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( object, geometry, material, program ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( 34962, buffer );
						state.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( 34962, buffer );
						state.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					var attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					var buffer = attribute.buffer;
					var type = attribute.type;

					state.enableAttributeAndDivisor( programAttribute + 0, 1 );
					state.enableAttributeAndDivisor( programAttribute + 1, 1 );
					state.enableAttributeAndDivisor( programAttribute + 2, 1 );
					state.enableAttributeAndDivisor( programAttribute + 3, 1 );

					_gl.bindBuffer( 34962, buffer );

					_gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					_gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					_gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					_gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.traverse( function ( object ) {

			if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( camera );

		const compiled = {};

		scene.traverse( function ( object ) {

			let material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						let material2 = material[ i ];

						if ( material2.uuid in compiled === false ) {

							initMaterial( material2, scene, object );
							compiled[ material2.uuid ] = true;

						}

					}

				} else if ( material.uuid in compiled === false ) {

					initMaterial( material, scene, object );
					compiled[ material.uuid ] = true;

				}

			}

		} );

	};

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( xr.isPresenting ) return;
		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		animation.start();

	};

	// Rendering

	this.render = function ( scene, camera ) {

		var renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( ! ( camera && camera.isCamera ) ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost ) return;

		// reset caching for this frame

		_currentGeometryProgram.geometry = null;
		_currentGeometryProgram.program = null;
		_currentGeometryProgram.wireframe = false;
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled && xr.isPresenting ) {

			camera = xr.getCamera( camera );

		}

		//
		scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		var shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights( camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		if ( this.info.autoReset ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

			// transparent pass (back-to-front order)

			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

		}

		//

		scene.onAfterRender( _this, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		currentRenderList = null;
		currentRenderState = null;

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var i = 0, l = groups.length; i < l; i ++ ) {

							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			if ( camera.isArrayCamera ) {

				_currentArrayCamera = camera;

				var cameras = camera.cameras;

				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

					var camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLights( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				_currentArrayCamera = null;

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			var program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

	}

	function initMaterial( material, scene, object ) {

		var materialProperties = properties.get( material );

		var lights = currentRenderState.state.lights;
		var shadowsArray = currentRenderState.state.shadowsArray;

		var lightsStateVersion = lights.state.version;

		var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );
		var programCacheKey = programCache.getProgramCacheKey( parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.cacheKey !== programCacheKey ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

			materialProperties.lightsStateVersion = lightsStateVersion;

			programChange = false;

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			program = programCache.acquireProgram( parameters, programCacheKey );

			materialProperties.program = program;
			materialProperties.uniforms = parameters.uniforms;
			materialProperties.outputEncoding = parameters.outputEncoding;
			material.program = program;

		}

		var programAttributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, scene, material, object ) {

		textures.resetTextureUnits();

		var fog = scene.fog;
		var environment = material.isMeshStandardMaterial ? scene.environment : null;
		var encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;

		var materialProperties = properties.get( material );
		var lights = currentRenderState.state.lights;

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.program === undefined ) {

				initMaterial( material, scene, object );

			} else if ( material.fog && materialProperties.fog !== fog ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.environment !== environment ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.outputEncoding !== encoding ) {

				initMaterial( material, scene, object );

			}

		} else {

			initMaterial( material, scene, object );
			materialProperties.__version = material.version;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				var bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === undefined ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = MathUtils.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, environment, _pixelRatio, _height );

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
			if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	//
	this.setFramebuffer = function ( value ) {

		if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );

		_framebuffer = value;

	};

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var framebuffer = _framebuffer;
		var isCube = false;

		if ( renderTarget ) {

			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( 36160, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipmapLevel || 0 );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( 36160, _currentFramebuffer );

				}

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level ) {

		if ( level === undefined ) level = 0;

		var levelScale = Math.pow( 2, - level );
		var width = Math.floor( texture.image.width * levelScale );
		var height = Math.floor( texture.image.height * levelScale );
		var glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

		if ( level === undefined ) level = 0;

		var width = srcTexture.image.width;
		var height = srcTexture.image.height;
		var glFormat = utils.convert( dstTexture.format );
		var glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2( color, density ) {

	this.name = '';

	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

}

Object.assign( FogExp2.prototype, {

	isFogExp2: true,

	clone: function () {

		return new FogExp2( this.color, this.density );

	},

	toJSON: function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog( color, near, far ) {

	this.name = '';

	this.color = new Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

}

Object.assign( Fog.prototype, {

	isFog: true,

	clone: function () {

		return new Fog( this.color, this.near, this.far );

	},

	toJSON: function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

var _vector$6 = new Vector3();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.name = '';

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( var i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

		var array = [];

		for ( var i = 0; i < this.count; i ++ ) {

			var index = i * this.data.stride + this.offset;

			for ( var j = 0; j < this.itemSize; j ++ ) {

				array.push( this.data.array[ index + j ] );

			}

		}

		return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

	},

	toJSON: function () {

		console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

		var array = [];

		for ( var i = 0; i < this.count; i ++ ) {

			var index = i * this.data.stride + this.offset;

			for ( var j = 0; j < this.itemSize; j ++ ) {

				array.push( this.data.array[ index + j ] );

			}

		}

		// deinterleave data and save it as an ordinary buffer attribute for now

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: array,
			normalized: this.normalized
		};

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.rotation = 0;

	this.sizeAttenuation = true;

	this.transparent = true;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.rotation = source.rotation;

	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

var _geometry;

var _intersectPoint = new Vector3();
var _worldScale = new Vector3();
var _mvPosition = new Vector3();

var _alignedPosition = new Vector2();
var _rotatedPosition = new Vector2();
var _viewWorldMatrix = new Matrix4();

var _vA$1 = new Vector3();
var _vB$1 = new Vector3();
var _vC$1 = new Vector3();

var _uvA$1 = new Vector2();
var _uvB$1 = new Vector2();
var _uvC$1 = new Vector2();

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	if ( _geometry === undefined ) {

		_geometry = new BufferGeometry();

		var float32Array = new Float32Array( [
			- 0.5, - 0.5, 0, 0, 0,
			0.5, - 0.5, 0, 1, 0,
			0.5, 0.5, 0, 1, 1,
			- 0.5, 0.5, 0, 0, 1
		] );

		var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

		_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
		_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
		_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

	}

	this.geometry = _geometry;
	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

	this.center = new Vector2( 0.5, 0.5 );

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: function ( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		var rotation = this.material.rotation;
		var sin, cos;
		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		var center = this.center;

		transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA$1.set( 0, 0 );
		_uvB$1.set( 1, 0 );
		_uvC$1.set( 1, 1 );

		// check first triangle
		var intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB$1.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		var distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
			face: null,
			object: this

		} );

	},

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		return this;

	}


} );

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _v1$4 = new Vector3();
var _v2$2 = new Vector3();

function LOD() {

	Object3D.call( this );

	this._currentLevel = 0;

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

	this.autoUpdate = true;

}

LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	isLOD: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	},

	getCurrentLevel: function () {

		return this._currentLevel;

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		if ( levels.length > 0 ) {

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	},

	raycast: function ( raycaster, intersects ) {

		var levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$4.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _v1$4 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	},

	update: function ( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$4.setFromMatrixPosition( camera.matrixWorld );
			_v2$2.setFromMatrixPosition( this.matrixWorld );

			var distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh( geometry, material ) {

	if ( geometry && geometry.isGeometry ) {

		console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		var vector = new Vector4();

		var skinWeight = this.geometry.attributes.skinWeight;

		for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			var scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	},

	boneTransform: ( function () {

		var basePosition = new Vector3();

		var skinIndex = new Vector4();
		var skinWeight = new Vector4();

		var vector = new Vector3();
		var matrix = new Matrix4();

		return function ( index, target ) {

			var skeleton = this.skeleton;
			var geometry = this.geometry;

			skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( var i = 0; i < 4; i ++ ) {

				var weight = skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					var boneIndex = skinIndex.getComponent( i );

					matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( vector.copy( basePosition ).applyMatrix4( matrix ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		};

	}() )

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();

function Skeleton( bones, boneInverses ) {

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );
	this.boneMatrices = new Float32Array( this.bones.length * 16 );

	this.frame = - 1;

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.getInverse( this.bones[ i ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone, i, il;

		// recover the bind-time world matrices

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ i ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: function () {

		var bones = this.bones;
		var boneInverses = this.boneInverses;
		var boneMatrices = this.boneMatrices;
		var boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( var i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			var matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== undefined ) {

			boneTexture.needsUpdate = true;

		}

	},

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses );

	},

	getBoneByName: function ( name ) {

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	},

	dispose: function ( ) {

		if ( this.boneTexture ) {

			this.boneTexture.dispose();

			this.boneTexture = undefined;

		}

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();

var _instanceIntersects = [];

var _mesh = new Mesh();

function InstancedMesh( geometry, material, count ) {

	Mesh.call( this, geometry, material );

	this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		var matrixWorld = this.matrixWorld;
		var raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( var i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				var intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.morphTargets = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial();

	this.updateMorphTargets();

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	computeLineDistances: function () {

		var geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				var positionAttribute = geometry.attributes.position;
				var lineDistances = [ 0 ];

				for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start.fromBufferAttribute( positionAttribute, i - 1 );
					_end.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var lineDistances = geometry.lineDistances;

			lineDistances[ 0 ] = 0;

			for ( var i = 1, l = vertices.length; i < l; i ++ ) {

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

			}

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;
		var threshold = raycaster.params.Line.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere );
		_sphere$2.applyMatrix4( matrixWorld );
		_sphere$2.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

		//

		_inverseMatrix$1.getInverse( matrixWorld );
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;

		var vStart = new Vector3();
		var vEnd = new Vector3();
		var interSegment = new Vector3();
		var interRay = new Vector3();
		var step = ( this && this.isLineSegments ) ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _start$1 = new Vector3();
var _end$1 = new Vector3();

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		var geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				var positionAttribute = geometry.attributes.position;
				var lineDistances = [];

				for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start$1.fromBufferAttribute( positionAttribute, i );
					_end$1.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var lineDistances = geometry.lineDistances;

			for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

				_start$1.copy( vertices[ i ] );
				_end$1.copy( vertices[ i + 1 ] );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

			}

		}

		return this;

	}

} );

/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineLoop';

}

LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineLoop,

	isLineLoop: true,

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.morphTargets = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial();

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;
		var threshold = raycaster.params.Points.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );
		_sphere$3.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.getInverse( matrixWorld );
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					_position$1.fromArray( positions, a * 3 );

					testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					_position$1.fromArray( positions, i * 3 );

					testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	var rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		var intersectPoint = new Vector3();

		_ray$2.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.format = format !== undefined ? format : RGBFormat;

	this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

	this.generateMipmaps = false;

}

VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

	constructor: VideoTexture,

	isVideoTexture: true,

	update: function () {

		var video = this.image;

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps	= false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry( geometry ) {

	BufferGeometry.call( this );

	this.type = 'WireframeGeometry';

	// buffer

	var vertices = [];

	// helper variables

	var i, j, l, o, ol;
	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];
	var vertex;

	// different logic for Geometry and BufferGeometry

	if ( geometry && geometry.isGeometry ) {

		// create a data structure that contains all edges without duplicates

		var faces = geometry.faces;

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			e = edges[ key ];

			vertex = geometry.vertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = geometry.vertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	} else if ( geometry && geometry.isBufferGeometry ) {

		var position, indices, groups;
		var group, start, count;
		var index1, index2;

		vertex = new Vector3();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			position = geometry.attributes.position;
			indices = geometry.index;
			groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

				group = groups[ o ];

				start = group.start;
				count = group.count;

				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( j = 0; j < 3; j ++ ) {

						edge1 = indices.getX( i + j );
						edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			position = geometry.attributes.position;

			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

// ParametricGeometry

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

// ParametricBufferGeometry

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	var EPS = 0.00001;

	var normal = new Vector3();

	var p0 = new Vector3(), p1 = new Vector3();
	var pu = new Vector3(), pv = new Vector3();

	var i, j;

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		var v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			var u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			var a = i * sliceCount + j;
			var b = i * sliceCount + j + 1;
			var c = ( i + 1 ) * sliceCount + j + 1;
			var d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

// PolyhedronGeometry

function PolyhedronGeometry( vertices, indices, radius, detail ) {

	Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();

}

PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

// PolyhedronBufferGeometry

function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

	BufferGeometry.call( this );

	this.type = 'PolyhedronBufferGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	// default buffer data

	var vertexBuffer = [];
	var uvBuffer = [];

	// the subdivision creates the vertex buffer data

	subdivide( detail );

	// all vertices should lie on a conceptual sphere with a given radius

	applyRadius( radius );

	// finally, create the uv data

	generateUVs();

	// build non-indexed geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

	if ( detail === 0 ) {

		this.computeVertexNormals(); // flat normals

	} else {

		this.normalizeNormals(); // smooth normals

	}

	// helper functions

	function subdivide( detail ) {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		// iterate over all faces and apply a subdivison with the given detail value

		for ( var i = 0; i < indices.length; i += 3 ) {

			// get the vertices of the face

			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );

			// perform subdivision

			subdivideFace( a, b, c, detail );

		}

	}

	function subdivideFace( a, b, c, detail ) {

		var cols = Math.pow( 2, detail );

		// we use this multidimensional array as a data structure for creating the subdivision

		var v = [];

		var i, j;

		// construct all of the vertices for this subdivision

		for ( i = 0; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );

			var rows = cols - i;

			for ( j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

				}

			}

		}

		// construct all of the faces

		for ( i = 0; i < cols; i ++ ) {

			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );

				} else {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );

				}

			}

		}

	}

	function applyRadius( radius ) {

		var vertex = new Vector3();

		// iterate over the entire buffer and apply the radius to each vertex

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			vertex.normalize().multiplyScalar( radius );

			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;

		}

	}

	function generateUVs() {

		var vertex = new Vector3();

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );

		}

		correctUVs();

		correctSeam();

	}

	function correctSeam() {

		// handle case when face straddles the seam, see #3269

		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

			// uv data of a single face

			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			// 0.9 is somewhat arbitrary

			if ( max > 0.9 && min < 0.1 ) {

				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

			}

		}

	}

	function pushVertex( vertex ) {

		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

	}

	function getVertexByIndex( index, vertex ) {

		var stride = index * 3;

		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];

	}

	function correctUVs() {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		var centroid = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

			var azi = azimuth( centroid );

			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );

		}

	}

	function correctUV( uv, stride, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

			uvBuffer[ stride ] = uv.x - 1;

		}

		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

		}

	}

	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

}

PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// TetrahedronGeometry

function TetrahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

// TetrahedronBufferGeometry

function TetrahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
	];

	var indices = [
		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// OctahedronGeometry

function OctahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;

// OctahedronBufferGeometry

function OctahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
	];

	var indices = [
		0, 2, 4,	0, 4, 3,	0, 3, 5,
		0, 5, 2,	1, 2, 5,	1, 5, 3,
		1, 3, 4,	1, 4, 2
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// IcosahedronGeometry

function IcosahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

// IcosahedronBufferGeometry

function IcosahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
	];

	var indices = [
		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
		 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// DodecahedronGeometry

function DodecahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

// DodecahedronBufferGeometry

function DodecahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		- 1, - 1, - 1,	- 1, - 1, 1,
		- 1, 1, - 1, - 1, 1, 1,
		1, - 1, - 1, 1, - 1, 1,
		1, 1, - 1, 1, 1, 1,

		// (0, 1/, )
		 0, - r, - t, 0, - r, t,
		 0, r, - t, 0, r, t,

		// (1/, , 0)
		- r, - t, 0, - r, t, 0,
		 r, - t, 0, r, t, 0,

		// (, 0, 1/)
		- t, 0, - r, t, 0, - r,
		- t, 0, r, t, 0, r
	];

	var indices = [
		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
		1, 12, 14, 	1, 14, 5, 	1, 5, 9
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */

// TubeGeometry

function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

	Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

	// expose internals

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	// create geometry

	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();

}

TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;

// TubeBufferGeometry

function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

	BufferGeometry.call( this );

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames( tubularSegments, closed );

	// expose internals

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	// helper variables

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();
	var P = new Vector3();

	var i, j;

	// buffer

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	// create buffer data

	generateBufferData();

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// functions

	function generateBufferData() {

		for ( i = 0; i < tubularSegments; i ++ ) {

			generateSegment( i );

		}

		// if the geometry is not closed, generate the last row of vertices and normals
		// at the regular position on the given path
		//
		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

		generateSegment( ( closed === false ) ? tubularSegments : 0 );

		// uvs are generated in a separate function.
		// this makes it easy compute correct values for closed geometries

		generateUVs();

		// finally create faces

		generateIndices();

	}

	function generateSegment( i ) {

		// we use getPointAt to sample evenly distributed points from the given path

		P = path.getPointAt( i / tubularSegments, P );

		// retrieve corresponding normal and binormal

		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];

		// generate normals and vertices for the current segment

		for ( j = 0; j <= radialSegments; j ++ ) {

			var v = j / radialSegments * Math.PI * 2;

			var sin = Math.sin( v );
			var cos = - Math.cos( v );

			// normal

			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();

			normals.push( normal.x, normal.y, normal.z );

			// vertex

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	function generateIndices() {

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

	}

	function generateUVs() {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			for ( j = 0; j <= radialSegments; j ++ ) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push( uv.x, uv.y );

			}

		}

	}

}

TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	data.path = this.parameters.path.toJSON();

	return data;

};

/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */

// TorusKnotGeometry

function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

}

TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

// TorusKnotBufferGeometry

function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

	BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 1;
	tube = tube || 0.4;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, j;

	var vertex = new Vector3();
	var normal = new Vector3();

	var P1 = new Vector3();
	var P2 = new Vector3();

	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

			normal.subVectors( vertex, P1 ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices

			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

}

TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// TorusGeometry

function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	this.mergeVertices();

}

TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;

// TorusBufferGeometry

function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 1;
	tube = tube || 0.4;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex

			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );
			normal.subVectors( vertex, center ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

var Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		var hasHoles = holeIndices && holeIndices.length,
			outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
			outerNode = linkedList( data, 0, outerLen, dim, true ),
			triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		var minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( var i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	var i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	var p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	var stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	var a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	var p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	var a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	var p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	var p = start;
	do {

		var a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	var a = start;
	do {

		var b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				var c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	var queue = [],
		i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		var b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	var p = outerNode,
		hx = hole.x,
		hy = hole.y,
		qx = - Infinity,
		m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	var stop = m,
		mx = m.x,
		my = m.y,
		tanMin = Infinity,
		tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	var p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	var i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	var p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	var o1 = sign( area( p1, q1, p2 ) );
	var o2 = sign( area( p1, q1, q2 ) );
	var o3 = sign( area( p2, q2, p1 ) );
	var o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	var p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	var p = a,
		inside = false,
		px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	var a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	var p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	var sum = 0;
	for ( var i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		var holeIndices = []; // array of hole indices
		var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		var holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( var i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		var triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( var i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	var l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( var i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

// ExtrudeGeometry

function ExtrudeGeometry( shapes, options ) {

	Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	this.parameters = {
		shapes: shapes,
		options: options
	};

	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
	this.mergeVertices();

}

ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {

	var data = Geometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;
	var options = this.parameters.options;

	return toJSON( shapes, options, data );

};

// ExtrudeBufferGeometry

function ExtrudeBufferGeometry( shapes, options ) {

	BufferGeometry.call( this );

	this.type = 'ExtrudeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		options: options
	};

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	var scope = this;

	var verticesArray = [];
	var uvArray = [];

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		var shape = shapes[ i ];
		addShape( shape );

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

	this.computeVertexNormals();

	// functions

	function addShape( shape ) {

		var placeholder = [];

		// options

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
		var steps = options.steps !== undefined ? options.steps : 1;
		var depth = options.depth !== undefined ? options.depth : 100;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
		var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var extrudePath = options.extrudePath;

		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

		// deprecated options

		if ( options.amount !== undefined ) {

			console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
			depth = options.amount;

		}

		//

		var extrudePts, extrudeByPath = false;
		var splineTube, binormal, normal, position2;

		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// TODO1 - have a .isClosed in spline?

			splineTube = extrudePath.computeFrenetFrames( steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new Vector3();
			normal = new Vector3();
			position2 = new Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
			bevelOffset = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( ShapeUtils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

		}


		var faces = ShapeUtils.triangulateShape( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x,
				v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x,
				v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
					( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return new Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false; // assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {

					if ( v_next_x > Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - Number.EPSILON ) {

						if ( v_next_x < - Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [],
			oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y, - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

			}

		}

		bs = bevelSize + bevelOffset;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, depth / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y, depth + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			var start = verticesArray.length / 3;

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

			scope.addGroup( start, verticesArray.length / 3 - start, 0 );

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var start = verticesArray.length / 3;
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}


			scope.addGroup( start, verticesArray.length / 3 - start, 1 );


		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0,
					sl = steps + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d );

				}

			}

		}

		function v( x, y, z ) {

			placeholder.push( x );
			placeholder.push( y );
			placeholder.push( z );

		}


		function f3( a, b, c ) {

			addVertex( a );
			addVertex( b );
			addVertex( c );

			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );

		}

		function f4( a, b, c, d ) {

			addVertex( a );
			addVertex( b );
			addVertex( d );

			addVertex( b );
			addVertex( c );
			addVertex( d );


			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 3 ] );

			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );
			addUV( uvs[ 3 ] );

		}

		function addVertex( index ) {

			verticesArray.push( placeholder[ index * 3 + 0 ] );
			verticesArray.push( placeholder[ index * 3 + 1 ] );
			verticesArray.push( placeholder[ index * 3 + 2 ] );

		}


		function addUV( vector2 ) {

			uvArray.push( vector2.x );
			uvArray.push( vector2.y );

		}

	}

}

ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;
	var options = this.parameters.options;

	return toJSON( shapes, options, data );

};

//

var WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var a_z = vertices[ indexA * 3 + 2 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var b_z = vertices[ indexB * 3 + 2 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];
		var c_z = vertices[ indexC * 3 + 2 ];
		var d_x = vertices[ indexD * 3 ];
		var d_y = vertices[ indexD * 3 + 1 ];
		var d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}
};

function toJSON( shapes, options, data ) {

	//

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	//

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

// TextGeometry

function TextGeometry( text, parameters ) {

	Geometry.call( this );

	this.type = 'TextGeometry';

	this.parameters = {
		text: text,
		parameters: parameters
	};

	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
	this.mergeVertices();

}

TextGeometry.prototype = Object.create( Geometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;

// TextBufferGeometry

function TextBufferGeometry( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( ! ( font && font.isFont ) ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size );

	// translate parameters to ExtrudeGeometry API

	parameters.depth = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	ExtrudeBufferGeometry.call( this, shapes, parameters );

	this.type = 'TextBufferGeometry';

}

TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
TextBufferGeometry.prototype.constructor = TextBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

// SphereGeometry

function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	this.mergeVertices();

}

SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;

// SphereBufferGeometry

function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 1;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

	var ix, iy;

	var index = 0;
	var grid = [];

	var vertex = new Vector3();
	var normal = new Vector3();

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy <= heightSegments; iy ++ ) {

		var verticesRow = [];

		var v = iy / heightSegments;

		// special case for the poles

		var uOffset = 0;

		if ( iy == 0 && thetaStart == 0 ) {

			uOffset = 0.5 / widthSegments;

		} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

			uOffset = - 0.5 / widthSegments;

		}

		for ( ix = 0; ix <= widthSegments; ix ++ ) {

			var u = ix / widthSegments;

			// vertex

			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normal.copy( vertex ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u + uOffset, 1 - v );

			verticesRow.push( index ++ );

		}

		grid.push( verticesRow );

	}

	// indices

	for ( iy = 0; iy < heightSegments; iy ++ ) {

		for ( ix = 0; ix < widthSegments; ix ++ ) {

			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];

			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */

// RingGeometry

function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;

// RingBufferGeometry

function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0.5;
	outerRadius = outerRadius || 1;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// some helper variables

	var segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			// values are generate from the inside of the ring to the outside

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uv

			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// increase the radius for next row of vertices

		radius += radiusStep;

	}

	// indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */

// LatheGeometry

function LatheGeometry( points, segments, phiStart, phiLength ) {

	Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

}

LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;

// LatheBufferGeometry

function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

	BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]

	phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );


	// buffers

	var indices = [];
	var vertices = [];
	var uvs = [];

	// helper variables

	var base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex

			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;

			vertices.push( vertex.x, vertex.y, vertex.z );

			// uv

			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );

			uvs.push( uv.x, uv.y );


		}

	}

	// indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if ( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();

		// this is the buffer offset for the last line of vertices

		base = segments * points.length * 3;

		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line

			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line

			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals

			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals

			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		}

	}

}

LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// ShapeGeometry

function ShapeGeometry( shapes, curveSegments ) {

	Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( typeof curveSegments === 'object' ) {

		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

		curveSegments = curveSegments.curveSegments;

	}

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();

}

ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;

ShapeGeometry.prototype.toJSON = function () {

	var data = Geometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;

	return toJSON$1( shapes, data );

};

// ShapeBufferGeometry

function ShapeBufferGeometry( shapes, curveSegments ) {

	BufferGeometry.call( this );

	this.type = 'ShapeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	curveSegments = curveSegments || 12;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var groupStart = 0;
	var groupCount = 0;

	// allow single and array values for "shapes" parameter

	if ( Array.isArray( shapes ) === false ) {

		addShape( shapes );

	} else {

		for ( var i = 0; i < shapes.length; i ++ ) {

			addShape( shapes[ i ] );

			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

			groupStart += groupCount;
			groupCount = 0;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


	// helper functions

	function addShape( shape ) {

		var i, l, shapeHole;

		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );

		var shapeVertices = points.shape;
		var shapeHoles = points.holes;

		// check direction of vertices

		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

			shapeVertices = shapeVertices.reverse();

		}

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];

			if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

				shapeHoles[ i ] = shapeHole.reverse();

			}

		}

		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

		// join vertices of inner and outer paths to a single array

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );

		}

		// vertices, normals, uvs

		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

			var vertex = shapeVertices[ i ];

			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y ); // world uvs

		}

		// incides

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;

			indices.push( a, b, c );
			groupCount += 3;

		}

	}

}

ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;

	return toJSON$1( shapes, data );

};

//

function toJSON$1( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

function EdgesGeometry( geometry, thresholdAngle ) {

	BufferGeometry.call( this );

	this.type = 'EdgesGeometry';

	this.parameters = {
		thresholdAngle: thresholdAngle
	};

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	// buffer

	var vertices = [];

	// helper variables

	var thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );
	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];

	// prepare source geometry

	var geometry2;

	if ( geometry.isBufferGeometry ) {

		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;

	// now create a data structure where each entry represents an edge with its adjoining faces

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge1 = face[ keys[ j ] ];
			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
			edge[ 0 ] = Math.min( edge1, edge2 );
			edge[ 1 ] = Math.max( edge1, edge2 );

			key = edge[ 0 ] + ',' + edge[ 1 ];

			if ( edges[ key ] === undefined ) {

				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				edges[ key ].face2 = i;

			}

		}

	}

	// generate vertices

	for ( key in edges ) {

		var e = edges[ key ];

		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

			var vertex = sourceVertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = sourceVertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// CylinderGeometry

function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;

// CylinderBufferGeometry

function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 1;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
	height = height || 1;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var index = 0;
	var indexArray = [];
	var halfHeight = height / 2;
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function generateTorso() {

		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var slope = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row

			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var theta = u * thetaLength + thetaStart;

				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				// save index of vertex in respective row

				indexRow.push( index ++ );

			}

			// now save vertices of the row in our index array

			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices

				var a = indexArray[ y ][ x ];
				var b = indexArray[ y + 1 ][ x ];
				var c = indexArray[ y + 1 ][ x + 1 ];
				var d = indexArray[ y ][ x + 1 ];

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// update group counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new Vector2();
		var vertex = new Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex

			vertices.push( 0, halfHeight * sign, 0 );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uvs.push( 0.5, 0.5 );

			// increase index

			index ++;

		}

		// save the index of the last center vertex

		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex

			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.push( uv.x, uv.y );

			// increase index

			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top

				indices.push( i, i + 1, c );

			} else {

				// face bottom

				indices.push( i + 1, i, c );

			}

			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

}

CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

// ConeGeometry

function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;

// ConeBufferGeometry

function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */

// CircleGeometry

function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;

// CircleBufferGeometry

function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 1;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, s;
	var vertex = new Vector3();
	var uv = new Vector2();

	// center point

	vertices.push( 0, 0, 0 );
	normals.push( 0, 0, 1 );
	uvs.push( 0.5, 0.5 );

	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

		var segment = thetaStart + s / segments * thetaLength;

		// vertex

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		vertices.push( vertex.x, vertex.y, vertex.z );

		// normal

		normals.push( 0, 0, 1 );

		// uvs

		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

		uvs.push( uv.x, uv.y );

	}

	// indices

	for ( i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextBufferGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry
});

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShadowMaterial';

	this.color = new Color( 0x000000 );
	this.transparent = true;

	this.setValues( parameters );

}

ShadowMaterial.prototype = Object.create( Material.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.vertexTangents = source.vertexTangents;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transparency: <float>
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new Vector2( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.sheen = null; // null will disable sheen bsdf

	this.transparency = 0.0;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transparency = source.transparency;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshToonMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.color = new Color( 0xffffff );
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;
	this.gradientMap = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( Material.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;
	this.gradientMap = source.gradientMap;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshMatcapMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'MATCAP': '' };

	this.type = 'MeshMatcapMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.matcap = null;

	this.map = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.alphaMap = null;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshMatcapMaterial.prototype = Object.create( Material.prototype );
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'MATCAP': '' };

	this.color.copy( source.color );

	this.matcap = source.matcap;

	this.map = source.map;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.alphaMap = source.alphaMap;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	LineBasicMaterial.call( this );

	this.type = 'LineDashedMaterial';

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	LineBasicMaterial.prototype.copy.call( this, source );

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {

		fps = fps || 30;

		var clip = sourceClip.clone();

		clip.name = name;

		var tracks = [];

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			var track = clip.tracks[ i ];
			var valueSize = track.getValueSize();

			var times = [];
			var values = [];

			for ( var j = 0; j < track.times.length; ++ j ) {

				var frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( var k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		var minStartTime = Infinity;

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {

		if ( referenceFrame === undefined ) referenceFrame = 0;
		if ( referenceClip === undefined ) referenceClip = targetClip;
		if ( fps === undefined || fps <= 0 ) fps = 30;

		var numTracks = targetClip.tracks.length;
		var referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( var i = 0; i < numTracks; ++ i ) {

			var referenceTrack = referenceClip.tracks[ i ];
			var referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			var targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			var valueSize = referenceTrack.getValueSize();
			var lastIndex = referenceTrack.times.length - 1;
			var referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, 0, referenceTrack.valueSize );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				var startIndex = lastIndex * valueSize;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex );

			} else {

				// Interpolate to the reference value
				var interpolant = referenceTrack.createInterpolant();
				interpolant.evaluate( referenceTime );
				referenceValue = interpolant.resultBuffer;

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				var referenceQuat = new Quaternion(
					referenceValue[ 0 ],
					referenceValue[ 1 ],
					referenceValue[ 2 ],
					referenceValue[ 3 ]
				).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			var numTimes = targetTrack.times.length;
			for ( var j = 0; j < numTimes; ++ j ) {

				var valueStart = j * valueSize;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					// Subtract each value for all other numeric track types
					for ( var k = 0; k < valueSize; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP = - wP * ppp + 2 * wP * pp - wP * p;
		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		var sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

/**
 * @author tschw
 */

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack( name, times, values, interpolation ) {

	if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
	if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

}

// Static methods

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	toJSON: function ( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

} );

Object.assign( KeyframeTrack.prototype, {

	constructor: KeyframeTrack,

	TimeBufferType: Float32Array,

	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
				this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		// times or values may be shared with other tracks, so overwriting is unsafe
		var times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			writeIndex = 1,
			lastIndex = times.length - 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	},

	clone: function () {

		var times = AnimationUtils.arraySlice( this.times, 0 );
		var values = AnimationUtils.arraySlice( this.values, 0 );

		var TypedKeyframeTrack = this.constructor;
		var track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

} );

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrack.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function ( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip( name, duration, tracks, blendMode ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;
	this.blendMode = ( blendMode !== undefined ) ? blendMode : NormalAnimationBlendMode;

	this.uuid = MathUtils.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	var trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		var times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

Object.assign( AnimationClip, {

	parse: function ( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks, json.blendMode );

	},

	toJSON: function ( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},

	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new AnimationClip( name, - 1, tracks );

	},

	findByName: function ( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || - 1;
		var fps = animation.fps || 30;
		var blendMode = animation.blendMode;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};

				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new AnimationClip( clipName, duration, tracks, blendMode );

		return clip;

	}

} );

Object.assign( AnimationClip.prototype, {

	resetDuration: function () {

		var tracks = this.tracks, duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	},

	trim: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	validate: function () {

		var valid = true;

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	},

	optimize: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	},

	clone: function () {

		var tracks = [];

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new AnimationClip( this.name, this.duration, tracks, this.blendMode );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false;
	var itemsLoaded = 0;
	var itemsTotal = 0;
	var urlModifier = undefined;
	var handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		var index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

var DefaultLoadingManager = new LoadingManager();

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.crossOrigin = 'anonymous';
	this.path = '';
	this.resourcePath = '';
	this.requestHeader = {};

}

Object.assign( Loader.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	loadAsync: function ( url, onProgress ) {

		var scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	},

	setRequestHeader: function ( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var loading = {};

function FileLoader( manager ) {

	Loader.call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];

			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						var view = new Uint8Array( data.length );

						for ( var i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			var request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = this.response;

				var callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, response );

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				var callbacks = loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				var callbacks = loading[ url ];

				delete loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				var callbacks = loading[ url ];

				delete loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( var header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader( manager ) {

	Loader.call( this, manager );

}

AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AnimationLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	Loader.call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new CompressedTexture();
		texture.image = images;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	Loader.call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new DataTexture();

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.load( url, function ( buffer ) {

			var texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader( manager ) {

	Loader.call( this, manager );

}

ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTextureLoader( manager ) {

	Loader.call( this, manager );

}

CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new CubeTexture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader( manager ) {

	Loader.call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new Texture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t, optionalTarget ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	},

	getTangentAt: function ( u, optionalTarget ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		var normal = new Vector3();

		var tangents = [];
		var normals = [];
		var binormals = [];

		var vec = new Vector3();
		var mat = new Matrix4();

		var i, u, theta;

		// compute the tangent vectors for each segment on the curve

		for ( i = 0; i <= segments; i ++ ) {

			u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	Curve.call( this );

	this.type = 'EllipseCurve';

	this.aX = aX || 0;
	this.aY = aY || 0;

	this.xRadius = xRadius || 1;
	this.yRadius = yRadius || 1;

	this.aStartAngle = aStartAngle || 0;
	this.aEndAngle = aEndAngle || 2 * Math.PI;

	this.aClockwise = aClockwise || false;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x - this.aX;
		var ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return point.set( x, y );

};

EllipseCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.aX = source.aX;
	this.aY = source.aY;

	this.xRadius = source.xRadius;
	this.yRadius = source.yRadius;

	this.aStartAngle = source.aStartAngle;
	this.aEndAngle = source.aEndAngle;

	this.aClockwise = source.aClockwise;

	this.aRotation = source.aRotation;

	return this;

};


EllipseCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.aX = this.aX;
	data.aY = this.aY;

	data.xRadius = this.xRadius;
	data.yRadius = this.yRadius;

	data.aStartAngle = this.aStartAngle;
	data.aEndAngle = this.aEndAngle;

	data.aClockwise = this.aClockwise;

	data.aRotation = this.aRotation;

	return data;

};

EllipseCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.aX = json.aX;
	this.aY = json.aY;

	this.xRadius = json.xRadius;
	this.yRadius = json.yRadius;

	this.aStartAngle = json.aStartAngle;
	this.aEndAngle = json.aEndAngle;

	this.aClockwise = json.aClockwise;

	this.aRotation = json.aRotation;

	return this;

};

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	this.type = 'ArcCurve';

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

ArcCurve.prototype.isArcCurve = true;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

var tmp = new Vector3();
var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

function CatmullRomCurve3( points, closed, curveType, tension ) {

	Curve.call( this );

	this.type = 'CatmullRomCurve3';

	this.points = points || [];
	this.closed = closed || false;
	this.curveType = curveType || 'centripetal';
	this.tension = tension || 0.5;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var points = this.points;
	var l = points.length;

	var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
	var intPoint = Math.floor( p );
	var weight = p - intPoint;

	if ( this.closed ) {

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

	} else if ( weight === 0 && intPoint === l - 1 ) {

		intPoint = l - 2;
		weight = 1;

	}

	var p0, p1, p2, p3; // 4 points

	if ( this.closed || intPoint > 0 ) {

		p0 = points[ ( intPoint - 1 ) % l ];

	} else {

		// extrapolate first point
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;

	}

	p1 = points[ intPoint % l ];
	p2 = points[ ( intPoint + 1 ) % l ];

	if ( this.closed || intPoint + 2 < l ) {

		p3 = points[ ( intPoint + 2 ) % l ];

	} else {

		// extrapolate last point
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;

	}

	if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

		// init Centripetal / Chordal Catmull-Rom
		var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

		// safety check for repeated points
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;

		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

	} else if ( this.curveType === 'catmullrom' ) {

		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

	}

	point.set(
		px.calc( weight ),
		py.calc( weight ),
		pz.calc( weight )
	);

	return point;

};

CatmullRomCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

		var point = source.points[ i ];

		this.points.push( point.clone() );

	}

	this.closed = source.closed;
	this.curveType = source.curveType;
	this.tension = source.tension;

	return this;

};

CatmullRomCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

		var point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	data.closed = this.closed;
	data.curveType = this.curveType;
	data.tension = this.tension;

	return data;

};

CatmullRomCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

		var point = json.points[ i ];
		this.points.push( new Vector3().fromArray( point ) );

	}

	this.closed = json.closed;
	this.curveType = json.curveType;
	this.tension = json.tension;

	return this;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	var v0 = ( p2 - p0 ) * 0.5;
	var v1 = ( p3 - p1 ) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	var k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

function CubicBezierCurve( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve';

	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();
	this.v3 = v3 || new Vector2();

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);

	return point;

};

CubicBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function CubicBezierCurve3( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve3';

	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();
	this.v3 = v3 || new Vector3();

}

CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);

	return point;

};

CubicBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function LineCurve( v1, v2 ) {

	Curve.call( this );

	this.type = 'LineCurve';

	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve.prototype.getTangent = function ( t, optionalTarget ) {

	var tangent = optionalTarget || new Vector2();

	var tangent = tangent.copy( this.v2 ).sub( this.v1 ).normalize();

	return tangent;

};

LineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function LineCurve3( v1, v2 ) {

	Curve.call( this );

	this.type = 'LineCurve3';

	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();

}

LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve( v0, v1, v2 ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve';

	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);

	return point;

};

QuadraticBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve3( v0, v1, v2 ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve3';

	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();

}

QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);

	return point;

};

QuadraticBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function SplineCurve( points /* array of Vector2 */ ) {

	Curve.call( this );

	this.type = 'SplineCurve';

	this.points = points || [];

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var points = this.points;
	var p = ( points.length - 1 ) * t;

	var intPoint = Math.floor( p );
	var weight = p - intPoint;

	var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var p1 = points[ intPoint ];
	var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	point.set(
		CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
		CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
	);

	return point;

};

SplineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

		var point = source.points[ i ];

		this.points.push( point.clone() );

	}

	return this;

};

SplineCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

		var point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	return data;

};

SplineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

		var point = json.points[ i ];
		this.points.push( new Vector2().fromArray( point ) );

	}

	return this;

};

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	Curve.call( this );

	this.type = 'CurvePath';

	this.curves = [];
	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 40;

		var points = [];

		for ( var i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var points = [], last;

		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

			var curve = curves[ i ];
			var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			var pts = curve.getPoints( resolution );

			for ( var j = 0; j < pts.length; j ++ ) {

				var point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	copy: function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.curves = [];

		for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

			var curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	},

	toJSON: function () {

		var data = Curve.prototype.toJSON.call( this );

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			var curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

			var curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path( points ) {

	CurvePath.call( this );

	this.type = 'Path';

	this.currentPoint = new Vector2();

	if ( points ) {

		this.setFromPoints( points );

	}

}

Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

	constructor: Path,

	setFromPoints: function ( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( var i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	},

	lineTo: function ( x, y ) {

		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var npts = [ this.currentPoint.clone() ].concat( pts );

		var curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			var firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	},

	copy: function ( source ) {

		CurvePath.prototype.copy.call( this, source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	},

	toJSON: function () {

		var data = CurvePath.prototype.toJSON.call( this );

		data.currentPoint = this.currentPoint.toArray();

		return data;

	},

	fromJSON: function ( json ) {

		CurvePath.prototype.fromJSON.call( this, json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape( points ) {

	Path.call( this, points );

	this.uuid = MathUtils.generateUUID();

	this.type = 'Shape';

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( Path.prototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	copy: function ( source ) {

		Path.prototype.copy.call( this, source );

		this.holes = [];

		for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

			var hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	},

	toJSON: function () {

		var data = Path.prototype.toJSON.call( this );

		data.uuid = this.uuid;
		data.holes = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			var hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Path.prototype.fromJSON.call( this, json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

			var hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light( color, intensity ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.mapPass = null;
	this.matrix = new Matrix4();

	this._frustum = new Frustum();
	this._frameExtents = new Vector2( 1, 1 );

	this._viewportCount = 1;

	this._viewports = [

		new Vector4( 0, 0, 1, 1 )

	];

}

Object.assign( LightShadow.prototype, {

	_projScreenMatrix: new Matrix4(),

	_lightPositionWorld: new Vector3(),

	_lookTarget: new Vector3(),

	getViewportCount: function () {

		return this._viewportCount;

	},

	getFrustum: function () {

		return this._frustum;

	},

	updateMatrices: function ( light ) {

		var shadowCamera = this.camera,
			shadowMatrix = this.matrix,
			projScreenMatrix = this._projScreenMatrix,
			lookTarget = this._lookTarget,
			lightPositionWorld = this._lightPositionWorld;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( lightPositionWorld );

		lookTarget.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( lookTarget );
		shadowCamera.updateMatrixWorld();

		projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	},

	getViewport: function ( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	},

	getFrameExtents: function () {

		return this._frameExtents;

	},

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	updateMatrices: function ( light ) {

		var camera = this.camera;

		var fov = MathUtils.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

function PointLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	this._frameExtents = new Vector2( 4, 2 );

	this._viewportCount = 6;

	this._viewports = [
		// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//  xzXZ
		//   y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction

		// positive X
		new Vector4( 2, 1, 1, 1 ),
		// negative X
		new Vector4( 0, 1, 1, 1 ),
		// positive Z
		new Vector4( 3, 1, 1, 1 ),
		// negative Z
		new Vector4( 1, 1, 1, 1 ),
		// positive Y
		new Vector4( 3, 0, 1, 1 ),
		// negative Y
		new Vector4( 1, 0, 1, 1 )
	];

	this._cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	this._cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

}

PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: PointLightShadow,

	isPointLightShadow: true,

	updateMatrices: function ( light, viewportIndex ) {

		if ( viewportIndex === undefined ) viewportIndex = 0;

		var camera = this.camera,
			shadowMatrix = this.matrix,
			lightPositionWorld = this._lightPositionWorld,
			lookTarget = this._lookTarget,
			projScreenMatrix = this._projScreenMatrix;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( lightPositionWorld );

		lookTarget.copy( camera.position );
		lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );

		projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / ( 4 * Math.PI );

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new PointLightShadow();

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = ( left !== undefined ) ? left : - 1;
	this.right = ( right !== undefined ) ? right : 1;
	this.top = ( top !== undefined ) ? top : 1;
	this.bottom = ( bottom !== undefined ) ? bottom : - 1;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow,

	isDirectionalLightShadow: true,

	updateMatrices: function ( light ) {

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

}

RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Light.prototype.toJSON.call( this, meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

function SphericalHarmonics3() {

	this.coefficients = [];

	for ( var i = 0; i < 9; i ++ ) {

		this.coefficients.push( new Vector3() );

	}

}

Object.assign( SphericalHarmonics3.prototype, {

	isSphericalHarmonics3: true,

	set: function ( coefficients ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	},

	zero: function () {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	},

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt: function ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	},

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt: function ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

		return target;

	},

	add: function ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	},

	addScaledSH: function ( sh, s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	},

	scale: function ( s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	},

	lerp: function ( sh, alpha ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	},

	equals: function ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	},

	copy: function ( sh ) {

		return this.set( sh.coefficients );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

} );

Object.assign( SphericalHarmonics3, {

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	getBasisAt: function ( normal, shBasis ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */

function LightProbe( sh, intensity ) {

	Light.call( this, undefined, intensity );

	this.type = 'LightProbe';

	this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();

}

LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: LightProbe,

	isLightProbe: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.sh.copy( source.sh );

		return this;

	},

	fromJSON: function ( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	},

	toJSON: function ( meta ) {

		var data = Light.prototype.toJSON.call( this, meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader( manager ) {

	Loader.call( this, manager );

	this.textures = {};

}

MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		var material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( var name in json.uniforms ) {

				var uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( var key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		return material;

	},

	setTextures: function ( value ) {

		this.textures = value;
		return this;

	}

} );

/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		var s = '';

		for ( var i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		var index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.instanceCount = Infinity;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.instanceCount = source.instanceCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		var data = BufferAttribute.prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader( manager ) {

	Loader.call( this, manager );

}

BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
			var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
			var bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );
			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			geometry.setAttribute( key, bufferAttribute );

		}

		var morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( var key in morphAttributes ) {

				var attributeArray = morphAttributes[ key ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute = attributeArray[ i ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

					var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		var morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

} );

var TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	// Workaround for IE11 pre KB2929437. See #11440
	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader( manager ) {

	Loader.call( this, manager );

}

ObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		var loader = new FileLoader( scope.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			var json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			var metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	},

	parse: function ( json, onLoad ) {

		var shapes = this.parseShape( json.shapes );
		var geometries = this.parseGeometries( json.geometries, shapes );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseShape: function ( json ) {

		var shapes = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	},

	parseGeometries: function ( json, shapes ) {

		var geometries = {};

		if ( json !== undefined ) {

			var bufferGeometryLoader = new BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						var geometryShapes = [];

						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							var shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						var geometryShapes = [];

						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							var shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						var extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var cache = {}; // MultiMaterial
		var materials = {};

		if ( json !== undefined ) {

			var loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					var array = [];

					for ( var j = 0; j < data.materials.length; j ++ ) {

						var material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var data = json[ i ];

			var clip = AnimationClip.parse( data );

			if ( data.uuid !== undefined ) clip.uuid = data.uuid;

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new LoadingManager( onLoad );

			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, il = json.length; i < il; i ++ ) {

				var image = json[ i ];
				var url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( var j = 0, jl = url.length; j < jl; j ++ ) {

						var currentUrl = url[ j ];

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

						images[ image.uuid ].push( loadImage( path ) );

					}

				} else {

					// load single image

					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture;

				if ( Array.isArray( images[ data.image ] ) ) {

					texture = new CubeTexture( images[ data.image ] );

				} else {

					texture = new Texture( images[ data.image ] );

				}

				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function ( data, geometries, materials ) {

		var object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				var array = [];

				for ( var i = 0, l = name.length; i < l; i ++ ) {

					var uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

			case 'Mesh':

				var geometry = getGeometry( data.geometry );
				var material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				var geometry = getGeometry( data.geometry );
				var material = getMaterial( data.material );
				var count = data.count;
				var instanceMatrix = data.instanceMatrix;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			var children = data.children;

			for ( var i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials ) );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			var levels = data.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				var level = levels[ l ];
				var child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

} );

var TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	SphericalReflectionMapping: SphericalReflectionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

var TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

var TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

/**
 * @author thespite / http://clicktorelease.com/
 */


function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	Loader.call( this, manager );

	this.options = undefined;

}

ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageBitmapLoader,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		fetch( url ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			if ( scope.options === undefined ) {

				// Workaround for FireFox. It causes an error if you pass options.
				return createImageBitmap( blob );

			} else {

				return createImageBitmap( blob, scope.options );

			}

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {

	this.type = 'ShapePath';

	this.color = new Color();

	this.subPaths = [];
	this.currentPath = null;

}

Object.assign( ShapePath.prototype, {

	moveTo: function ( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	},

	lineTo: function ( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	},

	splineThru: function ( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = ShapeUtils.isClockWise;

		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */


function Font( data ) {

	this.type = 'Font';

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size ) {

		if ( size === undefined ) size = 100;

		var shapes = [];
		var paths = createPaths( text, size, this.data );

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

function createPaths( text, size, data ) {

	var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
	var scale = size / data.resolution;
	var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	var paths = [];

	var offsetX = 0, offsetY = 0;

	for ( var i = 0; i < chars.length; i ++ ) {

		var char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			var ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	var path = new ShapePath();

	var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( var i = 0, l = outline.length; i < l; ) {

			var action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader( manager ) {

	Loader.call( this, manager );

}

FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FontLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _context;

var AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader( manager ) {

	Loader.call( this, manager );

}

AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AudioLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( scope.path );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );

				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function HemisphereLightProbe( skyColor, groundColor, intensity ) {

	LightProbe.call( this, undefined, intensity );

	var color1 = new Color().set( skyColor );
	var color2 = new Color().set( groundColor );

	var sky = new Vector3( color1.r, color1.g, color1.b );
	var ground = new Vector3( color2.r, color2.g, color2.b );

	// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
	var c0 = Math.sqrt( Math.PI );
	var c1 = c0 * Math.sqrt( 0.75 );

	this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
	this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

}

HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: HemisphereLightProbe,

	isHemisphereLightProbe: true,

	copy: function ( source ) { // modifying colors not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		var data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function AmbientLightProbe( color, intensity ) {

	LightProbe.call( this, undefined, intensity );

	var color1 = new Color().set( color );

	// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
	this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

}

AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: AmbientLightProbe,

	isAmbientLightProbe: true,

	copy: function ( source ) { // modifying color not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		var data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

	this._cache = {
		focus: null,
		fov: null,
		aspect: null,
		near: null,
		far: null,
		zoom: null,
		eyeSep: null
	};

}

Object.assign( StereoCamera.prototype, {

	update: function ( camera ) {

		var cache = this._cache;

		var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			var projectionMatrix = camera.projectionMatrix.clone();
			var eyeSepHalf = cache.eyeSep / 2;
			var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			var ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			var xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Object.assign( Clock.prototype, {

	start: function () {

		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$2 = new Vector3();
var _quaternion$3 = new Quaternion();
var _scale$1 = new Vector3();
var _orientation = new Vector3();

function AudioListener() {

	Object3D.call( this );

	this.type = 'AudioListener';

	this.context = AudioContext.getContext();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

	this.timeDelta = 0;

	// private

	this._clock = new Clock();

}

AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

		_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			var endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
			listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio( listener ) {

	Object3D.call( this );

	this.type = 'Audio';

	this.listener = listener;
	this.context = listener.context;

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.buffer = null;
	this.detune = 0;
	this.loop = false;
	this.loopStart = 0;
	this.loopEnd = 0;
	this.offset = 0;
	this.duration = undefined;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this._startedAt = 0;
	this._progress = 0;

	this.filters = [];

}

Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setMediaElementSource: function ( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	},

	setMediaStreamSource: function ( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function ( delay ) {

		if ( delay === undefined ) delay = 0;

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		var source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	setDetune: function ( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	},

	getDetune: function () {

		return this.detune;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	},

	setLoopStart: function ( value ) {

		this.loopStart = value;

		return this;

	},

	setLoopEnd: function ( value ) {

		this.loopEnd = value;

		return this;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},

	setVolume: function ( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$3 = new Vector3();
var _quaternion$4 = new Quaternion();
var _scale$2 = new Vector3();
var _orientation$1 = new Vector3();

function PositionalAudio( listener ) {

	Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.panningModel = 'HRTF';
	this.panner.connect( this.gain );

}

PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

	constructor: PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

		return this;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

		return this;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

		return this;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

		return this;

	},

	setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

		_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

		var panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			var endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

		} else {

			panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
			panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

}

Object.assign( AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var mixFunction,
		mixFunctionAdditive,
		setIdentity;

	// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property
	//
	// 'add' is used for additive cumulative results
	//
	// 'work' is optional and is only present for quaternion types. It is used
	// to store intermediate quaternion multiplication results

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			mixFunctionAdditive = this._slerpAdditive;
			setIdentity = this._setAdditiveIdentityQuaternion;

			this.buffer = new Float64Array( valueSize * 6 );
			this._workIndex = 5;
			break;

		case 'string':
		case 'bool':
			mixFunction = this._select;

			// Use the regular mix function and for additive on these types,
			// additive is not relevant for non-numeric types
			mixFunctionAdditive = this._select;

			setIdentity = this._setAdditiveIdentityOther;

			this.buffer = new Array( valueSize * 5 );
			break;

		default:
			mixFunction = this._lerp;
			mixFunctionAdditive = this._lerpAdditive;
			setIdentity = this._setAdditiveIdentityNumeric;

			this.buffer = new Float64Array( valueSize * 5 );

	}

	this._mixBufferRegion = mixFunction;
	this._mixBufferRegionAdditive = mixFunctionAdditive;
	this._setIdentity = setIdentity;
	this._origIndex = 3;
	this._addIndex = 4;

	this.cumulativeWeight = 0;
	this.cumulativeWeightAdditive = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, {

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function ( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive: function ( weight ) {

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function ( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function () {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function () {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},

	_setAdditiveIdentityNumeric: function () {

		var startIndex = this._addIndex * this.valueSize;
		var endIndex = startIndex + this.valueSize;

		for ( var i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	},

	_setAdditiveIdentityQuaternion: function () {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * 4 + 3 ] = 1;

	},

	_setAdditiveIdentityOther: function () {

		var startIndex = this._origIndex * this.valueSize;
		var targetIndex = this._addIndex * this.valueSize;

		for ( var i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	},


	// mix functions

	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	},

	_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		var workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	},

	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	},

	_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

} );

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

// Characters [].:/ are reserved for track binding syntax.
var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

var _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

var _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		var matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		var results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			var objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against a whitelist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			var bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			var searchNodeSubtree = function ( children ) {

				for ( var i = 0; i < children.length; i ++ ) {

					var childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					var result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			var subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup() {

	this.uuid = MathUtils.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0; // threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices; // for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = []; // inside: string
	this._parsedPaths = []; // inside: { we don't care, here }
	this._bindings = []; // inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; // inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() {

				return scope._objects.length;

			},
			get inUse() {

				return this.total - scope.nCachedObjects_;

			}
		},
		get bindingsPerObject() {

			return scope._bindings.length;

		}

	};

}

Object.assign( AnimationObjectGroup.prototype, {

	isAnimationObjectGroup: true,

	add: function () {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length,
			knownObject = undefined;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function () {

		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function () {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function ( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function ( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

} );

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction( mixer, clip, localRoot, blendMode ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;
	this.blendMode = blendMode || clip.blendMode;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants; // bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null; // for the memory manager
	this._byClipCacheIndex = null; // for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = LoopRepeat;
	this._loopCount = - 1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; // no. of repetitions when looping

	this.paused = false; // true -> zero effective time scale
	this.enabled = true; // false -> zero effective weight

	this.clampWhenFinished = false;// keep feeding the last frame?

	this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd = true;// clips for start, loop and end

}

Object.assign( AnimationAction.prototype, {

	// State & Scheduling

	play: function () {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function () {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function () {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function () {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function () {

		return this._mixer._isActiveAction( this );

	},

	startAt: function ( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function ( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function ( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function () {

		return this._effectiveWeight;

	},

	fadeIn: function ( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function ( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function ( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function ( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function () {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function ( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function () {

		return this._effectiveTimeScale;

	},

	setDuration: function ( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function ( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function ( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function ( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function () {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function () {

		return this._mixer;

	},

	getClip: function () {

		return this._clip;

	},

	getRoot: function () {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function ( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	},

	_updateWeight: function ( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function ( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function ( deltaTime ) {

		var time = this.time + deltaTime;
		var duration = this._clip.duration;
		var loop = this.loop;
		var loopCount = this._loopCount;

		var pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	},

	_setEndings: function ( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function ( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

} );

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: AnimationMixer,

	_bindAction: function ( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot, blendMode ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		var actions = this._actions,
			nActions = this._nActiveActions;

		for ( var i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// Allows you to seek to a specific time in an animation.
	setTime: function ( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( var i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

}

Uniform.prototype.clone = function () {

	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;
	this.camera = null;
	this.layers = new Layers();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

function Spherical( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
	this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

	return this;

}

Object.assign( Spherical.prototype, {

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function () {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function ( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	},

	setFromCartesianCoords: function ( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical( radius, theta, y ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

	return this;

}

Object.assign( Cylindrical.prototype, {

	set: function ( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	},

	setFromVector3: function ( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	},

	setFromCartesianCoords: function ( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _vector$7 = new Vector2();

function Box2( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

}

Object.assign( Box2.prototype, {

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function ( center, size ) {

		var halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	},

	getParameter: function ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new Vector2();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	},

	clampPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new Vector2();

		}

		return target.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function ( point ) {

		var clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	},

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _startP = new Vector3();
var _startEnd = new Vector3();

function Line3( start, end ) {

	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();

}

Object.assign( Line3.prototype, {

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new Vector3();

		}

		return target.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function ( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		var startEnd2 = _startEnd.dot( _startEnd );
		var startEnd_startP = _startEnd.dot( _startP );

		var t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = MathUtils.clamp( t, 0, 1 );

		}

		return t;

	},

	closestPointToPoint: function ( point, clampToLine, target ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

	this.hasPositions = false;
	this.hasNormals = false;
	this.hasColors = false;
	this.hasUvs = false;

	this.positionArray = null;
	this.normalArray = null;
	this.colorArray = null;
	this.uvArray = null;

	this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector$8 = new Vector3();

function SpotLightHelper( light, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	var geometry = new BufferGeometry();

	var positions = [
		0, 0, 0, 	0, 0, 1,
		0, 0, 0, 	1, 0, 1,
		0, 0, 0,	- 1, 0, 1,
		0, 0, 0, 	0, 1, 1,
		0, 0, 0, 	0, - 1, 1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

}

SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

SpotLightHelper.prototype.update = function () {

	this.light.updateMatrixWorld();

	var coneLength = this.light.distance ? this.light.distance : 1000;
	var coneWidth = coneLength * Math.tan( this.light.angle );

	this.cone.scale.set( coneWidth, coneWidth, coneLength );

	_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );

	this.cone.lookAt( _vector$8 );

	if ( this.color !== undefined ) {

		this.cone.material.color.set( this.color );

	} else {

		this.cone.material.color.copy( this.light.color );

	}

};

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

var _vector$9 = new Vector3();
var _boneMatrix = new Matrix4();
var _matrixWorldInv = new Matrix4();

function getBoneList( object ) {

	var boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

function SkeletonHelper( object ) {

	var bones = getBoneList( object );

	var geometry = new BufferGeometry();

	var vertices = [];
	var colors = [];

	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );

	for ( var i = 0; i < bones.length; i ++ ) {

		var bone = bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );

		}

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

	LineSegments.call( this, geometry, material );

	this.type = 'SkeletonHelper';

	this.root = object;
	this.bones = bones;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

}

SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.isSkeletonHelper = true;

SkeletonHelper.prototype.updateMatrixWorld = function ( force ) {

	var bones = this.bones;

	var geometry = this.geometry;
	var position = geometry.getAttribute( 'position' );

	_matrixWorldInv.getInverse( this.root.matrixWorld );

	for ( var i = 0, j = 0; i < bones.length; i ++ ) {

		var bone = bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
			_vector$9.setFromMatrixPosition( _boneMatrix );
			position.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );

			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
			_vector$9.setFromMatrixPosition( _boneMatrix );
			position.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );

			j += 2;

		}

	}

	geometry.getAttribute( 'position' ).needsUpdate = true;

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper( light, sphereSize, color ) {

	this.light = light;
	this.light.updateMatrixWorld();

	this.color = color;

	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

	Mesh.call( this, geometry, material );

	this.type = 'PointLightHelper';

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();


	/*
	var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

PointLightHelper.prototype.update = function () {

	if ( this.color !== undefined ) {

		this.material.color.set( this.color );

	} else {

		this.material.color.copy( this.light.color );

	}

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var _vector$a = new Vector3();
var _color1 = new Color();
var _color2 = new Color();

function HemisphereLightHelper( light, size, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );

	this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
	if ( this.color === undefined ) this.material.vertexColors = true;

	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );

	geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

	this.add( new Mesh( geometry, this.material ) );

	this.update();

}

HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

HemisphereLightHelper.prototype.update = function () {

	var mesh = this.children[ 0 ];

	if ( this.color !== undefined ) {

		this.material.color.set( this.color );

	} else {

		var colors = mesh.geometry.getAttribute( 'color' );

		_color1.copy( this.light.color );
		_color2.copy( this.light.groundColor );

		for ( var i = 0, l = colors.count; i < l; i ++ ) {

			var color = ( i < ( l / 2 ) ) ? _color1 : _color2;

			colors.setXYZ( i, color.r, color.g, color.b );

		}

		colors.needsUpdate = true;

	}

	mesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper( size, divisions, color1, color2 ) {

	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var center = divisions / 2;
	var step = size / divisions;
	var halfSize = size / 2;

	var vertices = [], colors = [];

	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

		vertices.push( - halfSize, 0, k, halfSize, 0, k );
		vertices.push( k, 0, - halfSize, k, 0, halfSize );

		var color = i === center ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

	this.type = 'GridHelper';

}

GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

	constructor: GridHelper,

	copy: function ( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.geometry.copy( source.geometry );
		this.material.copy( source.material );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	var x, z;
	var v, i, j, r, color;

	// create the radials

	for ( i = 0; i <= radials; i ++ ) {

		v = ( i / radials ) * ( Math.PI * 2 );

		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;

		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );

		color = ( i & 1 ) ? color1 : color2;

		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );

	}

	// create the circles

	for ( i = 0; i <= circles; i ++ ) {

		color = ( i & 1 ) ? color1 : color2;

		r = radius - ( radius / circles * i );

		for ( j = 0; j < divisions; j ++ ) {

			// first vertex

			v = ( j / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

			// second vertex

			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

		}

	}

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

	this.type = 'PolarGridHelper';

}

PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _v1$5 = new Vector3();
var _v2$3 = new Vector3();
var _v3$1 = new Vector3();

function DirectionalLightHelper( light, size, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	if ( size === undefined ) size = 1;

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( [
		- size, size, 0,
		size, size, 0,
		size, - size, 0,
		- size, - size, 0,
		- size, size, 0
	], 3 ) );

	var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

	this.lightPlane = new Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.targetLine = new Line( geometry, material );
	this.add( this.targetLine );

	this.update();

}

DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update = function () {

	_v1$5.setFromMatrixPosition( this.light.matrixWorld );
	_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
	_v3$1.subVectors( _v2$3, _v1$5 );

	this.lightPlane.lookAt( _v2$3 );

	if ( this.color !== undefined ) {

		this.lightPlane.material.color.set( this.color );
		this.targetLine.material.color.set( this.color );

	} else {

		this.lightPlane.material.color.copy( this.light.color );
		this.targetLine.material.color.copy( this.light.color );

	}

	this.targetLine.lookAt( _v2$3 );
	this.targetLine.scale.z = _v3$1.length();

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

var _vector$b = new Vector3();
var _camera = new Camera();

function CameraHelper( camera ) {

	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

	var vertices = [];
	var colors = [];

	var pointMap = {};

	// colors

	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );

	// near

	addLine( 'n1', 'n2', colorFrustum );
	addLine( 'n2', 'n4', colorFrustum );
	addLine( 'n4', 'n3', colorFrustum );
	addLine( 'n3', 'n1', colorFrustum );

	// far

	addLine( 'f1', 'f2', colorFrustum );
	addLine( 'f2', 'f4', colorFrustum );
	addLine( 'f4', 'f3', colorFrustum );
	addLine( 'f3', 'f1', colorFrustum );

	// sides

	addLine( 'n1', 'f1', colorFrustum );
	addLine( 'n2', 'f2', colorFrustum );
	addLine( 'n3', 'f3', colorFrustum );
	addLine( 'n4', 'f4', colorFrustum );

	// cone

	addLine( 'p', 'n1', colorCone );
	addLine( 'p', 'n2', colorCone );
	addLine( 'p', 'n3', colorCone );
	addLine( 'p', 'n4', colorCone );

	// up

	addLine( 'u1', 'u2', colorUp );
	addLine( 'u2', 'u3', colorUp );
	addLine( 'u3', 'u1', colorUp );

	// target

	addLine( 'c', 't', colorTarget );
	addLine( 'p', 'c', colorCross );

	// cross

	addLine( 'cn1', 'cn2', colorCross );
	addLine( 'cn3', 'cn4', colorCross );

	addLine( 'cf1', 'cf2', colorCross );
	addLine( 'cf3', 'cf4', colorCross );

	function addLine( a, b, color ) {

		addPoint( a, color );
		addPoint( b, color );

	}

	function addPoint( id, color ) {

		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	LineSegments.call( this, geometry, material );

	this.type = 'CameraHelper';

	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

}

CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {

	var geometry = this.geometry;
	var pointMap = this.pointMap;

	var w = 1, h = 1;

	// we need just camera projection matrix inverse
	// world matrix must be identity

	_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

	// center / target

	setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
	setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

	// near

	setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
	setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
	setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
	setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

	// far

	setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
	setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
	setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
	setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

	// up

	setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
	setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
	setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

	// cross

	setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
	setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
	setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
	setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

	setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
	setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
	setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
	setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

	geometry.getAttribute( 'position' ).needsUpdate = true;

};

function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector$b.set( x, y, z ).unproject( camera );

	var points = pointMap[ point ];

	if ( points !== undefined ) {

		var position = geometry.getAttribute( 'position' );

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */

var _box$3 = new Box3();

function BoxHelper( object, color ) {

	this.object = object;

	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	this.type = 'BoxHelper';

	this.matrixAutoUpdate = false;

	this.update();

}

BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function ( object ) {

	if ( object !== undefined ) {

		console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

	}

	if ( this.object !== undefined ) {

		_box$3.setFromObject( this.object );

	}

	if ( _box$3.isEmpty() ) return;

	var min = _box$3.min;
	var max = _box$3.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var position = this.geometry.attributes.position;
	var array = position.array;

	array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
	array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
	array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
	array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
	array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
	array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
	array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
	array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

	position.needsUpdate = true;

	this.geometry.computeBoundingSphere();


};

BoxHelper.prototype.setFromObject = function ( object ) {

	this.object = object;
	this.update();

	return this;

};

BoxHelper.prototype.copy = function ( source ) {

	LineSegments.prototype.copy.call( this, source );

	this.object = source.object;

	return this;

};

BoxHelper.prototype.clone = function () {

	return new this.constructor().copy( this );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3Helper( box, color ) {

	this.type = 'Box3Helper';

	this.box = box;

	color = color || 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

	var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

	var geometry = new BufferGeometry();

	geometry.setIndex( new BufferAttribute( indices, 1 ) );

	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	this.type = 'Box3Helper';

	this.geometry.computeBoundingSphere();

}

Box3Helper.prototype = Object.create( LineSegments.prototype );
Box3Helper.prototype.constructor = Box3Helper;

Box3Helper.prototype.updateMatrixWorld = function ( force ) {

	var box = this.box;

	if ( box.isEmpty() ) return;

	box.getCenter( this.position );

	box.getSize( this.scale );

	this.scale.multiplyScalar( 0.5 );

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function PlaneHelper( plane, size, hex ) {

	this.plane = plane;

	this.size = ( size === undefined ) ? 1 : size;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	geometry.computeBoundingSphere();

	Line.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	this.type = 'PlaneHelper';

	//

	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

	var geometry2 = new BufferGeometry();
	geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
	geometry2.computeBoundingSphere();

	this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

}

PlaneHelper.prototype = Object.create( Line.prototype );
PlaneHelper.prototype.constructor = PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

	var scale = - this.plane.constant;

	if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

	this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

	this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

	this.lookAt( this.plane.normal );

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var _axis = new Vector3();
var _lineGeometry, _coneGeometry;

function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

	// dir is assumed to be normalized

	Object3D.call( this );

	this.type = 'ArrowHelper';

	if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
	if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
	if ( length === undefined ) length = 1;
	if ( color === undefined ) color = 0xffff00;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( _lineGeometry === undefined ) {

		_lineGeometry = new BufferGeometry();
		_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		_coneGeometry.translate( 0, - 0.5, 0 );

	}

	this.position.copy( origin );

	this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

}

ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = function ( dir ) {

	// dir is assumed to be normalized

	if ( dir.y > 0.99999 ) {

		this.quaternion.set( 0, 0, 0, 1 );

	} else if ( dir.y < - 0.99999 ) {

		this.quaternion.set( 1, 0, 0, 0 );

	} else {

		_axis.set( dir.z, 0, - dir.x ).normalize();

		var radians = Math.acos( dir.y );

		this.quaternion.setFromAxisAngle( _axis, radians );

	}

};

ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

ArrowHelper.prototype.copy = function ( source ) {

	Object3D.prototype.copy.call( this, source, false );

	this.line.copy( source.line );
	this.cone.copy( source.cone );

	return this;

};

ArrowHelper.prototype.clone = function () {

	return new this.constructor().copy( this );

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxesHelper( size ) {

	size = size || 1;

	var vertices = [
		0, 0, 0,	size, 0, 0,
		0, 0, 0,	0, size, 0,
		0, 0, 0,	0, 0, size
	];

	var colors = [
		1, 0, 0,	1, 0.6, 0,
		0, 1, 0,	0.6, 1, 0,
		0, 0, 1,	0, 0.6, 1
	];

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

	this.type = 'AxesHelper';

}

AxesHelper.prototype = Object.create( LineSegments.prototype );
AxesHelper.prototype.constructor = AxesHelper;

/**
 * @author Emmett Lalish / elalish
 *
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
var EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
var MAX_SAMPLES = 20;

var ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

var _flatCamera = new OrthographicCamera();
var { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();
var _oldTarget = null;

// Golden Ratio
var PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
var INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
var _axisDirections = [
	new Vector3( 1, 1, 1 ),
	new Vector3( - 1, 1, 1 ),
	new Vector3( 1, 1, - 1 ),
	new Vector3( - 1, 1, - 1 ),
	new Vector3( 0, PHI, INV_PHI ),
	new Vector3( 0, PHI, - INV_PHI ),
	new Vector3( INV_PHI, 0, PHI ),
	new Vector3( - INV_PHI, 0, PHI ),
	new Vector3( PHI, INV_PHI, 0 ),
	new Vector3( - PHI, INV_PHI, 0 ) ];

function PMREMGenerator( renderer ) {

	this._renderer = renderer;
	this._pingPongRenderTarget = null;

	this._blurMaterial = _getBlurShader( MAX_SAMPLES );
	this._equirectShader = null;
	this._cubemapShader = null;

	this._compileMaterial( this._blurMaterial );

}

PMREMGenerator.prototype = {

	constructor: PMREMGenerator,

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		var cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	},

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular: function ( equirectangular ) {

		equirectangular.magFilter = NearestFilter;
		equirectangular.minFilter = NearestFilter;
		equirectangular.generateMipmaps = false;

		return this.fromCubemap( equirectangular );

	},

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap: function ( cubemap ) {

		_oldTarget = this._renderer.getRenderTarget();
		var cubeUVRenderTarget = this._allocateTargets( cubemap );
		this._textureToCubeUV( cubemap, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	},

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader: function () {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	},

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader: function () {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	},

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose: function () {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( var i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	},

	// private interface

	_cleanup: function ( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		// reset viewport and scissor
		outputTarget.setSize( outputTarget.width, outputTarget.height );

	},

	_allocateTargets: function ( equirectangular ) {

		var params = {
			magFilter: NearestFilter,
			minFilter: NearestFilter,
			generateMipmaps: false,
			type: UnsignedByteType,
			format: RGBEFormat,
			encoding: _isLDR( equirectangular ) ? equirectangular.encoding : RGBEEncoding,
			depthBuffer: false,
			stencilBuffer: false
		};

		var cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	},

	_compileMaterial: function ( material ) {

		var tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	},

	_sceneToCubeUV: function ( scene, near, far, cubeUVRenderTarget ) {

		var fov = 90;
		var aspect = 1;
		var cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		var upSign = [ 1, - 1, 1, 1, 1, 1 ];
		var forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		var renderer = this._renderer;

		var outputEncoding = renderer.outputEncoding;
		var toneMapping = renderer.toneMapping;
		var toneMappingExposure = renderer.toneMappingExposure;
		var clearColor = renderer.getClearColor();
		var clearAlpha = renderer.getClearAlpha();

		renderer.toneMapping = LinearToneMapping;
		renderer.toneMappingExposure = 1.0;
		renderer.outputEncoding = LinearEncoding;

		var background = scene.background;
		if ( background && background.isColor ) {

			background.convertSRGBToLinear();
			// Convert linear to RGBE
			var maxComponent = Math.max( background.r, background.g, background.b );
			var fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
			background = background.multiplyScalar( Math.pow( 2.0, - fExp ) );
			var alpha = ( fExp + 128.0 ) / 255.0;
			renderer.setClearColor( background, alpha );
			scene.background = null;

		}

		for ( var i = 0; i < 6; i ++ ) {

			var col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.toneMappingExposure = toneMappingExposure;
		renderer.outputEncoding = outputEncoding;
		renderer.setClearColor( clearColor, clearAlpha );

	},

	_textureToCubeUV: function ( texture, cubeUVRenderTarget ) {

		var renderer = this._renderer;

		if ( texture.isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
		var mesh = new Mesh( _lodPlanes[ 0 ], material );

		var uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! texture.isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	},

	_applyPMREM: function ( cubeUVRenderTarget ) {

		var renderer = this._renderer;
		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( var i = 1; i < TOTAL_LODS; i ++ ) {

			var sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			var poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	},

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur: function ( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		var pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	},

	_halfBlur: function ( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		var renderer = this._renderer;
		var blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		var STANDARD_DEVIATIONS = 3;

		var blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
		var blurUniforms = blurMaterial.uniforms;

		var pixels = _sizeLods[ lodIn ] - 1;
		var radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		var sigmaPixels = sigmaRadians / radiansPerPixel;
		var samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		var weights = [];
		var sum = 0;

		for ( var i = 0; i < MAX_SAMPLES; ++ i ) {

			var x = i / sigmaPixels;
			var weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( var i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

		var outputSize = _sizeLods[ lodOut ];
		var x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		var y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

};

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

}

function _createPlanes() {

	var _lodPlanes = [];
	var _sizeLods = [];
	var _sigmas = [];

	var lod = LOD_MAX;

	for ( var i = 0; i < TOTAL_LODS; i ++ ) {

		var sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		var sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		var texelSize = 1.0 / ( sizeLod - 1 );
		var min = - texelSize / 2;
		var max = 1 + texelSize / 2;
		var uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		var cubeFaces = 6;
		var vertices = 6;
		var positionSize = 3;
		var uvSize = 2;
		var faceIndexSize = 1;

		var position = new Float32Array( positionSize * vertices * cubeFaces );
		var uv = new Float32Array( uvSize * vertices * cubeFaces );
		var faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( var face = 0; face < cubeFaces; face ++ ) {

			var x = ( face % 3 ) * 2 / 3 - 1;
			var y = face > 2 ? 0 : - 1;
			var coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			var fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		var planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	var cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	var weights = new Float32Array( maxSamples );
	var poleAxis = new Vector3( 0, 1, 0 );
	var shaderMaterial = new RawShaderMaterial( {

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'SphericalGaussianBlur';

	return shaderMaterial;

}

function _getEquirectShader() {

	var texelSize = new Vector2( 1, 1 );
	var shaderMaterial = new RawShaderMaterial( {

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#include <common>

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv = equirectUv( outputDirection );
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'EquirectangularToCubeUV';

	return shaderMaterial;

}

function _getCubemapShader() {

	var shaderMaterial = new RawShaderMaterial( {

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'CubemapToCubeUV';

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;

// RH coordinate system; PMREM face-indexing convention
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx; // ( 1, v, u ) pos x
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.xz *= -1.0; // ( -u, 1, -v ) pos y
	} else if (face == 2.0) {
		direction.x *= -1.0; // ( -u, v, 1 ) pos z
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.xz *= -1.0; // ( -1, v, -u ) neg x
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.xy *= -1.0; // ( -u, -1, v ) neg y
	} else if (face == 5.0) {
		direction.z *= -1.0; // ( u, v, -1 ) neg z
	}
	return direction;
}

void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;

}

function _getEncodings() {

	return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

var LineStrip = 0;
var LinePieces = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials ) {

	if ( materials === undefined ) materials = [];

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Object.assign( CurvePath.prototype, {

	createPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from path points (for Line or Points objects)

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	createSpacedPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from equidistant sampling along the path

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		var geometry = new Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

//

Object.assign( Path.prototype, {

	fromPoints: function ( points ) {

		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		return this.setFromPoints( points );

	}

} );

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function SplineCurve3( points ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function Spline( points ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

Spline.prototype = Object.create( CatmullRomCurve3.prototype );

Object.assign( Spline.prototype, {

	initFromArray: function ( /* a */ ) {

		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

	},
	getControlPointsArray: function ( /* optionalTarget */ ) {

		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

	},
	reparametrizeByArcLength: function ( /* samplingCoef */ ) {

		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

	}

} );

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Object.assign( Loader.prototype, {

	extractUrlBase: function ( url ) {

		console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
		return LoaderUtils.extractUrlBase( url );

	}

} );

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

Object.assign( ObjectLoader.prototype, {

	setTexturePath: function ( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

} );

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Sphere.prototype, {

	empty: function () {

		console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},

} );

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Object.assign( MathUtils, {

	random16: function () {

		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	},

	nearestPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
		return MathUtils.floorPowerOfTwo( value );

	},

	nextPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
		return MathUtils.ceilPowerOfTwo( value );

	}

} );

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
		return attribute.applyMatrix3( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
		return new Vector3().setFromMatrixColumn( this, 3 );

	},
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyToArray: function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
		return attribute.applyMatrix4( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	},
	makeFrustum: function ( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Triangle.prototype, {

	area: function () {

		console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
		return this.getArea();

	},
	barycoordFromPoint: function ( point, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return this.getBarycoord( point, target );

	},
	midpoint: function ( target ) {

		console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
		return this.getMidpoint( target );

	},
	normal: function ( target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return this.getNormal( target );

	},
	plane: function ( target ) {

		console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
		return this.getPlane( target );

	}

} );

Object.assign( Triangle, {

	barycoordFromPoint: function ( point, a, b, c, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return Triangle.getBarycoord( point, a, b, c, target );

	},
	normal: function ( a, b, c, target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return Triangle.getNormal( a, b, c, target );

	}

} );

Object.assign( Shape.prototype, {

	extractAllPoints: function ( divisions ) {

		console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
		return this.extractPoints( divisions );

	},
	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector2.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	},
	applyProjection: function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	},
	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector4.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

//

Object.assign( Geometry.prototype, {

	computeTangents: function () {

		console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

	},
	computeLineDistances: function () {

		console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},
	getWorldRotation: function () {

		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.assign( Mesh.prototype, {

	setDrawMode: function () {

		console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

	},

} );

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

	get: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	},
	set: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

Object.assign( BufferAttribute.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	copyIndicesArray: function ( /* indices */ ) {

		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addAttribute: function ( name, attribute ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		return this.setAttribute( name, attribute );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	},
	removeAttribute: function ( name ) {

		console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

		return this.deleteAttribute( name );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( InstancedBufferGeometry.prototype, {

	maxInstancedCount: {
		get: function () {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			return this.instanceCount;

		},
		set: function ( value ) {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			this.instanceCount = value;

		}
	}

} );

Object.defineProperties( Raycaster.prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( InterleavedBuffer.prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

Object.assign( InterleavedBuffer.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

//

Object.assign( ExtrudeBufferGeometry.prototype, {

	getArrays: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

	},

	addShapeList: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

	},

	addShape: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

Object.assign( WebGLRenderer.prototype, {

	clearTarget: function ( renderTarget, color, depth, stencil ) {

		console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	},
	animate: function ( callback ) {

		console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
		this.setAnimationLoop( callback );

	},
	getCurrentRenderTarget: function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	},
	getMaxAnisotropy: function () {

		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();

	},
	getPrecision: function () {

		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;

	},
	resetGLState: function () {

		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();

	},
	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	},
	setFaceCulling: function () {

		console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

	},
	allocTextureUnit: function () {

		console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

	},
	setTexture: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

	},
	setTexture2D: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

	},
	setTextureCube: function () {

		console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

	},
	getActiveMipMapLevel: function () {

		console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
		return this.getActiveMipmapLevel();

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	}

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Object.defineProperties( Audio.prototype, {

	load: {
		value: function ( file ) {

			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );
			return this;

		}
	},
	startTime: {
		set: function () {

			console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

		}
	}

} );

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

//

var GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		var matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	var loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	var texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	var loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	var texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

var SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}




/***/ })

/******/ });
//# sourceMappingURL=mapview.bundle.js.map